diff --git a/.gitignore b/.gitignore
index 72232af265a7..8e0e277b24b1 100644
--- a/.gitignore
+++ b/.gitignore
@@ -152,7 +152,6 @@ x509.genkey
 /allyes.config
 
 # Kconfig savedefconfig output
-/defconfig
 
 # Kdevelop4
 *.kdev4
diff --git a/Makefile b/Makefile
index dec77944d0bf..63eaddac21fe 100644
--- a/Makefile
+++ b/Makefile
@@ -1211,7 +1211,6 @@ quiet_cmd_headers_install = INSTALL $(INSTALL_HDR_PATH)/include
 
 PHONY += headers_install
 headers_install: headers
-	$(call cmd,headers_install)
 
 headers:
 ifeq ($(KBUILD_EXTMOD),)
diff --git a/defconfig b/defconfig
new file mode 100644
index 000000000000..43af23286915
--- /dev/null
+++ b/defconfig
@@ -0,0 +1,7437 @@
+#
+# Automatically generated file; DO NOT EDIT.
+# Linux/arm64 5.15.104 Kernel Configuration
+#
+CONFIG_CC_VERSION_TEXT="aarch64-oe-linux-gnueabi-gcc (GCC) 11.4.0"
+CONFIG_CC_IS_GCC=y
+CONFIG_GCC_VERSION=110400
+CONFIG_CLANG_VERSION=0
+CONFIG_AS_IS_GNU=y
+CONFIG_AS_VERSION=20244508
+CONFIG_LD_IS_BFD=y
+CONFIG_LD_VERSION=20244508
+CONFIG_LLD_VERSION=0
+CONFIG_CC_HAS_ASM_GOTO=y
+CONFIG_CC_HAS_ASM_GOTO_OUTPUT=y
+CONFIG_CC_HAS_ASM_GOTO_TIED_OUTPUT=y
+CONFIG_CC_HAS_ASM_INLINE=y
+CONFIG_CC_HAS_NO_PROFILE_FN_ATTR=y
+CONFIG_PAHOLE_VERSION=0
+CONFIG_CONSTRUCTORS=y
+CONFIG_IRQ_WORK=y
+CONFIG_BUILDTIME_TABLE_SORT=y
+CONFIG_THREAD_INFO_IN_TASK=y
+
+#
+# General setup
+#
+CONFIG_INIT_ENV_ARG_LIMIT=32
+# CONFIG_COMPILE_TEST is not set
+CONFIG_WERROR=y
+CONFIG_LOCALVERSION=""
+CONFIG_LOCALVERSION_AUTO=y
+CONFIG_BUILD_SALT=""
+CONFIG_DEFAULT_INIT=""
+CONFIG_DEFAULT_HOSTNAME="(none)"
+CONFIG_SWAP=y
+# CONFIG_SYSVIPC is not set
+# CONFIG_POSIX_MQUEUE is not set
+# CONFIG_WATCH_QUEUE is not set
+CONFIG_CROSS_MEMORY_ATTACH=y
+# CONFIG_USELIB is not set
+CONFIG_AUDIT=y
+CONFIG_HAVE_ARCH_AUDITSYSCALL=y
+CONFIG_AUDITSYSCALL=y
+
+#
+# IRQ subsystem
+#
+CONFIG_GENERIC_IRQ_PROBE=y
+CONFIG_GENERIC_IRQ_SHOW=y
+CONFIG_GENERIC_IRQ_SHOW_LEVEL=y
+CONFIG_GENERIC_IRQ_EFFECTIVE_AFF_MASK=y
+CONFIG_GENERIC_IRQ_MIGRATION=y
+CONFIG_HARDIRQS_SW_RESEND=y
+CONFIG_GENERIC_IRQ_CHIP=y
+CONFIG_IRQ_DOMAIN=y
+CONFIG_IRQ_DOMAIN_HIERARCHY=y
+CONFIG_IRQ_FASTEOI_HIERARCHY_HANDLERS=y
+CONFIG_GENERIC_IRQ_IPI=y
+CONFIG_GENERIC_MSI_IRQ=y
+CONFIG_GENERIC_MSI_IRQ_DOMAIN=y
+CONFIG_IRQ_MSI_IOMMU=y
+CONFIG_HANDLE_DOMAIN_IRQ=y
+CONFIG_ARCH_WANTS_IRQ_RAW=y
+CONFIG_IRQ_FORCED_THREADING=y
+CONFIG_SPARSE_IRQ=y
+# CONFIG_GENERIC_IRQ_DEBUGFS is not set
+# end of IRQ subsystem
+
+CONFIG_GENERIC_TIME_VSYSCALL=y
+CONFIG_GENERIC_CLOCKEVENTS=y
+CONFIG_ARCH_HAS_TICK_BROADCAST=y
+CONFIG_GENERIC_CLOCKEVENTS_BROADCAST=y
+
+#
+# Timers subsystem
+#
+CONFIG_TICK_ONESHOT=y
+CONFIG_NO_HZ_COMMON=y
+# CONFIG_HZ_PERIODIC is not set
+CONFIG_NO_HZ_IDLE=y
+# CONFIG_NO_HZ_FULL is not set
+CONFIG_NO_HZ=y
+CONFIG_HIGH_RES_TIMERS=y
+# end of Timers subsystem
+
+CONFIG_BPF=y
+CONFIG_HAVE_EBPF_JIT=y
+CONFIG_ARCH_WANT_DEFAULT_BPF_JIT=y
+
+#
+# BPF subsystem
+#
+CONFIG_BPF_SYSCALL=y
+CONFIG_BPF_JIT=y
+CONFIG_BPF_JIT_ALWAYS_ON=y
+CONFIG_BPF_JIT_DEFAULT_ON=y
+# CONFIG_BPF_UNPRIV_DEFAULT_OFF is not set
+# CONFIG_BPF_PRELOAD is not set
+# CONFIG_BPF_LSM is not set
+# end of BPF subsystem
+
+# CONFIG_PREEMPT_NONE is not set
+# CONFIG_PREEMPT_VOLUNTARY is not set
+CONFIG_PREEMPT=y
+CONFIG_PREEMPT_COUNT=y
+CONFIG_PREEMPTION=y
+
+#
+# CPU/Task time and stats accounting
+#
+CONFIG_TICK_CPU_ACCOUNTING=y
+# CONFIG_VIRT_CPU_ACCOUNTING_GEN is not set
+CONFIG_IRQ_TIME_ACCOUNTING=y
+CONFIG_HAVE_SCHED_AVG_IRQ=y
+CONFIG_SCHED_THERMAL_PRESSURE=y
+# CONFIG_BSD_PROCESS_ACCT is not set
+CONFIG_TASKSTATS=y
+# CONFIG_MSM_SYSSTATS is not set
+# CONFIG_TASK_DELAY_ACCT is not set
+CONFIG_TASK_XACCT=y
+CONFIG_TASK_IO_ACCOUNTING=y
+CONFIG_PSI=y
+# CONFIG_PSI_DEFAULT_DISABLED is not set
+# end of CPU/Task time and stats accounting
+
+CONFIG_CPU_ISOLATION=y
+
+#
+# RCU Subsystem
+#
+CONFIG_TREE_RCU=y
+CONFIG_PREEMPT_RCU=y
+CONFIG_RCU_EXPERT=y
+CONFIG_SRCU=y
+CONFIG_TREE_SRCU=y
+CONFIG_TASKS_RCU_GENERIC=y
+CONFIG_TASKS_RCU=y
+CONFIG_TASKS_TRACE_RCU=y
+CONFIG_RCU_STALL_COMMON=y
+CONFIG_RCU_NEED_SEGCBLIST=y
+CONFIG_RCU_FANOUT=64
+CONFIG_RCU_FANOUT_LEAF=16
+CONFIG_RCU_FAST_NO_HZ=y
+CONFIG_RCU_BOOST=y
+CONFIG_RCU_BOOST_DELAY=500
+CONFIG_RCU_EXP_KTHREAD=y
+CONFIG_RCU_NOCB_CPU=y
+# CONFIG_TASKS_TRACE_RCU_READ_MB is not set
+# end of RCU Subsystem
+
+CONFIG_IKCONFIG=y
+CONFIG_IKCONFIG_PROC=y
+CONFIG_IKHEADERS=y
+CONFIG_LOG_BUF_SHIFT=17
+CONFIG_LOG_CPU_MAX_BUF_SHIFT=12
+CONFIG_PRINTK_SAFE_LOG_BUF_SHIFT=13
+# CONFIG_PRINTK_INDEX is not set
+CONFIG_GENERIC_SCHED_CLOCK=y
+
+#
+# Scheduler features
+#
+CONFIG_UCLAMP_TASK=y
+CONFIG_UCLAMP_BUCKETS_COUNT=20
+# end of Scheduler features
+
+CONFIG_ARCH_SUPPORTS_NUMA_BALANCING=y
+CONFIG_CC_HAS_INT128=y
+CONFIG_ARCH_SUPPORTS_INT128=y
+CONFIG_CGROUPS=y
+CONFIG_PAGE_COUNTER=y
+CONFIG_MEMCG=y
+CONFIG_MEMCG_SWAP=y
+CONFIG_MEMCG_KMEM=y
+CONFIG_BLK_CGROUP=y
+CONFIG_CGROUP_WRITEBACK=y
+CONFIG_CGROUP_SCHED=y
+CONFIG_FAIR_GROUP_SCHED=y
+# CONFIG_CFS_BANDWIDTH is not set
+# CONFIG_RT_GROUP_SCHED is not set
+CONFIG_UCLAMP_TASK_GROUP=y
+# CONFIG_CGROUP_PIDS is not set
+# CONFIG_CGROUP_RDMA is not set
+CONFIG_CGROUP_FREEZER=y
+CONFIG_CPUSETS=y
+CONFIG_PROC_PID_CPUSET=y
+# CONFIG_CGROUP_DEVICE is not set
+CONFIG_CGROUP_CPUACCT=y
+# CONFIG_CGROUP_PERF is not set
+CONFIG_CGROUP_BPF=y
+# CONFIG_CGROUP_MISC is not set
+# CONFIG_CGROUP_DEBUG is not set
+CONFIG_SOCK_CGROUP_DATA=y
+CONFIG_NAMESPACES=y
+CONFIG_UTS_NS=y
+CONFIG_TIME_NS=y
+# CONFIG_USER_NS is not set
+# CONFIG_PID_NS is not set
+CONFIG_NET_NS=y
+# CONFIG_CHECKPOINT_RESTORE is not set
+# CONFIG_SCHED_AUTOGROUP is not set
+CONFIG_RT_SOFTINT_OPTIMIZATION=y
+# CONFIG_SYSFS_DEPRECATED is not set
+CONFIG_RELAY=y
+CONFIG_BLK_DEV_INITRD=y
+CONFIG_INITRAMFS_SOURCE=""
+# CONFIG_INITRAMFS_FORCE is not set
+CONFIG_RD_GZIP=y
+# CONFIG_RD_BZIP2 is not set
+# CONFIG_RD_LZMA is not set
+# CONFIG_RD_XZ is not set
+# CONFIG_RD_LZO is not set
+CONFIG_RD_LZ4=y
+CONFIG_RD_ZSTD=y
+CONFIG_BOOT_CONFIG=y
+CONFIG_CC_OPTIMIZE_FOR_PERFORMANCE=y
+# CONFIG_CC_OPTIMIZE_FOR_SIZE is not set
+CONFIG_LD_ORPHAN_WARN=y
+CONFIG_SYSCTL=y
+CONFIG_HAVE_UID16=y
+CONFIG_SYSCTL_EXCEPTION_TRACE=y
+CONFIG_EXPERT=y
+CONFIG_UID16=y
+CONFIG_MULTIUSER=y
+# CONFIG_SGETMASK_SYSCALL is not set
+# CONFIG_SYSFS_SYSCALL is not set
+# CONFIG_FHANDLE is not set
+CONFIG_POSIX_TIMERS=y
+CONFIG_PRINTK=y
+CONFIG_BUG=y
+CONFIG_ELF_CORE=y
+CONFIG_BASE_FULL=y
+CONFIG_FUTEX=y
+CONFIG_FUTEX_PI=y
+CONFIG_HAVE_FUTEX_CMPXCHG=y
+CONFIG_EPOLL=y
+CONFIG_SIGNALFD=y
+CONFIG_TIMERFD=y
+CONFIG_EVENTFD=y
+CONFIG_SHMEM=y
+CONFIG_AIO=y
+CONFIG_IO_URING=y
+CONFIG_ADVISE_SYSCALLS=y
+CONFIG_HAVE_ARCH_USERFAULTFD_MINOR=y
+CONFIG_MEMBARRIER=y
+CONFIG_KALLSYMS=y
+CONFIG_KALLSYMS_ALL=y
+CONFIG_KALLSYMS_BASE_RELATIVE=y
+CONFIG_USERFAULTFD=y
+CONFIG_ARCH_HAS_MEMBARRIER_SYNC_CORE=y
+CONFIG_KCMP=y
+# CONFIG_RSEQ is not set
+CONFIG_EMBEDDED=y
+CONFIG_HAVE_PERF_EVENTS=y
+# CONFIG_PC104 is not set
+
+#
+# Kernel Performance Events And Counters
+#
+CONFIG_PERF_EVENTS=y
+# CONFIG_DEBUG_PERF_USE_VMALLOC is not set
+# end of Kernel Performance Events And Counters
+
+CONFIG_VM_EVENT_COUNTERS=y
+CONFIG_SLUB_DEBUG=y
+# CONFIG_COMPAT_BRK is not set
+# CONFIG_SLAB is not set
+CONFIG_SLUB=y
+# CONFIG_SLOB is not set
+# CONFIG_SLAB_MERGE_DEFAULT is not set
+CONFIG_SLAB_FREELIST_RANDOM=y
+CONFIG_SLAB_FREELIST_HARDENED=y
+CONFIG_SHUFFLE_PAGE_ALLOCATOR=y
+CONFIG_SLUB_CPU_PARTIAL=y
+CONFIG_SYSTEM_DATA_VERIFICATION=y
+CONFIG_PROFILING=y
+CONFIG_TRACEPOINTS=y
+# end of General setup
+
+CONFIG_ARM64=y
+CONFIG_64BIT=y
+CONFIG_MMU=y
+CONFIG_ARM64_PAGE_SHIFT=12
+CONFIG_ARM64_CONT_PTE_SHIFT=4
+CONFIG_ARM64_CONT_PMD_SHIFT=4
+CONFIG_ARCH_MMAP_RND_BITS_MIN=18
+CONFIG_ARCH_MMAP_RND_BITS_MAX=24
+CONFIG_ARCH_MMAP_RND_COMPAT_BITS_MIN=11
+CONFIG_ARCH_MMAP_RND_COMPAT_BITS_MAX=16
+CONFIG_STACKTRACE_SUPPORT=y
+CONFIG_ILLEGAL_POINTER_VALUE=0xdead000000000000
+CONFIG_LOCKDEP_SUPPORT=y
+CONFIG_GENERIC_BUG=y
+CONFIG_GENERIC_BUG_RELATIVE_POINTERS=y
+CONFIG_GENERIC_HWEIGHT=y
+CONFIG_GENERIC_CSUM=y
+CONFIG_GENERIC_CALIBRATE_DELAY=y
+CONFIG_ARCH_MHP_MEMMAP_ON_MEMORY_ENABLE=y
+CONFIG_SMP=y
+CONFIG_KERNEL_MODE_NEON=y
+CONFIG_FIX_EARLYCON_MEM=y
+CONFIG_PGTABLE_LEVELS=3
+CONFIG_ARCH_SUPPORTS_UPROBES=y
+CONFIG_ARCH_PROC_KCORE_TEXT=y
+CONFIG_KASAN_SHADOW_OFFSET=0xdfffffc000000000
+
+#
+# Platform selection
+#
+# CONFIG_ARCH_ACTIONS is not set
+# CONFIG_ARCH_SUNXI is not set
+# CONFIG_ARCH_ALPINE is not set
+# CONFIG_ARCH_APPLE is not set
+# CONFIG_ARCH_BCM2835 is not set
+# CONFIG_ARCH_BCM4908 is not set
+# CONFIG_ARCH_BCM_IPROC is not set
+# CONFIG_ARCH_BERLIN is not set
+# CONFIG_ARCH_BITMAIN is not set
+# CONFIG_ARCH_BRCMSTB is not set
+# CONFIG_ARCH_EXYNOS is not set
+# CONFIG_ARCH_SPARX5 is not set
+# CONFIG_ARCH_K3 is not set
+# CONFIG_ARCH_LAYERSCAPE is not set
+# CONFIG_ARCH_LG1K is not set
+# CONFIG_ARCH_HISI is not set
+# CONFIG_ARCH_KEEMBAY is not set
+# CONFIG_ARCH_MEDIATEK is not set
+# CONFIG_ARCH_MESON is not set
+# CONFIG_ARCH_MVEBU is not set
+# CONFIG_ARCH_MXC is not set
+CONFIG_ARCH_QCOM=y
+# CONFIG_ARCH_QTI_VM is not set
+# CONFIG_ARCH_KALAMA is not set
+# CONFIG_ARCH_KAKA is not set
+# CONFIG_ARCH_CROW is not set
+# CONFIG_ARCH_KONA is not set
+# CONFIG_ARCH_WAIPIO is not set
+# CONFIG_ARCH_BENGAL is not set
+# CONFIG_ARCH_KHAJE is not set
+CONFIG_ARCH_MONACO=y
+# CONFIG_ARCH_MONACO_AUTO is not set
+# CONFIG_ARCH_QCS405 is not set
+# CONFIG_ARCH_TRINKET is not set
+# CONFIG_ARCH_CINDER is not set
+# CONFIG_ARCH_SDXPINN is not set
+# CONFIG_ARCH_SA8155 is not set
+# CONFIG_ARCH_SA8195 is not set
+# CONFIG_ARCH_SA6155 is not set
+# CONFIG_QTI_QUIN_GVM is not set
+# CONFIG_ARCH_LEMANS is not set
+# CONFIG_ARCH_SA410M is not set
+# CONFIG_ARCH_SCUBA_AUTO is not set
+# CONFIG_ARCH_REALTEK is not set
+# CONFIG_ARCH_RENESAS is not set
+# CONFIG_ARCH_ROCKCHIP is not set
+# CONFIG_ARCH_S32 is not set
+# CONFIG_ARCH_SEATTLE is not set
+# CONFIG_ARCH_INTEL_SOCFPGA is not set
+# CONFIG_ARCH_SYNQUACER is not set
+# CONFIG_ARCH_TEGRA is not set
+# CONFIG_ARCH_SPRD is not set
+# CONFIG_ARCH_THUNDER is not set
+# CONFIG_ARCH_THUNDER2 is not set
+# CONFIG_ARCH_UNIPHIER is not set
+# CONFIG_ARCH_VEXPRESS is not set
+# CONFIG_ARCH_VISCONTI is not set
+# CONFIG_ARCH_XGENE is not set
+# CONFIG_ARCH_ZYNQMP is not set
+# end of Platform selection
+
+#
+# Kernel Features
+#
+
+#
+# ARM errata workarounds via the alternatives framework
+#
+CONFIG_ARM64_WORKAROUND_CLEAN_CACHE=y
+CONFIG_ARM64_ERRATUM_826319=y
+CONFIG_ARM64_ERRATUM_827319=y
+CONFIG_ARM64_ERRATUM_824069=y
+CONFIG_ARM64_ERRATUM_819472=y
+CONFIG_ARM64_ERRATUM_832075=y
+CONFIG_ARM64_ERRATUM_834220=y
+CONFIG_ARM64_ERRATUM_845719=y
+CONFIG_ARM64_ERRATUM_843419=y
+CONFIG_ARM64_LD_HAS_FIX_ERRATUM_843419=y
+CONFIG_ARM64_ERRATUM_1024718=y
+CONFIG_ARM64_ERRATUM_1418040=y
+CONFIG_ARM64_WORKAROUND_SPECULATIVE_AT=y
+CONFIG_ARM64_ERRATUM_1165522=y
+CONFIG_ARM64_ERRATUM_1319367=y
+CONFIG_ARM64_ERRATUM_1530923=y
+CONFIG_ARM64_WORKAROUND_REPEAT_TLBI=y
+CONFIG_ARM64_ERRATUM_2441007=y
+CONFIG_ARM64_ERRATUM_1286807=y
+CONFIG_ARM64_ERRATUM_1463225=y
+CONFIG_ARM64_ERRATUM_1508412=y
+CONFIG_ARM64_WORKAROUND_TSB_FLUSH_FAILURE=y
+CONFIG_ARM64_ERRATUM_2054223=y
+CONFIG_ARM64_ERRATUM_2067961=y
+CONFIG_ARM64_ERRATUM_2441009=y
+CONFIG_ARM64_ERRATUM_2457168=y
+CONFIG_CAVIUM_ERRATUM_22375=y
+CONFIG_CAVIUM_ERRATUM_23154=y
+CONFIG_FUJITSU_ERRATUM_010001=y
+CONFIG_HISILICON_ERRATUM_161600802=y
+CONFIG_QCOM_FALKOR_ERRATUM_1003=y
+CONFIG_QCOM_FALKOR_ERRATUM_1009=y
+CONFIG_QCOM_QDF2400_ERRATUM_0065=y
+CONFIG_QCOM_FALKOR_ERRATUM_E1041=y
+CONFIG_NVIDIA_CARMEL_CNP_ERRATUM=y
+CONFIG_SOCIONEXT_SYNQUACER_PREITS=y
+# end of ARM errata workarounds via the alternatives framework
+
+CONFIG_ARM64_4K_PAGES=y
+# CONFIG_ARM64_16K_PAGES is not set
+# CONFIG_ARM64_64K_PAGES is not set
+CONFIG_ARM64_VA_BITS_39=y
+# CONFIG_ARM64_VA_BITS_48 is not set
+CONFIG_ARM64_VA_BITS=39
+CONFIG_ARM64_PA_BITS_48=y
+CONFIG_ARM64_PA_BITS=48
+# CONFIG_ARM64_MEMMAP_ON_MEMORY is not set
+# CONFIG_CPU_BIG_ENDIAN is not set
+CONFIG_CPU_LITTLE_ENDIAN=y
+# CONFIG_ARM64_KMALLOC64 is not set
+CONFIG_SCHED_MC=y
+# CONFIG_SCHED_SMT is not set
+CONFIG_NR_CPUS=32
+CONFIG_HOTPLUG_CPU=y
+# CONFIG_NUMA is not set
+# CONFIG_HZ_100 is not set
+CONFIG_HZ_250=y
+# CONFIG_HZ_300 is not set
+# CONFIG_HZ_1000 is not set
+CONFIG_HZ=250
+CONFIG_SCHED_HRTICK=y
+CONFIG_ARCH_SPARSEMEM_ENABLE=y
+CONFIG_HW_PERF_EVENTS=y
+CONFIG_PARAVIRT=y
+CONFIG_PARAVIRT_TIME_ACCOUNTING=y
+# CONFIG_KEXEC is not set
+# CONFIG_KEXEC_FILE is not set
+# CONFIG_CRASH_DUMP is not set
+CONFIG_TRANS_TABLE=y
+# CONFIG_XEN is not set
+CONFIG_FORCE_MAX_ZONEORDER=11
+CONFIG_UNMAP_KERNEL_AT_EL0=y
+CONFIG_MITIGATE_SPECTRE_BRANCH_HISTORY=y
+CONFIG_RODATA_FULL_DEFAULT_ENABLED=y
+CONFIG_ARM64_SW_TTBR0_PAN=y
+CONFIG_ARM64_TAGGED_ADDR_ABI=y
+CONFIG_COMPAT=y
+CONFIG_KUSER_HELPERS=y
+CONFIG_ARMV8_DEPRECATED=y
+CONFIG_SWP_EMULATION=y
+CONFIG_CP15_BARRIER_EMULATION=y
+CONFIG_SETEND_EMULATION=y
+
+#
+# ARMv8.1 architectural features
+#
+CONFIG_ARM64_HW_AFDBM=y
+CONFIG_ARM64_PAN=y
+CONFIG_AS_HAS_LDAPR=y
+CONFIG_AS_HAS_LSE_ATOMICS=y
+CONFIG_ARM64_LSE_ATOMICS=y
+CONFIG_ARM64_USE_LSE_ATOMICS=y
+# end of ARMv8.1 architectural features
+
+#
+# ARMv8.2 architectural features
+#
+# CONFIG_ARM64_PMEM is not set
+CONFIG_ARM64_RAS_EXTN=y
+CONFIG_ARM64_CNP=y
+# end of ARMv8.2 architectural features
+
+#
+# ARMv8.3 architectural features
+#
+CONFIG_ARM64_PTR_AUTH=y
+CONFIG_ARM64_PTR_AUTH_KERNEL=y
+CONFIG_CC_HAS_BRANCH_PROT_PAC_RET=y
+CONFIG_CC_HAS_SIGN_RETURN_ADDRESS=y
+CONFIG_AS_HAS_PAC=y
+CONFIG_AS_HAS_CFI_NEGATE_RA_STATE=y
+# end of ARMv8.3 architectural features
+
+#
+# ARMv8.4 architectural features
+#
+CONFIG_ARM64_AMU_EXTN=y
+CONFIG_AS_HAS_ARMV8_4=y
+CONFIG_ARM64_TLB_RANGE=y
+CONFIG_ARM64_MPAM=y
+# end of ARMv8.4 architectural features
+
+#
+# ARMv8.5 architectural features
+#
+CONFIG_AS_HAS_ARMV8_5=y
+CONFIG_ARM64_BTI=y
+CONFIG_CC_HAS_BRANCH_PROT_PAC_RET_BTI=y
+CONFIG_ARM64_E0PD=y
+CONFIG_ARCH_RANDOM=y
+CONFIG_ARM64_AS_HAS_MTE=y
+CONFIG_ARM64_MTE=y
+# end of ARMv8.5 architectural features
+
+#
+# ARMv8.7 architectural features
+#
+CONFIG_ARM64_EPAN=y
+# end of ARMv8.7 architectural features
+
+CONFIG_ARM64_SVE=y
+CONFIG_ARM64_MODULE_PLTS=y
+# CONFIG_ARM64_PSEUDO_NMI is not set
+CONFIG_RELOCATABLE=y
+CONFIG_RANDOMIZE_BASE=y
+# CONFIG_RANDOMIZE_MODULE_REGION_FULL is not set
+CONFIG_CC_HAVE_STACKPROTECTOR_SYSREG=y
+CONFIG_STACKPROTECTOR_PER_TASK=y
+# end of Kernel Features
+
+#
+# Boot options
+#
+CONFIG_CMDLINE=" loglevel=3 console=tty"
+# CONFIG_CMDLINE_FROM_BOOTLOADER is not set
+CONFIG_CMDLINE_EXTEND=y
+# CONFIG_CMDLINE_FORCE is not set
+CONFIG_EFI_STUB=y
+CONFIG_EFI=y
+# CONFIG_DMI is not set
+# end of Boot options
+
+#
+# Power management options
+#
+CONFIG_SUSPEND=y
+CONFIG_SUSPEND_FREEZER=y
+# CONFIG_SUSPEND_SKIP_SYNC is not set
+CONFIG_HIBERNATE_CALLBACKS=y
+CONFIG_HIBERNATION=y
+CONFIG_HIBERNATION_SNAPSHOT_DEV=y
+CONFIG_PM_STD_PARTITION=""
+CONFIG_PM_SLEEP=y
+CONFIG_PM_SLEEP_SMP=y
+# CONFIG_PM_AUTOSLEEP is not set
+CONFIG_PM_WAKELOCKS=y
+CONFIG_PM_WAKELOCKS_LIMIT=0
+# CONFIG_PM_WAKELOCKS_GC is not set
+CONFIG_PM=y
+# CONFIG_PM_DEBUG is not set
+CONFIG_PM_CLK=y
+CONFIG_PM_GENERIC_DOMAINS=y
+# CONFIG_WQ_POWER_EFFICIENT_DEFAULT is not set
+CONFIG_PM_GENERIC_DOMAINS_SLEEP=y
+CONFIG_PM_GENERIC_DOMAINS_OF=y
+CONFIG_CPU_PM=y
+CONFIG_ENERGY_MODEL=y
+CONFIG_ARCH_HIBERNATION_POSSIBLE=y
+CONFIG_ARCH_HIBERNATION_HEADER=y
+CONFIG_ARCH_SUSPEND_POSSIBLE=y
+# end of Power management options
+
+#
+# CPU Power Management
+#
+
+#
+# CPU Idle
+#
+CONFIG_CPU_IDLE=y
+CONFIG_CPU_IDLE_MULTIPLE_DRIVERS=y
+# CONFIG_CPU_IDLE_GOV_LADDER is not set
+CONFIG_CPU_IDLE_GOV_MENU=y
+CONFIG_CPU_IDLE_GOV_TEO=y
+# CONFIG_CPU_IDLE_GOV_QCOM_LPM is not set
+# CONFIG_CPU_IDLE_SIMPLE_GOV_QCOM_LPM is not set
+CONFIG_DT_IDLE_STATES=y
+
+#
+# ARM CPU Idle Drivers
+#
+CONFIG_ARM_CPUIDLE=y
+CONFIG_ARM_PSCI_CPUIDLE=y
+CONFIG_ARM_PSCI_CPUIDLE_DOMAIN=y
+# end of ARM CPU Idle Drivers
+# end of CPU Idle
+
+#
+# CPU Frequency scaling
+#
+CONFIG_CPU_FREQ=y
+CONFIG_CPU_FREQ_GOV_ATTR_SET=y
+CONFIG_CPU_FREQ_GOV_COMMON=y
+CONFIG_CPU_FREQ_STAT=y
+CONFIG_CPU_FREQ_TIMES=y
+# CONFIG_CPU_FREQ_DEFAULT_GOV_PERFORMANCE is not set
+# CONFIG_CPU_FREQ_DEFAULT_GOV_POWERSAVE is not set
+# CONFIG_CPU_FREQ_DEFAULT_GOV_USERSPACE is not set
+# CONFIG_CPU_FREQ_DEFAULT_GOV_ONDEMAND is not set
+# CONFIG_CPU_FREQ_DEFAULT_GOV_CONSERVATIVE is not set
+CONFIG_CPU_FREQ_DEFAULT_GOV_SCHEDUTIL=y
+CONFIG_CPU_FREQ_GOV_PERFORMANCE=y
+CONFIG_CPU_FREQ_GOV_POWERSAVE=y
+# CONFIG_CPU_FREQ_GOV_USERSPACE is not set
+# CONFIG_CPU_FREQ_GOV_ONDEMAND is not set
+CONFIG_CPU_FREQ_GOV_CONSERVATIVE=y
+CONFIG_CPU_FREQ_GOV_SCHEDUTIL=y
+
+#
+# CPU frequency scaling drivers
+#
+# CONFIG_CPUFREQ_DT is not set
+# CONFIG_CPUFREQ_DUMMY is not set
+# CONFIG_CPUFREQ_VM is not set
+CONFIG_ARM_SCPI_CPUFREQ=y
+# CONFIG_ARM_QCOM_CPUFREQ_NVMEM is not set
+# CONFIG_ARM_QCOM_CPUFREQ_HW is not set
+CONFIG_ARM_SCMI_CPUFREQ=y
+# end of CPU Frequency scaling
+# end of CPU Power Management
+
+CONFIG_ARCH_SUPPORTS_ACPI=y
+# CONFIG_ACPI is not set
+CONFIG_IRQ_BYPASS_MANAGER=y
+CONFIG_HAVE_KVM=y
+CONFIG_HAVE_KVM_IRQCHIP=y
+CONFIG_HAVE_KVM_IRQFD=y
+CONFIG_HAVE_KVM_IRQ_ROUTING=y
+CONFIG_HAVE_KVM_EVENTFD=y
+CONFIG_KVM_MMIO=y
+CONFIG_HAVE_KVM_MSI=y
+CONFIG_HAVE_KVM_CPU_RELAX_INTERCEPT=y
+CONFIG_KVM_VFIO=y
+CONFIG_HAVE_KVM_ARCH_TLB_FLUSH_ALL=y
+CONFIG_KVM_GENERIC_DIRTYLOG_READ_PROTECT=y
+CONFIG_HAVE_KVM_IRQ_BYPASS=y
+CONFIG_HAVE_KVM_VCPU_RUN_PID_CHANGE=y
+CONFIG_KVM_XFER_TO_GUEST_WORK=y
+CONFIG_VIRTUALIZATION=y
+CONFIG_KVM=y
+# CONFIG_NVHE_EL2_DEBUG is not set
+CONFIG_KVM_S2MPU=y
+# CONFIG_TEST_KVM_S2MPU is not set
+
+#
+# Gunyah arm64 drivers
+#
+# CONFIG_GH_ARM64_DRV is not set
+# end of Gunyah arm64 drivers
+
+CONFIG_ARM64_CRYPTO=y
+CONFIG_CRYPTO_SHA256_ARM64=y
+CONFIG_CRYPTO_SHA512_ARM64=y
+# CONFIG_CRYPTO_SHA1_ARM64_CE is not set
+CONFIG_CRYPTO_SHA2_ARM64_CE=y
+CONFIG_CRYPTO_SHA512_ARM64_CE=y
+# CONFIG_CRYPTO_SHA3_ARM64 is not set
+# CONFIG_CRYPTO_SM3_ARM64_CE is not set
+# CONFIG_CRYPTO_SM4_ARM64_CE is not set
+CONFIG_CRYPTO_GHASH_ARM64_CE=y
+# CONFIG_CRYPTO_POLYVAL_ARM64_CE is not set
+# CONFIG_CRYPTO_AES_ARM64 is not set
+CONFIG_CRYPTO_AES_ARM64_CE=y
+# CONFIG_CRYPTO_AES_ARM64_CE_CCM is not set
+CONFIG_CRYPTO_AES_ARM64_CE_BLK=y
+# CONFIG_CRYPTO_AES_ARM64_NEON_BLK is not set
+CONFIG_CRYPTO_CHACHA20_NEON=y
+CONFIG_CRYPTO_POLY1305_NEON=y
+# CONFIG_CRYPTO_NHPOLY1305_NEON is not set
+# CONFIG_CRYPTO_AES_ARM64_BS is not set
+
+#
+# General architecture-dependent options
+#
+CONFIG_KPROBES=y
+CONFIG_JUMP_LABEL=y
+# CONFIG_STATIC_KEYS_SELFTEST is not set
+CONFIG_UPROBES=y
+CONFIG_HAVE_EFFICIENT_UNALIGNED_ACCESS=y
+CONFIG_KRETPROBES=y
+CONFIG_HAVE_KPROBES=y
+CONFIG_HAVE_KRETPROBES=y
+CONFIG_HAVE_FUNCTION_ERROR_INJECTION=y
+CONFIG_HAVE_NMI=y
+CONFIG_TRACE_IRQFLAGS_SUPPORT=y
+CONFIG_TRACE_IRQFLAGS_NMI_SUPPORT=y
+CONFIG_HAVE_ARCH_TRACEHOOK=y
+CONFIG_HAVE_DMA_CONTIGUOUS=y
+CONFIG_GENERIC_SMP_IDLE_THREAD=y
+CONFIG_GENERIC_IDLE_POLL_SETUP=y
+CONFIG_ARCH_HAS_FORTIFY_SOURCE=y
+CONFIG_ARCH_HAS_KEEPINITRD=y
+CONFIG_ARCH_HAS_SET_MEMORY=y
+CONFIG_ARCH_HAS_SET_DIRECT_MAP=y
+CONFIG_HAVE_ARCH_THREAD_STRUCT_WHITELIST=y
+CONFIG_ARCH_WANTS_NO_INSTR=y
+CONFIG_HAVE_ASM_MODVERSIONS=y
+CONFIG_HAVE_REGS_AND_STACK_ACCESS_API=y
+CONFIG_HAVE_RSEQ=y
+CONFIG_HAVE_FUNCTION_ARG_ACCESS_API=y
+CONFIG_HAVE_HW_BREAKPOINT=y
+CONFIG_HAVE_PERF_REGS=y
+CONFIG_HAVE_PERF_USER_STACK_DUMP=y
+CONFIG_HAVE_ARCH_JUMP_LABEL=y
+CONFIG_HAVE_ARCH_JUMP_LABEL_RELATIVE=y
+CONFIG_MMU_GATHER_TABLE_FREE=y
+CONFIG_MMU_GATHER_RCU_TABLE_FREE=y
+CONFIG_ARCH_HAVE_NMI_SAFE_CMPXCHG=y
+CONFIG_HAVE_ALIGNED_STRUCT_PAGE=y
+CONFIG_HAVE_CMPXCHG_LOCAL=y
+CONFIG_HAVE_CMPXCHG_DOUBLE=y
+CONFIG_ARCH_WANT_COMPAT_IPC_PARSE_VERSION=y
+CONFIG_HAVE_ARCH_SECCOMP=y
+CONFIG_HAVE_ARCH_SECCOMP_FILTER=y
+CONFIG_SECCOMP=y
+CONFIG_SECCOMP_FILTER=y
+# CONFIG_SECCOMP_CACHE_DEBUG is not set
+CONFIG_HAVE_ARCH_STACKLEAK=y
+CONFIG_HAVE_STACKPROTECTOR=y
+CONFIG_STACKPROTECTOR=y
+CONFIG_STACKPROTECTOR_STRONG=y
+CONFIG_ARCH_SUPPORTS_LTO_CLANG=y
+CONFIG_ARCH_SUPPORTS_LTO_CLANG_THIN=y
+CONFIG_LTO_NONE=y
+CONFIG_ARCH_SUPPORTS_CFI_CLANG=y
+CONFIG_HAVE_CONTEXT_TRACKING=y
+CONFIG_HAVE_VIRT_CPU_ACCOUNTING_GEN=y
+CONFIG_HAVE_IRQ_TIME_ACCOUNTING=y
+CONFIG_HAVE_MOVE_PUD=y
+CONFIG_HAVE_MOVE_PMD=y
+CONFIG_HAVE_ARCH_TRANSPARENT_HUGEPAGE=y
+CONFIG_HAVE_ARCH_HUGE_VMAP=y
+CONFIG_ARCH_WANT_HUGE_PMD_SHARE=y
+CONFIG_HAVE_MOD_ARCH_SPECIFIC=y
+CONFIG_MODULES_USE_ELF_RELA=y
+CONFIG_ARCH_HAS_ELF_RANDOMIZE=y
+CONFIG_HAVE_ARCH_MMAP_RND_BITS=y
+CONFIG_ARCH_MMAP_RND_BITS=18
+CONFIG_HAVE_ARCH_MMAP_RND_COMPAT_BITS=y
+CONFIG_ARCH_MMAP_RND_COMPAT_BITS=11
+CONFIG_ARCH_WANT_DEFAULT_TOPDOWN_MMAP_LAYOUT=y
+CONFIG_CLONE_BACKWARDS=y
+CONFIG_OLD_SIGSUSPEND3=y
+CONFIG_COMPAT_OLD_SIGACTION=y
+CONFIG_COMPAT_32BIT_TIME=y
+CONFIG_HAVE_ARCH_VMAP_STACK=y
+CONFIG_VMAP_STACK=y
+CONFIG_HAVE_ARCH_RANDOMIZE_KSTACK_OFFSET=y
+# CONFIG_RANDOMIZE_KSTACK_OFFSET_DEFAULT is not set
+CONFIG_ARCH_HAS_STRICT_KERNEL_RWX=y
+CONFIG_STRICT_KERNEL_RWX=y
+CONFIG_ARCH_HAS_STRICT_MODULE_RWX=y
+CONFIG_STRICT_MODULE_RWX=y
+CONFIG_HAVE_ARCH_COMPILER_H=y
+CONFIG_HAVE_ARCH_PREL32_RELOCATIONS=y
+CONFIG_ARCH_USE_MEMREMAP_PROT=y
+# CONFIG_LOCK_EVENT_COUNTS is not set
+CONFIG_ARCH_HAS_RELR=y
+CONFIG_ARCH_HAS_MEM_ENCRYPT=y
+CONFIG_ARCH_WANT_LD_ORPHAN_WARN=y
+CONFIG_ARCH_SUPPORTS_DEBUG_PAGEALLOC=y
+CONFIG_ARCH_HAVE_TRACE_MMIO_ACCESS=y
+
+#
+# GCOV-based kernel profiling
+#
+# CONFIG_GCOV_KERNEL is not set
+CONFIG_ARCH_HAS_GCOV_PROFILE_ALL=y
+# end of GCOV-based kernel profiling
+
+CONFIG_HAVE_GCC_PLUGINS=y
+CONFIG_GCC_PLUGINS=y
+# CONFIG_GCC_PLUGIN_CYC_COMPLEXITY is not set
+# CONFIG_GCC_PLUGIN_LATENT_ENTROPY is not set
+# CONFIG_GCC_PLUGIN_RANDSTRUCT is not set
+# end of General architecture-dependent options
+
+CONFIG_RT_MUTEXES=y
+CONFIG_BASE_SMALL=0
+CONFIG_MODULE_SIG_FORMAT=y
+CONFIG_MODULES=y
+CONFIG_MODULE_FORCE_LOAD=y
+CONFIG_MODULE_UNLOAD=y
+CONFIG_MODULE_FORCE_UNLOAD=y
+CONFIG_MODVERSIONS=y
+CONFIG_ASM_MODVERSIONS=y
+# CONFIG_MODULE_SRCVERSION_ALL is not set
+CONFIG_MODULE_SCMVERSION=y
+CONFIG_MODULE_SIG=y
+# CONFIG_MODULE_SIG_FORCE is not set
+CONFIG_MODULE_SIG_PROTECT=y
+CONFIG_MODULE_SIG_ALL=y
+CONFIG_MODULE_SIG_SHA1=y
+# CONFIG_MODULE_SIG_SHA224 is not set
+# CONFIG_MODULE_SIG_SHA256 is not set
+# CONFIG_MODULE_SIG_SHA384 is not set
+# CONFIG_MODULE_SIG_SHA512 is not set
+CONFIG_MODULE_SIG_HASH="sha1"
+CONFIG_MODULE_COMPRESS_NONE=y
+# CONFIG_MODULE_COMPRESS_GZIP is not set
+# CONFIG_MODULE_COMPRESS_XZ is not set
+# CONFIG_MODULE_COMPRESS_ZSTD is not set
+# CONFIG_MODULE_ALLOW_MISSING_NAMESPACE_IMPORTS is not set
+CONFIG_MODPROBE_PATH="/sbin/modprobe"
+CONFIG_TRIM_UNUSED_KSYMS=y
+CONFIG_UNUSED_KSYMS_WHITELIST=""
+CONFIG_MODULES_TREE_LOOKUP=y
+CONFIG_BLOCK=y
+CONFIG_BLK_RQ_ALLOC_TIME=y
+CONFIG_BLK_CGROUP_RWSTAT=y
+CONFIG_BLK_DEV_BSG_COMMON=y
+CONFIG_BLK_DEV_BSGLIB=y
+# CONFIG_BLK_DEV_INTEGRITY is not set
+# CONFIG_BLK_DEV_ZONED is not set
+# CONFIG_BLK_DEV_THROTTLING is not set
+# CONFIG_BLK_WBT is not set
+# CONFIG_BLK_CGROUP_IOLATENCY is not set
+CONFIG_BLK_CGROUP_IOCOST=y
+CONFIG_BLK_CGROUP_IOPRIO=y
+CONFIG_BLK_DEBUG_FS=y
+# CONFIG_BLK_SED_OPAL is not set
+CONFIG_BLK_INLINE_ENCRYPTION=y
+CONFIG_BLK_INLINE_ENCRYPTION_FALLBACK=y
+
+#
+# Partition Types
+#
+# CONFIG_PARTITION_ADVANCED is not set
+CONFIG_MSDOS_PARTITION=y
+CONFIG_EFI_PARTITION=y
+# end of Partition Types
+
+CONFIG_BLOCK_COMPAT=y
+CONFIG_BLK_MQ_PCI=y
+CONFIG_BLK_MQ_VIRTIO=y
+CONFIG_BLK_PM=y
+CONFIG_BLOCK_HOLDER_DEPRECATED=y
+
+#
+# IO Schedulers
+#
+CONFIG_MQ_IOSCHED_DEADLINE=y
+CONFIG_MQ_IOSCHED_KYBER=y
+CONFIG_IOSCHED_BFQ=y
+CONFIG_BFQ_GROUP_IOSCHED=y
+# CONFIG_BFQ_CGROUP_DEBUG is not set
+# end of IO Schedulers
+
+CONFIG_PREEMPT_NOTIFIERS=y
+CONFIG_ASN1=y
+CONFIG_UNINLINE_SPIN_UNLOCK=y
+CONFIG_ARCH_SUPPORTS_ATOMIC_RMW=y
+CONFIG_MUTEX_SPIN_ON_OWNER=y
+CONFIG_RWSEM_SPIN_ON_OWNER=y
+CONFIG_LOCK_SPIN_ON_OWNER=y
+CONFIG_ARCH_USE_QUEUED_SPINLOCKS=y
+CONFIG_QUEUED_SPINLOCKS=y
+CONFIG_ARCH_USE_QUEUED_RWLOCKS=y
+CONFIG_QUEUED_RWLOCKS=y
+CONFIG_ARCH_HAS_NON_OVERLAPPING_ADDRESS_SPACE=y
+CONFIG_ARCH_HAS_SYSCALL_WRAPPER=y
+CONFIG_GKI_HIDDEN_DRM_CONFIGS=y
+CONFIG_GKI_HIDDEN_REGMAP_CONFIGS=y
+CONFIG_GKI_HIDDEN_CRYPTO_CONFIGS=y
+CONFIG_GKI_HIDDEN_SND_CONFIGS=y
+CONFIG_GKI_HIDDEN_SND_SOC_CONFIGS=y
+CONFIG_GKI_HIDDEN_MMC_CONFIGS=y
+CONFIG_GKI_HIDDEN_GPIO_CONFIGS=y
+CONFIG_GKI_HIDDEN_QCOM_CONFIGS=y
+CONFIG_GKI_HIDDEN_MEDIA_CONFIGS=y
+CONFIG_GKI_HIDDEN_VIRTUAL_CONFIGS=y
+CONFIG_GKI_LEGACY_WEXT_ALLCONFIG=y
+CONFIG_GKI_HIDDEN_USB_CONFIGS=y
+CONFIG_GKI_HIDDEN_SOC_BUS_CONFIGS=y
+CONFIG_GKI_HIDDEN_RPMSG_CONFIGS=y
+CONFIG_GKI_HIDDEN_GPU_CONFIGS=y
+CONFIG_GKI_HIDDEN_IRQ_CONFIGS=y
+CONFIG_GKI_HIDDEN_HYPERVISOR_CONFIGS=y
+CONFIG_GKI_HIDDEN_NET_CONFIGS=y
+CONFIG_GKI_HIDDEN_PHY_CONFIGS=y
+CONFIG_GKI_HIDDEN_MM_CONFIGS=y
+CONFIG_GKI_HIDDEN_ETHERNET_CONFIGS=y
+CONFIG_GKI_HIDDEN_DMA_CONFIGS=y
+CONFIG_GKI_HACKS_TO_FIX=y
+# CONFIG_GKI_HACKS_FOR_DEBUG_CONFIG is not set
+CONFIG_FREEZER=y
+
+#
+# Executable file formats
+#
+CONFIG_BINFMT_ELF=y
+CONFIG_COMPAT_BINFMT_ELF=y
+CONFIG_ARCH_BINFMT_ELF_STATE=y
+CONFIG_ARCH_BINFMT_ELF_EXTRA_PHDRS=y
+CONFIG_ARCH_HAVE_ELF_PROT=y
+CONFIG_ARCH_USE_GNU_PROPERTY=y
+CONFIG_ELFCORE=y
+# CONFIG_CORE_DUMP_DEFAULT_ELF_HEADERS is not set
+CONFIG_BINFMT_SCRIPT=y
+CONFIG_BINFMT_MISC=y
+CONFIG_COREDUMP=y
+# end of Executable file formats
+
+#
+# Memory Management options
+#
+CONFIG_SPARSEMEM=y
+CONFIG_SPARSEMEM_EXTREME=y
+CONFIG_SPARSEMEM_VMEMMAP_ENABLE=y
+CONFIG_SPARSEMEM_VMEMMAP=y
+CONFIG_HAVE_FAST_GUP=y
+CONFIG_ARCH_KEEP_MEMBLOCK=y
+CONFIG_MEMORY_ISOLATION=y
+CONFIG_ARCH_ENABLE_MEMORY_HOTPLUG=y
+CONFIG_MEMORY_HOTPLUG=y
+CONFIG_MEMORY_HOTPLUG_SPARSE=y
+# CONFIG_MEMORY_HOTPLUG_DEFAULT_ONLINE is not set
+CONFIG_ARCH_ENABLE_MEMORY_HOTREMOVE=y
+CONFIG_MEMORY_HOTREMOVE=y
+CONFIG_MHP_MEMMAP_ON_MEMORY=y
+CONFIG_SPLIT_PTLOCK_CPUS=4
+CONFIG_ARCH_ENABLE_SPLIT_PMD_PTLOCK=y
+CONFIG_MEMORY_BALLOON=y
+CONFIG_BALLOON_COMPACTION=y
+CONFIG_COMPACTION=y
+CONFIG_PAGE_REPORTING=y
+CONFIG_MIGRATION=y
+CONFIG_ARCH_ENABLE_THP_MIGRATION=y
+CONFIG_CONTIG_ALLOC=y
+CONFIG_PHYS_ADDR_T_64BIT=y
+CONFIG_MMU_NOTIFIER=y
+# CONFIG_KSM is not set
+CONFIG_DEFAULT_MMAP_MIN_ADDR=32768
+CONFIG_ARCH_SUPPORTS_MEMORY_FAILURE=y
+# CONFIG_MEMORY_FAILURE is not set
+CONFIG_TRANSPARENT_HUGEPAGE=y
+# CONFIG_TRANSPARENT_HUGEPAGE_ALWAYS is not set
+CONFIG_TRANSPARENT_HUGEPAGE_MADVISE=y
+CONFIG_CLEANCACHE=y
+# CONFIG_FRONTSWAP is not set
+CONFIG_CMA=y
+# CONFIG_CMA_DEBUG is not set
+CONFIG_CMA_DEBUGFS=y
+# CONFIG_CMA_SYSFS is not set
+CONFIG_CMA_AREAS=32
+# CONFIG_ZPOOL is not set
+CONFIG_ZSMALLOC=m
+# CONFIG_ZSMALLOC_STAT is not set
+CONFIG_GENERIC_EARLY_IOREMAP=y
+# CONFIG_DEFERRED_STRUCT_PAGE_INIT is not set
+CONFIG_PAGE_IDLE_FLAG=y
+# CONFIG_IDLE_PAGE_TRACKING is not set
+CONFIG_ARCH_HAS_CACHE_LINE_SIZE=y
+CONFIG_ARCH_HAS_PTE_DEVMAP=y
+CONFIG_ARCH_HAS_ZONE_DMA_SET=y
+# CONFIG_ZONE_DMA is not set
+CONFIG_ZONE_DMA32=y
+# CONFIG_ZONE_DEVICE is not set
+CONFIG_ARCH_USES_HIGH_VMA_FLAGS=y
+# CONFIG_PERCPU_STATS is not set
+# CONFIG_GUP_TEST is not set
+# CONFIG_READ_ONLY_THP_FOR_FS is not set
+CONFIG_ARCH_HAS_PTE_SPECIAL=y
+CONFIG_ARCH_HAS_IOREMAP_PHYS_HOOKS=y
+CONFIG_ANON_VMA_NAME=y
+CONFIG_LRU_GEN=y
+# CONFIG_LRU_GEN_ENABLED is not set
+# CONFIG_LRU_GEN_STATS is not set
+
+#
+# Data Access Monitoring
+#
+CONFIG_DAMON=y
+# CONFIG_DAMON_VADDR is not set
+CONFIG_DAMON_PADDR=y
+CONFIG_DAMON_RECLAIM=y
+# end of Data Access Monitoring
+
+CONFIG_ARCH_SUPPORTS_SPECULATIVE_PAGE_FAULT=y
+CONFIG_SPECULATIVE_PAGE_FAULT=y
+# end of Memory Management options
+
+CONFIG_NET=y
+CONFIG_COMPAT_NETLINK_MESSAGES=y
+CONFIG_NET_INGRESS=y
+CONFIG_NET_EGRESS=y
+CONFIG_NET_REDIRECT=y
+CONFIG_SKB_EXTENSIONS=y
+
+#
+# Networking options
+#
+CONFIG_PACKET=y
+# CONFIG_PACKET_DIAG is not set
+CONFIG_UNIX=y
+CONFIG_UNIX_SCM=y
+CONFIG_AF_UNIX_OOB=y
+# CONFIG_UNIX_DIAG is not set
+# CONFIG_TLS is not set
+CONFIG_XFRM=y
+CONFIG_XFRM_ALGO=y
+CONFIG_XFRM_USER=y
+CONFIG_XFRM_INTERFACE=y
+# CONFIG_XFRM_SUB_POLICY is not set
+CONFIG_XFRM_MIGRATE=y
+CONFIG_XFRM_STATISTICS=y
+CONFIG_XFRM_ESP=y
+CONFIG_XFRM_IPCOMP=y
+CONFIG_NET_KEY=y
+# CONFIG_NET_KEY_MIGRATE is not set
+CONFIG_XDP_SOCKETS=y
+# CONFIG_XDP_SOCKETS_DIAG is not set
+CONFIG_INET=y
+CONFIG_IP_MULTICAST=y
+CONFIG_IP_ADVANCED_ROUTER=y
+# CONFIG_IP_FIB_TRIE_STATS is not set
+CONFIG_IP_MULTIPLE_TABLES=y
+# CONFIG_IP_ROUTE_MULTIPATH is not set
+# CONFIG_IP_ROUTE_VERBOSE is not set
+# CONFIG_IP_PNP is not set
+CONFIG_NET_IPIP=y
+CONFIG_NET_IPGRE_DEMUX=y
+CONFIG_NET_IP_TUNNEL=y
+CONFIG_NET_IPGRE=y
+# CONFIG_NET_IPGRE_BROADCAST is not set
+# CONFIG_IP_MROUTE is not set
+CONFIG_SYN_COOKIES=y
+CONFIG_NET_IPVTI=y
+CONFIG_NET_UDP_TUNNEL=y
+# CONFIG_NET_FOU is not set
+# CONFIG_NET_FOU_IP_TUNNELS is not set
+# CONFIG_INET_AH is not set
+CONFIG_INET_ESP=y
+# CONFIG_INET_ESP_OFFLOAD is not set
+# CONFIG_INET_ESPINTCP is not set
+# CONFIG_INET_IPCOMP is not set
+CONFIG_INET_TABLE_PERTURB_ORDER=16
+CONFIG_INET_TUNNEL=y
+CONFIG_INET_DIAG=y
+CONFIG_INET_TCP_DIAG=y
+CONFIG_INET_UDP_DIAG=y
+# CONFIG_INET_RAW_DIAG is not set
+CONFIG_INET_DIAG_DESTROY=y
+# CONFIG_TCP_CONG_ADVANCED is not set
+CONFIG_TCP_CONG_CUBIC=y
+CONFIG_DEFAULT_TCP_CONG="cubic"
+# CONFIG_TCP_MD5SIG is not set
+CONFIG_IPV6=y
+CONFIG_IPV6_ROUTER_PREF=y
+CONFIG_IPV6_ROUTE_INFO=y
+CONFIG_IPV6_OPTIMISTIC_DAD=y
+# CONFIG_INET6_AH is not set
+CONFIG_INET6_ESP=y
+# CONFIG_INET6_ESP_OFFLOAD is not set
+# CONFIG_INET6_ESPINTCP is not set
+CONFIG_INET6_IPCOMP=y
+CONFIG_IPV6_MIP6=y
+# CONFIG_IPV6_ILA is not set
+CONFIG_INET6_XFRM_TUNNEL=y
+CONFIG_INET6_TUNNEL=y
+CONFIG_IPV6_VTI=y
+CONFIG_IPV6_SIT=y
+# CONFIG_IPV6_SIT_6RD is not set
+CONFIG_IPV6_NDISC_NODETYPE=y
+CONFIG_IPV6_TUNNEL=y
+CONFIG_IPV6_GRE=y
+CONFIG_IPV6_MULTIPLE_TABLES=y
+# CONFIG_IPV6_SUBTREES is not set
+# CONFIG_IPV6_MROUTE is not set
+# CONFIG_IPV6_SEG6_LWTUNNEL is not set
+# CONFIG_IPV6_SEG6_HMAC is not set
+# CONFIG_IPV6_RPL_LWTUNNEL is not set
+# CONFIG_IPV6_IOAM6_LWTUNNEL is not set
+# CONFIG_NETLABEL is not set
+# CONFIG_MPTCP is not set
+CONFIG_NETWORK_SECMARK=y
+CONFIG_NET_PTP_CLASSIFY=y
+# CONFIG_NETWORK_PHY_TIMESTAMPING is not set
+CONFIG_NETFILTER=y
+CONFIG_NETFILTER_ADVANCED=y
+# CONFIG_BRIDGE_NETFILTER is not set
+
+#
+# Core Netfilter Configuration
+#
+CONFIG_NETFILTER_INGRESS=y
+CONFIG_NETFILTER_NETLINK=y
+CONFIG_NETFILTER_FAMILY_ARP=y
+# CONFIG_NETFILTER_NETLINK_ACCT is not set
+CONFIG_NETFILTER_NETLINK_QUEUE=y
+CONFIG_NETFILTER_NETLINK_LOG=y
+# CONFIG_NETFILTER_NETLINK_OSF is not set
+CONFIG_NF_CONNTRACK=y
+# CONFIG_NF_LOG_SYSLOG is not set
+CONFIG_NETFILTER_CONNCOUNT=y
+CONFIG_NF_CONNTRACK_MARK=y
+CONFIG_NF_CONNTRACK_SECMARK=y
+# CONFIG_NF_CONNTRACK_ZONES is not set
+CONFIG_NF_CONNTRACK_PROCFS=y
+CONFIG_NF_CONNTRACK_EVENTS=y
+# CONFIG_NF_CONNTRACK_TIMEOUT is not set
+# CONFIG_NF_CONNTRACK_TIMESTAMP is not set
+# CONFIG_NF_CONNTRACK_LABELS is not set
+CONFIG_NF_CT_PROTO_DCCP=y
+CONFIG_NF_CT_PROTO_GRE=y
+CONFIG_NF_CT_PROTO_SCTP=y
+CONFIG_NF_CT_PROTO_UDPLITE=y
+CONFIG_NF_CONNTRACK_AMANDA=y
+CONFIG_NF_CONNTRACK_FTP=y
+CONFIG_NF_CONNTRACK_H323=y
+CONFIG_NF_CONNTRACK_IRC=y
+CONFIG_NF_CONNTRACK_BROADCAST=y
+CONFIG_NF_CONNTRACK_NETBIOS_NS=y
+# CONFIG_NF_CONNTRACK_SNMP is not set
+CONFIG_NF_CONNTRACK_PPTP=y
+CONFIG_NF_CONNTRACK_SANE=y
+# CONFIG_NF_CONNTRACK_SIP is not set
+CONFIG_NF_CONNTRACK_TFTP=y
+CONFIG_NF_CT_NETLINK=y
+# CONFIG_NETFILTER_NETLINK_GLUE_CT is not set
+CONFIG_NF_NAT=y
+CONFIG_NF_NAT_AMANDA=y
+CONFIG_NF_NAT_FTP=y
+CONFIG_NF_NAT_IRC=y
+CONFIG_NF_NAT_TFTP=y
+CONFIG_NF_NAT_REDIRECT=y
+CONFIG_NF_NAT_MASQUERADE=y
+# CONFIG_NF_TABLES is not set
+CONFIG_NETFILTER_XTABLES=y
+CONFIG_NETFILTER_XTABLES_COMPAT=y
+
+#
+# Xtables combined modules
+#
+CONFIG_NETFILTER_XT_MARK=y
+CONFIG_NETFILTER_XT_CONNMARK=y
+
+#
+# Xtables targets
+#
+# CONFIG_NETFILTER_XT_TARGET_AUDIT is not set
+# CONFIG_NETFILTER_XT_TARGET_CHECKSUM is not set
+CONFIG_NETFILTER_XT_TARGET_CLASSIFY=y
+CONFIG_NETFILTER_XT_TARGET_CONNMARK=y
+CONFIG_NETFILTER_XT_TARGET_CONNSECMARK=y
+CONFIG_NETFILTER_XT_TARGET_CT=y
+CONFIG_NETFILTER_XT_TARGET_DSCP=y
+# CONFIG_NETFILTER_XT_TARGET_HL is not set
+# CONFIG_NETFILTER_XT_TARGET_HMARK is not set
+CONFIG_NETFILTER_XT_TARGET_IDLETIMER=y
+# CONFIG_NETFILTER_XT_TARGET_LED is not set
+# CONFIG_NETFILTER_XT_TARGET_LOG is not set
+CONFIG_NETFILTER_XT_TARGET_MARK=y
+CONFIG_NETFILTER_XT_NAT=y
+CONFIG_NETFILTER_XT_TARGET_NETMAP=y
+CONFIG_NETFILTER_XT_TARGET_NFLOG=y
+CONFIG_NETFILTER_XT_TARGET_NFQUEUE=y
+CONFIG_NETFILTER_XT_TARGET_NOTRACK=y
+# CONFIG_NETFILTER_XT_TARGET_RATEEST is not set
+CONFIG_NETFILTER_XT_TARGET_REDIRECT=y
+CONFIG_NETFILTER_XT_TARGET_MASQUERADE=y
+CONFIG_NETFILTER_XT_TARGET_TEE=y
+CONFIG_NETFILTER_XT_TARGET_TPROXY=y
+CONFIG_NETFILTER_XT_TARGET_TRACE=y
+CONFIG_NETFILTER_XT_TARGET_SECMARK=y
+CONFIG_NETFILTER_XT_TARGET_TCPMSS=y
+# CONFIG_NETFILTER_XT_TARGET_TCPOPTSTRIP is not set
+
+#
+# Xtables matches
+#
+# CONFIG_NETFILTER_XT_MATCH_ADDRTYPE is not set
+CONFIG_NETFILTER_XT_MATCH_BPF=y
+# CONFIG_NETFILTER_XT_MATCH_CGROUP is not set
+# CONFIG_NETFILTER_XT_MATCH_CLUSTER is not set
+CONFIG_NETFILTER_XT_MATCH_COMMENT=y
+# CONFIG_NETFILTER_XT_MATCH_CONNBYTES is not set
+# CONFIG_NETFILTER_XT_MATCH_CONNLABEL is not set
+CONFIG_NETFILTER_XT_MATCH_CONNLIMIT=y
+CONFIG_NETFILTER_XT_MATCH_CONNMARK=y
+CONFIG_NETFILTER_XT_MATCH_CONNTRACK=y
+# CONFIG_NETFILTER_XT_MATCH_CPU is not set
+# CONFIG_NETFILTER_XT_MATCH_DCCP is not set
+# CONFIG_NETFILTER_XT_MATCH_DEVGROUP is not set
+CONFIG_NETFILTER_XT_MATCH_DSCP=y
+CONFIG_NETFILTER_XT_MATCH_ECN=y
+CONFIG_NETFILTER_XT_MATCH_ESP=y
+CONFIG_NETFILTER_XT_MATCH_HASHLIMIT=y
+CONFIG_NETFILTER_XT_MATCH_HELPER=y
+CONFIG_NETFILTER_XT_MATCH_HL=y
+# CONFIG_NETFILTER_XT_MATCH_IPCOMP is not set
+CONFIG_NETFILTER_XT_MATCH_IPRANGE=y
+CONFIG_NETFILTER_XT_MATCH_L2TP=y
+CONFIG_NETFILTER_XT_MATCH_LENGTH=y
+CONFIG_NETFILTER_XT_MATCH_LIMIT=y
+CONFIG_NETFILTER_XT_MATCH_MAC=y
+CONFIG_NETFILTER_XT_MATCH_MARK=y
+CONFIG_NETFILTER_XT_MATCH_MULTIPORT=y
+# CONFIG_NETFILTER_XT_MATCH_NFACCT is not set
+# CONFIG_NETFILTER_XT_MATCH_OSF is not set
+CONFIG_NETFILTER_XT_MATCH_OWNER=y
+CONFIG_NETFILTER_XT_MATCH_POLICY=y
+CONFIG_NETFILTER_XT_MATCH_PKTTYPE=y
+CONFIG_NETFILTER_XT_MATCH_QUOTA=y
+CONFIG_NETFILTER_XT_MATCH_QUOTA2=y
+CONFIG_NETFILTER_XT_MATCH_QUOTA2_LOG=y
+# CONFIG_NETFILTER_XT_MATCH_RATEEST is not set
+# CONFIG_NETFILTER_XT_MATCH_REALM is not set
+# CONFIG_NETFILTER_XT_MATCH_RECENT is not set
+# CONFIG_NETFILTER_XT_MATCH_SCTP is not set
+CONFIG_NETFILTER_XT_MATCH_SOCKET=y
+CONFIG_NETFILTER_XT_MATCH_STATE=y
+CONFIG_NETFILTER_XT_MATCH_STATISTIC=y
+CONFIG_NETFILTER_XT_MATCH_STRING=y
+# CONFIG_NETFILTER_XT_MATCH_TCPMSS is not set
+CONFIG_NETFILTER_XT_MATCH_TIME=y
+CONFIG_NETFILTER_XT_MATCH_U32=y
+# end of Core Netfilter Configuration
+
+# CONFIG_IP_SET is not set
+# CONFIG_IP_VS is not set
+
+#
+# IP: Netfilter Configuration
+#
+CONFIG_NF_DEFRAG_IPV4=y
+CONFIG_NF_SOCKET_IPV4=y
+CONFIG_NF_TPROXY_IPV4=y
+CONFIG_NF_DUP_IPV4=y
+# CONFIG_NF_LOG_ARP is not set
+# CONFIG_NF_LOG_IPV4 is not set
+CONFIG_NF_REJECT_IPV4=y
+CONFIG_NF_NAT_PPTP=y
+CONFIG_NF_NAT_H323=y
+CONFIG_IP_NF_IPTABLES=y
+# CONFIG_IP_NF_MATCH_AH is not set
+CONFIG_IP_NF_MATCH_ECN=y
+# CONFIG_IP_NF_MATCH_RPFILTER is not set
+CONFIG_IP_NF_MATCH_TTL=y
+CONFIG_IP_NF_FILTER=y
+CONFIG_IP_NF_TARGET_REJECT=y
+# CONFIG_IP_NF_TARGET_SYNPROXY is not set
+CONFIG_IP_NF_NAT=y
+CONFIG_IP_NF_TARGET_MASQUERADE=y
+CONFIG_IP_NF_TARGET_NETMAP=y
+CONFIG_IP_NF_TARGET_REDIRECT=y
+CONFIG_IP_NF_MANGLE=y
+# CONFIG_IP_NF_TARGET_CLUSTERIP is not set
+# CONFIG_IP_NF_TARGET_ECN is not set
+# CONFIG_IP_NF_TARGET_TTL is not set
+CONFIG_IP_NF_RAW=y
+CONFIG_IP_NF_SECURITY=y
+CONFIG_IP_NF_ARPTABLES=y
+CONFIG_IP_NF_ARPFILTER=y
+CONFIG_IP_NF_ARP_MANGLE=y
+# end of IP: Netfilter Configuration
+
+#
+# IPv6: Netfilter Configuration
+#
+CONFIG_NF_SOCKET_IPV6=y
+CONFIG_NF_TPROXY_IPV6=y
+CONFIG_NF_DUP_IPV6=y
+CONFIG_NF_REJECT_IPV6=y
+# CONFIG_NF_LOG_IPV6 is not set
+CONFIG_IP6_NF_IPTABLES=y
+# CONFIG_IP6_NF_MATCH_AH is not set
+# CONFIG_IP6_NF_MATCH_EUI64 is not set
+# CONFIG_IP6_NF_MATCH_FRAG is not set
+# CONFIG_IP6_NF_MATCH_OPTS is not set
+# CONFIG_IP6_NF_MATCH_HL is not set
+# CONFIG_IP6_NF_MATCH_IPV6HEADER is not set
+# CONFIG_IP6_NF_MATCH_MH is not set
+CONFIG_IP6_NF_MATCH_RPFILTER=y
+# CONFIG_IP6_NF_MATCH_RT is not set
+# CONFIG_IP6_NF_MATCH_SRH is not set
+# CONFIG_IP6_NF_TARGET_HL is not set
+CONFIG_IP6_NF_FILTER=y
+CONFIG_IP6_NF_TARGET_REJECT=y
+# CONFIG_IP6_NF_TARGET_SYNPROXY is not set
+CONFIG_IP6_NF_MANGLE=y
+CONFIG_IP6_NF_RAW=y
+# CONFIG_IP6_NF_SECURITY is not set
+# CONFIG_IP6_NF_NAT is not set
+# end of IPv6: Netfilter Configuration
+
+CONFIG_NF_DEFRAG_IPV6=y
+# CONFIG_NF_CONNTRACK_BRIDGE is not set
+# CONFIG_BRIDGE_NF_EBTABLES is not set
+# CONFIG_BPFILTER is not set
+# CONFIG_IP_DCCP is not set
+# CONFIG_IP_SCTP is not set
+# CONFIG_RDS is not set
+CONFIG_TIPC=y
+CONFIG_TIPC_MEDIA_UDP=y
+CONFIG_TIPC_CRYPTO=y
+CONFIG_TIPC_DIAG=y
+# CONFIG_ATM is not set
+CONFIG_L2TP=y
+# CONFIG_L2TP_DEBUGFS is not set
+# CONFIG_L2TP_V3 is not set
+CONFIG_STP=y
+CONFIG_BRIDGE=y
+CONFIG_BRIDGE_IGMP_SNOOPING=y
+# CONFIG_BRIDGE_VLAN_FILTERING is not set
+# CONFIG_BRIDGE_MRP is not set
+# CONFIG_BRIDGE_CFM is not set
+# CONFIG_NET_DSA is not set
+CONFIG_VLAN_8021Q=y
+# CONFIG_VLAN_8021Q_GVRP is not set
+# CONFIG_VLAN_8021Q_MVRP is not set
+# CONFIG_DECNET is not set
+CONFIG_LLC=y
+# CONFIG_LLC2 is not set
+# CONFIG_ATALK is not set
+# CONFIG_X25 is not set
+# CONFIG_LAPB is not set
+# CONFIG_PHONET is not set
+CONFIG_6LOWPAN=y
+# CONFIG_6LOWPAN_DEBUGFS is not set
+CONFIG_6LOWPAN_NHC=y
+CONFIG_6LOWPAN_NHC_DEST=y
+CONFIG_6LOWPAN_NHC_FRAGMENT=y
+CONFIG_6LOWPAN_NHC_HOP=y
+CONFIG_6LOWPAN_NHC_IPV6=y
+CONFIG_6LOWPAN_NHC_MOBILITY=y
+CONFIG_6LOWPAN_NHC_ROUTING=y
+CONFIG_6LOWPAN_NHC_UDP=y
+# CONFIG_6LOWPAN_GHC_EXT_HDR_HOP is not set
+# CONFIG_6LOWPAN_GHC_UDP is not set
+# CONFIG_6LOWPAN_GHC_ICMPV6 is not set
+# CONFIG_6LOWPAN_GHC_EXT_HDR_DEST is not set
+# CONFIG_6LOWPAN_GHC_EXT_HDR_FRAG is not set
+# CONFIG_6LOWPAN_GHC_EXT_HDR_ROUTE is not set
+CONFIG_IEEE802154=y
+# CONFIG_IEEE802154_NL802154_EXPERIMENTAL is not set
+CONFIG_IEEE802154_SOCKET=y
+CONFIG_IEEE802154_6LOWPAN=y
+CONFIG_MAC802154=y
+CONFIG_NET_SCHED=y
+
+#
+# Queueing/Scheduling
+#
+# CONFIG_NET_SCH_CBQ is not set
+CONFIG_NET_SCH_HTB=y
+# CONFIG_NET_SCH_HFSC is not set
+CONFIG_NET_SCH_PRIO=y
+CONFIG_NET_SCH_MULTIQ=y
+# CONFIG_NET_SCH_RED is not set
+# CONFIG_NET_SCH_SFB is not set
+CONFIG_NET_SCH_SFQ=y
+# CONFIG_NET_SCH_TEQL is not set
+CONFIG_NET_SCH_TBF=y
+# CONFIG_NET_SCH_CBS is not set
+# CONFIG_NET_SCH_ETF is not set
+# CONFIG_NET_SCH_TAPRIO is not set
+# CONFIG_NET_SCH_GRED is not set
+# CONFIG_NET_SCH_DSMARK is not set
+CONFIG_NET_SCH_NETEM=y
+# CONFIG_NET_SCH_DRR is not set
+# CONFIG_NET_SCH_MQPRIO is not set
+# CONFIG_NET_SCH_SKBPRIO is not set
+# CONFIG_NET_SCH_CHOKE is not set
+# CONFIG_NET_SCH_QFQ is not set
+CONFIG_NET_SCH_CODEL=y
+CONFIG_NET_SCH_FQ_CODEL=y
+# CONFIG_NET_SCH_CAKE is not set
+CONFIG_NET_SCH_FQ=y
+# CONFIG_NET_SCH_HHF is not set
+# CONFIG_NET_SCH_PIE is not set
+CONFIG_NET_SCH_INGRESS=y
+# CONFIG_NET_SCH_PLUG is not set
+# CONFIG_NET_SCH_ETS is not set
+# CONFIG_NET_SCH_DEFAULT is not set
+
+#
+# Classification
+#
+CONFIG_NET_CLS=y
+CONFIG_NET_CLS_BASIC=y
+# CONFIG_NET_CLS_ROUTE4 is not set
+CONFIG_NET_CLS_FW=y
+CONFIG_NET_CLS_U32=y
+# CONFIG_CLS_U32_PERF is not set
+CONFIG_CLS_U32_MARK=y
+# CONFIG_NET_CLS_RSVP is not set
+# CONFIG_NET_CLS_RSVP6 is not set
+CONFIG_NET_CLS_FLOW=y
+# CONFIG_NET_CLS_CGROUP is not set
+CONFIG_NET_CLS_BPF=y
+# CONFIG_NET_CLS_FLOWER is not set
+CONFIG_NET_CLS_MATCHALL=y
+CONFIG_NET_EMATCH=y
+CONFIG_NET_EMATCH_STACK=32
+CONFIG_NET_EMATCH_CMP=y
+CONFIG_NET_EMATCH_NBYTE=y
+CONFIG_NET_EMATCH_U32=y
+CONFIG_NET_EMATCH_META=y
+CONFIG_NET_EMATCH_TEXT=y
+# CONFIG_NET_EMATCH_CANID is not set
+# CONFIG_NET_EMATCH_IPT is not set
+CONFIG_NET_CLS_ACT=y
+CONFIG_NET_ACT_POLICE=y
+CONFIG_NET_ACT_GACT=y
+# CONFIG_GACT_PROB is not set
+CONFIG_NET_ACT_MIRRED=y
+# CONFIG_NET_ACT_SAMPLE is not set
+# CONFIG_NET_ACT_IPT is not set
+# CONFIG_NET_ACT_NAT is not set
+# CONFIG_NET_ACT_PEDIT is not set
+# CONFIG_NET_ACT_SIMP is not set
+CONFIG_NET_ACT_SKBEDIT=y
+# CONFIG_NET_ACT_CSUM is not set
+# CONFIG_NET_ACT_MPLS is not set
+# CONFIG_NET_ACT_VLAN is not set
+CONFIG_NET_ACT_BPF=y
+# CONFIG_NET_ACT_CONNMARK is not set
+# CONFIG_NET_ACT_CTINFO is not set
+# CONFIG_NET_ACT_SKBMOD is not set
+# CONFIG_NET_ACT_IFE is not set
+# CONFIG_NET_ACT_TUNNEL_KEY is not set
+# CONFIG_NET_ACT_GATE is not set
+# CONFIG_NET_TC_SKB_EXT is not set
+CONFIG_NET_SCH_FIFO=y
+# CONFIG_DCB is not set
+# CONFIG_DNS_RESOLVER is not set
+# CONFIG_BATMAN_ADV is not set
+# CONFIG_OPENVSWITCH is not set
+CONFIG_VSOCKETS=y
+CONFIG_VSOCKETS_DIAG=y
+CONFIG_VSOCKETS_LOOPBACK=y
+# CONFIG_VIRTIO_VSOCKETS is not set
+CONFIG_VIRTIO_VSOCKETS_COMMON=y
+# CONFIG_NETLINK_DIAG is not set
+# CONFIG_MPLS is not set
+# CONFIG_NET_NSH is not set
+# CONFIG_HSR is not set
+# CONFIG_NET_SWITCHDEV is not set
+# CONFIG_NET_L3_MASTER_DEV is not set
+CONFIG_QRTR=y
+CONFIG_QRTR_NODE_ID=1
+CONFIG_QRTR_WAKEUP_MS=0
+# CONFIG_QRTR_SMD is not set
+# CONFIG_QRTR_TUN is not set
+# CONFIG_QRTR_GUNYAH is not set
+# CONFIG_QRTR_GENPOOL is not set
+# CONFIG_QRTR_BPF_FILTER is not set
+# CONFIG_NET_NCSI is not set
+CONFIG_PCPU_DEV_REFCNT=y
+CONFIG_RPS=y
+CONFIG_RFS_ACCEL=y
+CONFIG_SOCK_RX_QUEUE_MAPPING=y
+CONFIG_XPS=y
+CONFIG_CGROUP_NET_PRIO=y
+# CONFIG_CGROUP_NET_CLASSID is not set
+CONFIG_NET_RX_BUSY_POLL=y
+CONFIG_BQL=y
+# CONFIG_BPF_STREAM_PARSER is not set
+CONFIG_NET_FLOW_LIMIT=y
+
+#
+# Network testing
+#
+# CONFIG_NET_PKTGEN is not set
+# CONFIG_NET_DROP_MONITOR is not set
+# end of Network testing
+# end of Networking options
+
+# CONFIG_HAMRADIO is not set
+CONFIG_CAN=y
+CONFIG_CAN_RAW=y
+CONFIG_CAN_BCM=y
+CONFIG_CAN_GW=y
+# CONFIG_CAN_J1939 is not set
+# CONFIG_CAN_ISOTP is not set
+
+#
+# CAN Device Drivers
+#
+# CONFIG_CAN_VCAN is not set
+# CONFIG_CAN_VXCAN is not set
+# CONFIG_CAN_SLCAN is not set
+CONFIG_CAN_DEV=y
+CONFIG_CAN_CALC_BITTIMING=y
+# CONFIG_CAN_FLEXCAN is not set
+# CONFIG_CAN_GRCAN is not set
+# CONFIG_CAN_KVASER_PCIEFD is not set
+# CONFIG_CAN_XILINXCAN is not set
+# CONFIG_CAN_C_CAN is not set
+# CONFIG_CAN_CC770 is not set
+# CONFIG_CAN_IFI_CANFD is not set
+# CONFIG_CAN_M_CAN is not set
+# CONFIG_CAN_PEAK_PCIEFD is not set
+# CONFIG_CAN_SJA1000 is not set
+# CONFIG_CAN_SOFTING is not set
+
+#
+# CAN SPI interfaces
+#
+# CONFIG_CAN_HI311X is not set
+# CONFIG_CAN_MCP251X is not set
+# CONFIG_CAN_MCP251XFD is not set
+# CONFIG_QTI_CAN is not set
+# end of CAN SPI interfaces
+
+#
+# CAN USB interfaces
+#
+# CONFIG_CAN_8DEV_USB is not set
+# CONFIG_CAN_EMS_USB is not set
+# CONFIG_CAN_ESD_USB2 is not set
+# CONFIG_CAN_ETAS_ES58X is not set
+# CONFIG_CAN_GS_USB is not set
+# CONFIG_CAN_KVASER_USB is not set
+# CONFIG_CAN_MCBA_USB is not set
+# CONFIG_CAN_PEAK_USB is not set
+# CONFIG_CAN_UCAN is not set
+# end of CAN USB interfaces
+
+# CONFIG_CAN_DEBUG_DEVICES is not set
+# end of CAN Device Drivers
+
+CONFIG_BT=y
+CONFIG_BT_BREDR=y
+CONFIG_BT_RFCOMM=y
+CONFIG_BT_RFCOMM_TTY=y
+# CONFIG_BT_BNEP is not set
+CONFIG_BT_HIDP=y
+# CONFIG_BT_HS is not set
+CONFIG_BT_LE=y
+# CONFIG_BT_6LOWPAN is not set
+# CONFIG_BT_LEDS is not set
+# CONFIG_BT_MSFTEXT is not set
+# CONFIG_BT_AOSPEXT is not set
+CONFIG_BT_DEBUGFS=y
+# CONFIG_BT_SELFTEST is not set
+# CONFIG_BT_FEATURE_DEBUG is not set
+
+#
+# Bluetooth device drivers
+#
+CONFIG_BT_BCM=y
+CONFIG_BT_QCA=y
+# CONFIG_BT_HCIBTUSB is not set
+CONFIG_BT_HCIBTSDIO=y
+CONFIG_BT_HCIUART=y
+CONFIG_BT_HCIUART_SERDEV=y
+CONFIG_BT_HCIUART_H4=y
+# CONFIG_BT_HCIUART_NOKIA is not set
+# CONFIG_BT_HCIUART_BCSP is not set
+# CONFIG_BT_HCIUART_ATH3K is not set
+CONFIG_BT_HCIUART_LL=y
+# CONFIG_BT_HCIUART_3WIRE is not set
+# CONFIG_BT_HCIUART_INTEL is not set
+CONFIG_BT_HCIUART_BCM=y
+# CONFIG_BT_HCIUART_RTL is not set
+CONFIG_BT_HCIUART_QCA=y
+# CONFIG_BT_HCIUART_AG6XX is not set
+# CONFIG_BT_HCIUART_MRVL is not set
+# CONFIG_BT_HCIBCM203X is not set
+# CONFIG_BT_HCIBPA10X is not set
+# CONFIG_BT_HCIBFUSB is not set
+# CONFIG_BT_HCIVHCI is not set
+# CONFIG_BT_MRVL is not set
+# CONFIG_BT_MTKSDIO is not set
+# CONFIG_BT_MTKUART is not set
+# CONFIG_BT_VIRTIO is not set
+# end of Bluetooth device drivers
+
+# CONFIG_AF_RXRPC is not set
+# CONFIG_AF_KCM is not set
+# CONFIG_MCTP is not set
+CONFIG_FIB_RULES=y
+CONFIG_WIRELESS=y
+CONFIG_WIRELESS_EXT=y
+CONFIG_WEXT_CORE=y
+CONFIG_WEXT_PROC=y
+CONFIG_WEXT_SPY=y
+CONFIG_WEXT_PRIV=y
+# CONFIG_CFG80211 is not set
+
+#
+# CFG80211 needs to be enabled for MAC80211
+#
+CONFIG_MAC80211_STA_HASH_MAX_SIZE=0
+CONFIG_RFKILL=y
+CONFIG_RFKILL_LEDS=y
+# CONFIG_RFKILL_INPUT is not set
+# CONFIG_RFKILL_GPIO is not set
+# CONFIG_NET_9P is not set
+# CONFIG_CAIF is not set
+# CONFIG_CEPH_LIB is not set
+CONFIG_NFC=y
+# CONFIG_NFC_DIGITAL is not set
+# CONFIG_NFC_NCI is not set
+# CONFIG_NFC_HCI is not set
+
+#
+# Near Field Communication (NFC) devices
+#
+# CONFIG_NFC_PN533_USB is not set
+# CONFIG_NFC_PN533_I2C is not set
+# CONFIG_NFC_PN532_UART is not set
+# end of Near Field Communication (NFC) devices
+
+# CONFIG_PSAMPLE is not set
+# CONFIG_NET_IFE is not set
+# CONFIG_LWTUNNEL is not set
+CONFIG_DST_CACHE=y
+CONFIG_GRO_CELLS=y
+CONFIG_NET_SELFTESTS=y
+CONFIG_NET_SOCK_MSG=y
+CONFIG_NET_DEVLINK=y
+CONFIG_PAGE_POOL=y
+# CONFIG_FAILOVER is not set
+CONFIG_ETHTOOL_NETLINK=y
+
+#
+# Device Drivers
+#
+CONFIG_ARM_AMBA=y
+CONFIG_HAVE_PCI=y
+CONFIG_PCI=y
+CONFIG_PCI_DOMAINS=y
+CONFIG_PCI_DOMAINS_GENERIC=y
+CONFIG_PCI_SYSCALL=y
+CONFIG_PCIEPORTBUS=y
+CONFIG_PCIEAER=y
+# CONFIG_PCIEAER_INJECT is not set
+# CONFIG_PCIE_ECRC is not set
+CONFIG_PCIEASPM=y
+CONFIG_PCIEASPM_DEFAULT=y
+# CONFIG_PCIEASPM_POWERSAVE is not set
+# CONFIG_PCIEASPM_POWER_SUPERSAVE is not set
+# CONFIG_PCIEASPM_PERFORMANCE is not set
+CONFIG_PCIE_PME=y
+# CONFIG_PCIE_DPC is not set
+# CONFIG_PCIE_PTM is not set
+CONFIG_PCI_MSI=y
+CONFIG_PCI_MSI_IRQ_DOMAIN=y
+CONFIG_PCI_QUIRKS=y
+# CONFIG_PCI_DEBUG is not set
+# CONFIG_PCI_REALLOC_ENABLE_AUTO is not set
+# CONFIG_PCI_STUB is not set
+# CONFIG_PCI_PF_STUB is not set
+CONFIG_PCI_ATS=y
+CONFIG_PCI_ECAM=y
+CONFIG_PCI_IOV=y
+# CONFIG_PCI_PRI is not set
+# CONFIG_PCI_PASID is not set
+# CONFIG_PCIE_BUS_TUNE_OFF is not set
+CONFIG_PCIE_BUS_DEFAULT=y
+# CONFIG_PCIE_BUS_SAFE is not set
+# CONFIG_PCIE_BUS_PERFORMANCE is not set
+# CONFIG_PCIE_BUS_PEER2PEER is not set
+# CONFIG_HOTPLUG_PCI is not set
+
+#
+# PCI controller drivers
+#
+# CONFIG_PCI_FTPCI100 is not set
+CONFIG_PCI_HOST_COMMON=y
+CONFIG_PCI_HOST_GENERIC=y
+# CONFIG_PCIE_XILINX is not set
+# CONFIG_PCI_XGENE is not set
+# CONFIG_PCIE_ALTERA is not set
+# CONFIG_PCI_HOST_THUNDER_PEM is not set
+# CONFIG_PCI_HOST_THUNDER_ECAM is not set
+# CONFIG_PCIE_MICROCHIP_HOST is not set
+# CONFIG_PCI_MSM is not set
+
+#
+# DesignWare PCI Core Support
+#
+CONFIG_PCIE_DW=y
+CONFIG_PCIE_DW_HOST=y
+CONFIG_PCIE_DW_EP=y
+CONFIG_PCIE_DW_PLAT=y
+# CONFIG_PCIE_DW_PLAT_HOST is not set
+CONFIG_PCIE_DW_PLAT_EP=y
+# CONFIG_PCI_HISI is not set
+CONFIG_PCIE_QCOM=y
+CONFIG_PCIE_KIRIN=y
+# CONFIG_PCI_MESON is not set
+# CONFIG_PCIE_AL is not set
+# end of DesignWare PCI Core Support
+
+#
+# Mobiveil PCIe Core Support
+#
+# end of Mobiveil PCIe Core Support
+
+#
+# Cadence PCIe controllers support
+#
+# CONFIG_PCIE_CADENCE_PLAT_HOST is not set
+# CONFIG_PCIE_CADENCE_PLAT_EP is not set
+# CONFIG_PCI_J721E_HOST is not set
+# CONFIG_PCI_J721E_EP is not set
+# end of Cadence PCIe controllers support
+# end of PCI controller drivers
+
+#
+# PCI Endpoint
+#
+CONFIG_PCI_ENDPOINT=y
+# CONFIG_PCI_ENDPOINT_CONFIGFS is not set
+# CONFIG_PCI_EPF_TEST is not set
+# CONFIG_PCI_EPF_NTB is not set
+# end of PCI Endpoint
+
+#
+# PCI switch controller drivers
+#
+# CONFIG_PCI_SW_SWITCHTEC is not set
+# end of PCI switch controller drivers
+
+# CONFIG_CXL_BUS is not set
+# CONFIG_PCCARD is not set
+# CONFIG_RAPIDIO is not set
+
+#
+# Generic Driver Options
+#
+# CONFIG_UEVENT_HELPER is not set
+CONFIG_DEVTMPFS=y
+CONFIG_DEVTMPFS_MOUNT=y
+CONFIG_STANDALONE=y
+CONFIG_PREVENT_FIRMWARE_BUILD=y
+
+#
+# Firmware loader
+#
+CONFIG_FW_LOADER=y
+CONFIG_FW_LOADER_PAGED_BUF=y
+CONFIG_EXTRA_FIRMWARE=""
+CONFIG_FW_LOADER_USER_HELPER=y
+# CONFIG_FW_LOADER_USER_HELPER_FALLBACK is not set
+# CONFIG_FW_LOADER_COMPRESS is not set
+# CONFIG_FW_CACHE is not set
+# end of Firmware loader
+
+CONFIG_WANT_DEV_COREDUMP=y
+CONFIG_ALLOW_DEV_COREDUMP=y
+CONFIG_DEV_COREDUMP=y
+# CONFIG_DEBUG_DRIVER is not set
+# CONFIG_DEBUG_DEVRES is not set
+# CONFIG_DEBUG_TEST_DRIVER_REMOVE is not set
+# CONFIG_TEST_ASYNC_DRIVER_PROBE is not set
+CONFIG_SYS_HYPERVISOR=y
+CONFIG_GENERIC_CPU_AUTOPROBE=y
+CONFIG_GENERIC_CPU_VULNERABILITIES=y
+CONFIG_SOC_BUS=y
+CONFIG_REGMAP=y
+CONFIG_REGMAP_I2C=y
+CONFIG_REGMAP_SPI=y
+CONFIG_REGMAP_SPMI=y
+CONFIG_REGMAP_MMIO=y
+CONFIG_REGMAP_IRQ=y
+# CONFIG_REGMAP_QTI_DEBUGFS is not set
+CONFIG_DMA_SHARED_BUFFER=y
+# CONFIG_DMA_FENCE_TRACE is not set
+CONFIG_GENERIC_ARCH_TOPOLOGY=y
+# end of Generic Driver Options
+
+#
+# Bus devices
+#
+# CONFIG_BRCMSTB_GISB_ARB is not set
+# CONFIG_MOXTET is not set
+CONFIG_QCOM_EBI2=y
+# CONFIG_VEXPRESS_CONFIG is not set
+# CONFIG_MHI_BUS is not set
+
+#
+# MHI device support
+#
+# end of MHI device support
+
+#
+# MHI controllers
+#
+# end of MHI controllers
+# end of Bus devices
+
+# CONFIG_CONNECTOR is not set
+
+#
+# Firmware Drivers
+#
+
+#
+# ARM System Control and Management Interface Protocol
+#
+CONFIG_ARM_SCMI_PROTOCOL=y
+CONFIG_ARM_SCMI_HAVE_TRANSPORT=y
+CONFIG_ARM_SCMI_HAVE_SHMEM=y
+CONFIG_ARM_SCMI_TRANSPORT_MAILBOX=y
+CONFIG_ARM_SCMI_TRANSPORT_SMC=y
+# CONFIG_ARM_SCMI_TRANSPORT_VIRTIO is not set
+# CONFIG_QTI_SCMI_PMU_PROTOCOL is not set
+# CONFIG_QTI_SCMI_C1DCVS_PROTOCOL is not set
+# CONFIG_QTI_SCMI_MEMLAT_PROTOCOL is not set
+# CONFIG_QTI_SCMI_CPUFREQ_STATS_PROTOCOL is not set
+# CONFIG_ARM_SCMI_POWER_DOMAIN is not set
+# end of ARM System Control and Management Interface Protocol
+
+CONFIG_ARM_SCPI_PROTOCOL=y
+# CONFIG_ARM_SCPI_POWER_DOMAIN is not set
+# CONFIG_FIRMWARE_MEMMAP is not set
+# CONFIG_FW_CFG_SYSFS is not set
+CONFIG_QCOM_SCM=y
+CONFIG_QCOM_SCM_DOWNLOAD_MODE_DEFAULT=y
+CONFIG_QTEE_SHM_BRIDGE=y
+# CONFIG_ARM_FFA_TRANSPORT is not set
+# CONFIG_GOOGLE_FIRMWARE is not set
+
+#
+# EFI (Extensible Firmware Interface) Support
+#
+CONFIG_EFI_ESRT=y
+CONFIG_EFI_VARS_PSTORE=y
+# CONFIG_EFI_VARS_PSTORE_DEFAULT_DISABLE is not set
+CONFIG_EFI_PARAMS_FROM_FDT=y
+CONFIG_EFI_RUNTIME_WRAPPERS=y
+CONFIG_EFI_GENERIC_STUB=y
+# CONFIG_EFI_ARMSTUB_DTB_LOADER is not set
+# CONFIG_EFI_GENERIC_STUB_INITRD_CMDLINE_LOADER is not set
+# CONFIG_EFI_BOOTLOADER_CONTROL is not set
+# CONFIG_EFI_CAPSULE_LOADER is not set
+# CONFIG_EFI_TEST is not set
+# CONFIG_RESET_ATTACK_MITIGATION is not set
+# CONFIG_EFI_DISABLE_PCI_DMA is not set
+# end of EFI (Extensible Firmware Interface) Support
+
+CONFIG_EFI_EARLYCON=y
+CONFIG_ARM_PSCI_FW=y
+# CONFIG_ARM_PSCI_CHECKER is not set
+CONFIG_HAVE_ARM_SMCCC=y
+CONFIG_HAVE_ARM_SMCCC_DISCOVERY=y
+CONFIG_ARM_SMCCC_SOC_ID=y
+
+#
+# Tegra firmware driver
+#
+# end of Tegra firmware driver
+# end of Firmware Drivers
+
+CONFIG_GNSS=y
+# CONFIG_GNSS_MTK_SERIAL is not set
+# CONFIG_GNSS_SIRF_SERIAL is not set
+# CONFIG_GNSS_UBX_SERIAL is not set
+# CONFIG_MTD is not set
+CONFIG_DTC=y
+CONFIG_OF=y
+# CONFIG_OF_UNITTEST is not set
+CONFIG_OF_FLATTREE=y
+CONFIG_OF_EARLY_FLATTREE=y
+CONFIG_OF_KOBJ=y
+CONFIG_OF_DYNAMIC=y
+CONFIG_OF_ADDRESS=y
+CONFIG_OF_IRQ=y
+CONFIG_OF_RESERVED_MEM=y
+CONFIG_OF_RESOLVE=y
+CONFIG_OF_OVERLAY=y
+# CONFIG_PARPORT is not set
+CONFIG_BLK_DEV=y
+# CONFIG_BLK_DEV_NULL_BLK is not set
+# CONFIG_BLK_DEV_PCIESSD_MTIP32XX is not set
+# CONFIG_ZRAM is not set
+CONFIG_BLK_DEV_LOOP=y
+CONFIG_BLK_DEV_LOOP_MIN_COUNT=8
+# CONFIG_BLK_DEV_CRYPTOLOOP is not set
+# CONFIG_BLK_DEV_DRBD is not set
+# CONFIG_BLK_DEV_NBD is not set
+# CONFIG_BLK_DEV_SX8 is not set
+CONFIG_BLK_DEV_RAM=y
+CONFIG_BLK_DEV_RAM_COUNT=16
+CONFIG_BLK_DEV_RAM_SIZE=4096
+# CONFIG_CDROM_PKTCDVD is not set
+# CONFIG_ATA_OVER_ETH is not set
+# CONFIG_VIRTIO_BLK is not set
+# CONFIG_BLK_DEV_RBD is not set
+# CONFIG_BLK_DEV_RSXX is not set
+
+#
+# NVME Support
+#
+# CONFIG_BLK_DEV_NVME is not set
+# CONFIG_NVME_FC is not set
+# CONFIG_NVME_TCP is not set
+# CONFIG_NVME_TARGET is not set
+# end of NVME Support
+
+#
+# Misc devices
+#
+# CONFIG_AD525X_DPOT is not set
+# CONFIG_DUMMY_IRQ is not set
+# CONFIG_PHANTOM is not set
+# CONFIG_TIFM_CORE is not set
+# CONFIG_ICS932S401 is not set
+# CONFIG_ENCLOSURE_SERVICES is not set
+# CONFIG_HI6421V600_IRQ is not set
+# CONFIG_HP_ILO is not set
+# CONFIG_QCOM_COINCELL is not set
+# CONFIG_QCOM_FASTRPC is not set
+# CONFIG_APDS9802ALS is not set
+# CONFIG_ISL29003 is not set
+# CONFIG_ISL29020 is not set
+# CONFIG_SENSORS_TSL2550 is not set
+# CONFIG_SENSORS_BH1770 is not set
+# CONFIG_SENSORS_APDS990X is not set
+# CONFIG_HMC6352 is not set
+# CONFIG_DS1682 is not set
+# CONFIG_LATTICE_ECP3_CONFIG is not set
+CONFIG_SRAM=y
+# CONFIG_DW_XDATA_PCIE is not set
+# CONFIG_PCI_ENDPOINT_TEST is not set
+# CONFIG_XILINX_SDFEC is not set
+CONFIG_UID_SYS_STATS=y
+# CONFIG_UID_SYS_STATS_DEBUG is not set
+# CONFIG_HISI_HIKEY_USB is not set
+CONFIG_QSEECOM_PROXY=y
+# CONFIG_OPEN_DICE is not set
+# CONFIG_C2PORT is not set
+
+#
+# EEPROM support
+#
+# CONFIG_EEPROM_AT24 is not set
+# CONFIG_EEPROM_AT25 is not set
+# CONFIG_EEPROM_LEGACY is not set
+# CONFIG_EEPROM_MAX6875 is not set
+# CONFIG_EEPROM_93CX6 is not set
+# CONFIG_EEPROM_93XX46 is not set
+# CONFIG_EEPROM_IDT_89HPESX is not set
+# CONFIG_EEPROM_EE1004 is not set
+# end of EEPROM support
+
+# CONFIG_CB710_CORE is not set
+
+#
+# Texas Instruments shared transport line discipline
+#
+# CONFIG_TI_ST is not set
+# end of Texas Instruments shared transport line discipline
+
+# CONFIG_SENSORS_LIS3_SPI is not set
+# CONFIG_SENSORS_LIS3_I2C is not set
+# CONFIG_ALTERA_STAPL is not set
+# CONFIG_GENWQE is not set
+# CONFIG_ECHO is not set
+# CONFIG_BCM_VK is not set
+# CONFIG_MISC_ALCOR_PCI is not set
+# CONFIG_MISC_RTSX_PCI is not set
+# CONFIG_MISC_RTSX_USB is not set
+# CONFIG_HABANA_AI is not set
+# CONFIG_UACCE is not set
+# CONFIG_PVPANIC is not set
+# end of Misc devices
+
+#
+# SCSI device support
+#
+CONFIG_SCSI_MOD=y
+# CONFIG_RAID_ATTRS is not set
+CONFIG_SCSI_COMMON=y
+CONFIG_SCSI=y
+CONFIG_SCSI_DMA=y
+# CONFIG_SCSI_PROC_FS is not set
+
+#
+# SCSI support type (disk, tape, CD-ROM)
+#
+CONFIG_BLK_DEV_SD=y
+# CONFIG_CHR_DEV_ST is not set
+# CONFIG_BLK_DEV_SR is not set
+# CONFIG_CHR_DEV_SG is not set
+CONFIG_BLK_DEV_BSG=y
+# CONFIG_CHR_DEV_SCH is not set
+# CONFIG_SCSI_CONSTANTS is not set
+# CONFIG_SCSI_LOGGING is not set
+# CONFIG_SCSI_SCAN_ASYNC is not set
+
+#
+# SCSI Transports
+#
+# CONFIG_SCSI_SPI_ATTRS is not set
+# CONFIG_SCSI_FC_ATTRS is not set
+# CONFIG_SCSI_ISCSI_ATTRS is not set
+# CONFIG_SCSI_SAS_ATTRS is not set
+# CONFIG_SCSI_SAS_LIBSAS is not set
+# CONFIG_SCSI_SRP_ATTRS is not set
+# end of SCSI Transports
+
+CONFIG_SCSI_LOWLEVEL=y
+# CONFIG_ISCSI_TCP is not set
+# CONFIG_ISCSI_BOOT_SYSFS is not set
+# CONFIG_SCSI_CXGB3_ISCSI is not set
+# CONFIG_SCSI_CXGB4_ISCSI is not set
+# CONFIG_SCSI_BNX2_ISCSI is not set
+# CONFIG_BE2ISCSI is not set
+# CONFIG_BLK_DEV_3W_XXXX_RAID is not set
+# CONFIG_SCSI_HPSA is not set
+# CONFIG_SCSI_3W_9XXX is not set
+# CONFIG_SCSI_3W_SAS is not set
+# CONFIG_SCSI_ACARD is not set
+# CONFIG_SCSI_AACRAID is not set
+# CONFIG_SCSI_AIC7XXX is not set
+# CONFIG_SCSI_AIC79XX is not set
+# CONFIG_SCSI_AIC94XX is not set
+# CONFIG_SCSI_MVSAS is not set
+# CONFIG_SCSI_MVUMI is not set
+# CONFIG_SCSI_ADVANSYS is not set
+# CONFIG_SCSI_ARCMSR is not set
+# CONFIG_SCSI_ESAS2R is not set
+# CONFIG_MEGARAID_NEWGEN is not set
+# CONFIG_MEGARAID_LEGACY is not set
+# CONFIG_MEGARAID_SAS is not set
+# CONFIG_SCSI_MPT3SAS is not set
+# CONFIG_SCSI_MPT2SAS is not set
+# CONFIG_SCSI_MPI3MR is not set
+# CONFIG_SCSI_SMARTPQI is not set
+CONFIG_SCSI_UFSHCD=y
+# CONFIG_UFS_DBG is not set
+CONFIG_SCSI_UFSHCD_PCI=y
+# CONFIG_SCSI_UFS_DWC_TC_PCI is not set
+CONFIG_SCSI_UFSHCD_PLATFORM=y
+# CONFIG_SCSI_UFS_CDNS_PLATFORM is not set
+CONFIG_SCSI_UFS_DWC_TC_PLATFORM=y
+# CONFIG_SCSI_UFS_QCOM is not set
+CONFIG_SCSI_UFS_BSG=y
+CONFIG_SCSI_UFS_CRYPTO=y
+# CONFIG_SCSI_UFS_CRYPTO_QTI is not set
+CONFIG_SCSI_UFS_HPB=y
+# CONFIG_SCSI_HPTIOP is not set
+# CONFIG_SCSI_MYRB is not set
+# CONFIG_SCSI_MYRS is not set
+# CONFIG_SCSI_SNIC is not set
+# CONFIG_SCSI_DMX3191D is not set
+# CONFIG_SCSI_FDOMAIN_PCI is not set
+# CONFIG_SCSI_IPS is not set
+# CONFIG_SCSI_INITIO is not set
+# CONFIG_SCSI_INIA100 is not set
+# CONFIG_SCSI_STEX is not set
+# CONFIG_SCSI_SYM53C8XX_2 is not set
+# CONFIG_SCSI_QLOGIC_1280 is not set
+# CONFIG_SCSI_QLA_ISCSI is not set
+# CONFIG_SCSI_DC395x is not set
+# CONFIG_SCSI_AM53C974 is not set
+# CONFIG_SCSI_WD719X is not set
+# CONFIG_SCSI_DEBUG is not set
+# CONFIG_SCSI_PMCRAID is not set
+# CONFIG_SCSI_PM8001 is not set
+# CONFIG_SCSI_VIRTIO is not set
+# CONFIG_SCSI_DH is not set
+# end of SCSI device support
+
+CONFIG_HAVE_PATA_PLATFORM=y
+# CONFIG_ATA is not set
+CONFIG_MD=y
+# CONFIG_BLK_DEV_MD is not set
+# CONFIG_BCACHE is not set
+CONFIG_BLK_DEV_DM_BUILTIN=y
+CONFIG_BLK_DEV_DM=y
+# CONFIG_DM_DEBUG is not set
+CONFIG_DM_BUFIO=y
+# CONFIG_DM_DEBUG_BLOCK_MANAGER_LOCKING is not set
+# CONFIG_DM_UNSTRIPED is not set
+CONFIG_DM_CRYPT=y
+CONFIG_DM_DEFAULT_KEY=y
+CONFIG_DM_SNAPSHOT=y
+# CONFIG_DM_THIN_PROVISIONING is not set
+# CONFIG_DM_CACHE is not set
+# CONFIG_DM_WRITECACHE is not set
+# CONFIG_DM_EBS is not set
+# CONFIG_DM_ERA is not set
+# CONFIG_DM_CLONE is not set
+# CONFIG_DM_MIRROR is not set
+# CONFIG_DM_RAID is not set
+# CONFIG_DM_ZERO is not set
+# CONFIG_DM_MULTIPATH is not set
+# CONFIG_DM_DELAY is not set
+# CONFIG_DM_DUST is not set
+CONFIG_DM_INIT=y
+CONFIG_DM_UEVENT=y
+# CONFIG_DM_FLAKEY is not set
+CONFIG_DM_VERITY=y
+# CONFIG_DM_VERITY_VERIFY_ROOTHASH_SIG is not set
+CONFIG_DM_VERITY_FEC=y
+# CONFIG_DM_SWITCH is not set
+# CONFIG_DM_LOG_WRITES is not set
+# CONFIG_DM_INTEGRITY is not set
+CONFIG_DM_BOW=y
+CONFIG_DM_USER=y
+# CONFIG_TARGET_CORE is not set
+# CONFIG_FUSION is not set
+
+#
+# IEEE 1394 (FireWire) support
+#
+# CONFIG_FIREWIRE is not set
+# CONFIG_FIREWIRE_NOSY is not set
+# end of IEEE 1394 (FireWire) support
+
+CONFIG_NETDEVICES=y
+CONFIG_MII=y
+CONFIG_NET_CORE=y
+# CONFIG_BONDING is not set
+CONFIG_DUMMY=y
+CONFIG_WIREGUARD=y
+# CONFIG_WIREGUARD_DEBUG is not set
+# CONFIG_EQUALIZER is not set
+# CONFIG_NET_FC is not set
+CONFIG_IFB=y
+# CONFIG_NET_TEAM is not set
+# CONFIG_MACVLAN is not set
+# CONFIG_IPVLAN is not set
+# CONFIG_VXLAN is not set
+# CONFIG_GENEVE is not set
+# CONFIG_BAREUDP is not set
+# CONFIG_GTP is not set
+CONFIG_MACSEC=y
+# CONFIG_NETCONSOLE is not set
+CONFIG_TUN=y
+# CONFIG_TUN_VNET_CROSS_LE is not set
+CONFIG_VETH=y
+# CONFIG_VIRTIO_NET is not set
+# CONFIG_NLMON is not set
+# CONFIG_VSOCKMON is not set
+# CONFIG_ARCNET is not set
+CONFIG_ETHERNET=y
+CONFIG_NET_VENDOR_3COM=y
+# CONFIG_VORTEX is not set
+# CONFIG_TYPHOON is not set
+CONFIG_NET_VENDOR_ADAPTEC=y
+# CONFIG_ADAPTEC_STARFIRE is not set
+CONFIG_NET_VENDOR_AGERE=y
+# CONFIG_ET131X is not set
+CONFIG_NET_VENDOR_ALACRITECH=y
+# CONFIG_SLICOSS is not set
+CONFIG_NET_VENDOR_ALTEON=y
+# CONFIG_ACENIC is not set
+# CONFIG_ALTERA_TSE is not set
+CONFIG_NET_VENDOR_AMAZON=y
+# CONFIG_ENA_ETHERNET is not set
+CONFIG_NET_VENDOR_AMD=y
+# CONFIG_AMD8111_ETH is not set
+# CONFIG_PCNET32 is not set
+# CONFIG_AMD_XGBE is not set
+CONFIG_NET_VENDOR_AQUANTIA=y
+# CONFIG_AQTION is not set
+CONFIG_NET_VENDOR_ARC=y
+CONFIG_NET_VENDOR_ATHEROS=y
+# CONFIG_ATL2 is not set
+# CONFIG_ATL1 is not set
+# CONFIG_ATL1E is not set
+# CONFIG_ATL1C is not set
+# CONFIG_ALX is not set
+CONFIG_NET_VENDOR_BROADCOM=y
+# CONFIG_B44 is not set
+# CONFIG_BCMGENET is not set
+# CONFIG_BNX2 is not set
+# CONFIG_CNIC is not set
+# CONFIG_TIGON3 is not set
+# CONFIG_BNX2X is not set
+# CONFIG_SYSTEMPORT is not set
+# CONFIG_BNXT is not set
+CONFIG_NET_VENDOR_CADENCE=y
+# CONFIG_MACB is not set
+CONFIG_NET_VENDOR_CAVIUM=y
+# CONFIG_THUNDER_NIC_PF is not set
+# CONFIG_THUNDER_NIC_VF is not set
+# CONFIG_THUNDER_NIC_BGX is not set
+# CONFIG_THUNDER_NIC_RGX is not set
+# CONFIG_CAVIUM_PTP is not set
+# CONFIG_LIQUIDIO is not set
+# CONFIG_LIQUIDIO_VF is not set
+CONFIG_NET_VENDOR_CHELSIO=y
+# CONFIG_CHELSIO_T1 is not set
+# CONFIG_CHELSIO_T3 is not set
+# CONFIG_CHELSIO_T4 is not set
+# CONFIG_CHELSIO_T4VF is not set
+CONFIG_NET_VENDOR_CISCO=y
+# CONFIG_ENIC is not set
+CONFIG_NET_VENDOR_CORTINA=y
+# CONFIG_GEMINI_ETHERNET is not set
+# CONFIG_DNET is not set
+CONFIG_NET_VENDOR_DEC=y
+# CONFIG_NET_TULIP is not set
+CONFIG_NET_VENDOR_DLINK=y
+# CONFIG_DL2K is not set
+# CONFIG_SUNDANCE is not set
+CONFIG_NET_VENDOR_EMULEX=y
+# CONFIG_BE2NET is not set
+CONFIG_NET_VENDOR_EZCHIP=y
+# CONFIG_EZCHIP_NPS_MANAGEMENT_ENET is not set
+CONFIG_NET_VENDOR_GOOGLE=y
+# CONFIG_GVE is not set
+CONFIG_NET_VENDOR_HISILICON=y
+# CONFIG_HIX5HD2_GMAC is not set
+# CONFIG_HISI_FEMAC is not set
+# CONFIG_HIP04_ETH is not set
+# CONFIG_HNS_DSAF is not set
+# CONFIG_HNS_ENET is not set
+# CONFIG_HNS3 is not set
+CONFIG_NET_VENDOR_HUAWEI=y
+# CONFIG_HINIC is not set
+CONFIG_NET_VENDOR_I825XX=y
+CONFIG_NET_VENDOR_INTEL=y
+# CONFIG_E100 is not set
+# CONFIG_E1000 is not set
+# CONFIG_E1000E is not set
+# CONFIG_IGB is not set
+# CONFIG_IGBVF is not set
+# CONFIG_IXGB is not set
+# CONFIG_IXGBE is not set
+# CONFIG_IXGBEVF is not set
+# CONFIG_I40E is not set
+# CONFIG_I40EVF is not set
+# CONFIG_ICE is not set
+# CONFIG_FM10K is not set
+# CONFIG_IGC is not set
+# CONFIG_JME is not set
+CONFIG_NET_VENDOR_LITEX=y
+# CONFIG_LITEX_LITEETH is not set
+CONFIG_NET_VENDOR_MARVELL=y
+# CONFIG_MVMDIO is not set
+# CONFIG_SKGE is not set
+# CONFIG_SKY2 is not set
+# CONFIG_OCTEONTX2_AF is not set
+# CONFIG_OCTEONTX2_PF is not set
+CONFIG_NET_VENDOR_MELLANOX=y
+# CONFIG_MLX4_EN is not set
+# CONFIG_MLX5_CORE is not set
+# CONFIG_MLXSW_CORE is not set
+# CONFIG_MLXFW is not set
+CONFIG_NET_VENDOR_MICREL=y
+# CONFIG_KS8842 is not set
+# CONFIG_KS8851 is not set
+# CONFIG_KS8851_MLL is not set
+# CONFIG_KSZ884X_PCI is not set
+CONFIG_NET_VENDOR_MICROCHIP=y
+# CONFIG_ENC28J60 is not set
+# CONFIG_ENCX24J600 is not set
+# CONFIG_LAN743X is not set
+CONFIG_NET_VENDOR_MICROSEMI=y
+CONFIG_NET_VENDOR_MICROSOFT=y
+CONFIG_NET_VENDOR_MYRI=y
+# CONFIG_MYRI10GE is not set
+# CONFIG_FEALNX is not set
+CONFIG_NET_VENDOR_NI=y
+# CONFIG_NI_XGE_MANAGEMENT_ENET is not set
+CONFIG_NET_VENDOR_NATSEMI=y
+# CONFIG_NATSEMI is not set
+# CONFIG_NS83820 is not set
+CONFIG_NET_VENDOR_NETERION=y
+# CONFIG_S2IO is not set
+# CONFIG_VXGE is not set
+CONFIG_NET_VENDOR_NETRONOME=y
+# CONFIG_NFP is not set
+CONFIG_NET_VENDOR_8390=y
+# CONFIG_NE2K_PCI is not set
+CONFIG_NET_VENDOR_NVIDIA=y
+# CONFIG_FORCEDETH is not set
+CONFIG_NET_VENDOR_OKI=y
+# CONFIG_ETHOC is not set
+CONFIG_NET_VENDOR_PACKET_ENGINES=y
+# CONFIG_HAMACHI is not set
+# CONFIG_YELLOWFIN is not set
+CONFIG_NET_VENDOR_PENSANDO=y
+# CONFIG_IONIC is not set
+CONFIG_NET_VENDOR_QLOGIC=y
+# CONFIG_QLA3XXX is not set
+# CONFIG_QLCNIC is not set
+# CONFIG_NETXEN_NIC is not set
+# CONFIG_QED is not set
+CONFIG_NET_VENDOR_BROCADE=y
+# CONFIG_BNA is not set
+CONFIG_NET_VENDOR_QUALCOMM=y
+# CONFIG_QCA7000_SPI is not set
+# CONFIG_QCA7000_UART is not set
+# CONFIG_QCOM_EMAC is not set
+# CONFIG_RMNET is not set
+CONFIG_NET_VENDOR_RDC=y
+# CONFIG_R6040 is not set
+CONFIG_NET_VENDOR_REALTEK=y
+# CONFIG_8139CP is not set
+# CONFIG_8139TOO is not set
+# CONFIG_R8169 is not set
+CONFIG_NET_VENDOR_RENESAS=y
+CONFIG_NET_VENDOR_ROCKER=y
+CONFIG_NET_VENDOR_SAMSUNG=y
+# CONFIG_SXGBE_ETH is not set
+CONFIG_NET_VENDOR_SEEQ=y
+CONFIG_NET_VENDOR_SILAN=y
+# CONFIG_SC92031 is not set
+CONFIG_NET_VENDOR_SIS=y
+# CONFIG_SIS900 is not set
+# CONFIG_SIS190 is not set
+CONFIG_NET_VENDOR_SOLARFLARE=y
+# CONFIG_SFC is not set
+# CONFIG_SFC_FALCON is not set
+CONFIG_NET_VENDOR_SMSC=y
+# CONFIG_SMC91X is not set
+# CONFIG_EPIC100 is not set
+# CONFIG_SMSC911X is not set
+# CONFIG_SMSC9420 is not set
+CONFIG_NET_VENDOR_SOCIONEXT=y
+CONFIG_NET_VENDOR_STMICRO=y
+# CONFIG_STMMAC_ETH is not set
+CONFIG_NET_VENDOR_SUN=y
+# CONFIG_HAPPYMEAL is not set
+# CONFIG_SUNGEM is not set
+# CONFIG_CASSINI is not set
+# CONFIG_NIU is not set
+CONFIG_NET_VENDOR_SYNOPSYS=y
+# CONFIG_DWC_XLGMAC is not set
+CONFIG_NET_VENDOR_TEHUTI=y
+# CONFIG_TEHUTI is not set
+CONFIG_NET_VENDOR_TI=y
+# CONFIG_TI_CPSW_PHY_SEL is not set
+# CONFIG_TLAN is not set
+CONFIG_NET_VENDOR_VIA=y
+# CONFIG_VIA_RHINE is not set
+# CONFIG_VIA_VELOCITY is not set
+CONFIG_NET_VENDOR_WIZNET=y
+# CONFIG_WIZNET_W5100 is not set
+# CONFIG_WIZNET_W5300 is not set
+CONFIG_NET_VENDOR_XILINX=y
+# CONFIG_XILINX_EMACLITE is not set
+# CONFIG_XILINX_AXI_EMAC is not set
+# CONFIG_XILINX_LL_TEMAC is not set
+# CONFIG_FDDI is not set
+# CONFIG_HIPPI is not set
+# CONFIG_QCOM_IPA is not set
+CONFIG_PHYLINK=y
+CONFIG_PHYLIB=y
+CONFIG_SWPHY=y
+# CONFIG_LED_TRIGGER_PHY is not set
+CONFIG_FIXED_PHY=y
+# CONFIG_SFP is not set
+
+#
+# MII PHY device drivers
+#
+# CONFIG_AMD_PHY is not set
+# CONFIG_ADIN_PHY is not set
+# CONFIG_AQUANTIA_PHY is not set
+CONFIG_AX88796B_PHY=y
+# CONFIG_BROADCOM_PHY is not set
+# CONFIG_BCM54140_PHY is not set
+# CONFIG_BCM7XXX_PHY is not set
+# CONFIG_BCM84881_PHY is not set
+# CONFIG_BCM87XX_PHY is not set
+# CONFIG_CICADA_PHY is not set
+# CONFIG_CORTINA_PHY is not set
+# CONFIG_DAVICOM_PHY is not set
+# CONFIG_ICPLUS_PHY is not set
+# CONFIG_LXT_PHY is not set
+# CONFIG_INTEL_XWAY_PHY is not set
+# CONFIG_LSI_ET1011C_PHY is not set
+# CONFIG_MARVELL_PHY is not set
+# CONFIG_MARVELL_10G_PHY is not set
+# CONFIG_MARVELL_88X2222_PHY is not set
+# CONFIG_MAXLINEAR_GPHY is not set
+# CONFIG_MEDIATEK_GE_PHY is not set
+# CONFIG_MICREL_PHY is not set
+# CONFIG_MICROCHIP_PHY is not set
+# CONFIG_MICROCHIP_T1_PHY is not set
+# CONFIG_MICROSEMI_PHY is not set
+# CONFIG_MOTORCOMM_PHY is not set
+# CONFIG_NATIONAL_PHY is not set
+# CONFIG_NXP_C45_TJA11XX_PHY is not set
+# CONFIG_AT803X_PHY is not set
+CONFIG_QSEMI_PHY=y
+# CONFIG_REALTEK_PHY is not set
+# CONFIG_RENESAS_PHY is not set
+# CONFIG_ROCKCHIP_PHY is not set
+# CONFIG_SMSC_PHY is not set
+# CONFIG_STE10XP is not set
+# CONFIG_TERANETICS_PHY is not set
+# CONFIG_DP83822_PHY is not set
+# CONFIG_DP83TC811_PHY is not set
+# CONFIG_DP83848_PHY is not set
+# CONFIG_DP83867_PHY is not set
+# CONFIG_DP83869_PHY is not set
+# CONFIG_VITESSE_PHY is not set
+# CONFIG_XILINX_GMII2RGMII is not set
+# CONFIG_MICREL_KS8995MA is not set
+CONFIG_MDIO_DEVICE=y
+CONFIG_MDIO_BUS=y
+CONFIG_FWNODE_MDIO=y
+CONFIG_OF_MDIO=y
+CONFIG_MDIO_DEVRES=y
+# CONFIG_MDIO_BITBANG is not set
+# CONFIG_MDIO_BCM_UNIMAC is not set
+# CONFIG_MDIO_HISI_FEMAC is not set
+# CONFIG_MDIO_MVUSB is not set
+# CONFIG_MDIO_MSCC_MIIM is not set
+# CONFIG_MDIO_OCTEON is not set
+# CONFIG_MDIO_IPQ4019 is not set
+# CONFIG_MDIO_IPQ8064 is not set
+# CONFIG_MDIO_THUNDER is not set
+
+#
+# MDIO Multiplexers
+#
+# CONFIG_MDIO_BUS_MUX_GPIO is not set
+# CONFIG_MDIO_BUS_MUX_MULTIPLEXER is not set
+# CONFIG_MDIO_BUS_MUX_MMIOREG is not set
+
+#
+# PCS device drivers
+#
+# CONFIG_PCS_XPCS is not set
+# end of PCS device drivers
+
+CONFIG_PPP=y
+CONFIG_PPP_BSDCOMP=y
+CONFIG_PPP_DEFLATE=y
+# CONFIG_PPP_FILTER is not set
+CONFIG_PPP_MPPE=y
+# CONFIG_PPP_MULTILINK is not set
+# CONFIG_PPPOE is not set
+CONFIG_PPTP=y
+CONFIG_PPPOL2TP=y
+# CONFIG_PPP_ASYNC is not set
+# CONFIG_PPP_SYNC_TTY is not set
+# CONFIG_SLIP is not set
+CONFIG_SLHC=y
+CONFIG_USB_NET_DRIVERS=y
+# CONFIG_USB_CATC is not set
+# CONFIG_USB_KAWETH is not set
+# CONFIG_USB_PEGASUS is not set
+CONFIG_USB_RTL8150=y
+CONFIG_USB_RTL8152=y
+# CONFIG_USB_LAN78XX is not set
+CONFIG_USB_USBNET=y
+CONFIG_USB_NET_AX8817X=y
+CONFIG_USB_NET_AX88179_178A=y
+CONFIG_USB_NET_CDCETHER=y
+CONFIG_USB_NET_CDC_EEM=y
+CONFIG_USB_NET_CDC_NCM=y
+# CONFIG_USB_NET_HUAWEI_CDC_NCM is not set
+# CONFIG_USB_NET_CDC_MBIM is not set
+# CONFIG_USB_NET_DM9601 is not set
+# CONFIG_USB_NET_SR9700 is not set
+# CONFIG_USB_NET_SR9800 is not set
+# CONFIG_USB_NET_SMSC75XX is not set
+# CONFIG_USB_NET_SMSC95XX is not set
+# CONFIG_USB_NET_GL620A is not set
+CONFIG_USB_NET_NET1080=y
+# CONFIG_USB_NET_PLUSB is not set
+# CONFIG_USB_NET_MCS7830 is not set
+# CONFIG_USB_NET_RNDIS_HOST is not set
+CONFIG_USB_NET_CDC_SUBSET_ENABLE=y
+CONFIG_USB_NET_CDC_SUBSET=y
+# CONFIG_USB_ALI_M5632 is not set
+# CONFIG_USB_AN2720 is not set
+CONFIG_USB_BELKIN=y
+CONFIG_USB_ARMLINUX=y
+# CONFIG_USB_EPSON2888 is not set
+# CONFIG_USB_KC2190 is not set
+CONFIG_USB_NET_ZAURUS=y
+# CONFIG_USB_NET_CX82310_ETH is not set
+# CONFIG_USB_NET_KALMIA is not set
+# CONFIG_USB_NET_QMI_WWAN is not set
+# CONFIG_USB_HSO is not set
+# CONFIG_USB_NET_INT51X1 is not set
+# CONFIG_USB_IPHETH is not set
+# CONFIG_USB_SIERRA_NET is not set
+# CONFIG_USB_VL600 is not set
+# CONFIG_USB_NET_CH9200 is not set
+CONFIG_USB_NET_AQC111=y
+CONFIG_USB_RTL8153_ECM=y
+CONFIG_WLAN=y
+CONFIG_WLAN_VENDOR_ADMTEK=y
+CONFIG_WLAN_VENDOR_ATH=y
+# CONFIG_ATH_DEBUG is not set
+# CONFIG_ATH5K_PCI is not set
+CONFIG_WLAN_VENDOR_ATMEL=y
+CONFIG_WLAN_VENDOR_BROADCOM=y
+CONFIG_WLAN_VENDOR_CISCO=y
+CONFIG_WLAN_VENDOR_INTEL=y
+CONFIG_WLAN_VENDOR_INTERSIL=y
+# CONFIG_HOSTAP is not set
+CONFIG_WLAN_VENDOR_MARVELL=y
+CONFIG_WLAN_VENDOR_MEDIATEK=y
+CONFIG_WLAN_VENDOR_MICROCHIP=y
+CONFIG_WLAN_VENDOR_RALINK=y
+CONFIG_WLAN_VENDOR_REALTEK=y
+CONFIG_WLAN_VENDOR_RSI=y
+CONFIG_WLAN_VENDOR_ST=y
+CONFIG_WLAN_VENDOR_TI=y
+CONFIG_WLAN_VENDOR_ZYDAS=y
+CONFIG_WLAN_VENDOR_QUANTENNA=y
+# CONFIG_CNSS2_DEBUG is not set
+# CONFIG_WAN is not set
+CONFIG_IEEE802154_DRIVERS=y
+# CONFIG_IEEE802154_FAKELB is not set
+# CONFIG_IEEE802154_AT86RF230 is not set
+# CONFIG_IEEE802154_MRF24J40 is not set
+# CONFIG_IEEE802154_CC2520 is not set
+# CONFIG_IEEE802154_ATUSB is not set
+# CONFIG_IEEE802154_ADF7242 is not set
+# CONFIG_IEEE802154_CA8210 is not set
+# CONFIG_IEEE802154_MCR20A is not set
+# CONFIG_IEEE802154_HWSIM is not set
+
+#
+# Wireless WAN
+#
+# CONFIG_WWAN is not set
+# end of Wireless WAN
+
+# CONFIG_VMXNET3 is not set
+# CONFIG_NETDEVSIM is not set
+# CONFIG_NET_FAILOVER is not set
+# CONFIG_ISDN is not set
+
+#
+# Input device support
+#
+CONFIG_INPUT=y
+CONFIG_INPUT_LEDS=y
+CONFIG_INPUT_FF_MEMLESS=y
+# CONFIG_INPUT_SPARSEKMAP is not set
+# CONFIG_INPUT_MATRIXKMAP is not set
+
+#
+# Userland interfaces
+#
+# CONFIG_INPUT_MOUSEDEV is not set
+# CONFIG_INPUT_JOYDEV is not set
+CONFIG_INPUT_EVDEV=y
+# CONFIG_INPUT_EVBUG is not set
+
+#
+# Input Device Drivers
+#
+CONFIG_INPUT_KEYBOARD=y
+# CONFIG_KEYBOARD_ADC is not set
+# CONFIG_KEYBOARD_ADP5588 is not set
+# CONFIG_KEYBOARD_ADP5589 is not set
+CONFIG_KEYBOARD_ATKBD=y
+# CONFIG_KEYBOARD_QT1050 is not set
+# CONFIG_KEYBOARD_QT1070 is not set
+# CONFIG_KEYBOARD_QT2160 is not set
+# CONFIG_KEYBOARD_DLINK_DIR685 is not set
+# CONFIG_KEYBOARD_LKKBD is not set
+CONFIG_KEYBOARD_GPIO=y
+# CONFIG_KEYBOARD_GPIO_POLLED is not set
+# CONFIG_KEYBOARD_TCA6416 is not set
+# CONFIG_KEYBOARD_TCA8418 is not set
+# CONFIG_KEYBOARD_MATRIX is not set
+# CONFIG_KEYBOARD_LM8323 is not set
+# CONFIG_KEYBOARD_LM8333 is not set
+# CONFIG_KEYBOARD_MAX7359 is not set
+# CONFIG_KEYBOARD_MCS is not set
+# CONFIG_KEYBOARD_MPR121 is not set
+# CONFIG_KEYBOARD_NEWTON is not set
+# CONFIG_KEYBOARD_OPENCORES is not set
+# CONFIG_KEYBOARD_SAMSUNG is not set
+# CONFIG_KEYBOARD_STOWAWAY is not set
+# CONFIG_KEYBOARD_SUNKBD is not set
+# CONFIG_KEYBOARD_OMAP4 is not set
+# CONFIG_KEYBOARD_TM2_TOUCHKEY is not set
+# CONFIG_KEYBOARD_XTKBD is not set
+# CONFIG_KEYBOARD_CAP11XX is not set
+# CONFIG_KEYBOARD_BCM is not set
+CONFIG_INPUT_MOUSE=y
+# CONFIG_MOUSE_PS2 is not set
+# CONFIG_MOUSE_SERIAL is not set
+# CONFIG_MOUSE_APPLETOUCH is not set
+# CONFIG_MOUSE_BCM5974 is not set
+# CONFIG_MOUSE_CYAPA is not set
+# CONFIG_MOUSE_ELAN_I2C is not set
+# CONFIG_MOUSE_VSXXXAA is not set
+# CONFIG_MOUSE_GPIO is not set
+# CONFIG_MOUSE_SYNAPTICS_I2C is not set
+# CONFIG_MOUSE_SYNAPTICS_USB is not set
+CONFIG_INPUT_JOYSTICK=y
+# CONFIG_JOYSTICK_ANALOG is not set
+# CONFIG_JOYSTICK_A3D is not set
+# CONFIG_JOYSTICK_ADC is not set
+# CONFIG_JOYSTICK_ADI is not set
+# CONFIG_JOYSTICK_COBRA is not set
+# CONFIG_JOYSTICK_GF2K is not set
+# CONFIG_JOYSTICK_GRIP is not set
+# CONFIG_JOYSTICK_GRIP_MP is not set
+# CONFIG_JOYSTICK_GUILLEMOT is not set
+# CONFIG_JOYSTICK_INTERACT is not set
+# CONFIG_JOYSTICK_SIDEWINDER is not set
+# CONFIG_JOYSTICK_TMDC is not set
+# CONFIG_JOYSTICK_IFORCE is not set
+# CONFIG_JOYSTICK_WARRIOR is not set
+# CONFIG_JOYSTICK_MAGELLAN is not set
+# CONFIG_JOYSTICK_SPACEORB is not set
+# CONFIG_JOYSTICK_SPACEBALL is not set
+# CONFIG_JOYSTICK_STINGER is not set
+# CONFIG_JOYSTICK_TWIDJOY is not set
+# CONFIG_JOYSTICK_ZHENHUA is not set
+# CONFIG_JOYSTICK_AS5011 is not set
+# CONFIG_JOYSTICK_JOYDUMP is not set
+CONFIG_JOYSTICK_XPAD=y
+# CONFIG_JOYSTICK_XPAD_FF is not set
+# CONFIG_JOYSTICK_XPAD_LEDS is not set
+# CONFIG_JOYSTICK_PSXPAD_SPI is not set
+# CONFIG_JOYSTICK_PXRC is not set
+# CONFIG_JOYSTICK_QWIIC is not set
+# CONFIG_JOYSTICK_FSIA6B is not set
+# CONFIG_INPUT_TABLET is not set
+CONFIG_INPUT_TOUCHSCREEN=y
+# CONFIG_TOUCHSCREEN_ADS7846 is not set
+# CONFIG_TOUCHSCREEN_AD7877 is not set
+# CONFIG_TOUCHSCREEN_AD7879 is not set
+# CONFIG_TOUCHSCREEN_ADC is not set
+# CONFIG_TOUCHSCREEN_AR1021_I2C is not set
+# CONFIG_TOUCHSCREEN_ATMEL_MXT is not set
+# CONFIG_TOUCHSCREEN_AUO_PIXCIR is not set
+# CONFIG_TOUCHSCREEN_BU21013 is not set
+# CONFIG_TOUCHSCREEN_BU21029 is not set
+# CONFIG_TOUCHSCREEN_CHIPONE_ICN8318 is not set
+# CONFIG_TOUCHSCREEN_CY8CTMA140 is not set
+# CONFIG_TOUCHSCREEN_CY8CTMG110 is not set
+# CONFIG_TOUCHSCREEN_CYTTSP_CORE is not set
+# CONFIG_TOUCHSCREEN_CYTTSP4_CORE is not set
+# CONFIG_TOUCHSCREEN_DYNAPRO is not set
+# CONFIG_TOUCHSCREEN_HAMPSHIRE is not set
+# CONFIG_TOUCHSCREEN_EETI is not set
+# CONFIG_TOUCHSCREEN_EGALAX is not set
+# CONFIG_TOUCHSCREEN_EGALAX_SERIAL is not set
+# CONFIG_TOUCHSCREEN_EXC3000 is not set
+# CONFIG_TOUCHSCREEN_FUJITSU is not set
+# CONFIG_TOUCHSCREEN_GOODIX is not set
+# CONFIG_TOUCHSCREEN_HIDEEP is not set
+# CONFIG_TOUCHSCREEN_HYCON_HY46XX is not set
+# CONFIG_TOUCHSCREEN_ILI210X is not set
+# CONFIG_TOUCHSCREEN_ILITEK is not set
+# CONFIG_TOUCHSCREEN_S6SY761 is not set
+# CONFIG_TOUCHSCREEN_GUNZE is not set
+# CONFIG_TOUCHSCREEN_EKTF2127 is not set
+# CONFIG_TOUCHSCREEN_ELAN is not set
+# CONFIG_TOUCHSCREEN_ELO is not set
+# CONFIG_TOUCHSCREEN_WACOM_W8001 is not set
+# CONFIG_TOUCHSCREEN_WACOM_I2C is not set
+# CONFIG_TOUCHSCREEN_MAX11801 is not set
+# CONFIG_TOUCHSCREEN_MCS5000 is not set
+# CONFIG_TOUCHSCREEN_MMS114 is not set
+# CONFIG_TOUCHSCREEN_MELFAS_MIP4 is not set
+# CONFIG_TOUCHSCREEN_MSG2638 is not set
+# CONFIG_TOUCHSCREEN_MTOUCH is not set
+# CONFIG_TOUCHSCREEN_IMX6UL_TSC is not set
+# CONFIG_TOUCHSCREEN_INEXIO is not set
+# CONFIG_TOUCHSCREEN_MK712 is not set
+# CONFIG_TOUCHSCREEN_PENMOUNT is not set
+# CONFIG_TOUCHSCREEN_EDT_FT5X06 is not set
+# CONFIG_TOUCHSCREEN_TOUCHRIGHT is not set
+# CONFIG_TOUCHSCREEN_TOUCHWIN is not set
+# CONFIG_TOUCHSCREEN_PIXCIR is not set
+# CONFIG_TOUCHSCREEN_WDT87XX_I2C is not set
+# CONFIG_TOUCHSCREEN_USB_COMPOSITE is not set
+# CONFIG_TOUCHSCREEN_TOUCHIT213 is not set
+# CONFIG_TOUCHSCREEN_TSC_SERIO is not set
+# CONFIG_TOUCHSCREEN_TSC2004 is not set
+# CONFIG_TOUCHSCREEN_TSC2005 is not set
+# CONFIG_TOUCHSCREEN_TSC2007 is not set
+# CONFIG_TOUCHSCREEN_RM_TS is not set
+# CONFIG_TOUCHSCREEN_SILEAD is not set
+# CONFIG_TOUCHSCREEN_SIS_I2C is not set
+# CONFIG_TOUCHSCREEN_ST1232 is not set
+# CONFIG_TOUCHSCREEN_STMFTS is not set
+# CONFIG_TOUCHSCREEN_SUR40 is not set
+# CONFIG_TOUCHSCREEN_SURFACE3_SPI is not set
+# CONFIG_TOUCHSCREEN_SX8654 is not set
+# CONFIG_TOUCHSCREEN_TPS6507X is not set
+# CONFIG_TOUCHSCREEN_ZET6223 is not set
+# CONFIG_TOUCHSCREEN_ZFORCE is not set
+# CONFIG_TOUCHSCREEN_ROHM_BU21023 is not set
+# CONFIG_TOUCHSCREEN_IQS5XX is not set
+# CONFIG_TOUCHSCREEN_ZINITIX is not set
+CONFIG_INPUT_MISC=y
+# CONFIG_INPUT_AD714X is not set
+# CONFIG_INPUT_ATMEL_CAPTOUCH is not set
+# CONFIG_INPUT_BMA150 is not set
+# CONFIG_INPUT_E3X0_BUTTON is not set
+# CONFIG_INPUT_PM8941_PWRKEY is not set
+# CONFIG_INPUT_PM8XXX_VIBRATOR is not set
+CONFIG_INPUT_QPNP_POWER_ON=y
+# CONFIG_INPUT_QTI_HAPTICS is not set
+# CONFIG_INPUT_QCOM_HV_HAPTICS is not set
+# CONFIG_INPUT_MMA8450 is not set
+# CONFIG_INPUT_GPIO_BEEPER is not set
+# CONFIG_INPUT_GPIO_DECODER is not set
+# CONFIG_INPUT_GPIO_VIBRA is not set
+# CONFIG_INPUT_ATI_REMOTE2 is not set
+# CONFIG_INPUT_KEYSPAN_REMOTE is not set
+# CONFIG_INPUT_KXTJ9 is not set
+# CONFIG_INPUT_POWERMATE is not set
+# CONFIG_INPUT_YEALINK is not set
+# CONFIG_INPUT_CM109 is not set
+# CONFIG_INPUT_REGULATOR_HAPTIC is not set
+CONFIG_INPUT_UINPUT=y
+# CONFIG_INPUT_PCF8574 is not set
+# CONFIG_INPUT_PWM_BEEPER is not set
+# CONFIG_INPUT_PWM_VIBRA is not set
+# CONFIG_INPUT_GPIO_ROTARY_ENCODER is not set
+# CONFIG_INPUT_DA7280_HAPTICS is not set
+# CONFIG_INPUT_ADXL34X is not set
+# CONFIG_INPUT_IMS_PCU is not set
+# CONFIG_INPUT_IQS269A is not set
+# CONFIG_INPUT_IQS626A is not set
+# CONFIG_INPUT_CMA3000 is not set
+# CONFIG_INPUT_DRV260X_HAPTICS is not set
+# CONFIG_INPUT_DRV2665_HAPTICS is not set
+# CONFIG_INPUT_DRV2667_HAPTICS is not set
+# CONFIG_RMI4_CORE is not set
+
+#
+# Hardware I/O ports
+#
+CONFIG_SERIO=y
+CONFIG_SERIO_SERPORT=y
+# CONFIG_SERIO_AMBAKMI is not set
+# CONFIG_SERIO_PCIPS2 is not set
+CONFIG_SERIO_LIBPS2=y
+# CONFIG_SERIO_RAW is not set
+# CONFIG_SERIO_ALTERA_PS2 is not set
+# CONFIG_SERIO_PS2MULT is not set
+# CONFIG_SERIO_ARC_PS2 is not set
+# CONFIG_SERIO_APBPS2 is not set
+# CONFIG_SERIO_GPIO_PS2 is not set
+# CONFIG_USERIO is not set
+# CONFIG_GAMEPORT is not set
+# end of Hardware I/O ports
+# end of Input device support
+
+#
+# Character devices
+#
+CONFIG_TTY=y
+CONFIG_VT=y
+CONFIG_CONSOLE_TRANSLATIONS=y
+CONFIG_VT_CONSOLE=y
+CONFIG_VT_CONSOLE_SLEEP=y
+CONFIG_HW_CONSOLE=y
+# CONFIG_VT_HW_CONSOLE_BINDING is not set
+CONFIG_UNIX98_PTYS=y
+# CONFIG_LEGACY_PTYS is not set
+CONFIG_LDISC_AUTOLOAD=y
+
+#
+# Serial drivers
+#
+CONFIG_SERIAL_EARLYCON=y
+CONFIG_SERIAL_8250=y
+# CONFIG_SERIAL_8250_DEPRECATED_OPTIONS is not set
+CONFIG_SERIAL_8250_16550A_VARIANTS=y
+# CONFIG_SERIAL_8250_FINTEK is not set
+CONFIG_SERIAL_8250_CONSOLE=y
+CONFIG_SERIAL_8250_DMA=y
+CONFIG_SERIAL_8250_PCI=y
+# CONFIG_SERIAL_8250_EXAR is not set
+CONFIG_SERIAL_8250_NR_UARTS=32
+CONFIG_SERIAL_8250_RUNTIME_UARTS=0
+# CONFIG_SERIAL_8250_EXTENDED is not set
+# CONFIG_SERIAL_8250_ASPEED_VUART is not set
+CONFIG_SERIAL_8250_DWLIB=y
+CONFIG_SERIAL_8250_FSL=y
+CONFIG_SERIAL_8250_DW=y
+# CONFIG_SERIAL_8250_RT288X is not set
+CONFIG_SERIAL_OF_PLATFORM=y
+
+#
+# Non-8250 serial port support
+#
+# CONFIG_SERIAL_AMBA_PL010 is not set
+CONFIG_SERIAL_AMBA_PL011=y
+CONFIG_SERIAL_AMBA_PL011_CONSOLE=y
+# CONFIG_SERIAL_EARLYCON_ARM_SEMIHOST is not set
+CONFIG_SERIAL_SAMSUNG=y
+CONFIG_SERIAL_SAMSUNG_UARTS_4=y
+CONFIG_SERIAL_SAMSUNG_UARTS=4
+CONFIG_SERIAL_SAMSUNG_CONSOLE=y
+# CONFIG_SERIAL_MAX3100 is not set
+# CONFIG_SERIAL_MAX310X is not set
+# CONFIG_SERIAL_UARTLITE is not set
+CONFIG_SERIAL_CORE=y
+CONFIG_SERIAL_CORE_CONSOLE=y
+# CONFIG_SERIAL_JSM is not set
+# CONFIG_SERIAL_MSM is not set
+CONFIG_SERIAL_QCOM_GENI=y
+# CONFIG_SERIAL_QCOM_GENI_CONSOLE_DEFAULT_ENABLED is not set
+CONFIG_SERIAL_QCOM_GENI_CONSOLE=y
+CONFIG_SERIAL_MSM_GENI=y
+# CONFIG_SERIAL_SIFIVE is not set
+# CONFIG_SERIAL_SCCNXP is not set
+# CONFIG_SERIAL_SC16IS7XX is not set
+# CONFIG_SERIAL_BCM63XX is not set
+# CONFIG_SERIAL_ALTERA_JTAGUART is not set
+# CONFIG_SERIAL_ALTERA_UART is not set
+# CONFIG_SERIAL_XILINX_PS_UART is not set
+# CONFIG_SERIAL_ARC is not set
+# CONFIG_SERIAL_RP2 is not set
+# CONFIG_SERIAL_FSL_LPUART is not set
+# CONFIG_SERIAL_FSL_LINFLEXUART is not set
+# CONFIG_SERIAL_CONEXANT_DIGICOLOR is not set
+CONFIG_SERIAL_SPRD=y
+CONFIG_SERIAL_SPRD_CONSOLE=y
+# end of Serial drivers
+
+CONFIG_SERIAL_MCTRL_GPIO=y
+# CONFIG_SERIAL_NONSTANDARD is not set
+# CONFIG_N_GSM is not set
+# CONFIG_NOZOMI is not set
+# CONFIG_NULL_TTY is not set
+CONFIG_HVC_DRIVER=y
+CONFIG_HVC_DCC=y
+# CONFIG_HVC_DCC_SERIALIZE_SMP is not set
+CONFIG_SERIAL_DEV_BUS=y
+CONFIG_SERIAL_DEV_CTRL_TTYPORT=y
+# CONFIG_TTY_PRINTK is not set
+# CONFIG_VIRTIO_CONSOLE is not set
+# CONFIG_IPMI_HANDLER is not set
+CONFIG_HW_RANDOM=y
+# CONFIG_HW_RANDOM_TIMERIOMEM is not set
+# CONFIG_HW_RANDOM_BA431 is not set
+# CONFIG_HW_RANDOM_VIRTIO is not set
+# CONFIG_HW_RANDOM_MSM_LEGACY is not set
+# CONFIG_HW_RANDOM_CCTRNG is not set
+# CONFIG_HW_RANDOM_XIPHERA is not set
+CONFIG_HW_RANDOM_ARM_SMCCC_TRNG=y
+# CONFIG_APPLICOM is not set
+CONFIG_DEVMEM=y
+# CONFIG_DEVPORT is not set
+# CONFIG_TCG_TPM is not set
+# CONFIG_XILLYBUS is not set
+# CONFIG_XILLYUSB is not set
+# CONFIG_MSM_ADSPRPC_TRUSTED is not set
+# CONFIG_MSM_RDBG is not set
+CONFIG_RANDOM_TRUST_CPU=y
+CONFIG_RANDOM_TRUST_BOOTLOADER=y
+# CONFIG_VIRTIO_FASTRPC is not set
+# end of Character devices
+
+#
+# I2C support
+#
+CONFIG_I2C=y
+CONFIG_I2C_BOARDINFO=y
+# CONFIG_I2C_COMPAT is not set
+# CONFIG_I2C_CHARDEV is not set
+# CONFIG_I2C_MUX is not set
+# CONFIG_I2C_HELPER_AUTO is not set
+# CONFIG_I2C_SMBUS is not set
+
+#
+# I2C Algorithms
+#
+CONFIG_I2C_ALGOBIT=y
+# CONFIG_I2C_ALGOPCF is not set
+# CONFIG_I2C_ALGOPCA is not set
+# end of I2C Algorithms
+
+#
+# I2C Hardware Bus support
+#
+
+#
+# PC SMBus host controller drivers
+#
+# CONFIG_I2C_ALI1535 is not set
+# CONFIG_I2C_ALI1563 is not set
+# CONFIG_I2C_ALI15X3 is not set
+# CONFIG_I2C_AMD756 is not set
+# CONFIG_I2C_AMD8111 is not set
+# CONFIG_I2C_I801 is not set
+# CONFIG_I2C_ISCH is not set
+# CONFIG_I2C_PIIX4 is not set
+# CONFIG_I2C_NFORCE2 is not set
+# CONFIG_I2C_NVIDIA_GPU is not set
+# CONFIG_I2C_SIS5595 is not set
+# CONFIG_I2C_SIS630 is not set
+# CONFIG_I2C_SIS96X is not set
+# CONFIG_I2C_VIA is not set
+# CONFIG_I2C_VIAPRO is not set
+
+#
+# I2C system bus drivers (mostly embedded / system-on-chip)
+#
+# CONFIG_I2C_CADENCE is not set
+# CONFIG_I2C_CBUS_GPIO is not set
+# CONFIG_I2C_DESIGNWARE_PLATFORM is not set
+# CONFIG_I2C_DESIGNWARE_PCI is not set
+# CONFIG_I2C_EMEV2 is not set
+# CONFIG_I2C_GPIO is not set
+# CONFIG_I2C_NOMADIK is not set
+# CONFIG_I2C_OCORES is not set
+# CONFIG_I2C_PCA_PLATFORM is not set
+# CONFIG_I2C_QCOM_CCI is not set
+CONFIG_I2C_QCOM_GENI=y
+CONFIG_I2C_MSM_GENI=y
+# CONFIG_I2C_SLAVE_QCOM is not set
+# CONFIG_I2C_SLAVE_TEST is not set
+# CONFIG_I2C_QUP is not set
+# CONFIG_I2C_RK3X is not set
+# CONFIG_I2C_SIMTEC is not set
+# CONFIG_I2C_THUNDERX is not set
+# CONFIG_I2C_XILINX is not set
+
+#
+# External I2C/SMBus adapter drivers
+#
+# CONFIG_I2C_DIOLAN_U2C is not set
+# CONFIG_I2C_CP2615 is not set
+# CONFIG_I2C_ROBOTFUZZ_OSIF is not set
+# CONFIG_I2C_TAOS_EVM is not set
+# CONFIG_I2C_TINY_USB is not set
+
+#
+# Other I2C/SMBus bus drivers
+#
+# CONFIG_I2C_VIRTIO is not set
+# end of I2C Hardware Bus support
+
+# CONFIG_I2C_STUB is not set
+# CONFIG_I2C_SLAVE is not set
+# CONFIG_I2C_DEBUG_CORE is not set
+# CONFIG_I2C_DEBUG_ALGO is not set
+# CONFIG_I2C_DEBUG_BUS is not set
+# end of I2C support
+
+CONFIG_I3C=y
+# CONFIG_CDNS_I3C_MASTER is not set
+# CONFIG_DW_I3C_MASTER is not set
+# CONFIG_SVC_I3C_MASTER is not set
+# CONFIG_MIPI_I3C_HCI is not set
+# CONFIG_I3C_MASTER_MSM_GENI is not set
+CONFIG_SPI=y
+# CONFIG_SPI_DEBUG is not set
+CONFIG_SPI_MASTER=y
+CONFIG_SPI_MEM=y
+
+#
+# SPI Master Controller Drivers
+#
+# CONFIG_SPI_ALTERA is not set
+# CONFIG_SPI_AXI_SPI_ENGINE is not set
+# CONFIG_SPI_BITBANG is not set
+# CONFIG_SPI_CADENCE is not set
+# CONFIG_SPI_CADENCE_QUADSPI is not set
+# CONFIG_SPI_DESIGNWARE is not set
+# CONFIG_SPI_NXP_FLEXSPI is not set
+# CONFIG_SPI_GPIO is not set
+# CONFIG_SPI_FSL_SPI is not set
+# CONFIG_SPI_OC_TINY is not set
+# CONFIG_SPI_PL022 is not set
+# CONFIG_SPI_PXA2XX is not set
+# CONFIG_SPI_ROCKCHIP is not set
+# CONFIG_SPI_QCOM_QSPI is not set
+# CONFIG_SPI_QUP is not set
+CONFIG_SPI_QCOM_GENI=y
+CONFIG_SPI_MSM_GENI=y
+# CONFIG_VIRTIO_SPI is not set
+# CONFIG_SPI_SC18IS602 is not set
+# CONFIG_SPI_SIFIVE is not set
+# CONFIG_SPI_MXIC is not set
+# CONFIG_SPI_THUNDERX is not set
+# CONFIG_SPI_XCOMM is not set
+# CONFIG_SPI_XILINX is not set
+# CONFIG_SPI_ZYNQMP_GQSPI is not set
+# CONFIG_SPI_AMD is not set
+
+#
+# SPI Multiplexer support
+#
+# CONFIG_SPI_MUX is not set
+
+#
+# SPI Protocol Masters
+#
+# CONFIG_SPI_SPIDEV is not set
+# CONFIG_SPI_LOOPBACK_TEST is not set
+# CONFIG_SPI_TLE62X0 is not set
+# CONFIG_SPI_SLAVE is not set
+CONFIG_SPI_DYNAMIC=y
+CONFIG_SPMI=y
+# CONFIG_SPMI_HISI3670 is not set
+CONFIG_SPMI_MSM_PMIC_ARB=y
+CONFIG_SPMI_MSM_PMIC_ARB_DEBUG=y
+CONFIG_VIOSPMI_MSM_PMIC_ARB=y
+# CONFIG_HSI is not set
+CONFIG_PPS=y
+# CONFIG_PPS_DEBUG is not set
+
+#
+# PPS clients support
+#
+# CONFIG_PPS_CLIENT_KTIMER is not set
+# CONFIG_PPS_CLIENT_LDISC is not set
+# CONFIG_PPS_CLIENT_GPIO is not set
+
+#
+# PPS generators support
+#
+
+#
+# PTP clock support
+#
+CONFIG_PTP_1588_CLOCK=y
+CONFIG_PTP_1588_CLOCK_OPTIONAL=y
+
+#
+# Enable PHYLIB and NETWORK_PHY_TIMESTAMPING to see the additional clocks.
+#
+CONFIG_PTP_1588_CLOCK_KVM=y
+# CONFIG_PTP_1588_CLOCK_IDT82P33 is not set
+# CONFIG_PTP_1588_CLOCK_IDTCM is not set
+# CONFIG_PTP_QCOM_CLOCK_TSC is not set
+# end of PTP clock support
+
+CONFIG_PINCTRL=y
+CONFIG_GENERIC_PINCTRL_GROUPS=y
+CONFIG_PINMUX=y
+CONFIG_GENERIC_PINMUX_FUNCTIONS=y
+CONFIG_PINCONF=y
+CONFIG_GENERIC_PINCONF=y
+# CONFIG_DEBUG_PINCTRL is not set
+# CONFIG_PINCTRL_MCP23S08 is not set
+CONFIG_PINCTRL_SINGLE=y
+# CONFIG_PINCTRL_SX150X is not set
+# CONFIG_PINCTRL_STMFX is not set
+# CONFIG_PINCTRL_OCELOT is not set
+# CONFIG_PINCTRL_MICROCHIP_SGPIO is not set
+CONFIG_PINCTRL_MSM=y
+CONFIG_QCOM_PINCTRL=y
+# CONFIG_PINCTRL_KALAMA is not set
+# CONFIG_PINCTRL_KAKA is not set
+# CONFIG_PINCTRL_CROW is not set
+# CONFIG_PINCTRL_CINDER is not set
+# CONFIG_PINCTRL_SDXPINN is not set
+# CONFIG_PINCTRL_SCUBA_AUTO is not set
+# CONFIG_PINCTRL_APQ8064 is not set
+# CONFIG_PINCTRL_APQ8084 is not set
+# CONFIG_PINCTRL_IPQ4019 is not set
+# CONFIG_PINCTRL_IPQ8064 is not set
+# CONFIG_PINCTRL_IPQ8074 is not set
+# CONFIG_PINCTRL_IPQ6018 is not set
+# CONFIG_PINCTRL_MSM8226 is not set
+# CONFIG_PINCTRL_MSM8660 is not set
+# CONFIG_PINCTRL_MSM8960 is not set
+# CONFIG_PINCTRL_MDM9607 is not set
+# CONFIG_PINCTRL_MDM9615 is not set
+# CONFIG_PINCTRL_MSM8X74 is not set
+# CONFIG_PINCTRL_MSM8916 is not set
+# CONFIG_PINCTRL_MSM8953 is not set
+# CONFIG_PINCTRL_MSM8976 is not set
+# CONFIG_PINCTRL_MSM8994 is not set
+# CONFIG_PINCTRL_MSM8996 is not set
+# CONFIG_PINCTRL_MSM8998 is not set
+# CONFIG_PINCTRL_QCS404 is not set
+CONFIG_PINCTRL_QCOM_SPMI_PMIC=y
+CONFIG_PINCTRL_QCOM_SSBI_PMIC=y
+# CONFIG_PINCTRL_SC7180 is not set
+# CONFIG_PINCTRL_SC7280 is not set
+# CONFIG_PINCTRL_SC8180X is not set
+# CONFIG_PINCTRL_SDM660 is not set
+# CONFIG_PINCTRL_SDM845 is not set
+# CONFIG_PINCTRL_SDX55 is not set
+# CONFIG_PINCTRL_SM6115 is not set
+# CONFIG_PINCTRL_SM6125 is not set
+# CONFIG_PINCTRL_SM8150 is not set
+# CONFIG_PINCTRL_SM6150 is not set
+# CONFIG_PINCTRL_SM8250 is not set
+# CONFIG_PINCTRL_SM8350 is not set
+# CONFIG_PINCTRL_SDMSHRIKE is not set
+# CONFIG_PINCTRL_SLPI is not set
+# CONFIG_PINCTRL_KHAJE is not set
+# CONFIG_PINCTRL_BENGAL is not set
+# CONFIG_PINCTRL_SA410M is not set
+CONFIG_PINCTRL_MONACO=y
+# CONFIG_PINCTRL_MONACO_ACCESS_QUP02 is not set
+# CONFIG_PINCTRL_KONA is not set
+# CONFIG_PINCTRL_TRINKET is not set
+# CONFIG_PINCTRL_LPASS_LPI is not set
+# CONFIG_PINCTRL_SDXBAAGHA is not set
+# CONFIG_PINCTRL_LEMANS is not set
+# CONFIG_PINCTRL_DIREWOLF is not set
+# CONFIG_PINCTRL_MONACO_AUTO is not set
+
+#
+# Renesas pinctrl drivers
+#
+# end of Renesas pinctrl drivers
+
+CONFIG_GPIOLIB=y
+CONFIG_GPIOLIB_FASTPATH_LIMIT=512
+CONFIG_OF_GPIO=y
+CONFIG_GPIOLIB_IRQCHIP=y
+# CONFIG_DEBUG_GPIO is not set
+# CONFIG_GPIO_SYSFS is not set
+CONFIG_GPIO_CDEV=y
+CONFIG_GPIO_CDEV_V1=y
+CONFIG_GPIO_GENERIC=y
+
+#
+# Memory mapped GPIO drivers
+#
+# CONFIG_GPIO_74XX_MMIO is not set
+# CONFIG_GPIO_ALTERA is not set
+# CONFIG_GPIO_CADENCE is not set
+CONFIG_GPIO_DWAPB=y
+# CONFIG_GPIO_FTGPIO010 is not set
+CONFIG_GPIO_GENERIC_PLATFORM=y
+# CONFIG_GPIO_GRGPIO is not set
+# CONFIG_GPIO_HLWD is not set
+# CONFIG_GPIO_LOGICVC is not set
+# CONFIG_GPIO_MB86S7X is not set
+CONFIG_GPIO_PL061=y
+# CONFIG_GPIO_SAMA5D2_PIOBU is not set
+# CONFIG_GPIO_SIFIVE is not set
+CONFIG_GPIO_SYSCON=y
+# CONFIG_GPIO_XGENE is not set
+# CONFIG_GPIO_XILINX is not set
+# CONFIG_GPIO_AMD_FCH is not set
+# end of Memory mapped GPIO drivers
+
+#
+# I2C GPIO expanders
+#
+# CONFIG_GPIO_ADP5588 is not set
+# CONFIG_GPIO_ADNP is not set
+# CONFIG_GPIO_GW_PLD is not set
+# CONFIG_GPIO_MAX7300 is not set
+# CONFIG_GPIO_MAX732X is not set
+# CONFIG_GPIO_PCA953X is not set
+# CONFIG_GPIO_PCA9570 is not set
+# CONFIG_GPIO_PCF857X is not set
+CONFIG_GPIO_TPIC2810=y
+# end of I2C GPIO expanders
+
+#
+# MFD GPIO expanders
+#
+# end of MFD GPIO expanders
+
+#
+# PCI GPIO expanders
+#
+# CONFIG_GPIO_BT8XX is not set
+# CONFIG_GPIO_PCI_IDIO_16 is not set
+# CONFIG_GPIO_PCIE_IDIO_24 is not set
+# CONFIG_GPIO_RDC321X is not set
+# end of PCI GPIO expanders
+
+#
+# SPI GPIO expanders
+#
+# CONFIG_GPIO_74X164 is not set
+# CONFIG_GPIO_MAX3191X is not set
+# CONFIG_GPIO_MAX7301 is not set
+# CONFIG_GPIO_MC33880 is not set
+# CONFIG_GPIO_PISOSR is not set
+# CONFIG_GPIO_XRA1403 is not set
+# end of SPI GPIO expanders
+
+#
+# USB GPIO expanders
+#
+# end of USB GPIO expanders
+
+#
+# Virtual GPIO drivers
+#
+# CONFIG_GPIO_AGGREGATOR is not set
+# CONFIG_GPIO_MOCKUP is not set
+# CONFIG_GPIO_VIRTIO is not set
+# end of Virtual GPIO drivers
+
+# CONFIG_W1 is not set
+CONFIG_POWER_RESET=y
+# CONFIG_POWER_RESET_BRCMSTB is not set
+# CONFIG_POWER_RESET_GPIO is not set
+# CONFIG_POWER_RESET_GPIO_RESTART is not set
+CONFIG_POWER_RESET_MSM=y
+CONFIG_POWER_RESET_QCOM_DOWNLOAD_MODE=y
+CONFIG_POWER_RESET_QCOM_DOWNLOAD_MODE_DEFAULT=y
+CONFIG_POWER_RESET_QCOM_PON=y
+CONFIG_POWER_RESET_QCOM_REBOOT_REASON=y
+# CONFIG_POWER_RESET_LTC2952 is not set
+# CONFIG_POWER_RESET_REGULATOR is not set
+# CONFIG_POWER_RESET_RESTART is not set
+# CONFIG_POWER_RESET_XGENE is not set
+# CONFIG_POWER_RESET_SYSCON is not set
+# CONFIG_POWER_RESET_SYSCON_POWEROFF is not set
+CONFIG_REBOOT_MODE=y
+# CONFIG_SYSCON_REBOOT_MODE is not set
+# CONFIG_NVMEM_REBOOT_MODE is not set
+# CONFIG_POWER_RESET_QCOM_VM is not set
+# CONFIG_PM_SILENT_MODE is not set
+CONFIG_POWER_SUPPLY=y
+# CONFIG_POWER_SUPPLY_DEBUG is not set
+# CONFIG_PDA_POWER is not set
+# CONFIG_GENERIC_ADC_BATTERY is not set
+# CONFIG_TEST_POWER is not set
+# CONFIG_WALLPOWER_CHARGER is not set
+# CONFIG_CHARGER_ADP5061 is not set
+# CONFIG_BATTERY_ACT8945A is not set
+# CONFIG_BATTERY_CW2015 is not set
+# CONFIG_BATTERY_DS2780 is not set
+# CONFIG_BATTERY_DS2781 is not set
+# CONFIG_BATTERY_DS2782 is not set
+# CONFIG_BATTERY_SBS is not set
+# CONFIG_CHARGER_SBS is not set
+# CONFIG_BATTERY_BQ27XXX is not set
+# CONFIG_BATTERY_MAX17040 is not set
+# CONFIG_BATTERY_MAX17042 is not set
+# CONFIG_QTI_BATTERY_CHARGER is not set
+# CONFIG_CHARGER_ISP1704 is not set
+# CONFIG_CHARGER_MAX8903 is not set
+# CONFIG_CHARGER_LP8727 is not set
+# CONFIG_CHARGER_GPIO is not set
+# CONFIG_CHARGER_MANAGER is not set
+# CONFIG_CHARGER_LT3651 is not set
+# CONFIG_CHARGER_LTC4162L is not set
+# CONFIG_CHARGER_DETECTOR_MAX14656 is not set
+# CONFIG_CHARGER_QCOM_SMBB is not set
+# CONFIG_CHARGER_BQ2415X is not set
+# CONFIG_CHARGER_BQ24190 is not set
+# CONFIG_CHARGER_BQ24257 is not set
+# CONFIG_CHARGER_BQ24735 is not set
+# CONFIG_CHARGER_BQ2515X is not set
+# CONFIG_CHARGER_BQ25890 is not set
+# CONFIG_CHARGER_BQ25980 is not set
+# CONFIG_CHARGER_BQ256XX is not set
+# CONFIG_CHARGER_SMB347 is not set
+# CONFIG_BATTERY_GAUGE_LTC2941 is not set
+# CONFIG_BATTERY_GOLDFISH is not set
+# CONFIG_BATTERY_RT5033 is not set
+# CONFIG_CHARGER_RT9455 is not set
+# CONFIG_CHARGER_UCS1002 is not set
+# CONFIG_CHARGER_BD99954 is not set
+CONFIG_QCOM_POWER_SUPPLY=y
+# CONFIG_QPNP_QNOVO5 is not set
+# CONFIG_QPNP_QG is not set
+# CONFIG_QPNP_SMB5 is not set
+CONFIG_QPNP_SMBLITE=y
+# CONFIG_SMB23X_CHARGER is not set
+CONFIG_QTI_QBG=y
+# CONFIG_HWMON is not set
+CONFIG_THERMAL=y
+CONFIG_THERMAL_NETLINK=y
+CONFIG_THERMAL_STATISTICS=y
+CONFIG_THERMAL_EMERGENCY_POWEROFF_DELAY_MS=100
+CONFIG_THERMAL_OF=y
+CONFIG_THERMAL_WRITABLE_TRIPS=y
+CONFIG_THERMAL_DEFAULT_GOV_STEP_WISE=y
+# CONFIG_THERMAL_DEFAULT_GOV_FAIR_SHARE is not set
+# CONFIG_THERMAL_DEFAULT_GOV_USER_SPACE is not set
+# CONFIG_THERMAL_DEFAULT_GOV_POWER_ALLOCATOR is not set
+# CONFIG_THERMAL_GOV_FAIR_SHARE is not set
+CONFIG_THERMAL_GOV_STEP_WISE=y
+# CONFIG_THERMAL_GOV_BANG_BANG is not set
+CONFIG_THERMAL_GOV_USER_SPACE=y
+CONFIG_THERMAL_GOV_POWER_ALLOCATOR=y
+CONFIG_CPU_THERMAL=y
+CONFIG_CPU_FREQ_THERMAL=y
+CONFIG_DEVFREQ_THERMAL=y
+CONFIG_THERMAL_EMULATION=y
+# CONFIG_THERMAL_MMIO is not set
+# CONFIG_GENERIC_ADC_THERMAL is not set
+
+#
+# Qualcomm thermal drivers
+#
+# CONFIG_QCOM_TSENS is not set
+CONFIG_QCOM_SPMI_ADC_TM5=y
+# CONFIG_QCOM_SPMI_TEMP_ALARM is not set
+CONFIG_QCOM_LMH=y
+CONFIG_QTI_CPU_PAUSE_COOLING_DEVICE=y
+# CONFIG_QTI_BCL_PMIC5 is not set
+# CONFIG_QTI_BCL_SOC_DRIVER is not set
+# CONFIG_QTI_CPU_HOTPLUG_COOLING_DEVICE is not set
+# CONFIG_QTI_CPU_VOLTAGE_COOLING_DEVICE is not set
+# CONFIG_QTI_DDR_COOLING_DEVICE is not set
+# CONFIG_MAX31760_FAN_CONTROLLER is not set
+# CONFIG_QTI_THERMAL_LIMITS_DCVS is not set
+# CONFIG_QTI_POLICY_ENGINE_SENSOR is not set
+# CONFIG_QTI_QMI_COOLING_DEVICE is not set
+# CONFIG_QTI_QMI_SENSOR_V2 is not set
+# CONFIG_QTI_CPUFREQ_CDEV is not set
+# CONFIG_QTI_DEVFREQ_CDEV is not set
+# CONFIG_QTI_USERSPACE_CDEV is not set
+# CONFIG_QTI_SDPM_CLOCK_MONITOR is not set
+# CONFIG_QTI_THERMALZONE_CONFIG_DEBUG is not set
+# CONFIG_THERMAL_TSENS_LEGACY is not set
+# CONFIG_QTI_LMH_CPU_VDD_COOLING_DEVICE is not set
+# CONFIG_QTI_CX_IPEAK_COOLING_DEVICE is not set
+# CONFIG_REGULATOR_COOLING_DEVICE is not set
+# CONFIG_QTI_QMI_SENSOR is not set
+# CONFIG_QTI_RPM_SMD_COOLING_DEVICE is not set
+# CONFIG_QTI_THERMAL_MINIDUMP is not set
+# CONFIG_QTI_BCL_OFF_COOLING_DEVICE is not set
+# CONFIG_QTI_VIRTUAL_SENSOR is not set
+# CONFIG_QTI_AOP_PMIC_SENSOR is not set
+# end of Qualcomm thermal drivers
+
+# CONFIG_WATCHDOG is not set
+CONFIG_SSB_POSSIBLE=y
+# CONFIG_SSB is not set
+CONFIG_BCMA_POSSIBLE=y
+# CONFIG_BCMA is not set
+
+#
+# Multifunction device drivers
+#
+CONFIG_MFD_CORE=y
+CONFIG_MFD_ACT8945A=y
+# CONFIG_MFD_AS3711 is not set
+# CONFIG_MFD_AS3722 is not set
+# CONFIG_PMIC_ADP5520 is not set
+# CONFIG_MFD_AAT2870_CORE is not set
+# CONFIG_MFD_ATMEL_FLEXCOM is not set
+# CONFIG_MFD_ATMEL_HLCDC is not set
+# CONFIG_MFD_BCM590XX is not set
+# CONFIG_MFD_BD9571MWV is not set
+# CONFIG_MFD_AXP20X_I2C is not set
+# CONFIG_MFD_MADERA is not set
+# CONFIG_PMIC_DA903X is not set
+# CONFIG_MFD_DA9052_SPI is not set
+# CONFIG_MFD_DA9052_I2C is not set
+# CONFIG_MFD_DA9055 is not set
+# CONFIG_MFD_DA9062 is not set
+# CONFIG_MFD_DA9063 is not set
+# CONFIG_MFD_DA9150 is not set
+# CONFIG_MFD_DLN2 is not set
+# CONFIG_MFD_GATEWORKS_GSC is not set
+# CONFIG_MFD_MC13XXX_SPI is not set
+# CONFIG_MFD_MC13XXX_I2C is not set
+# CONFIG_MFD_MP2629 is not set
+# CONFIG_MFD_HI6421_PMIC is not set
+# CONFIG_MFD_HI6421_SPMI is not set
+# CONFIG_HTC_PASIC3 is not set
+# CONFIG_HTC_I2CPLD is not set
+# CONFIG_LPC_ICH is not set
+# CONFIG_LPC_SCH is not set
+# CONFIG_MFD_INTEL_PMT is not set
+# CONFIG_MFD_IQS62X is not set
+# CONFIG_MFD_JANZ_CMODIO is not set
+# CONFIG_MFD_KEMPLD is not set
+# CONFIG_MFD_88PM800 is not set
+# CONFIG_MFD_88PM805 is not set
+# CONFIG_MFD_88PM860X is not set
+# CONFIG_MFD_MAX14577 is not set
+# CONFIG_MFD_MAX77620 is not set
+# CONFIG_MFD_MAX77650 is not set
+# CONFIG_MFD_MAX77686 is not set
+# CONFIG_MFD_MAX77693 is not set
+# CONFIG_MFD_MAX77843 is not set
+# CONFIG_MFD_MAX8907 is not set
+# CONFIG_MFD_MAX8925 is not set
+# CONFIG_MFD_MAX8997 is not set
+# CONFIG_MFD_MAX8998 is not set
+# CONFIG_MFD_MT6360 is not set
+# CONFIG_MFD_MT6397 is not set
+# CONFIG_MFD_MENF21BMC is not set
+# CONFIG_EZX_PCAP is not set
+# CONFIG_MFD_CPCAP is not set
+# CONFIG_MFD_VIPERBOARD is not set
+# CONFIG_MFD_NTXEC is not set
+# CONFIG_MFD_RETU is not set
+# CONFIG_MFD_PCF50633 is not set
+# CONFIG_MFD_I2C_PMIC is not set
+CONFIG_MFD_QCOM_RPM=y
+CONFIG_MFD_SPMI_PMIC=y
+# CONFIG_MFD_RDC321X is not set
+# CONFIG_MFD_RT4831 is not set
+# CONFIG_MFD_RT5033 is not set
+# CONFIG_MFD_RC5T583 is not set
+# CONFIG_MFD_RK808 is not set
+# CONFIG_MFD_RN5T618 is not set
+# CONFIG_MFD_SEC_CORE is not set
+# CONFIG_MFD_SI476X_CORE is not set
+# CONFIG_MFD_SM501 is not set
+# CONFIG_MFD_SKY81452 is not set
+# CONFIG_MFD_STMPE is not set
+CONFIG_MFD_SYSCON=y
+# CONFIG_MFD_TI_AM335X_TSCADC is not set
+# CONFIG_MFD_LP3943 is not set
+# CONFIG_MFD_LP8788 is not set
+# CONFIG_MFD_TI_LMU is not set
+# CONFIG_MFD_PALMAS is not set
+# CONFIG_TPS6105X is not set
+# CONFIG_TPS65010 is not set
+# CONFIG_TPS6507X is not set
+# CONFIG_MFD_TPS65086 is not set
+# CONFIG_MFD_TPS65090 is not set
+# CONFIG_MFD_TPS65217 is not set
+# CONFIG_MFD_TI_LP873X is not set
+# CONFIG_MFD_TI_LP87565 is not set
+# CONFIG_MFD_TPS65218 is not set
+# CONFIG_MFD_TPS6586X is not set
+# CONFIG_MFD_TPS65910 is not set
+# CONFIG_MFD_TPS65912_I2C is not set
+# CONFIG_MFD_TPS65912_SPI is not set
+# CONFIG_MFD_TPS80031 is not set
+# CONFIG_TWL4030_CORE is not set
+# CONFIG_TWL6040_CORE is not set
+# CONFIG_MFD_WL1273_CORE is not set
+# CONFIG_MFD_LM3533 is not set
+# CONFIG_MFD_TC3589X is not set
+# CONFIG_MFD_TQMX86 is not set
+# CONFIG_MFD_VX855 is not set
+# CONFIG_MFD_LOCHNAGAR is not set
+# CONFIG_MFD_ARIZONA_I2C is not set
+# CONFIG_MFD_ARIZONA_SPI is not set
+# CONFIG_MFD_WM8400 is not set
+# CONFIG_MFD_WM831X_I2C is not set
+# CONFIG_MFD_WM831X_SPI is not set
+# CONFIG_MFD_WM8350_I2C is not set
+# CONFIG_MFD_WM8994 is not set
+# CONFIG_MFD_ROHM_BD718XX is not set
+# CONFIG_MFD_ROHM_BD70528 is not set
+# CONFIG_MFD_ROHM_BD71828 is not set
+# CONFIG_MFD_ROHM_BD957XMUF is not set
+# CONFIG_MFD_STPMIC1 is not set
+# CONFIG_MFD_STMFX is not set
+# CONFIG_MFD_ATC260X_I2C is not set
+# CONFIG_MFD_QCOM_PM8008 is not set
+# CONFIG_RAVE_SP_CORE is not set
+# CONFIG_MFD_INTEL_M10_BMC is not set
+# CONFIG_MFD_RSMU_I2C is not set
+# CONFIG_MFD_RSMU_SPI is not set
+# end of Multifunction device drivers
+
+CONFIG_REGULATOR=y
+CONFIG_REGULATOR_DEBUG=y
+# CONFIG_REGULATOR_DEBUG_CONTROL is not set
+CONFIG_REGULATOR_FIXED_VOLTAGE=y
+CONFIG_REGULATOR_QTI_FIXED_VOLTAGE=y
+# CONFIG_REGULATOR_VIRTUAL_CONSUMER is not set
+# CONFIG_REGULATOR_USERSPACE_CONSUMER is not set
+CONFIG_REGULATOR_PROXY_CONSUMER=y
+# CONFIG_REGULATOR_PROXY_CONSUMER_LEGACY is not set
+# CONFIG_REGULATOR_88PG86X is not set
+# CONFIG_REGULATOR_ACT8865 is not set
+# CONFIG_REGULATOR_ACT8945A is not set
+# CONFIG_REGULATOR_AD5398 is not set
+# CONFIG_REGULATOR_ARM_SCMI is not set
+# CONFIG_REGULATOR_CPR is not set
+# CONFIG_REGULATOR_DA9121 is not set
+# CONFIG_REGULATOR_DA9210 is not set
+# CONFIG_REGULATOR_DA9211 is not set
+# CONFIG_REGULATOR_FAN53555 is not set
+# CONFIG_REGULATOR_FAN53880 is not set
+# CONFIG_REGULATOR_GPIO is not set
+# CONFIG_REGULATOR_ISL9305 is not set
+# CONFIG_REGULATOR_ISL6271A is not set
+# CONFIG_REGULATOR_LP3971 is not set
+# CONFIG_REGULATOR_LP3972 is not set
+# CONFIG_REGULATOR_LP872X is not set
+# CONFIG_REGULATOR_LP8755 is not set
+# CONFIG_REGULATOR_LTC3589 is not set
+# CONFIG_REGULATOR_LTC3676 is not set
+# CONFIG_REGULATOR_MAX1586 is not set
+# CONFIG_REGULATOR_MAX8649 is not set
+# CONFIG_REGULATOR_MAX8660 is not set
+# CONFIG_REGULATOR_MAX8893 is not set
+# CONFIG_REGULATOR_MAX8952 is not set
+# CONFIG_REGULATOR_MAX8973 is not set
+# CONFIG_REGULATOR_MAX77826 is not set
+# CONFIG_REGULATOR_MCP16502 is not set
+# CONFIG_REGULATOR_MP5416 is not set
+# CONFIG_REGULATOR_MP8859 is not set
+# CONFIG_REGULATOR_MP886X is not set
+# CONFIG_REGULATOR_MPQ7920 is not set
+# CONFIG_REGULATOR_MT6311 is not set
+# CONFIG_REGULATOR_MT6315 is not set
+# CONFIG_REGULATOR_PCA9450 is not set
+# CONFIG_REGULATOR_PF8X00 is not set
+# CONFIG_REGULATOR_PFUZE100 is not set
+# CONFIG_REGULATOR_PV88060 is not set
+# CONFIG_REGULATOR_PV88080 is not set
+# CONFIG_REGULATOR_PV88090 is not set
+# CONFIG_REGULATOR_PWM is not set
+CONFIG_REGULATOR_QCOM_RPM=y
+CONFIG_REGULATOR_QCOM_SMD_RPM=y
+CONFIG_REGULATOR_QCOM_SPMI=y
+# CONFIG_REGULATOR_SPM is not set
+CONFIG_REGULATOR_QCOM_USB_VBUS=y
+CONFIG_REGULATOR_QPNP_AMOLED=y
+# CONFIG_REGULATOR_QPNP_LCDB is not set
+# CONFIG_REGULATOR_RASPBERRYPI_TOUCHSCREEN_ATTINY is not set
+# CONFIG_REGULATOR_RT4801 is not set
+# CONFIG_REGULATOR_RT6160 is not set
+# CONFIG_REGULATOR_RT6245 is not set
+# CONFIG_REGULATOR_RTQ2134 is not set
+# CONFIG_REGULATOR_RTMV20 is not set
+# CONFIG_REGULATOR_RTQ6752 is not set
+# CONFIG_REGULATOR_SLG51000 is not set
+# CONFIG_REGULATOR_SY8106A is not set
+# CONFIG_REGULATOR_SY8824X is not set
+# CONFIG_REGULATOR_SY8827N is not set
+# CONFIG_REGULATOR_TPS51632 is not set
+# CONFIG_REGULATOR_TPS62360 is not set
+# CONFIG_REGULATOR_TPS65023 is not set
+# CONFIG_REGULATOR_TPS6507X is not set
+# CONFIG_REGULATOR_TPS65132 is not set
+# CONFIG_REGULATOR_TPS6524X is not set
+# CONFIG_REGULATOR_VCTRL is not set
+# CONFIG_REGULATOR_VQMMC_IPQ4019 is not set
+# CONFIG_REGULATOR_REFGEN is not set
+# CONFIG_REGULATOR_QCOM_LABIBB is not set
+# CONFIG_REGULATOR_RPMH is not set
+CONFIG_REGULATOR_RPM_SMD=y
+# CONFIG_REGULATOR_STUB is not set
+# CONFIG_REGULATOR_QTI_OCP_NOTIFIER is not set
+# CONFIG_VIRTIO_REGULATOR is not set
+CONFIG_RC_CORE=y
+# CONFIG_RC_MAP is not set
+CONFIG_LIRC=y
+CONFIG_BPF_LIRC_MODE2=y
+CONFIG_RC_DECODERS=y
+# CONFIG_IR_NEC_DECODER is not set
+# CONFIG_IR_RC5_DECODER is not set
+# CONFIG_IR_RC6_DECODER is not set
+# CONFIG_IR_JVC_DECODER is not set
+# CONFIG_IR_SONY_DECODER is not set
+# CONFIG_IR_SANYO_DECODER is not set
+# CONFIG_IR_SHARP_DECODER is not set
+# CONFIG_IR_MCE_KBD_DECODER is not set
+# CONFIG_IR_XMP_DECODER is not set
+# CONFIG_IR_IMON_DECODER is not set
+# CONFIG_IR_RCMM_DECODER is not set
+CONFIG_RC_DEVICES=y
+# CONFIG_RC_ATI_REMOTE is not set
+# CONFIG_IR_HIX5HD2 is not set
+# CONFIG_IR_IMON is not set
+# CONFIG_IR_IMON_RAW is not set
+# CONFIG_IR_MCEUSB is not set
+# CONFIG_IR_REDRAT3 is not set
+# CONFIG_IR_SPI is not set
+# CONFIG_IR_STREAMZAP is not set
+# CONFIG_IR_IGORPLUGUSB is not set
+# CONFIG_IR_IGUANA is not set
+# CONFIG_IR_TTUSBIR is not set
+# CONFIG_RC_LOOPBACK is not set
+# CONFIG_IR_GPIO_CIR is not set
+# CONFIG_IR_GPIO_TX is not set
+# CONFIG_IR_PWM_TX is not set
+# CONFIG_IR_SERIAL is not set
+# CONFIG_IR_SIR is not set
+# CONFIG_RC_XBOX_DVD is not set
+# CONFIG_IR_TOY is not set
+CONFIG_CEC_CORE=y
+CONFIG_CEC_NOTIFIER=y
+CONFIG_CEC_PIN=y
+CONFIG_MEDIA_CEC_RC=y
+# CONFIG_CEC_PIN_ERROR_INJ is not set
+CONFIG_MEDIA_CEC_SUPPORT=y
+# CONFIG_CEC_CH7322 is not set
+# CONFIG_CEC_GPIO is not set
+# CONFIG_USB_PULSE8_CEC is not set
+# CONFIG_USB_RAINSHADOW_CEC is not set
+CONFIG_MEDIA_SUPPORT=y
+# CONFIG_MEDIA_SUPPORT_FILTER is not set
+# CONFIG_MEDIA_SUBDRV_AUTOSELECT is not set
+
+#
+# Media device types
+#
+CONFIG_MEDIA_CAMERA_SUPPORT=y
+# CONFIG_MEDIA_ANALOG_TV_SUPPORT is not set
+# CONFIG_MEDIA_DIGITAL_TV_SUPPORT is not set
+# CONFIG_MEDIA_RADIO_SUPPORT is not set
+# CONFIG_MEDIA_SDR_SUPPORT is not set
+CONFIG_MEDIA_PLATFORM_SUPPORT=y
+# CONFIG_MEDIA_TEST_SUPPORT is not set
+# end of Media device types
+
+#
+# Media core support
+#
+CONFIG_VIDEO_DEV=y
+CONFIG_MEDIA_CONTROLLER=y
+# end of Media core support
+
+#
+# Video4Linux options
+#
+CONFIG_VIDEO_V4L2=y
+CONFIG_VIDEO_V4L2_I2C=y
+CONFIG_VIDEO_V4L2_SUBDEV_API=y
+# CONFIG_VIDEO_ADV_DEBUG is not set
+# CONFIG_VIDEO_FIXED_MINOR_RANGES is not set
+CONFIG_V4L2_MEM2MEM_DEV=y
+# CONFIG_V4L2_FLASH_LED_CLASS is not set
+# end of Video4Linux options
+
+#
+# Media controller options
+#
+CONFIG_MEDIA_CONTROLLER_REQUEST_API=y
+
+#
+# Please notice that the enabled Media controller Request API is EXPERIMENTAL
+#
+# end of Media controller options
+
+#
+# Media drivers
+#
+CONFIG_MEDIA_USB_SUPPORT=y
+
+#
+# Webcam devices
+#
+CONFIG_USB_VIDEO_CLASS=y
+CONFIG_USB_VIDEO_CLASS_INPUT_EVDEV=y
+CONFIG_USB_GSPCA=y
+# CONFIG_USB_M5602 is not set
+# CONFIG_USB_STV06XX is not set
+# CONFIG_USB_GL860 is not set
+# CONFIG_USB_GSPCA_BENQ is not set
+# CONFIG_USB_GSPCA_CONEX is not set
+# CONFIG_USB_GSPCA_CPIA1 is not set
+# CONFIG_USB_GSPCA_DTCS033 is not set
+# CONFIG_USB_GSPCA_ETOMS is not set
+# CONFIG_USB_GSPCA_FINEPIX is not set
+# CONFIG_USB_GSPCA_JEILINJ is not set
+# CONFIG_USB_GSPCA_JL2005BCD is not set
+# CONFIG_USB_GSPCA_KINECT is not set
+# CONFIG_USB_GSPCA_KONICA is not set
+# CONFIG_USB_GSPCA_MARS is not set
+# CONFIG_USB_GSPCA_MR97310A is not set
+# CONFIG_USB_GSPCA_NW80X is not set
+# CONFIG_USB_GSPCA_OV519 is not set
+# CONFIG_USB_GSPCA_OV534 is not set
+# CONFIG_USB_GSPCA_OV534_9 is not set
+# CONFIG_USB_GSPCA_PAC207 is not set
+# CONFIG_USB_GSPCA_PAC7302 is not set
+# CONFIG_USB_GSPCA_PAC7311 is not set
+# CONFIG_USB_GSPCA_SE401 is not set
+# CONFIG_USB_GSPCA_SN9C2028 is not set
+# CONFIG_USB_GSPCA_SN9C20X is not set
+# CONFIG_USB_GSPCA_SONIXB is not set
+# CONFIG_USB_GSPCA_SONIXJ is not set
+# CONFIG_USB_GSPCA_SPCA500 is not set
+# CONFIG_USB_GSPCA_SPCA501 is not set
+# CONFIG_USB_GSPCA_SPCA505 is not set
+# CONFIG_USB_GSPCA_SPCA506 is not set
+# CONFIG_USB_GSPCA_SPCA508 is not set
+# CONFIG_USB_GSPCA_SPCA561 is not set
+# CONFIG_USB_GSPCA_SPCA1528 is not set
+# CONFIG_USB_GSPCA_SQ905 is not set
+# CONFIG_USB_GSPCA_SQ905C is not set
+# CONFIG_USB_GSPCA_SQ930X is not set
+# CONFIG_USB_GSPCA_STK014 is not set
+# CONFIG_USB_GSPCA_STK1135 is not set
+# CONFIG_USB_GSPCA_STV0680 is not set
+# CONFIG_USB_GSPCA_SUNPLUS is not set
+# CONFIG_USB_GSPCA_T613 is not set
+# CONFIG_USB_GSPCA_TOPRO is not set
+# CONFIG_USB_GSPCA_TOUPTEK is not set
+# CONFIG_USB_GSPCA_TV8532 is not set
+# CONFIG_USB_GSPCA_VC032X is not set
+# CONFIG_USB_GSPCA_VICAM is not set
+# CONFIG_USB_GSPCA_XIRLINK_CIT is not set
+# CONFIG_USB_GSPCA_ZC3XX is not set
+# CONFIG_USB_PWC is not set
+# CONFIG_VIDEO_CPIA2 is not set
+# CONFIG_USB_ZR364XX is not set
+# CONFIG_USB_STKWEBCAM is not set
+# CONFIG_USB_S2255 is not set
+# CONFIG_VIDEO_USBTV is not set
+
+#
+# Webcam, TV (analog/digital) USB devices
+#
+# CONFIG_VIDEO_EM28XX is not set
+# CONFIG_MEDIA_PCI_SUPPORT is not set
+CONFIG_VIDEOBUF2_CORE=y
+CONFIG_VIDEOBUF2_V4L2=y
+CONFIG_VIDEOBUF2_MEMOPS=y
+CONFIG_VIDEOBUF2_DMA_CONTIG=y
+CONFIG_VIDEOBUF2_VMALLOC=y
+CONFIG_VIDEOBUF2_DMA_SG=y
+CONFIG_V4L_PLATFORM_DRIVERS=y
+# CONFIG_VIDEO_CAFE_CCIC is not set
+# CONFIG_VIDEO_CADENCE is not set
+# CONFIG_VIDEO_ASPEED is not set
+# CONFIG_VIDEO_MUX is not set
+# CONFIG_VIDEO_QCOM_CAMSS is not set
+# CONFIG_VIDEO_XILINX is not set
+CONFIG_V4L_MEM2MEM_DRIVERS=y
+# CONFIG_VIDEO_MEM2MEM_DEINTERLACE is not set
+# CONFIG_VIDEO_QCOM_VENUS is not set
+# CONFIG_MSM_GLOBAL_SYNX is not set
+# CONFIG_VIRTIO_NPU is not set
+# CONFIG_MSM_NPU is not set
+# end of Media drivers
+
+#
+# Media ancillary drivers
+#
+CONFIG_VIDEO_IR_I2C=y
+
+#
+# Audio decoders, processors and mixers
+#
+# CONFIG_VIDEO_TVAUDIO is not set
+# CONFIG_VIDEO_TDA7432 is not set
+# CONFIG_VIDEO_TDA9840 is not set
+# CONFIG_VIDEO_TDA1997X is not set
+# CONFIG_VIDEO_TEA6415C is not set
+# CONFIG_VIDEO_TEA6420 is not set
+# CONFIG_VIDEO_MSP3400 is not set
+# CONFIG_VIDEO_CS3308 is not set
+# CONFIG_VIDEO_CS5345 is not set
+# CONFIG_VIDEO_CS53L32A is not set
+# CONFIG_VIDEO_TLV320AIC23B is not set
+# CONFIG_VIDEO_UDA1342 is not set
+# CONFIG_VIDEO_WM8775 is not set
+# CONFIG_VIDEO_WM8739 is not set
+# CONFIG_VIDEO_VP27SMPX is not set
+# CONFIG_VIDEO_SONY_BTF_MPX is not set
+# end of Audio decoders, processors and mixers
+
+#
+# RDS decoders
+#
+# CONFIG_VIDEO_SAA6588 is not set
+# end of RDS decoders
+
+#
+# Video decoders
+#
+# CONFIG_VIDEO_ADV7180 is not set
+# CONFIG_VIDEO_ADV7183 is not set
+# CONFIG_VIDEO_ADV748X is not set
+# CONFIG_VIDEO_ADV7604 is not set
+# CONFIG_VIDEO_ADV7842 is not set
+# CONFIG_VIDEO_BT819 is not set
+# CONFIG_VIDEO_BT856 is not set
+# CONFIG_VIDEO_BT866 is not set
+# CONFIG_VIDEO_KS0127 is not set
+# CONFIG_VIDEO_ML86V7667 is not set
+# CONFIG_VIDEO_SAA7110 is not set
+# CONFIG_VIDEO_SAA711X is not set
+# CONFIG_VIDEO_TC358743 is not set
+# CONFIG_VIDEO_TVP514X is not set
+# CONFIG_VIDEO_TVP5150 is not set
+# CONFIG_VIDEO_TVP7002 is not set
+# CONFIG_VIDEO_TW2804 is not set
+# CONFIG_VIDEO_TW9903 is not set
+# CONFIG_VIDEO_TW9906 is not set
+# CONFIG_VIDEO_TW9910 is not set
+# CONFIG_VIDEO_VPX3220 is not set
+
+#
+# Video and audio decoders
+#
+# CONFIG_VIDEO_SAA717X is not set
+# CONFIG_VIDEO_CX25840 is not set
+# end of Video decoders
+
+#
+# Video encoders
+#
+# CONFIG_VIDEO_SAA7127 is not set
+# CONFIG_VIDEO_SAA7185 is not set
+# CONFIG_VIDEO_ADV7170 is not set
+# CONFIG_VIDEO_ADV7175 is not set
+# CONFIG_VIDEO_ADV7343 is not set
+# CONFIG_VIDEO_ADV7393 is not set
+# CONFIG_VIDEO_ADV7511 is not set
+# CONFIG_VIDEO_AD9389B is not set
+# CONFIG_VIDEO_AK881X is not set
+# CONFIG_VIDEO_THS8200 is not set
+# end of Video encoders
+
+#
+# Video improvement chips
+#
+# CONFIG_VIDEO_UPD64031A is not set
+# CONFIG_VIDEO_UPD64083 is not set
+# end of Video improvement chips
+
+#
+# Audio/Video compression chips
+#
+# CONFIG_VIDEO_SAA6752HS is not set
+# end of Audio/Video compression chips
+
+#
+# SDR tuner chips
+#
+# end of SDR tuner chips
+
+#
+# Miscellaneous helper chips
+#
+# CONFIG_VIDEO_THS7303 is not set
+# CONFIG_VIDEO_M52790 is not set
+# CONFIG_VIDEO_I2C is not set
+# CONFIG_VIDEO_ST_MIPID02 is not set
+# end of Miscellaneous helper chips
+
+#
+# Camera sensor devices
+#
+# CONFIG_VIDEO_HI556 is not set
+# CONFIG_VIDEO_IMX208 is not set
+# CONFIG_VIDEO_IMX214 is not set
+# CONFIG_VIDEO_IMX219 is not set
+# CONFIG_VIDEO_IMX258 is not set
+# CONFIG_VIDEO_IMX274 is not set
+# CONFIG_VIDEO_IMX290 is not set
+# CONFIG_VIDEO_IMX319 is not set
+# CONFIG_VIDEO_IMX334 is not set
+# CONFIG_VIDEO_IMX335 is not set
+# CONFIG_VIDEO_IMX355 is not set
+# CONFIG_VIDEO_IMX412 is not set
+# CONFIG_VIDEO_OV02A10 is not set
+# CONFIG_VIDEO_OV2640 is not set
+# CONFIG_VIDEO_OV2659 is not set
+# CONFIG_VIDEO_OV2680 is not set
+# CONFIG_VIDEO_OV2685 is not set
+# CONFIG_VIDEO_OV5640 is not set
+# CONFIG_VIDEO_OV5645 is not set
+# CONFIG_VIDEO_OV5647 is not set
+# CONFIG_VIDEO_OV5648 is not set
+# CONFIG_VIDEO_OV6650 is not set
+# CONFIG_VIDEO_OV5670 is not set
+# CONFIG_VIDEO_OV5675 is not set
+# CONFIG_VIDEO_OV5695 is not set
+# CONFIG_VIDEO_OV7251 is not set
+# CONFIG_VIDEO_OV772X is not set
+# CONFIG_VIDEO_OV7640 is not set
+# CONFIG_VIDEO_OV7670 is not set
+# CONFIG_VIDEO_OV7740 is not set
+# CONFIG_VIDEO_OV8856 is not set
+# CONFIG_VIDEO_OV8865 is not set
+# CONFIG_VIDEO_OV9282 is not set
+# CONFIG_VIDEO_OV9640 is not set
+# CONFIG_VIDEO_OV9650 is not set
+# CONFIG_VIDEO_OV13858 is not set
+# CONFIG_VIDEO_VS6624 is not set
+# CONFIG_VIDEO_MT9M001 is not set
+# CONFIG_VIDEO_MT9M032 is not set
+# CONFIG_VIDEO_MT9M111 is not set
+# CONFIG_VIDEO_MT9P031 is not set
+# CONFIG_VIDEO_MT9T001 is not set
+# CONFIG_VIDEO_MT9T112 is not set
+# CONFIG_VIDEO_MT9V011 is not set
+# CONFIG_VIDEO_MT9V032 is not set
+# CONFIG_VIDEO_MT9V111 is not set
+# CONFIG_VIDEO_SR030PC30 is not set
+# CONFIG_VIDEO_NOON010PC30 is not set
+# CONFIG_VIDEO_M5MOLS is not set
+# CONFIG_VIDEO_RDACM20 is not set
+# CONFIG_VIDEO_RDACM21 is not set
+# CONFIG_VIDEO_RJ54N1 is not set
+# CONFIG_VIDEO_S5K6AA is not set
+# CONFIG_VIDEO_S5K6A3 is not set
+# CONFIG_VIDEO_S5K4ECGX is not set
+# CONFIG_VIDEO_S5K5BAF is not set
+# CONFIG_VIDEO_CCS is not set
+# CONFIG_VIDEO_ET8EK8 is not set
+# CONFIG_VIDEO_S5C73M3 is not set
+# end of Camera sensor devices
+
+#
+# Lens drivers
+#
+# CONFIG_VIDEO_AD5820 is not set
+# CONFIG_VIDEO_AK7375 is not set
+# CONFIG_VIDEO_DW9714 is not set
+# CONFIG_VIDEO_DW9768 is not set
+# CONFIG_VIDEO_DW9807_VCM is not set
+# end of Lens drivers
+
+#
+# Flash devices
+#
+# CONFIG_VIDEO_ADP1653 is not set
+# CONFIG_VIDEO_LM3560 is not set
+# CONFIG_VIDEO_LM3646 is not set
+# end of Flash devices
+
+#
+# SPI helper chips
+#
+# CONFIG_VIDEO_GS1662 is not set
+# end of SPI helper chips
+
+#
+# Media SPI Adapters
+#
+# end of Media SPI Adapters
+# end of Media ancillary drivers
+
+#
+# Graphics support
+#
+# CONFIG_VGA_ARB is not set
+CONFIG_DRM=y
+CONFIG_DRM_MIPI_DSI=y
+# CONFIG_DRM_DP_AUX_CHARDEV is not set
+# CONFIG_DRM_DEBUG_MM is not set
+# CONFIG_DRM_DEBUG_SELFTEST is not set
+CONFIG_DRM_KMS_HELPER=y
+# CONFIG_DRM_DEBUG_DP_MST_TOPOLOGY_REFS is not set
+CONFIG_DRM_FBDEV_EMULATION=y
+CONFIG_DRM_FBDEV_OVERALLOC=100
+# CONFIG_DRM_FBDEV_LEAK_PHYS_SMEM is not set
+# CONFIG_DRM_LOAD_EDID_FIRMWARE is not set
+# CONFIG_DRM_DP_CEC is not set
+CONFIG_DRM_TTM=y
+CONFIG_DRM_GEM_CMA_HELPER=y
+CONFIG_DRM_KMS_CMA_HELPER=y
+CONFIG_DRM_GEM_SHMEM_HELPER=y
+CONFIG_DRM_SCHED=y
+
+#
+# I2C encoder or helper chips
+#
+# CONFIG_DRM_I2C_CH7006 is not set
+# CONFIG_DRM_I2C_SIL164 is not set
+# CONFIG_DRM_I2C_NXP_TDA998X is not set
+# CONFIG_DRM_I2C_NXP_TDA9950 is not set
+# end of I2C encoder or helper chips
+
+#
+# ARM devices
+#
+# CONFIG_DRM_HDLCD is not set
+# CONFIG_DRM_MALI_DISPLAY is not set
+# CONFIG_DRM_KOMEDA is not set
+# end of ARM devices
+
+# CONFIG_DRM_RADEON is not set
+# CONFIG_DRM_AMDGPU is not set
+# CONFIG_DRM_NOUVEAU is not set
+# CONFIG_DRM_VGEM is not set
+# CONFIG_DRM_VKMS is not set
+# CONFIG_DRM_VMWGFX is not set
+# CONFIG_DRM_UDL is not set
+# CONFIG_DRM_AST is not set
+# CONFIG_DRM_MGAG200 is not set
+# CONFIG_DRM_RCAR_DW_HDMI is not set
+# CONFIG_DRM_RCAR_LVDS is not set
+# CONFIG_DRM_QXL is not set
+# CONFIG_DRM_VIRTIO_GPU is not set
+CONFIG_DRM_MSM=y
+CONFIG_DRM_MSM_GPU_STATE=y
+# CONFIG_DRM_MSM_REGISTER_LOGGING is not set
+CONFIG_DRM_MSM_GPU_SUDO=y
+CONFIG_DRM_MSM_HDMI_HDCP=y
+CONFIG_DRM_MSM_DP=y
+CONFIG_DRM_MSM_DSI=y
+CONFIG_DRM_MSM_DSI_28NM_PHY=y
+CONFIG_DRM_MSM_DSI_20NM_PHY=y
+CONFIG_DRM_MSM_DSI_28NM_8960_PHY=y
+CONFIG_DRM_MSM_DSI_14NM_PHY=y
+CONFIG_DRM_MSM_DSI_10NM_PHY=y
+CONFIG_DRM_MSM_DSI_7NM_PHY=y
+CONFIG_DRM_PANEL=y
+
+#
+# Display Panels
+#
+# CONFIG_DRM_PANEL_ABT_Y030XX067A is not set
+# CONFIG_DRM_PANEL_ARM_VERSATILE is not set
+# CONFIG_DRM_PANEL_ASUS_Z00T_TM5P5_NT35596 is not set
+# CONFIG_DRM_PANEL_BOE_HIMAX8279D is not set
+# CONFIG_DRM_PANEL_BOE_TV101WUM_NL6 is not set
+# CONFIG_DRM_PANEL_DSI_CM is not set
+# CONFIG_DRM_PANEL_LVDS is not set
+# CONFIG_DRM_PANEL_SIMPLE is not set
+# CONFIG_DRM_PANEL_ELIDA_KD35T133 is not set
+# CONFIG_DRM_PANEL_FEIXIN_K101_IM2BA02 is not set
+# CONFIG_DRM_PANEL_FEIYANG_FY07024DI26A30D is not set
+# CONFIG_DRM_PANEL_ILITEK_IL9322 is not set
+# CONFIG_DRM_PANEL_ILITEK_ILI9341 is not set
+# CONFIG_DRM_PANEL_ILITEK_ILI9881C is not set
+# CONFIG_DRM_PANEL_INNOLUX_EJ030NA is not set
+# CONFIG_DRM_PANEL_INNOLUX_P079ZCA is not set
+# CONFIG_DRM_PANEL_JDI_LT070ME05000 is not set
+# CONFIG_DRM_PANEL_KHADAS_TS050 is not set
+# CONFIG_DRM_PANEL_KINGDISPLAY_KD097D04 is not set
+# CONFIG_DRM_PANEL_LEADTEK_LTK050H3146W is not set
+# CONFIG_DRM_PANEL_LEADTEK_LTK500HD1829 is not set
+# CONFIG_DRM_PANEL_SAMSUNG_LD9040 is not set
+# CONFIG_DRM_PANEL_LG_LB035Q02 is not set
+# CONFIG_DRM_PANEL_LG_LG4573 is not set
+# CONFIG_DRM_PANEL_NEC_NL8048HL11 is not set
+# CONFIG_DRM_PANEL_NOVATEK_NT35510 is not set
+# CONFIG_DRM_PANEL_NOVATEK_NT36672A is not set
+# CONFIG_DRM_PANEL_NOVATEK_NT39016 is not set
+# CONFIG_DRM_PANEL_MANTIX_MLAF057WE51 is not set
+# CONFIG_DRM_PANEL_OLIMEX_LCD_OLINUXINO is not set
+# CONFIG_DRM_PANEL_ORISETECH_OTM8009A is not set
+# CONFIG_DRM_PANEL_OSD_OSD101T2587_53TS is not set
+# CONFIG_DRM_PANEL_PANASONIC_VVX10F034N00 is not set
+# CONFIG_DRM_PANEL_RASPBERRYPI_TOUCHSCREEN is not set
+# CONFIG_DRM_PANEL_RAYDIUM_RM67191 is not set
+# CONFIG_DRM_PANEL_RAYDIUM_RM68200 is not set
+# CONFIG_DRM_PANEL_RONBO_RB070D30 is not set
+# CONFIG_DRM_PANEL_SAMSUNG_ATNA33XC20 is not set
+# CONFIG_DRM_PANEL_SAMSUNG_DB7430 is not set
+# CONFIG_DRM_PANEL_SAMSUNG_S6D16D0 is not set
+# CONFIG_DRM_PANEL_SAMSUNG_S6E3HA2 is not set
+# CONFIG_DRM_PANEL_SAMSUNG_S6E63J0X03 is not set
+# CONFIG_DRM_PANEL_SAMSUNG_S6E63M0 is not set
+# CONFIG_DRM_PANEL_SAMSUNG_S6E88A0_AMS452EF01 is not set
+# CONFIG_DRM_PANEL_SAMSUNG_S6E8AA0 is not set
+# CONFIG_DRM_PANEL_SAMSUNG_SOFEF00 is not set
+# CONFIG_DRM_PANEL_SEIKO_43WVF1G is not set
+# CONFIG_DRM_PANEL_SHARP_LQ101R1SX01 is not set
+# CONFIG_DRM_PANEL_SHARP_LS037V7DW01 is not set
+# CONFIG_DRM_PANEL_SHARP_LS043T1LE01 is not set
+# CONFIG_DRM_PANEL_SITRONIX_ST7701 is not set
+# CONFIG_DRM_PANEL_SITRONIX_ST7703 is not set
+# CONFIG_DRM_PANEL_SITRONIX_ST7789V is not set
+# CONFIG_DRM_PANEL_SONY_ACX424AKP is not set
+# CONFIG_DRM_PANEL_SONY_ACX565AKM is not set
+# CONFIG_DRM_PANEL_TDO_TL070WSH30 is not set
+# CONFIG_DRM_PANEL_TPO_TD028TTEC1 is not set
+# CONFIG_DRM_PANEL_TPO_TD043MTEA1 is not set
+# CONFIG_DRM_PANEL_TPO_TPG110 is not set
+# CONFIG_DRM_PANEL_TRULY_NT35597_WQXGA is not set
+# CONFIG_DRM_PANEL_VISIONOX_RM69299 is not set
+# CONFIG_DRM_PANEL_WIDECHIPS_WS2401 is not set
+# CONFIG_DRM_PANEL_XINPENG_XPP055C272 is not set
+# end of Display Panels
+
+CONFIG_DRM_BRIDGE=y
+CONFIG_DRM_PANEL_BRIDGE=y
+
+#
+# Display Interface Bridges
+#
+# CONFIG_DRM_CDNS_DSI is not set
+# CONFIG_DRM_CHIPONE_ICN6211 is not set
+# CONFIG_DRM_CHRONTEL_CH7033 is not set
+# CONFIG_DRM_DISPLAY_CONNECTOR is not set
+# CONFIG_DRM_LONTIUM_LT8912B is not set
+# CONFIG_DRM_LONTIUM_LT9611 is not set
+# CONFIG_DRM_LT9611UXC is not set
+# CONFIG_DRM_LONTIUM_LT9611UXC is not set
+# CONFIG_DRM_ITE_IT66121 is not set
+# CONFIG_DRM_LVDS_CODEC is not set
+# CONFIG_DRM_MEGACHIPS_STDPXXXX_GE_B850V3_FW is not set
+# CONFIG_DRM_NWL_MIPI_DSI is not set
+# CONFIG_DRM_NXP_PTN3460 is not set
+# CONFIG_DRM_PARADE_PS8622 is not set
+# CONFIG_DRM_PARADE_PS8640 is not set
+# CONFIG_DRM_SIL_SII8620 is not set
+# CONFIG_DRM_SII902X is not set
+# CONFIG_DRM_SII9234 is not set
+# CONFIG_DRM_SIMPLE_BRIDGE is not set
+# CONFIG_DRM_THINE_THC63LVD1024 is not set
+# CONFIG_DRM_TOSHIBA_TC358762 is not set
+# CONFIG_DRM_TOSHIBA_TC358764 is not set
+# CONFIG_DRM_TOSHIBA_TC358767 is not set
+# CONFIG_DRM_TOSHIBA_TC358768 is not set
+# CONFIG_DRM_TOSHIBA_TC358775 is not set
+# CONFIG_DRM_TI_TFP410 is not set
+# CONFIG_DRM_TI_SN65DSI83 is not set
+# CONFIG_DRM_TI_SN65DSI86 is not set
+# CONFIG_DRM_TI_TPD12S015 is not set
+# CONFIG_DRM_ANALOGIX_ANX6345 is not set
+# CONFIG_DRM_ANALOGIX_ANX78XX is not set
+# CONFIG_DRM_ANALOGIX_ANX7625 is not set
+# CONFIG_DRM_I2C_ADV7511 is not set
+# CONFIG_DRM_CDNS_MHDP8546 is not set
+# end of Display Interface Bridges
+
+# CONFIG_DRM_ETNAVIV is not set
+# CONFIG_DRM_HISI_HIBMC is not set
+# CONFIG_DRM_HISI_KIRIN is not set
+# CONFIG_DRM_ARCPGU is not set
+# CONFIG_DRM_BOCHS is not set
+# CONFIG_DRM_CIRRUS_QEMU is not set
+# CONFIG_DRM_GM12U320 is not set
+# CONFIG_DRM_SIMPLEDRM is not set
+# CONFIG_TINYDRM_HX8357D is not set
+# CONFIG_TINYDRM_ILI9225 is not set
+# CONFIG_TINYDRM_ILI9341 is not set
+# CONFIG_TINYDRM_ILI9486 is not set
+# CONFIG_TINYDRM_MI0283QT is not set
+# CONFIG_TINYDRM_REPAPER is not set
+# CONFIG_TINYDRM_ST7586 is not set
+# CONFIG_TINYDRM_ST7735R is not set
+# CONFIG_DRM_PL111 is not set
+# CONFIG_DRM_LIMA is not set
+# CONFIG_DRM_PANFROST is not set
+# CONFIG_DRM_TIDSS is not set
+# CONFIG_DRM_GUD is not set
+# CONFIG_DRM_LEGACY is not set
+CONFIG_DRM_PANEL_ORIENTATION_QUIRKS=y
+
+#
+# Frame buffer Devices
+#
+CONFIG_FB_CMDLINE=y
+CONFIG_FB_NOTIFY=y
+CONFIG_FB=y
+# CONFIG_FIRMWARE_EDID is not set
+CONFIG_FB_CFB_FILLRECT=y
+CONFIG_FB_CFB_COPYAREA=y
+CONFIG_FB_CFB_IMAGEBLIT=y
+CONFIG_FB_SYS_FILLRECT=y
+CONFIG_FB_SYS_COPYAREA=y
+CONFIG_FB_SYS_IMAGEBLIT=y
+# CONFIG_FB_FOREIGN_ENDIAN is not set
+CONFIG_FB_SYS_FOPS=y
+CONFIG_FB_DEFERRED_IO=y
+# CONFIG_FB_MODE_HELPERS is not set
+# CONFIG_FB_TILEBLITTING is not set
+
+#
+# Frame buffer hardware drivers
+#
+# CONFIG_FB_CIRRUS is not set
+# CONFIG_FB_PM2 is not set
+# CONFIG_FB_ARMCLCD is not set
+# CONFIG_FB_CYBER2000 is not set
+# CONFIG_FB_ASILIANT is not set
+# CONFIG_FB_IMSTT is not set
+# CONFIG_FB_EFI is not set
+# CONFIG_FB_OPENCORES is not set
+# CONFIG_FB_S1D13XXX is not set
+# CONFIG_FB_NVIDIA is not set
+# CONFIG_FB_RIVA is not set
+# CONFIG_FB_I740 is not set
+# CONFIG_FB_MATROX is not set
+# CONFIG_FB_RADEON is not set
+# CONFIG_FB_ATY128 is not set
+# CONFIG_FB_ATY is not set
+# CONFIG_FB_S3 is not set
+# CONFIG_FB_SAVAGE is not set
+# CONFIG_FB_SIS is not set
+# CONFIG_FB_NEOMAGIC is not set
+# CONFIG_FB_KYRO is not set
+# CONFIG_FB_3DFX is not set
+# CONFIG_FB_VOODOO1 is not set
+# CONFIG_FB_VT8623 is not set
+# CONFIG_FB_TRIDENT is not set
+# CONFIG_FB_ARK is not set
+# CONFIG_FB_PM3 is not set
+# CONFIG_FB_CARMINE is not set
+# CONFIG_FB_SMSCUFX is not set
+# CONFIG_FB_UDL is not set
+# CONFIG_FB_IBM_GXT4500 is not set
+# CONFIG_FB_VIRTUAL is not set
+# CONFIG_FB_METRONOME is not set
+# CONFIG_FB_MB862XX is not set
+# CONFIG_FB_SIMPLE is not set
+# CONFIG_FB_SSD1307 is not set
+# CONFIG_FB_SM712 is not set
+# end of Frame buffer Devices
+
+#
+# Backlight & LCD device support
+#
+# CONFIG_LCD_CLASS_DEVICE is not set
+CONFIG_BACKLIGHT_CLASS_DEVICE=y
+# CONFIG_BACKLIGHT_KTD253 is not set
+# CONFIG_BACKLIGHT_PWM is not set
+CONFIG_BACKLIGHT_QCOM_WLED=y
+# CONFIG_BACKLIGHT_ADP8860 is not set
+# CONFIG_BACKLIGHT_ADP8870 is not set
+# CONFIG_BACKLIGHT_LM3630A is not set
+# CONFIG_BACKLIGHT_LM3639 is not set
+# CONFIG_BACKLIGHT_LP855X is not set
+# CONFIG_BACKLIGHT_GPIO is not set
+# CONFIG_BACKLIGHT_LV5207LP is not set
+# CONFIG_BACKLIGHT_BD6107 is not set
+# CONFIG_BACKLIGHT_ARCXCNN is not set
+# CONFIG_BACKLIGHT_LED is not set
+# end of Backlight & LCD device support
+
+CONFIG_VIDEOMODE_HELPERS=y
+CONFIG_HDMI=y
+
+#
+# Console display driver support
+#
+CONFIG_DUMMY_CONSOLE=y
+CONFIG_DUMMY_CONSOLE_COLUMNS=80
+CONFIG_DUMMY_CONSOLE_ROWS=25
+# CONFIG_FRAMEBUFFER_CONSOLE is not set
+# end of Console display driver support
+
+CONFIG_LOGO=y
+CONFIG_LOGO_LINUX_MONO=y
+CONFIG_LOGO_LINUX_VGA16=y
+CONFIG_LOGO_LINUX_CLUT224=y
+# end of Graphics support
+
+CONFIG_SOUND=y
+CONFIG_SND=y
+CONFIG_SND_TIMER=y
+CONFIG_SND_PCM=y
+CONFIG_SND_PCM_ELD=y
+CONFIG_SND_PCM_IEC958=y
+CONFIG_SND_DMAENGINE_PCM=y
+CONFIG_SND_HWDEP=y
+CONFIG_SND_RAWMIDI=y
+CONFIG_SND_COMPRESS_OFFLOAD=y
+CONFIG_SND_JACK=y
+CONFIG_SND_JACK_INPUT_DEV=y
+# CONFIG_SND_OSSEMUL is not set
+CONFIG_SND_PCM_TIMER=y
+CONFIG_SND_HRTIMER=y
+CONFIG_SND_DYNAMIC_MINORS=y
+CONFIG_SND_MAX_CARDS=32
+# CONFIG_SND_SUPPORT_OLD_API is not set
+CONFIG_SND_PROC_FS=y
+# CONFIG_SND_VERBOSE_PROCFS is not set
+# CONFIG_SND_VERBOSE_PRINTK is not set
+CONFIG_SND_CTL_FAST_LOOKUP=y
+# CONFIG_SND_DEBUG is not set
+CONFIG_SND_VMASTER=y
+# CONFIG_SND_SEQUENCER is not set
+# CONFIG_SND_DRIVERS is not set
+CONFIG_SND_PCI=y
+# CONFIG_SND_AD1889 is not set
+# CONFIG_SND_ATIIXP is not set
+# CONFIG_SND_ATIIXP_MODEM is not set
+# CONFIG_SND_AU8810 is not set
+# CONFIG_SND_AU8820 is not set
+# CONFIG_SND_AU8830 is not set
+# CONFIG_SND_AW2 is not set
+# CONFIG_SND_BT87X is not set
+# CONFIG_SND_CA0106 is not set
+# CONFIG_SND_CMIPCI is not set
+# CONFIG_SND_OXYGEN is not set
+# CONFIG_SND_CS4281 is not set
+# CONFIG_SND_CS46XX is not set
+# CONFIG_SND_CTXFI is not set
+# CONFIG_SND_DARLA20 is not set
+# CONFIG_SND_GINA20 is not set
+# CONFIG_SND_LAYLA20 is not set
+# CONFIG_SND_DARLA24 is not set
+# CONFIG_SND_GINA24 is not set
+# CONFIG_SND_LAYLA24 is not set
+# CONFIG_SND_MONA is not set
+# CONFIG_SND_MIA is not set
+# CONFIG_SND_ECHO3G is not set
+# CONFIG_SND_INDIGO is not set
+# CONFIG_SND_INDIGOIO is not set
+# CONFIG_SND_INDIGODJ is not set
+# CONFIG_SND_INDIGOIOX is not set
+# CONFIG_SND_INDIGODJX is not set
+# CONFIG_SND_ENS1370 is not set
+# CONFIG_SND_ENS1371 is not set
+# CONFIG_SND_FM801 is not set
+# CONFIG_SND_HDSP is not set
+# CONFIG_SND_HDSPM is not set
+# CONFIG_SND_ICE1724 is not set
+# CONFIG_SND_INTEL8X0 is not set
+# CONFIG_SND_INTEL8X0M is not set
+# CONFIG_SND_KORG1212 is not set
+# CONFIG_SND_LOLA is not set
+# CONFIG_SND_LX6464ES is not set
+# CONFIG_SND_MIXART is not set
+# CONFIG_SND_NM256 is not set
+# CONFIG_SND_PCXHR is not set
+# CONFIG_SND_RIPTIDE is not set
+# CONFIG_SND_RME32 is not set
+# CONFIG_SND_RME96 is not set
+# CONFIG_SND_RME9652 is not set
+# CONFIG_SND_SE6X is not set
+# CONFIG_SND_VIA82XX is not set
+# CONFIG_SND_VIA82XX_MODEM is not set
+# CONFIG_SND_VIRTUOSO is not set
+# CONFIG_SND_VX222 is not set
+# CONFIG_SND_YMFPCI is not set
+
+#
+# HD-Audio
+#
+# CONFIG_SND_HDA_INTEL is not set
+# end of HD-Audio
+
+CONFIG_SND_HDA_PREALLOC_SIZE=64
+CONFIG_SND_SPI=y
+CONFIG_SND_USB=y
+CONFIG_SND_USB_AUDIO=y
+CONFIG_SND_USB_AUDIO_USE_MEDIA_CONTROLLER=y
+# CONFIG_SND_USB_UA101 is not set
+# CONFIG_SND_USB_CAIAQ is not set
+# CONFIG_SND_USB_6FIRE is not set
+# CONFIG_SND_USB_HIFACE is not set
+# CONFIG_SND_BCD2000 is not set
+# CONFIG_SND_USB_POD is not set
+# CONFIG_SND_USB_PODHD is not set
+# CONFIG_SND_USB_TONEPORT is not set
+# CONFIG_SND_USB_VARIAX is not set
+# CONFIG_SND_USB_AUDIO_QMI is not set
+CONFIG_SND_SOC=y
+CONFIG_SND_SOC_GENERIC_DMAENGINE_PCM=y
+CONFIG_SND_SOC_COMPRESS=y
+CONFIG_SND_SOC_TOPOLOGY=y
+# CONFIG_SND_SOC_ADI is not set
+# CONFIG_SND_SOC_AMD_ACP is not set
+# CONFIG_SND_ATMEL_SOC is not set
+# CONFIG_SND_BCM63XX_I2S_WHISTLER is not set
+# CONFIG_SND_DESIGNWARE_I2S is not set
+
+#
+# SoC Audio for Freescale CPUs
+#
+
+#
+# Common SoC Audio options for Freescale CPUs:
+#
+# CONFIG_SND_SOC_FSL_ASRC is not set
+# CONFIG_SND_SOC_FSL_SAI is not set
+# CONFIG_SND_SOC_FSL_AUDMIX is not set
+# CONFIG_SND_SOC_FSL_SSI is not set
+# CONFIG_SND_SOC_FSL_SPDIF is not set
+# CONFIG_SND_SOC_FSL_ESAI is not set
+# CONFIG_SND_SOC_FSL_MICFIL is not set
+# CONFIG_SND_SOC_FSL_XCVR is not set
+# CONFIG_SND_SOC_FSL_RPMSG is not set
+# CONFIG_SND_SOC_IMX_AUDMUX is not set
+# end of SoC Audio for Freescale CPUs
+
+# CONFIG_SND_I2S_HI6210_I2S is not set
+# CONFIG_SND_SOC_IMG is not set
+# CONFIG_SND_SOC_MTK_BTCVSD is not set
+# CONFIG_SND_SOC_QCOM is not set
+# CONFIG_SND_SOC_SOF_TOPLEVEL is not set
+
+#
+# STMicroelectronics STM32 SOC audio support
+#
+# end of STMicroelectronics STM32 SOC audio support
+
+# CONFIG_SND_SOC_XILINX_I2S is not set
+# CONFIG_SND_SOC_XILINX_AUDIO_FORMATTER is not set
+# CONFIG_SND_SOC_XILINX_SPDIF is not set
+# CONFIG_SND_SOC_XTFPGA_I2S is not set
+CONFIG_SND_SOC_I2C_AND_SPI=y
+
+#
+# CODEC drivers
+#
+# CONFIG_SND_SOC_AC97_CODEC is not set
+# CONFIG_SND_SOC_ADAU1372_I2C is not set
+# CONFIG_SND_SOC_ADAU1372_SPI is not set
+# CONFIG_SND_SOC_ADAU1701 is not set
+# CONFIG_SND_SOC_ADAU1761_I2C is not set
+# CONFIG_SND_SOC_ADAU1761_SPI is not set
+# CONFIG_SND_SOC_ADAU7002 is not set
+# CONFIG_SND_SOC_ADAU7118_HW is not set
+# CONFIG_SND_SOC_ADAU7118_I2C is not set
+# CONFIG_SND_SOC_AK4104 is not set
+# CONFIG_SND_SOC_AK4118 is not set
+# CONFIG_SND_SOC_AK4458 is not set
+# CONFIG_SND_SOC_AK4554 is not set
+# CONFIG_SND_SOC_AK4613 is not set
+# CONFIG_SND_SOC_AK4642 is not set
+# CONFIG_SND_SOC_AK5386 is not set
+# CONFIG_SND_SOC_AK5558 is not set
+# CONFIG_SND_SOC_ALC5623 is not set
+# CONFIG_SND_SOC_BD28623 is not set
+# CONFIG_SND_SOC_BT_SCO is not set
+# CONFIG_SND_SOC_CS35L32 is not set
+# CONFIG_SND_SOC_CS35L33 is not set
+# CONFIG_SND_SOC_CS35L34 is not set
+# CONFIG_SND_SOC_CS35L35 is not set
+# CONFIG_SND_SOC_CS35L36 is not set
+# CONFIG_SND_SOC_CS42L42 is not set
+# CONFIG_SND_SOC_CS42L51_I2C is not set
+# CONFIG_SND_SOC_CS42L52 is not set
+# CONFIG_SND_SOC_CS42L56 is not set
+# CONFIG_SND_SOC_CS42L73 is not set
+# CONFIG_SND_SOC_CS4234 is not set
+# CONFIG_SND_SOC_CS4265 is not set
+# CONFIG_SND_SOC_CS4270 is not set
+# CONFIG_SND_SOC_CS4271_I2C is not set
+# CONFIG_SND_SOC_CS4271_SPI is not set
+# CONFIG_SND_SOC_CS42XX8_I2C is not set
+# CONFIG_SND_SOC_CS43130 is not set
+# CONFIG_SND_SOC_CS4341 is not set
+# CONFIG_SND_SOC_CS4349 is not set
+# CONFIG_SND_SOC_CS53L30 is not set
+# CONFIG_SND_SOC_CX2072X is not set
+# CONFIG_SND_SOC_DA7213 is not set
+# CONFIG_SND_SOC_DMIC is not set
+CONFIG_SND_SOC_HDMI_CODEC=y
+# CONFIG_SND_SOC_ES7134 is not set
+# CONFIG_SND_SOC_ES7241 is not set
+# CONFIG_SND_SOC_ES8316 is not set
+# CONFIG_SND_SOC_ES8328_I2C is not set
+# CONFIG_SND_SOC_ES8328_SPI is not set
+# CONFIG_SND_SOC_GTM601 is not set
+# CONFIG_SND_SOC_ICS43432 is not set
+# CONFIG_SND_SOC_INNO_RK3036 is not set
+# CONFIG_SND_SOC_MAX98088 is not set
+# CONFIG_SND_SOC_MAX98357A is not set
+# CONFIG_SND_SOC_MAX98504 is not set
+# CONFIG_SND_SOC_MAX9867 is not set
+# CONFIG_SND_SOC_MAX98927 is not set
+# CONFIG_SND_SOC_MAX98373_I2C is not set
+# CONFIG_SND_SOC_MAX98390 is not set
+# CONFIG_SND_SOC_MAX9860 is not set
+# CONFIG_SND_SOC_MSM8916_WCD_ANALOG is not set
+# CONFIG_SND_SOC_MSM8916_WCD_DIGITAL is not set
+# CONFIG_SND_SOC_PCM1681 is not set
+# CONFIG_SND_SOC_PCM1789_I2C is not set
+# CONFIG_SND_SOC_PCM179X_I2C is not set
+# CONFIG_SND_SOC_PCM179X_SPI is not set
+# CONFIG_SND_SOC_PCM186X_I2C is not set
+# CONFIG_SND_SOC_PCM186X_SPI is not set
+# CONFIG_SND_SOC_PCM3060_I2C is not set
+# CONFIG_SND_SOC_PCM3060_SPI is not set
+# CONFIG_SND_SOC_PCM3168A_I2C is not set
+# CONFIG_SND_SOC_PCM3168A_SPI is not set
+# CONFIG_SND_SOC_PCM5102A is not set
+# CONFIG_SND_SOC_PCM512x_I2C is not set
+# CONFIG_SND_SOC_PCM512x_SPI is not set
+# CONFIG_SND_SOC_RK3328 is not set
+# CONFIG_SND_SOC_RT5616 is not set
+# CONFIG_SND_SOC_RT5631 is not set
+# CONFIG_SND_SOC_RT5640 is not set
+# CONFIG_SND_SOC_RT5659 is not set
+# CONFIG_SND_SOC_SGTL5000 is not set
+# CONFIG_SND_SOC_SIMPLE_AMPLIFIER is not set
+# CONFIG_SND_SOC_SIMPLE_MUX is not set
+# CONFIG_SND_SOC_SPDIF is not set
+# CONFIG_SND_SOC_SSM2305 is not set
+# CONFIG_SND_SOC_SSM2518 is not set
+# CONFIG_SND_SOC_SSM2602_SPI is not set
+# CONFIG_SND_SOC_SSM2602_I2C is not set
+# CONFIG_SND_SOC_SSM4567 is not set
+# CONFIG_SND_SOC_STA32X is not set
+# CONFIG_SND_SOC_STA350 is not set
+# CONFIG_SND_SOC_STI_SAS is not set
+# CONFIG_SND_SOC_TAS2552 is not set
+# CONFIG_SND_SOC_TAS2562 is not set
+# CONFIG_SND_SOC_TAS2764 is not set
+# CONFIG_SND_SOC_TAS2770 is not set
+# CONFIG_SND_SOC_TAS5086 is not set
+# CONFIG_SND_SOC_TAS571X is not set
+# CONFIG_SND_SOC_TAS5720 is not set
+# CONFIG_SND_SOC_TAS6424 is not set
+# CONFIG_SND_SOC_TDA7419 is not set
+# CONFIG_SND_SOC_TFA9879 is not set
+# CONFIG_SND_SOC_TFA989X is not set
+# CONFIG_SND_SOC_TLV320AIC23_I2C is not set
+# CONFIG_SND_SOC_TLV320AIC23_SPI is not set
+# CONFIG_SND_SOC_TLV320AIC31XX is not set
+# CONFIG_SND_SOC_TLV320AIC32X4_I2C is not set
+# CONFIG_SND_SOC_TLV320AIC32X4_SPI is not set
+# CONFIG_SND_SOC_TLV320AIC3X_I2C is not set
+# CONFIG_SND_SOC_TLV320AIC3X_SPI is not set
+# CONFIG_SND_SOC_TLV320ADCX140 is not set
+# CONFIG_SND_SOC_TS3A227E is not set
+# CONFIG_SND_SOC_TSCS42XX is not set
+# CONFIG_SND_SOC_TSCS454 is not set
+# CONFIG_SND_SOC_UDA1334 is not set
+# CONFIG_SND_SOC_WM8510 is not set
+# CONFIG_SND_SOC_WM8523 is not set
+# CONFIG_SND_SOC_WM8524 is not set
+# CONFIG_SND_SOC_WM8580 is not set
+# CONFIG_SND_SOC_WM8711 is not set
+# CONFIG_SND_SOC_WM8728 is not set
+# CONFIG_SND_SOC_WM8731 is not set
+# CONFIG_SND_SOC_WM8737 is not set
+# CONFIG_SND_SOC_WM8741 is not set
+# CONFIG_SND_SOC_WM8750 is not set
+# CONFIG_SND_SOC_WM8753 is not set
+# CONFIG_SND_SOC_WM8770 is not set
+# CONFIG_SND_SOC_WM8776 is not set
+# CONFIG_SND_SOC_WM8782 is not set
+# CONFIG_SND_SOC_WM8804_I2C is not set
+# CONFIG_SND_SOC_WM8804_SPI is not set
+# CONFIG_SND_SOC_WM8903 is not set
+# CONFIG_SND_SOC_WM8904 is not set
+# CONFIG_SND_SOC_WM8960 is not set
+# CONFIG_SND_SOC_WM8962 is not set
+# CONFIG_SND_SOC_WM8974 is not set
+# CONFIG_SND_SOC_WM8978 is not set
+# CONFIG_SND_SOC_WM8985 is not set
+# CONFIG_SND_SOC_ZL38060 is not set
+# CONFIG_SND_SOC_MAX9759 is not set
+# CONFIG_SND_SOC_MT6351 is not set
+# CONFIG_SND_SOC_MT6358 is not set
+# CONFIG_SND_SOC_MT6660 is not set
+# CONFIG_SND_SOC_NAU8315 is not set
+# CONFIG_SND_SOC_NAU8540 is not set
+# CONFIG_SND_SOC_NAU8810 is not set
+# CONFIG_SND_SOC_NAU8822 is not set
+# CONFIG_SND_SOC_NAU8824 is not set
+# CONFIG_SND_SOC_TPA6130A2 is not set
+# CONFIG_SND_SOC_LPASS_WSA_MACRO is not set
+# CONFIG_SND_SOC_LPASS_VA_MACRO is not set
+# CONFIG_SND_SOC_LPASS_RX_MACRO is not set
+# CONFIG_SND_SOC_LPASS_TX_MACRO is not set
+# CONFIG_SND_SOC_TAS5805M is not set
+# end of CODEC drivers
+
+# CONFIG_SND_SIMPLE_CARD is not set
+# CONFIG_SND_AUDIO_GRAPH_CARD is not set
+# CONFIG_SND_VIRTIO is not set
+
+#
+# HID support
+#
+CONFIG_HID=y
+CONFIG_HID_BATTERY_STRENGTH=y
+CONFIG_HIDRAW=y
+CONFIG_UHID=y
+CONFIG_HID_GENERIC=y
+
+#
+# Special HID drivers
+#
+# CONFIG_HID_A4TECH is not set
+# CONFIG_HID_ACCUTOUCH is not set
+# CONFIG_HID_ACRUX is not set
+CONFIG_HID_APPLE=y
+# CONFIG_HID_APPLEIR is not set
+# CONFIG_HID_ASUS is not set
+# CONFIG_HID_AUREAL is not set
+# CONFIG_HID_BELKIN is not set
+# CONFIG_HID_BETOP_FF is not set
+# CONFIG_HID_BIGBEN_FF is not set
+# CONFIG_HID_CHERRY is not set
+# CONFIG_HID_CHICONY is not set
+# CONFIG_HID_CORSAIR is not set
+# CONFIG_HID_COUGAR is not set
+# CONFIG_HID_MACALLY is not set
+CONFIG_HID_PRODIKEYS=y
+# CONFIG_HID_CMEDIA is not set
+# CONFIG_HID_CP2112 is not set
+# CONFIG_HID_CREATIVE_SB0540 is not set
+# CONFIG_HID_CYPRESS is not set
+# CONFIG_HID_DRAGONRISE is not set
+# CONFIG_HID_EMS_FF is not set
+# CONFIG_HID_ELAN is not set
+CONFIG_HID_ELECOM=y
+# CONFIG_HID_ELO is not set
+# CONFIG_HID_EZKEY is not set
+# CONFIG_HID_FT260 is not set
+# CONFIG_HID_GEMBIRD is not set
+# CONFIG_HID_GFRM is not set
+# CONFIG_HID_GLORIOUS is not set
+# CONFIG_HID_HOLTEK is not set
+# CONFIG_HID_VIVALDI is not set
+# CONFIG_HID_GT683R is not set
+# CONFIG_HID_KEYTOUCH is not set
+# CONFIG_HID_KYE is not set
+CONFIG_HID_UCLOGIC=y
+# CONFIG_HID_WALTOP is not set
+# CONFIG_HID_VIEWSONIC is not set
+# CONFIG_HID_GYRATION is not set
+# CONFIG_HID_ICADE is not set
+# CONFIG_HID_ITE is not set
+# CONFIG_HID_JABRA is not set
+# CONFIG_HID_TWINHAN is not set
+# CONFIG_HID_KENSINGTON is not set
+# CONFIG_HID_LCPOWER is not set
+# CONFIG_HID_LED is not set
+# CONFIG_HID_LENOVO is not set
+CONFIG_HID_LOGITECH=y
+CONFIG_HID_LOGITECH_DJ=y
+CONFIG_HID_LOGITECH_HIDPP=y
+# CONFIG_LOGITECH_FF is not set
+# CONFIG_LOGIRUMBLEPAD2_FF is not set
+# CONFIG_LOGIG940_FF is not set
+# CONFIG_LOGIWHEELS_FF is not set
+CONFIG_HID_MAGICMOUSE=y
+# CONFIG_HID_MALTRON is not set
+# CONFIG_HID_MAYFLASH is not set
+# CONFIG_HID_REDRAGON is not set
+CONFIG_HID_MICROSOFT=y
+# CONFIG_HID_MONTEREY is not set
+CONFIG_HID_MULTITOUCH=y
+CONFIG_HID_NINTENDO=y
+# CONFIG_HID_NTI is not set
+# CONFIG_HID_NTRIG is not set
+# CONFIG_HID_ORTEK is not set
+# CONFIG_HID_PANTHERLORD is not set
+# CONFIG_HID_PENMOUNT is not set
+# CONFIG_HID_PETALYNX is not set
+CONFIG_HID_PICOLCD=y
+# CONFIG_HID_PICOLCD_FB is not set
+# CONFIG_HID_PICOLCD_BACKLIGHT is not set
+# CONFIG_HID_PICOLCD_LEDS is not set
+# CONFIG_HID_PICOLCD_CIR is not set
+CONFIG_HID_PLANTRONICS=y
+CONFIG_HID_PLAYSTATION=y
+CONFIG_PLAYSTATION_FF=y
+# CONFIG_HID_PRIMAX is not set
+# CONFIG_HID_RETRODE is not set
+CONFIG_HID_ROCCAT=y
+# CONFIG_HID_SAITEK is not set
+# CONFIG_HID_SAMSUNG is not set
+# CONFIG_HID_SEMITEK is not set
+CONFIG_HID_SONY=y
+CONFIG_SONY_FF=y
+# CONFIG_HID_SPEEDLINK is not set
+CONFIG_HID_STEAM=y
+# CONFIG_HID_STEELSERIES is not set
+# CONFIG_HID_SUNPLUS is not set
+# CONFIG_HID_RMI is not set
+# CONFIG_HID_GREENASIA is not set
+# CONFIG_HID_SMARTJOYPLUS is not set
+# CONFIG_HID_TIVO is not set
+# CONFIG_HID_TOPSEED is not set
+# CONFIG_HID_THINGM is not set
+# CONFIG_HID_THRUSTMASTER is not set
+# CONFIG_HID_UDRAW_PS3 is not set
+# CONFIG_HID_U2FZERO is not set
+CONFIG_HID_WACOM=y
+CONFIG_HID_WIIMOTE=y
+# CONFIG_HID_XINMO is not set
+# CONFIG_HID_ZEROPLUS is not set
+# CONFIG_HID_ZYDACRON is not set
+# CONFIG_HID_SENSOR_HUB is not set
+# CONFIG_HID_ALPS is not set
+# CONFIG_HID_MCP2221 is not set
+# end of Special HID drivers
+
+#
+# USB HID support
+#
+CONFIG_USB_HID=y
+# CONFIG_HID_PID is not set
+CONFIG_USB_HIDDEV=y
+# end of USB HID support
+
+#
+# I2C HID support
+#
+# CONFIG_I2C_HID_OF is not set
+# CONFIG_I2C_HID_OF_GOODIX is not set
+# end of I2C HID support
+# end of HID support
+
+CONFIG_USB_OHCI_LITTLE_ENDIAN=y
+CONFIG_USB_SUPPORT=y
+CONFIG_USB_COMMON=y
+# CONFIG_USB_LED_TRIG is not set
+# CONFIG_USB_ULPI_BUS is not set
+# CONFIG_USB_CONN_GPIO is not set
+CONFIG_USB_ARCH_HAS_HCD=y
+CONFIG_USB=y
+CONFIG_USB_PCI=y
+CONFIG_USB_ANNOUNCE_NEW_DEVICES=y
+
+#
+# Miscellaneous USB options
+#
+CONFIG_USB_DEFAULT_PERSIST=y
+# CONFIG_USB_FEW_INIT_RETRIES is not set
+# CONFIG_USB_DYNAMIC_MINORS is not set
+CONFIG_USB_OTG=y
+# CONFIG_USB_OTG_PRODUCTLIST is not set
+# CONFIG_USB_OTG_DISABLE_EXTERNAL_HUB is not set
+# CONFIG_USB_OTG_FSM is not set
+# CONFIG_USB_LEDS_TRIGGER_USBPORT is not set
+CONFIG_USB_AUTOSUSPEND_DELAY=2
+# CONFIG_USB_MON is not set
+
+#
+# USB Host Controller Drivers
+#
+# CONFIG_USB_C67X00_HCD is not set
+CONFIG_USB_XHCI_HCD=y
+# CONFIG_USB_XHCI_DBGCAP is not set
+CONFIG_USB_XHCI_PCI=y
+# CONFIG_USB_XHCI_PCI_RENESAS is not set
+CONFIG_USB_XHCI_PLATFORM=y
+CONFIG_USB_EHCI_HCD=y
+CONFIG_USB_EHCI_ROOT_HUB_TT=y
+CONFIG_USB_EHCI_TT_NEWSCHED=y
+CONFIG_USB_EHCI_PCI=y
+# CONFIG_USB_EHCI_FSL is not set
+CONFIG_USB_EHCI_HCD_PLATFORM=y
+# CONFIG_USB_OXU210HP_HCD is not set
+# CONFIG_USB_ISP116X_HCD is not set
+# CONFIG_USB_FOTG210_HCD is not set
+# CONFIG_USB_MAX3421_HCD is not set
+# CONFIG_USB_OHCI_HCD is not set
+# CONFIG_USB_UHCI_HCD is not set
+# CONFIG_USB_SL811_HCD is not set
+# CONFIG_USB_R8A66597_HCD is not set
+# CONFIG_USB_HCD_TEST_MODE is not set
+
+#
+# USB Device Class drivers
+#
+CONFIG_USB_ACM=y
+# CONFIG_USB_PRINTER is not set
+# CONFIG_USB_WDM is not set
+# CONFIG_USB_TMC is not set
+
+#
+# NOTE: USB_STORAGE depends on SCSI but BLK_DEV_SD may
+#
+
+#
+# also be needed; see USB_STORAGE Help for more info
+#
+CONFIG_USB_STORAGE=y
+# CONFIG_USB_STORAGE_DEBUG is not set
+# CONFIG_USB_STORAGE_REALTEK is not set
+# CONFIG_USB_STORAGE_DATAFAB is not set
+# CONFIG_USB_STORAGE_FREECOM is not set
+# CONFIG_USB_STORAGE_ISD200 is not set
+# CONFIG_USB_STORAGE_USBAT is not set
+# CONFIG_USB_STORAGE_SDDR09 is not set
+# CONFIG_USB_STORAGE_SDDR55 is not set
+# CONFIG_USB_STORAGE_JUMPSHOT is not set
+# CONFIG_USB_STORAGE_ALAUDA is not set
+# CONFIG_USB_STORAGE_ONETOUCH is not set
+# CONFIG_USB_STORAGE_KARMA is not set
+# CONFIG_USB_STORAGE_CYPRESS_ATACB is not set
+# CONFIG_USB_STORAGE_ENE_UB6250 is not set
+CONFIG_USB_UAS=y
+
+#
+# USB Imaging devices
+#
+# CONFIG_USB_MDC800 is not set
+# CONFIG_USB_MICROTEK is not set
+# CONFIG_USBIP_CORE is not set
+# CONFIG_USB_CDNS_SUPPORT is not set
+# CONFIG_USB_MUSB_HDRC is not set
+CONFIG_USB_DWC3=y
+# CONFIG_USB_DWC3_HOST is not set
+CONFIG_USB_DWC3_GADGET=y
+# CONFIG_USB_DWC3_DUAL_ROLE is not set
+
+#
+# Platform Glue Driver Support
+#
+CONFIG_USB_DWC3_HAPS=y
+CONFIG_USB_DWC3_OF_SIMPLE=y
+CONFIG_USB_DWC3_QCOM=y
+CONFIG_USB_DWC3_MSM=y
+# CONFIG_USB_DWC2 is not set
+# CONFIG_USB_CHIPIDEA is not set
+# CONFIG_USB_ISP1760 is not set
+
+#
+# USB port drivers
+#
+# CONFIG_USB_SERIAL is not set
+
+#
+# USB Miscellaneous drivers
+#
+# CONFIG_USB_EMI62 is not set
+# CONFIG_USB_EMI26 is not set
+# CONFIG_USB_ADUTUX is not set
+# CONFIG_USB_SEVSEG is not set
+# CONFIG_USB_LEGOTOWER is not set
+# CONFIG_USB_LCD is not set
+# CONFIG_USB_CYPRESS_CY7C63 is not set
+# CONFIG_USB_CYTHERM is not set
+# CONFIG_USB_IDMOUSE is not set
+# CONFIG_USB_FTDI_ELAN is not set
+# CONFIG_USB_APPLEDISPLAY is not set
+# CONFIG_APPLE_MFI_FASTCHARGE is not set
+# CONFIG_USB_SISUSBVGA is not set
+# CONFIG_USB_LD is not set
+# CONFIG_USB_TRANCEVIBRATOR is not set
+# CONFIG_USB_IOWARRIOR is not set
+# CONFIG_USB_TEST is not set
+# CONFIG_USB_EHSET_TEST_FIXTURE is not set
+# CONFIG_USB_ISIGHTFW is not set
+# CONFIG_USB_YUREX is not set
+# CONFIG_USB_EZUSB_FX2 is not set
+# CONFIG_USB_HUB_USB251XB is not set
+# CONFIG_USB_HSIC_USB3503 is not set
+# CONFIG_USB_HSIC_USB4604 is not set
+# CONFIG_USB_LINK_LAYER_TEST is not set
+# CONFIG_USB_CHAOSKEY is not set
+
+#
+# USB Physical Layer drivers
+#
+CONFIG_USB_PHY=y
+CONFIG_NOP_USB_XCEIV=y
+CONFIG_USB_GPIO_VBUS=y
+# CONFIG_USB_ISP1301 is not set
+# CONFIG_USB_ULPI is not set
+CONFIG_USB_QCOM_EMU_PHY=y
+CONFIG_USB_MSM_SSPHY_QMP=y
+CONFIG_MSM_HSUSB_PHY=y
+CONFIG_MSM_QUSB_PHY=y
+CONFIG_USB_MSM_EUSB2_PHY=y
+CONFIG_USB_M31_MSM_EUSB2_PHY=y
+# end of USB Physical Layer drivers
+
+#
+# USB Power Delivery
+#
+# CONFIG_USB_PD_POLICY is not set
+# CONFIG_QPNP_USB_PDPHY is not set
+# end of USB Power Delivery
+
+CONFIG_USB_GADGET=y
+# CONFIG_USB_GADGET_DEBUG is not set
+# CONFIG_USB_GADGET_DEBUG_FILES is not set
+# CONFIG_USB_GADGET_DEBUG_FS is not set
+CONFIG_USB_GADGET_VBUS_DRAW=2
+CONFIG_USB_GADGET_STORAGE_NUM_BUFFERS=2
+CONFIG_U_SERIAL_CONSOLE=y
+
+#
+# USB Peripheral Controller
+#
+# CONFIG_USB_FOTG210_UDC is not set
+# CONFIG_USB_GR_UDC is not set
+# CONFIG_USB_R8A66597 is not set
+# CONFIG_USB_PXA27X is not set
+# CONFIG_USB_MV_UDC is not set
+# CONFIG_USB_MV_U3D is not set
+# CONFIG_USB_SNP_UDC_PLAT is not set
+# CONFIG_USB_M66592 is not set
+# CONFIG_USB_BDC_UDC is not set
+# CONFIG_USB_AMD5536UDC is not set
+# CONFIG_USB_NET2272 is not set
+# CONFIG_USB_NET2280 is not set
+# CONFIG_USB_GOKU is not set
+# CONFIG_USB_EG20T is not set
+# CONFIG_USB_GADGET_XILINX is not set
+# CONFIG_USB_MAX3420_UDC is not set
+# CONFIG_USB_DUMMY_HCD is not set
+# end of USB Peripheral Controller
+
+CONFIG_USB_LIBCOMPOSITE=y
+CONFIG_USB_F_ACM=y
+CONFIG_USB_U_SERIAL=y
+CONFIG_USB_U_ETHER=y
+CONFIG_USB_U_AUDIO=y
+CONFIG_USB_F_SERIAL=y
+CONFIG_USB_F_NCM=y
+CONFIG_USB_F_ECM=y
+CONFIG_USB_F_EEM=y
+CONFIG_USB_F_MASS_STORAGE=y
+CONFIG_USB_F_FS=y
+CONFIG_USB_F_UAC2=y
+CONFIG_USB_F_UVC=y
+CONFIG_USB_F_MIDI=y
+CONFIG_USB_F_HID=y
+CONFIG_USB_F_ACC=y
+CONFIG_USB_F_AUDIO_SRC=y
+CONFIG_USB_CONFIGFS=y
+CONFIG_USB_CONFIGFS_UEVENT=y
+CONFIG_USB_CONFIGFS_SERIAL=y
+CONFIG_USB_CONFIGFS_ACM=y
+# CONFIG_USB_CONFIGFS_OBEX is not set
+CONFIG_USB_CONFIGFS_NCM=y
+CONFIG_USB_CONFIGFS_ECM=y
+# CONFIG_USB_CONFIGFS_ECM_SUBSET is not set
+# CONFIG_USB_CONFIGFS_RNDIS is not set
+CONFIG_USB_CONFIGFS_EEM=y
+CONFIG_USB_CONFIGFS_MASS_STORAGE=y
+# CONFIG_USB_CONFIGFS_F_LB_SS is not set
+CONFIG_USB_CONFIGFS_F_FS=y
+CONFIG_USB_CONFIGFS_F_ACC=y
+CONFIG_USB_CONFIGFS_F_AUDIO_SRC=y
+# CONFIG_USB_CONFIGFS_F_UAC1 is not set
+# CONFIG_USB_CONFIGFS_F_UAC1_LEGACY is not set
+CONFIG_USB_CONFIGFS_F_UAC2=y
+CONFIG_USB_CONFIGFS_F_MIDI=y
+CONFIG_USB_CONFIGFS_F_HID=y
+CONFIG_USB_CONFIGFS_F_UVC=y
+# CONFIG_USB_CONFIGFS_F_PRINTER is not set
+# CONFIG_USB_CONFIGFS_F_CDEV is not set
+# CONFIG_USB_CONFIGFS_F_CCID is not set
+# CONFIG_USB_CONFIGFS_F_QDSS is not set
+# CONFIG_USB_CONFIGFS_F_GSI is not set
+# CONFIG_USB_CONFIGFS_F_DIAG is not set
+
+#
+# USB Gadget precomposed configurations
+#
+# CONFIG_USB_ZERO is not set
+# CONFIG_USB_AUDIO is not set
+# CONFIG_USB_ETH is not set
+# CONFIG_USB_G_NCM is not set
+# CONFIG_USB_GADGETFS is not set
+# CONFIG_USB_FUNCTIONFS is not set
+# CONFIG_USB_MASS_STORAGE is not set
+# CONFIG_USB_G_SERIAL is not set
+# CONFIG_USB_MIDI_GADGET is not set
+# CONFIG_USB_G_PRINTER is not set
+# CONFIG_USB_CDC_COMPOSITE is not set
+# CONFIG_USB_G_ACM_MS is not set
+# CONFIG_USB_G_MULTI is not set
+# CONFIG_USB_G_HID is not set
+# CONFIG_USB_G_DBGP is not set
+# CONFIG_USB_G_WEBCAM is not set
+# CONFIG_USB_RAW_GADGET is not set
+# end of USB Gadget precomposed configurations
+
+CONFIG_TYPEC=y
+CONFIG_TYPEC_TCPM=y
+CONFIG_TYPEC_TCPCI=y
+# CONFIG_TYPEC_RT1711H is not set
+# CONFIG_TYPEC_TCPCI_MAXIM is not set
+# CONFIG_TYPEC_FUSB302 is not set
+CONFIG_TYPEC_UCSI=y
+# CONFIG_UCSI_CCG is not set
+# CONFIG_UCSI_QTI_GLINK is not set
+# CONFIG_TYPEC_TPS6598X is not set
+# CONFIG_TYPEC_HD3SS3220 is not set
+# CONFIG_TYPEC_STUSB160X is not set
+CONFIG_TYPEC_QCOM_PMIC=y
+
+#
+# USB Type-C Multiplexer/DeMultiplexer Switch support
+#
+# CONFIG_TYPEC_MUX_PI3USB30532 is not set
+# end of USB Type-C Multiplexer/DeMultiplexer Switch support
+
+#
+# USB Type-C Alternate Mode drivers
+#
+# CONFIG_TYPEC_DP_ALTMODE is not set
+# end of USB Type-C Alternate Mode drivers
+
+CONFIG_USB_ROLE_SWITCH=y
+
+#
+# USB eUSB2 repeater drivers
+#
+# CONFIG_USB_REPEATER is not set
+# end of USB eUSB2 repeater drivers
+
+# CONFIG_USB_REDRIVER is not set
+CONFIG_MMC=y
+# CONFIG_PWRSEQ_EMMC is not set
+# CONFIG_PWRSEQ_SIMPLE is not set
+CONFIG_MMC_BLOCK=y
+CONFIG_MMC_BLOCK_MINORS=8
+# CONFIG_SDIO_UART is not set
+# CONFIG_MMC_TEST is not set
+CONFIG_MMC_CRYPTO=y
+
+#
+# MMC/SD/SDIO Host Controller Drivers
+#
+# CONFIG_MMC_DEBUG is not set
+# CONFIG_MMC_ARMMMCI is not set
+CONFIG_MMC_SDHCI=y
+CONFIG_MMC_SDHCI_IO_ACCESSORS=y
+# CONFIG_MMC_SDHCI_PCI is not set
+CONFIG_MMC_SDHCI_PLTFM=y
+# CONFIG_MMC_SDHCI_OF_ARASAN is not set
+# CONFIG_MMC_SDHCI_OF_ASPEED is not set
+# CONFIG_MMC_SDHCI_OF_AT91 is not set
+# CONFIG_MMC_SDHCI_OF_DWCMSHC is not set
+# CONFIG_MMC_SDHCI_CADENCE is not set
+# CONFIG_MMC_SDHCI_F_SDH30 is not set
+# CONFIG_MMC_SDHCI_MILBEAUT is not set
+# CONFIG_MMC_SDHCI_MSM is not set
+# CONFIG_MMC_TIFM_SD is not set
+# CONFIG_MMC_SPI is not set
+# CONFIG_MMC_CB710 is not set
+# CONFIG_MMC_VIA_SDMMC is not set
+# CONFIG_MMC_DW is not set
+# CONFIG_MMC_VUB300 is not set
+# CONFIG_MMC_USHC is not set
+# CONFIG_MMC_USDHI6ROL0 is not set
+CONFIG_MMC_CQHCI=y
+# CONFIG_MMC_HSQ is not set
+# CONFIG_MMC_TOSHIBA_PCI is not set
+# CONFIG_MMC_MTK is not set
+# CONFIG_MMC_SDHCI_XENON is not set
+# CONFIG_MMC_SDHCI_OMAP is not set
+# CONFIG_MMC_SDHCI_AM654 is not set
+# CONFIG_MMC_CRYPTO_QTI is not set
+# CONFIG_MEMSTICK is not set
+CONFIG_NEW_LEDS=y
+CONFIG_LEDS_CLASS=y
+CONFIG_LEDS_CLASS_FLASH=y
+CONFIG_LEDS_CLASS_MULTICOLOR=y
+# CONFIG_LEDS_BRIGHTNESS_HW_CHANGED is not set
+
+#
+# LED drivers
+#
+# CONFIG_LEDS_AN30259A is not set
+# CONFIG_LEDS_AW2013 is not set
+# CONFIG_LEDS_AW2016 is not set
+# CONFIG_LEDS_BCM6328 is not set
+# CONFIG_LEDS_BCM6358 is not set
+# CONFIG_LEDS_CR0014114 is not set
+# CONFIG_LEDS_EL15203000 is not set
+# CONFIG_LEDS_LM3530 is not set
+# CONFIG_LEDS_LM3532 is not set
+# CONFIG_LEDS_LM3642 is not set
+# CONFIG_LEDS_LM3692X is not set
+# CONFIG_LEDS_QTI_FLASH is not set
+# CONFIG_LEDS_QPNP_FLASH_V2 is not set
+# CONFIG_LEDS_PCA9532 is not set
+# CONFIG_LEDS_GPIO is not set
+# CONFIG_LEDS_LP3944 is not set
+# CONFIG_LEDS_LP3952 is not set
+# CONFIG_LEDS_LP50XX is not set
+# CONFIG_LEDS_LP55XX_COMMON is not set
+# CONFIG_LEDS_LP8860 is not set
+# CONFIG_LEDS_PCA955X is not set
+# CONFIG_LEDS_PCA963X is not set
+# CONFIG_LEDS_DAC124S085 is not set
+# CONFIG_LEDS_PWM is not set
+# CONFIG_LEDS_REGULATOR is not set
+# CONFIG_LEDS_BD2802 is not set
+# CONFIG_LEDS_LT3593 is not set
+# CONFIG_LEDS_TCA6507 is not set
+# CONFIG_LEDS_TLC591XX is not set
+# CONFIG_LEDS_LM355x is not set
+# CONFIG_LEDS_IS31FL319X is not set
+# CONFIG_LEDS_IS31FL32XX is not set
+
+#
+# LED driver for blink(1) USB RGB LED is under Special HID drivers (HID_THINGM)
+#
+# CONFIG_LEDS_BLINKM is not set
+# CONFIG_LEDS_SYSCON is not set
+# CONFIG_LEDS_MLXREG is not set
+# CONFIG_LEDS_USER is not set
+# CONFIG_LEDS_SPI_BYTE is not set
+# CONFIG_LEDS_TI_LMU_COMMON is not set
+# CONFIG_LEDS_QTI_TRI_LED is not set
+# CONFIG_LEDS_QPNP_VIBRATOR_LDO is not set
+
+#
+# Flash and Torch LED drivers
+#
+# CONFIG_LEDS_AAT1290 is not set
+# CONFIG_LEDS_AS3645A is not set
+# CONFIG_LEDS_KTD2692 is not set
+# CONFIG_LEDS_LM3601X is not set
+# CONFIG_LEDS_RT4505 is not set
+# CONFIG_LEDS_RT8515 is not set
+# CONFIG_LEDS_SGM3140 is not set
+
+#
+# LED Triggers
+#
+CONFIG_LEDS_TRIGGERS=y
+CONFIG_LEDS_TRIGGER_TIMER=y
+# CONFIG_LEDS_TRIGGER_ONESHOT is not set
+# CONFIG_LEDS_TRIGGER_HEARTBEAT is not set
+# CONFIG_LEDS_TRIGGER_BACKLIGHT is not set
+# CONFIG_LEDS_TRIGGER_CPU is not set
+# CONFIG_LEDS_TRIGGER_ACTIVITY is not set
+# CONFIG_LEDS_TRIGGER_GPIO is not set
+# CONFIG_LEDS_TRIGGER_DEFAULT_ON is not set
+
+#
+# iptables trigger is under Netfilter config (LED target)
+#
+CONFIG_LEDS_TRIGGER_TRANSIENT=y
+# CONFIG_LEDS_TRIGGER_CAMERA is not set
+# CONFIG_LEDS_TRIGGER_PANIC is not set
+# CONFIG_LEDS_TRIGGER_NETDEV is not set
+# CONFIG_LEDS_TRIGGER_PATTERN is not set
+# CONFIG_LEDS_TRIGGER_AUDIO is not set
+# CONFIG_LEDS_TRIGGER_TTY is not set
+# CONFIG_ACCESSIBILITY is not set
+# CONFIG_INFINIBAND is not set
+CONFIG_EDAC_SUPPORT=y
+CONFIG_EDAC=y
+CONFIG_EDAC_LEGACY_SYSFS=y
+# CONFIG_EDAC_DEBUG is not set
+# CONFIG_EDAC_THUNDERX is not set
+# CONFIG_EDAC_XGENE is not set
+# CONFIG_EDAC_KRYO_ARM64 is not set
+CONFIG_EDAC_QCOM=y
+# CONFIG_EDAC_QCOM_LLCC_PANIC_ON_CE is not set
+# CONFIG_EDAC_QCOM_LLCC_PANIC_ON_UE is not set
+# CONFIG_EDAC_DMC520 is not set
+CONFIG_RTC_LIB=y
+CONFIG_RTC_CLASS=y
+CONFIG_RTC_HCTOSYS=y
+CONFIG_RTC_HCTOSYS_DEVICE="rtc0"
+CONFIG_RTC_SYSTOHC=y
+CONFIG_RTC_SYSTOHC_DEVICE="rtc0"
+# CONFIG_RTC_DEBUG is not set
+CONFIG_RTC_NVMEM=y
+
+#
+# RTC interfaces
+#
+CONFIG_RTC_INTF_SYSFS=y
+CONFIG_RTC_INTF_PROC=y
+CONFIG_RTC_INTF_DEV=y
+# CONFIG_RTC_INTF_DEV_UIE_EMUL is not set
+# CONFIG_RTC_DRV_TEST is not set
+
+#
+# I2C RTC drivers
+#
+# CONFIG_RTC_DRV_ABB5ZES3 is not set
+# CONFIG_RTC_DRV_ABEOZ9 is not set
+# CONFIG_RTC_DRV_ABX80X is not set
+# CONFIG_RTC_DRV_DS1307 is not set
+# CONFIG_RTC_DRV_DS1374 is not set
+# CONFIG_RTC_DRV_DS1672 is not set
+# CONFIG_RTC_DRV_HYM8563 is not set
+# CONFIG_RTC_DRV_MAX6900 is not set
+# CONFIG_RTC_DRV_RS5C372 is not set
+# CONFIG_RTC_DRV_ISL1208 is not set
+# CONFIG_RTC_DRV_ISL12022 is not set
+# CONFIG_RTC_DRV_ISL12026 is not set
+# CONFIG_RTC_DRV_X1205 is not set
+# CONFIG_RTC_DRV_PCF8523 is not set
+# CONFIG_RTC_DRV_PCF85063 is not set
+# CONFIG_RTC_DRV_PCF85363 is not set
+# CONFIG_RTC_DRV_PCF8563 is not set
+# CONFIG_RTC_DRV_PCF8583 is not set
+# CONFIG_RTC_DRV_M41T80 is not set
+# CONFIG_RTC_DRV_BQ32K is not set
+# CONFIG_RTC_DRV_S35390A is not set
+# CONFIG_RTC_DRV_FM3130 is not set
+# CONFIG_RTC_DRV_RX8010 is not set
+# CONFIG_RTC_DRV_RX8581 is not set
+# CONFIG_RTC_DRV_RX8025 is not set
+# CONFIG_RTC_DRV_EM3027 is not set
+# CONFIG_RTC_DRV_RV3028 is not set
+# CONFIG_RTC_DRV_RV3032 is not set
+# CONFIG_RTC_DRV_RV8803 is not set
+# CONFIG_RTC_DRV_SD3078 is not set
+
+#
+# SPI RTC drivers
+#
+# CONFIG_RTC_DRV_M41T93 is not set
+# CONFIG_RTC_DRV_M41T94 is not set
+# CONFIG_RTC_DRV_DS1302 is not set
+# CONFIG_RTC_DRV_DS1305 is not set
+# CONFIG_RTC_DRV_DS1343 is not set
+# CONFIG_RTC_DRV_DS1347 is not set
+# CONFIG_RTC_DRV_DS1390 is not set
+# CONFIG_RTC_DRV_MAX6916 is not set
+# CONFIG_RTC_DRV_R9701 is not set
+# CONFIG_RTC_DRV_RX4581 is not set
+# CONFIG_RTC_DRV_RS5C348 is not set
+# CONFIG_RTC_DRV_MAX6902 is not set
+# CONFIG_RTC_DRV_PCF2123 is not set
+# CONFIG_RTC_DRV_MCP795 is not set
+CONFIG_RTC_I2C_AND_SPI=y
+
+#
+# SPI and I2C RTC drivers
+#
+# CONFIG_RTC_DRV_DS3232 is not set
+# CONFIG_RTC_DRV_PCF2127 is not set
+# CONFIG_RTC_DRV_RV3029C2 is not set
+# CONFIG_RTC_DRV_RX6110 is not set
+
+#
+# Platform RTC drivers
+#
+# CONFIG_RTC_DRV_DS1286 is not set
+# CONFIG_RTC_DRV_DS1511 is not set
+# CONFIG_RTC_DRV_DS1553 is not set
+# CONFIG_RTC_DRV_DS1685_FAMILY is not set
+# CONFIG_RTC_DRV_DS1742 is not set
+# CONFIG_RTC_DRV_DS2404 is not set
+# CONFIG_RTC_DRV_EFI is not set
+# CONFIG_RTC_DRV_STK17TA8 is not set
+# CONFIG_RTC_DRV_M48T86 is not set
+# CONFIG_RTC_DRV_M48T35 is not set
+# CONFIG_RTC_DRV_M48T59 is not set
+# CONFIG_RTC_DRV_MSM6242 is not set
+# CONFIG_RTC_DRV_BQ4802 is not set
+# CONFIG_RTC_DRV_RP5C01 is not set
+# CONFIG_RTC_DRV_V3020 is not set
+# CONFIG_RTC_DRV_ZYNQMP is not set
+
+#
+# on-CPU RTC drivers
+#
+CONFIG_RTC_DRV_PL030=y
+CONFIG_RTC_DRV_PL031=y
+# CONFIG_RTC_DRV_CADENCE is not set
+# CONFIG_RTC_DRV_FTRTC010 is not set
+# CONFIG_RTC_DRV_PM8XXX is not set
+# CONFIG_RTC_DRV_R7301 is not set
+
+#
+# HID Sensor RTC drivers
+#
+# CONFIG_RTC_DRV_GOLDFISH is not set
+CONFIG_DMADEVICES=y
+# CONFIG_DMADEVICES_DEBUG is not set
+
+#
+# DMA Devices
+#
+CONFIG_ASYNC_TX_ENABLE_CHANNEL_SWITCH=y
+CONFIG_DMA_ENGINE=y
+CONFIG_DMA_VIRTUAL_CHANNELS=y
+CONFIG_DMA_OF=y
+# CONFIG_ALTERA_MSGDMA is not set
+# CONFIG_AMBA_PL08X is not set
+# CONFIG_DW_AXI_DMAC is not set
+# CONFIG_FSL_EDMA is not set
+# CONFIG_FSL_QDMA is not set
+# CONFIG_INTEL_IDMA64 is not set
+# CONFIG_MV_XOR_V2 is not set
+# CONFIG_PL330_DMA is not set
+# CONFIG_PLX_DMA is not set
+# CONFIG_XILINX_DMA is not set
+# CONFIG_XILINX_ZYNQMP_DMA is not set
+# CONFIG_XILINX_ZYNQMP_DPDMA is not set
+# CONFIG_QCOM_BAM_DMA is not set
+CONFIG_QCOM_GPI_DMA=y
+CONFIG_MSM_GPI_DMA=y
+# CONFIG_MSM_GPI_DMA_DEBUG is not set
+CONFIG_QCOM_HIDMA_MGMT=y
+CONFIG_QCOM_HIDMA=y
+# CONFIG_DW_DMAC is not set
+# CONFIG_DW_DMAC_PCI is not set
+# CONFIG_DW_EDMA is not set
+# CONFIG_DW_EDMA_PCIE is not set
+# CONFIG_SF_PDMA is not set
+
+#
+# DMA Clients
+#
+# CONFIG_ASYNC_TX_DMA is not set
+# CONFIG_DMATEST is not set
+
+#
+# DMABUF options
+#
+CONFIG_SYNC_FILE=y
+# CONFIG_SW_SYNC is not set
+# CONFIG_UDMABUF is not set
+# CONFIG_DMABUF_MOVE_NOTIFY is not set
+# CONFIG_DMABUF_DEBUG is not set
+# CONFIG_DMABUF_SELFTESTS is not set
+CONFIG_DMABUF_HEAPS=y
+CONFIG_DMABUF_SYSFS_STATS=y
+CONFIG_DMABUF_HEAPS_DEFERRED_FREE=y
+CONFIG_DMABUF_HEAPS_PAGE_POOL=y
+CONFIG_DMABUF_HEAPS_SYSTEM=y
+CONFIG_DMABUF_HEAPS_CMA=y
+CONFIG_QCOM_DMABUF_HEAPS=y
+# CONFIG_QCOM_DMABUF_HEAPS_SYSTEM is not set
+# CONFIG_QCOM_DMABUF_HEAPS_CMA is not set
+# CONFIG_QCOM_DMABUF_HEAPS_CARVEOUT is not set
+# CONFIG_QCOM_DMABUF_HEAPS_TUI_CARVEOUT is not set
+# end of DMABUF options
+
+# CONFIG_AUXDISPLAY is not set
+CONFIG_UIO=y
+# CONFIG_UIO_CIF is not set
+# CONFIG_UIO_PDRV_GENIRQ is not set
+# CONFIG_UIO_DMEM_GENIRQ is not set
+# CONFIG_UIO_AEC is not set
+# CONFIG_UIO_SERCOS3 is not set
+# CONFIG_UIO_PCI_GENERIC is not set
+# CONFIG_UIO_NETX is not set
+# CONFIG_UIO_PRUSS is not set
+# CONFIG_UIO_MF624 is not set
+CONFIG_UIO_MSM_SHAREDMEM=y
+# CONFIG_VFIO is not set
+# CONFIG_VIRT_DRIVERS is not set
+CONFIG_VIRTIO=y
+CONFIG_VIRTIO_MENU=y
+# CONFIG_VIRTIO_PCI is not set
+# CONFIG_VIRTIO_PMEM is not set
+# CONFIG_VIRTIO_BALLOON is not set
+# CONFIG_VIRTIO_MEM is not set
+# CONFIG_VIRTIO_INPUT is not set
+# CONFIG_VIRTIO_MMIO is not set
+# CONFIG_VIRTIO_DMA_SHARED_BUFFER is not set
+# CONFIG_VDPA is not set
+CONFIG_VHOST_IOTLB=y
+CONFIG_VHOST=y
+CONFIG_VHOST_MENU=y
+# CONFIG_VHOST_NET is not set
+CONFIG_VHOST_VSOCK=y
+# CONFIG_VHOST_CROSS_ENDIAN_LEGACY is not set
+
+#
+# Microsoft Hyper-V guest support
+#
+# end of Microsoft Hyper-V guest support
+
+# CONFIG_GREYBUS is not set
+# CONFIG_COMEDI is not set
+CONFIG_STAGING=y
+# CONFIG_RTL8192U is not set
+# CONFIG_RTLLIB is not set
+# CONFIG_RTS5208 is not set
+
+#
+# IIO staging drivers
+#
+
+#
+# Accelerometers
+#
+# CONFIG_ADIS16203 is not set
+# CONFIG_ADIS16240 is not set
+# end of Accelerometers
+
+#
+# Analog to digital converters
+#
+# CONFIG_AD7816 is not set
+# CONFIG_AD7280 is not set
+# end of Analog to digital converters
+
+#
+# Analog digital bi-direction converters
+#
+# CONFIG_ADT7316 is not set
+# end of Analog digital bi-direction converters
+
+#
+# Capacitance to digital converters
+#
+# CONFIG_AD7746 is not set
+# end of Capacitance to digital converters
+
+#
+# Direct Digital Synthesis
+#
+# CONFIG_AD9832 is not set
+# CONFIG_AD9834 is not set
+# end of Direct Digital Synthesis
+
+#
+# Network Analyzer, Impedance Converters
+#
+# CONFIG_AD5933 is not set
+# end of Network Analyzer, Impedance Converters
+
+#
+# Active energy metering IC
+#
+# CONFIG_ADE7854 is not set
+# end of Active energy metering IC
+
+#
+# Resolver to digital converters
+#
+# CONFIG_AD2S1210 is not set
+# end of Resolver to digital converters
+# end of IIO staging drivers
+
+# CONFIG_FB_SM750 is not set
+# CONFIG_STAGING_MEDIA is not set
+
+#
+# Android
+#
+CONFIG_ASHMEM=y
+CONFIG_DEBUG_KINFO=y
+# end of Android
+
+# CONFIG_STAGING_BOARD is not set
+# CONFIG_LTE_GDM724X is not set
+# CONFIG_GS_FPGABOOT is not set
+# CONFIG_UNISYSSPAR is not set
+# CONFIG_COMMON_CLK_XLNX_CLKWZRD is not set
+# CONFIG_FB_TFT is not set
+# CONFIG_KS7010 is not set
+# CONFIG_PI433 is not set
+# CONFIG_XIL_AXIS_FIFO is not set
+# CONFIG_FIELDBUS_DEV is not set
+# CONFIG_QLGE is not set
+# CONFIG_GOLDFISH is not set
+# CONFIG_CHROME_PLATFORMS is not set
+# CONFIG_MELLANOX_PLATFORM is not set
+
+#
+# Qualcomm technologies inc. MSM specific device drivers
+#
+CONFIG_ECPRI_DMA=y
+CONFIG_IPA3=y
+CONFIG_QPNP_REVID=y
+# CONFIG_EP_PCIE is not set
+# end of Qualcomm technologies inc. MSM specific device drivers
+
+CONFIG_HAVE_CLK=y
+CONFIG_HAVE_CLK_PREPARE=y
+CONFIG_COMMON_CLK=y
+
+#
+# Clock driver for ARM Reference designs
+#
+# CONFIG_ICST is not set
+# CONFIG_CLK_SP810 is not set
+# end of Clock driver for ARM Reference designs
+
+# CONFIG_LMK04832 is not set
+# CONFIG_COMMON_CLK_MAX9485 is not set
+# CONFIG_COMMON_CLK_SCMI is not set
+CONFIG_COMMON_CLK_SCPI=y
+# CONFIG_COMMON_CLK_SI5341 is not set
+# CONFIG_COMMON_CLK_SI5351 is not set
+# CONFIG_COMMON_CLK_SI514 is not set
+# CONFIG_COMMON_CLK_SI544 is not set
+# CONFIG_COMMON_CLK_SI570 is not set
+# CONFIG_COMMON_CLK_CDCE706 is not set
+# CONFIG_COMMON_CLK_CDCE925 is not set
+# CONFIG_COMMON_CLK_CS2000_CP is not set
+# CONFIG_COMMON_CLK_AXI_CLKGEN is not set
+# CONFIG_COMMON_CLK_XGENE is not set
+# CONFIG_COMMON_CLK_PWM is not set
+# CONFIG_COMMON_CLK_VC5 is not set
+# CONFIG_COMMON_CLK_FIXED_MMIO is not set
+CONFIG_QCOM_GDSC=y
+CONFIG_QCOM_RPMCC=y
+CONFIG_COMMON_CLK_QCOM=y
+CONFIG_QCOM_A53PLL=y
+CONFIG_QCOM_A7PLL=y
+CONFIG_QCOM_CLK_APCS_MSM8916=y
+CONFIG_QCOM_CLK_APCC_MSM8996=y
+CONFIG_QCOM_CLK_APCS_SDX55=y
+CONFIG_QCOM_CLK_RPM=y
+CONFIG_QCOM_CLK_SMD_RPM=y
+CONFIG_QCOM_CLK_RPMH=y
+CONFIG_APQ_GCC_8084=y
+# CONFIG_APQ_MMCC_8084 is not set
+# CONFIG_IPQ_APSS_PLL is not set
+# CONFIG_IPQ_APSS_6018 is not set
+# CONFIG_IPQ_GCC_4019 is not set
+# CONFIG_IPQ_GCC_6018 is not set
+# CONFIG_IPQ_GCC_806X is not set
+# CONFIG_IPQ_LCC_806X is not set
+# CONFIG_IPQ_GCC_8074 is not set
+# CONFIG_MSM_GCC_8660 is not set
+# CONFIG_MSM_GCC_8916 is not set
+# CONFIG_MSM_GCC_8939 is not set
+# CONFIG_MSM_GCC_8960 is not set
+# CONFIG_MSM_LCC_8960 is not set
+# CONFIG_MDM_GCC_9607 is not set
+# CONFIG_MDM_GCC_9615 is not set
+# CONFIG_MDM_LCC_9615 is not set
+# CONFIG_MSM_MMCC_8960 is not set
+# CONFIG_MSM_GCC_8953 is not set
+# CONFIG_MSM_GCC_8974 is not set
+# CONFIG_MSM_MMCC_8974 is not set
+# CONFIG_MSM_MMCC_8994 is not set
+# CONFIG_MSM_GCC_8994 is not set
+# CONFIG_MSM_GCC_8996 is not set
+# CONFIG_MSM_MMCC_8996 is not set
+# CONFIG_MSM_GCC_8998 is not set
+# CONFIG_MSM_GPUCC_8998 is not set
+# CONFIG_MSM_MMCC_8998 is not set
+# CONFIG_QCS_GCC_404 is not set
+# CONFIG_SC_CAMCC_7180 is not set
+# CONFIG_SC_DISPCC_7180 is not set
+# CONFIG_SC_DISPCC_7280 is not set
+# CONFIG_SC_GCC_7180 is not set
+# CONFIG_SC_GCC_7280 is not set
+# CONFIG_SC_GCC_8180X is not set
+# CONFIG_SC_LPASS_CORECC_7180 is not set
+# CONFIG_SC_GPUCC_7180 is not set
+# CONFIG_SC_GPUCC_7280 is not set
+# CONFIG_SC_MSS_7180 is not set
+# CONFIG_SC_VIDEOCC_7180 is not set
+# CONFIG_SC_VIDEOCC_7280 is not set
+# CONFIG_SDM_CAMCC_845 is not set
+# CONFIG_SDM_GCC_660 is not set
+# CONFIG_SDM_MMCC_660 is not set
+# CONFIG_SDM_GPUCC_660 is not set
+# CONFIG_QCS_TURING_404 is not set
+# CONFIG_QCS_Q6SSTOP_404 is not set
+# CONFIG_SDM_GCC_845 is not set
+# CONFIG_SDM_GPUCC_845 is not set
+# CONFIG_SDM_VIDEOCC_845 is not set
+# CONFIG_SDM_DISPCC_845 is not set
+# CONFIG_SDM_LPASSCC_845 is not set
+# CONFIG_SDX_GCC_55 is not set
+# CONFIG_SM_CAMCC_8250 is not set
+# CONFIG_SM_DEBUGCC_8250 is not set
+# CONFIG_SM_NPUCC_8250 is not set
+# CONFIG_SM_GCC_6115 is not set
+# CONFIG_SM_GCC_6125 is not set
+# CONFIG_SM_GCC_6350 is not set
+# CONFIG_SM_GCC_8150 is not set
+# CONFIG_SM_GCC_8250 is not set
+# CONFIG_SM_GCC_8350 is not set
+# CONFIG_SM_GPUCC_8150 is not set
+# CONFIG_SM_GPUCC_8250 is not set
+# CONFIG_SM_VIDEOCC_8150 is not set
+# CONFIG_SM_VIDEOCC_8250 is not set
+# CONFIG_SPMI_PMIC_CLKDIV is not set
+CONFIG_QCOM_HFPLL=y
+# CONFIG_KPSS_XCC is not set
+# CONFIG_CLK_GFM_LPASS_SM8250 is not set
+CONFIG_QCOM_GDSC_REGULATOR=y
+# CONFIG_SM_GCC_KALAMA is not set
+# CONFIG_SM_DEBUGCC_KALAMA is not set
+# CONFIG_MSM_GCC_WAIPIO is not set
+# CONFIG_MSM_VIDEOCC_WAIPIO is not set
+# CONFIG_MSM_GPUCC_WAIPIO is not set
+# CONFIG_MSM_DISPCC_WAIPIO is not set
+# CONFIG_MSM_DEBUGCC_WAIPIO is not set
+# CONFIG_QDRU_GCC_CINDER is not set
+# CONFIG_SM_CAMCC_8150 is not set
+# CONFIG_SM_NPUCC_8150 is not set
+# CONFIG_SM_SCC_8150 is not set
+# CONFIG_SM_DEBUGCC_8150 is not set
+# CONFIG_QDRU_ECPRICC_CINDER is not set
+# CONFIG_QDRU_DEBUGCC_CINDER is not set
+# CONFIG_SM_GCC_KHAJE is not set
+# CONFIG_SM_DISPCC_KHAJE is not set
+# CONFIG_SM_GPUCC_KHAJE is not set
+# CONFIG_SM_DEBUGCC_KHAJE is not set
+# CONFIG_SC_CAMCC_8180X is not set
+# CONFIG_SDX_GCC_PINN is not set
+# CONFIG_SDX_DEBUGCC_PINN is not set
+# CONFIG_SM_GCC_SCUBA is not set
+CONFIG_SDW_GCC_MONACO=y
+CONFIG_SDW_GPUCC_MONACO=y
+CONFIG_SDW_DISPCC_MONACO=y
+CONFIG_SDW_DEBUGCC_MONACO=y
+# CONFIG_SM_GPUCC_SCUBA is not set
+# CONFIG_SM_DISPCC_SCUBA is not set
+# CONFIG_SA_GCC_LEMANS is not set
+# CONFIG_SA_CAMCC_LEMANS is not set
+# CONFIG_SA_VIDEOCC_LEMANS is not set
+# CONFIG_SA_GPUCC_LEMANS is not set
+# CONFIG_SA_DISPCC_LEMANS is not set
+# CONFIG_SA_GCC_410M is not set
+# CONFIG_SDX_GCC_BAAGHA is not set
+# CONFIG_SDX_DEBUGCC_BAAGHA is not set
+# CONFIG_VIRTIO_CLK is not set
+# CONFIG_XILINX_VCU is not set
+CONFIG_HWSPINLOCK=y
+CONFIG_HWSPINLOCK_QCOM=y
+
+#
+# Clock Source drivers
+#
+CONFIG_TIMER_OF=y
+CONFIG_TIMER_PROBE=y
+CONFIG_CLKSRC_MMIO=y
+CONFIG_SUN4I_TIMER=y
+CONFIG_ARM_ARCH_TIMER=y
+CONFIG_ARM_ARCH_TIMER_EVTSTREAM=y
+CONFIG_ARM_ARCH_TIMER_OOL_WORKAROUND=y
+CONFIG_FSL_ERRATUM_A008585=y
+CONFIG_HISILICON_ERRATUM_161010101=y
+CONFIG_ARM64_ERRATUM_858921=y
+# CONFIG_MICROCHIP_PIT64B is not set
+# end of Clock Source drivers
+
+CONFIG_MAILBOX=y
+# CONFIG_ARM_MHU is not set
+# CONFIG_ARM_MHU_V2 is not set
+# CONFIG_PLATFORM_MHU is not set
+# CONFIG_PL320_MBOX is not set
+# CONFIG_ALTERA_MBOX is not set
+# CONFIG_MAILBOX_TEST is not set
+CONFIG_QCOM_APCS_IPC=y
+CONFIG_QCOM_IPCC=y
+CONFIG_MSM_QMP=y
+CONFIG_IOMMU_IOVA=y
+CONFIG_IOMMU_API=y
+CONFIG_IOMMU_SUPPORT=y
+
+#
+# Generic IOMMU Pagetable Support
+#
+CONFIG_IOMMU_IO_PGTABLE=y
+CONFIG_IOMMU_IO_PGTABLE_LPAE=y
+# CONFIG_IOMMU_IO_PGTABLE_LPAE_SELFTEST is not set
+CONFIG_IOMMU_IO_PGTABLE_FAST=y
+# CONFIG_IOMMU_IO_PGTABLE_FAST_SELFTEST is not set
+# CONFIG_IOMMU_IO_PGTABLE_FAST_PROVE_TLB is not set
+CONFIG_IOMMU_IO_PGTABLE_ARMV7S=y
+# CONFIG_IOMMU_IO_PGTABLE_ARMV7S_SELFTEST is not set
+# end of Generic IOMMU Pagetable Support
+
+# CONFIG_IOMMU_DEBUGFS is not set
+CONFIG_IOMMU_DEFAULT_DMA_STRICT=y
+# CONFIG_IOMMU_DEFAULT_DMA_LAZY is not set
+# CONFIG_IOMMU_DEFAULT_PASSTHROUGH is not set
+CONFIG_OF_IOMMU=y
+CONFIG_IOMMU_DMA=y
+CONFIG_QTI_IOMMU_SUPPORT=y
+CONFIG_ARM_SMMU=y
+# CONFIG_ARM_SMMU_LEGACY_DT_BINDINGS is not set
+CONFIG_ARM_SMMU_DISABLE_BYPASS_BY_DEFAULT=y
+# CONFIG_ARM_SMMU_SELFTEST is not set
+CONFIG_ARM_SMMU_QCOM=y
+# CONFIG_ARM_SMMU_TESTBUS is not set
+CONFIG_ARM_SMMU_V3=y
+CONFIG_ARM_PARAVIRT_SMMU_V3=y
+# CONFIG_ARM_SMMU_V3_SVA is not set
+# CONFIG_IOMMU_TLBSYNC_DEBUG is not set
+CONFIG_QCOM_LAZY_MAPPING=y
+CONFIG_QCOM_IOMMU=y
+# CONFIG_VIRTIO_IOMMU is not set
+CONFIG_QCOM_IOMMU_UTIL=y
+# CONFIG_QCOM_IOMMU_DEBUG is not set
+
+#
+# Remoteproc drivers
+#
+CONFIG_REMOTEPROC=y
+CONFIG_REMOTEPROC_CDEV=y
+CONFIG_QCOM_RPROC_COMMON=y
+# CONFIG_QCOM_Q6V5_ADSP is not set
+# CONFIG_QCOM_Q6V5_MSS is not set
+# CONFIG_QCOM_Q6V5_PAS is not set
+# CONFIG_QCOM_SPSS is not set
+# CONFIG_QCOM_ESOC is not set
+# CONFIG_QCOM_ESOC_DEV is not set
+# CONFIG_QCOM_ESOC_CLIENT is not set
+# CONFIG_QCOM_ESOC_DEBUG is not set
+# CONFIG_QCOM_ESOC_MDM_4X is not set
+# CONFIG_QCOM_ESOC_MDM_DRV is not set
+# CONFIG_QCOM_Q6V5_WCSS is not set
+# CONFIG_QCOM_SYSMON is not set
+# CONFIG_QCOM_WCNSS_PIL is not set
+# CONFIG_QCOM_PANIC_ON_NOTIF_TIMEOUT is not set
+CONFIG_RPROC_SYSMON_NOTIF_TIMEOUT=10000
+CONFIG_RPROC_SSR_NOTIF_TIMEOUT=10000
+# CONFIG_QCOM_RPROC_SLATE is not set
+# CONFIG_MSM_QUIN_SUBSYSTEM_NOTIF_VIRT is not set
+# end of Remoteproc drivers
+
+#
+# Rpmsg drivers
+#
+CONFIG_RPMSG=y
+CONFIG_RPMSG_CHAR=y
+CONFIG_RPMSG_CTRL=y
+# CONFIG_RPMSG_NS is not set
+CONFIG_RPMSG_QCOM_GLINK=y
+# CONFIG_RPMSG_QCOM_GLINK_DEBUG is not set
+CONFIG_RPMSG_QCOM_GLINK_RPM=y
+CONFIG_RPMSG_QCOM_GLINK_SMEM=y
+CONFIG_RPMSG_QCOM_GLINK_SPSS=y
+CONFIG_RPMSG_QCOM_SMD=y
+# CONFIG_RPMSG_VIRTIO is not set
+# CONFIG_RPMSG_QCOM_GLINK_SLATECOM is not set
+CONFIG_MSM_RPM_SMD=y
+# end of Rpmsg drivers
+
+# CONFIG_SOUNDWIRE is not set
+
+#
+# SOC (System On Chip) specific Drivers
+#
+
+#
+# Amlogic SoC drivers
+#
+# end of Amlogic SoC drivers
+
+#
+# Broadcom SoC drivers
+#
+# CONFIG_SOC_BRCMSTB is not set
+# end of Broadcom SoC drivers
+
+#
+# NXP/Freescale QorIQ SoC drivers
+#
+# CONFIG_QUICC_ENGINE is not set
+# CONFIG_FSL_RCPM is not set
+# end of NXP/Freescale QorIQ SoC drivers
+
+#
+# i.MX SoC drivers
+#
+# end of i.MX SoC drivers
+
+#
+# Enable LiteX SoC Builder specific drivers
+#
+# CONFIG_LITEX_SOC_CONTROLLER is not set
+# end of Enable LiteX SoC Builder specific drivers
+
+#
+# Qualcomm SoC drivers
+#
+CONFIG_SPS=y
+CONFIG_SPS_SUPPORT_BAMDMA=y
+# CONFIG_SPS_SUPPORT_NDP_BAM is not set
+CONFIG_QCOM_AOSS_QMP=y
+# CONFIG_QCOM_COMMAND_DB is not set
+CONFIG_QCOM_CPR=y
+# CONFIG_QCOM_CPUSS_SLEEP_STATS is not set
+# CONFIG_SHOW_SUSPEND_EPOCH is not set
+CONFIG_QCOM_CRM=y
+CONFIG_QCOM_GENI_SE=y
+CONFIG_QCOM_GSBI=y
+CONFIG_QCOM_MSM_IPCC=y
+CONFIG_QCOM_RIMPS=y
+CONFIG_QCOM_TLMM_VM_IRQCHIP=y
+# CONFIG_GIC_INTERRUPT_ROUTING is not set
+CONFIG_QCOM_LLCC=y
+CONFIG_QCOM_KRYO_L2_ACCESSORS=y
+# CONFIG_QCOM_LLCC_PERFMON is not set
+CONFIG_QCOM_MDT_LOADER=y
+# CONFIG_QCOM_OCMEM is not set
+CONFIG_QCOM_PDR_HELPERS=y
+# CONFIG_QCOM_PANIC_ON_PDR_NOTIF_TIMEOUT is not set
+CONFIG_PDR_INDICATION_NOTIF_TIMEOUT=3000
+# CONFIG_MSM_BOOT_TIME_MARKER is not set
+CONFIG_QCOM_QMI_HELPERS=y
+# CONFIG_MSM_HAB is not set
+CONFIG_MSM_HAB_DEFAULT_VMID=2
+# CONFIG_MEM_SHARE_QMI_SERVICE is not set
+# CONFIG_QCOM_QFPROM_SYS is not set
+CONFIG_QCOM_RMTFS_MEM=y
+CONFIG_MSM_CORE_HANG_DETECT=y
+CONFIG_QCOM_RPMH=y
+CONFIG_QCOM_RPMPD=y
+# CONFIG_QCOM_RUN_QUEUE_STATS is not set
+CONFIG_QCOM_SMEM=y
+CONFIG_QCOM_SMD_RPM=y
+CONFIG_QCOM_MEMORY_DUMP_V2=y
+CONFIG_QCOM_SMEM_STATE=y
+CONFIG_QCOM_SMP2P=y
+# CONFIG_QCOM_SMSM is not set
+# CONFIG_QCOM_MICRODUMP is not set
+# CONFIG_QCOM_SMP2P_SLEEPSTATE is not set
+# CONFIG_QSEE_IPC_IRQ_BRIDGE is not set
+CONFIG_QCOM_GLINK=y
+CONFIG_QCOM_GLINK_PKT=y
+CONFIG_QTI_PMIC_GLINK=y
+# CONFIG_QTI_PMIC_GLINK_CLIENT_DEBUG is not set
+# CONFIG_QTI_BATTERY_GLINK_DEBUG is not set
+# CONFIG_QTI_CHARGER_ULOG_GLINK is not set
+# CONFIG_QTI_ALTMODE_GLINK is not set
+# CONFIG_SPMI_QTI_GLINK_DEBUG is not set
+# CONFIG_QCOM_SECURE_BUFFER is not set
+# CONFIG_QCOM_MEM_HOOKS is not set
+# CONFIG_QCOM_BALANCE_ANON_FILE_RECLAIM is not set
+# CONFIG_MSM_CDSP_LOADER is not set
+# CONFIG_QTI_SYS_PM_VX is not set
+# CONFIG_QCOM_SOCINFO is not set
+# CONFIG_QCOM_SOCINFO_DT is not set
+# CONFIG_QCOM_PMU_LIB is not set
+# CONFIG_QCOM_DCVS_FP is not set
+CONFIG_QCOM_DCVS=y
+CONFIG_QCOM_BWMON=y
+# CONFIG_MSM_JTAGV8 is not set
+# CONFIG_QCOM_SOC_SLEEP_STATS is not set
+# CONFIG_QTI_RPM_STATS_LOG is not set
+# CONFIG_QCOM_ADSP_SLEEPMON is not set
+# CONFIG_QCOM_WDT_CORE is not set
+# CONFIG_QCOM_CX_IPEAK is not set
+CONFIG_QCOM_LOGBUF_VENDOR_HOOKS=y
+CONFIG_QCOM_LOGBUF_BOOTLOG=y
+# CONFIG_QCOM_WCNSS_CTRL is not set
+CONFIG_QCOM_DCC_V2=y
+# CONFIG_QCOM_SUBSYSTEM_SLEEP_STATS is not set
+# CONFIG_QCOM_CDSP_RM is not set
+# CONFIG_CDSPRM_VTCM_DYNAMIC_DEBUG is not set
+# CONFIG_QCOM_SYSMON_SUBSYSTEM_STATS is not set
+# CONFIG_MSM_SLATECOM is not set
+# CONFIG_MSM_SLATERSB is not set
+# CONFIG_MSM_SEB is not set
+# CONFIG_QCOM_APR is not set
+CONFIG_QCOM_EUD=y
+# CONFIG_QPNP_PBS is not set
+# CONFIG_QTI_PMIC_PON_LOG is not set
+# CONFIG_QTI_PMIC_LPM is not set
+CONFIG_MSM_BOOT_STATS=y
+CONFIG_USB_BAM=y
+CONFIG_QCOM_RAMDUMP=y
+CONFIG_QCOM_CPU_VENDOR_HOOKS=y
+# CONFIG_QCOM_PANEL_EVENT_NOTIFIER is not set
+# CONFIG_QTI_HW_KEY_MANAGER is not set
+# CONFIG_QTI_HW_KEY_MANAGER_V1 is not set
+# CONFIG_QCOM_MEM_OFFLINE is not set
+# CONFIG_QCOM_HUNG_TASK_ENH is not set
+# CONFIG_QCOM_GUESTVM is not set
+# CONFIG_QCOM_FSA4480_I2C is not set
+# CONFIG_MSM_PERFORMANCE is not set
+CONFIG_QCOM_MINIDUMP=y
+# CONFIG_QCOM_VA_MINIDUMP is not set
+# CONFIG_QCOM_DYN_MINIDUMP_STACK is not set
+# CONFIG_QCOM_MINIDUMP_FTRACE is not set
+# CONFIG_QCOM_MINIDUMP_PANIC_DUMP is not set
+# CONFIG_QCOM_MINIDUMP_PSTORE is not set
+CONFIG_MINIDUMP_MAX_ENTRIES=200
+# CONFIG_MINIDUMP_ALL_TASK_INFO is not set
+# CONFIG_MSM_QBT_HANDLER is not set
+# CONFIG_QCOM_DEBUG_SYMBOL is not set
+CONFIG_QCOM_MEM_BUF=y
+CONFIG_QCOM_MEM_BUF_DEV=y
+# CONFIG_MSM_TMECOM_QMP is not set
+
+#
+# GNSS SIRF controls
+#
+# CONFIG_GNSS_SIRF is not set
+# end of GNSS SIRF controls
+
+# CONFIG_DUMP_XBL_LOG is not set
+# CONFIG_QCOM_AOP_SET_DDR is not set
+# CONFIG_ICNSS2_DEBUG is not set
+# CONFIG_MSM_POWER_STATE is not set
+# CONFIG_QCOM_S2D_VENDOR_HOOK is not set
+# CONFIG_QCOM_SECURE_HIBERNATION is not set
+# end of Qualcomm SoC drivers
+
+# CONFIG_SOC_TI is not set
+
+#
+# Xilinx SoC drivers
+#
+# end of Xilinx SoC drivers
+# end of SOC (System On Chip) specific Drivers
+
+CONFIG_PM_DEVFREQ=y
+
+#
+# DEVFREQ Governors
+#
+CONFIG_DEVFREQ_GOV_SIMPLE_ONDEMAND=y
+CONFIG_DEVFREQ_GOV_PERFORMANCE=y
+CONFIG_DEVFREQ_GOV_POWERSAVE=y
+CONFIG_DEVFREQ_GOV_USERSPACE=y
+CONFIG_DEVFREQ_GOV_PASSIVE=y
+
+#
+# DEVFREQ Drivers
+#
+CONFIG_PM_DEVFREQ_EVENT=y
+CONFIG_EXTCON=y
+
+#
+# Extcon Device Drivers
+#
+# CONFIG_EXTCON_ADC_JACK is not set
+# CONFIG_EXTCON_FSA9480 is not set
+# CONFIG_EXTCON_GPIO is not set
+# CONFIG_EXTCON_MAX3355 is not set
+# CONFIG_EXTCON_PTN5150 is not set
+CONFIG_EXTCON_QCOM_SPMI_MISC=y
+# CONFIG_EXTCON_RT8973A is not set
+# CONFIG_EXTCON_SM5502 is not set
+# CONFIG_EXTCON_USB_GPIO is not set
+# CONFIG_EXTCON_USBC_TUSB320 is not set
+# CONFIG_MEMORY is not set
+CONFIG_IIO=y
+CONFIG_IIO_BUFFER=y
+# CONFIG_IIO_BUFFER_CB is not set
+# CONFIG_IIO_BUFFER_DMA is not set
+# CONFIG_IIO_BUFFER_DMAENGINE is not set
+# CONFIG_IIO_BUFFER_HW_CONSUMER is not set
+CONFIG_IIO_KFIFO_BUF=y
+CONFIG_IIO_TRIGGERED_BUFFER=y
+# CONFIG_IIO_CONFIGFS is not set
+CONFIG_IIO_TRIGGER=y
+CONFIG_IIO_CONSUMERS_PER_TRIGGER=2
+# CONFIG_IIO_SW_DEVICE is not set
+# CONFIG_IIO_SW_TRIGGER is not set
+# CONFIG_IIO_TRIGGERED_EVENT is not set
+
+#
+# Accelerometers
+#
+# CONFIG_ADIS16201 is not set
+# CONFIG_ADIS16209 is not set
+# CONFIG_ADXL345_I2C is not set
+# CONFIG_ADXL345_SPI is not set
+# CONFIG_ADXL372_SPI is not set
+# CONFIG_ADXL372_I2C is not set
+# CONFIG_BMA180 is not set
+# CONFIG_BMA220 is not set
+# CONFIG_BMA400 is not set
+# CONFIG_BMC150_ACCEL is not set
+# CONFIG_BMI088_ACCEL is not set
+# CONFIG_DA280 is not set
+# CONFIG_DA311 is not set
+# CONFIG_DMARD06 is not set
+# CONFIG_DMARD09 is not set
+# CONFIG_DMARD10 is not set
+# CONFIG_FXLS8962AF_I2C is not set
+# CONFIG_FXLS8962AF_SPI is not set
+# CONFIG_IIO_ST_ACCEL_3AXIS is not set
+# CONFIG_KXSD9 is not set
+# CONFIG_KXCJK1013 is not set
+# CONFIG_MC3230 is not set
+# CONFIG_MMA7455_I2C is not set
+# CONFIG_MMA7455_SPI is not set
+# CONFIG_MMA7660 is not set
+# CONFIG_MMA8452 is not set
+# CONFIG_MMA9551 is not set
+# CONFIG_MMA9553 is not set
+# CONFIG_MXC4005 is not set
+# CONFIG_MXC6255 is not set
+# CONFIG_SCA3000 is not set
+# CONFIG_SCA3300 is not set
+# CONFIG_STK8312 is not set
+# CONFIG_STK8BA50 is not set
+# end of Accelerometers
+
+#
+# Analog to digital converters
+#
+# CONFIG_AD7091R5 is not set
+# CONFIG_AD7124 is not set
+# CONFIG_AD7192 is not set
+# CONFIG_AD7266 is not set
+# CONFIG_AD7291 is not set
+# CONFIG_AD7292 is not set
+# CONFIG_AD7298 is not set
+# CONFIG_AD7476 is not set
+# CONFIG_AD7606_IFACE_PARALLEL is not set
+# CONFIG_AD7606_IFACE_SPI is not set
+# CONFIG_AD7766 is not set
+# CONFIG_AD7768_1 is not set
+# CONFIG_AD7780 is not set
+# CONFIG_AD7791 is not set
+# CONFIG_AD7793 is not set
+# CONFIG_AD7887 is not set
+# CONFIG_AD7923 is not set
+# CONFIG_AD7949 is not set
+# CONFIG_AD799X is not set
+# CONFIG_ADI_AXI_ADC is not set
+# CONFIG_CC10001_ADC is not set
+# CONFIG_ENVELOPE_DETECTOR is not set
+# CONFIG_HI8435 is not set
+# CONFIG_HX711 is not set
+# CONFIG_INA2XX_ADC is not set
+# CONFIG_LTC2471 is not set
+# CONFIG_LTC2485 is not set
+# CONFIG_LTC2496 is not set
+# CONFIG_LTC2497 is not set
+# CONFIG_MAX1027 is not set
+# CONFIG_MAX11100 is not set
+# CONFIG_MAX1118 is not set
+# CONFIG_MAX1241 is not set
+# CONFIG_MAX1363 is not set
+# CONFIG_MAX9611 is not set
+# CONFIG_MCP320X is not set
+# CONFIG_MCP3422 is not set
+# CONFIG_MCP3911 is not set
+# CONFIG_NAU7802 is not set
+CONFIG_QCOM_VADC_COMMON=y
+CONFIG_QCOM_SPMI_IADC=y
+CONFIG_QCOM_SPMI_VADC=y
+CONFIG_QCOM_SPMI_ADC5=y
+CONFIG_QCOM_SPMI_ADC5_GEN3=y
+# CONFIG_SD_ADC_MODULATOR is not set
+# CONFIG_TI_ADC081C is not set
+# CONFIG_TI_ADC0832 is not set
+# CONFIG_TI_ADC084S021 is not set
+# CONFIG_TI_ADC12138 is not set
+# CONFIG_TI_ADC108S102 is not set
+# CONFIG_TI_ADC128S052 is not set
+# CONFIG_TI_ADC161S626 is not set
+# CONFIG_TI_ADS1015 is not set
+# CONFIG_TI_ADS7950 is not set
+# CONFIG_TI_ADS8344 is not set
+# CONFIG_TI_ADS8688 is not set
+# CONFIG_TI_ADS124S08 is not set
+# CONFIG_TI_ADS131E08 is not set
+# CONFIG_TI_TLC4541 is not set
+# CONFIG_TI_TSC2046 is not set
+# CONFIG_VF610_ADC is not set
+# CONFIG_XILINX_XADC is not set
+# end of Analog to digital converters
+
+#
+# Analog Front Ends
+#
+# CONFIG_IIO_RESCALE is not set
+# end of Analog Front Ends
+
+#
+# Amplifiers
+#
+# CONFIG_AD8366 is not set
+# CONFIG_HMC425 is not set
+# end of Amplifiers
+
+#
+# Capacitance to digital converters
+#
+# CONFIG_AD7150 is not set
+# end of Capacitance to digital converters
+
+#
+# Chemical Sensors
+#
+# CONFIG_ATLAS_PH_SENSOR is not set
+# CONFIG_ATLAS_EZO_SENSOR is not set
+# CONFIG_BME680 is not set
+# CONFIG_CCS811 is not set
+# CONFIG_IAQCORE is not set
+# CONFIG_PMS7003 is not set
+# CONFIG_SCD30_CORE is not set
+# CONFIG_SENSIRION_SGP30 is not set
+# CONFIG_SENSIRION_SGP40 is not set
+# CONFIG_SPS30_I2C is not set
+# CONFIG_SPS30_SERIAL is not set
+# CONFIG_VZ89X is not set
+# end of Chemical Sensors
+
+#
+# Hid Sensor IIO Common
+#
+# end of Hid Sensor IIO Common
+
+#
+# IIO SCMI Sensors
+#
+# CONFIG_IIO_SCMI is not set
+# end of IIO SCMI Sensors
+
+#
+# SSP Sensor Common
+#
+# CONFIG_IIO_SSP_SENSORHUB is not set
+# end of SSP Sensor Common
+
+#
+# Digital to analog converters
+#
+# CONFIG_AD5064 is not set
+# CONFIG_AD5360 is not set
+# CONFIG_AD5380 is not set
+# CONFIG_AD5421 is not set
+# CONFIG_AD5446 is not set
+# CONFIG_AD5449 is not set
+# CONFIG_AD5592R is not set
+# CONFIG_AD5593R is not set
+# CONFIG_AD5504 is not set
+# CONFIG_AD5624R_SPI is not set
+# CONFIG_AD5686_SPI is not set
+# CONFIG_AD5696_I2C is not set
+# CONFIG_AD5755 is not set
+# CONFIG_AD5758 is not set
+# CONFIG_AD5761 is not set
+# CONFIG_AD5764 is not set
+# CONFIG_AD5766 is not set
+# CONFIG_AD5770R is not set
+# CONFIG_AD5791 is not set
+# CONFIG_AD7303 is not set
+# CONFIG_AD8801 is not set
+# CONFIG_DPOT_DAC is not set
+# CONFIG_DS4424 is not set
+# CONFIG_LTC1660 is not set
+# CONFIG_LTC2632 is not set
+# CONFIG_M62332 is not set
+# CONFIG_MAX517 is not set
+# CONFIG_MAX5821 is not set
+# CONFIG_MCP4725 is not set
+# CONFIG_MCP4922 is not set
+# CONFIG_TI_DAC082S085 is not set
+# CONFIG_TI_DAC5571 is not set
+# CONFIG_TI_DAC7311 is not set
+# CONFIG_TI_DAC7612 is not set
+# CONFIG_VF610_DAC is not set
+# end of Digital to analog converters
+
+#
+# IIO dummy driver
+#
+# end of IIO dummy driver
+
+#
+# Frequency Synthesizers DDS/PLL
+#
+
+#
+# Clock Generator/Distribution
+#
+# CONFIG_AD9523 is not set
+# end of Clock Generator/Distribution
+
+#
+# Phase-Locked Loop (PLL) frequency synthesizers
+#
+# CONFIG_ADF4350 is not set
+# CONFIG_ADF4371 is not set
+# end of Phase-Locked Loop (PLL) frequency synthesizers
+# end of Frequency Synthesizers DDS/PLL
+
+#
+# Digital gyroscope sensors
+#
+# CONFIG_ADIS16080 is not set
+# CONFIG_ADIS16130 is not set
+# CONFIG_ADIS16136 is not set
+# CONFIG_ADIS16260 is not set
+# CONFIG_ADXRS290 is not set
+# CONFIG_ADXRS450 is not set
+# CONFIG_BMG160 is not set
+# CONFIG_FXAS21002C is not set
+# CONFIG_MPU3050_I2C is not set
+# CONFIG_IIO_ST_GYRO_3AXIS is not set
+# CONFIG_ITG3200 is not set
+# end of Digital gyroscope sensors
+
+#
+# Health Sensors
+#
+
+#
+# Heart Rate Monitors
+#
+# CONFIG_AFE4403 is not set
+# CONFIG_AFE4404 is not set
+# CONFIG_MAX30100 is not set
+# CONFIG_MAX30102 is not set
+# end of Heart Rate Monitors
+# end of Health Sensors
+
+#
+# Humidity sensors
+#
+# CONFIG_AM2315 is not set
+# CONFIG_DHT11 is not set
+# CONFIG_HDC100X is not set
+# CONFIG_HDC2010 is not set
+# CONFIG_HTS221 is not set
+# CONFIG_HTU21 is not set
+# CONFIG_SI7005 is not set
+# CONFIG_SI7020 is not set
+# end of Humidity sensors
+
+#
+# Inertial measurement units
+#
+# CONFIG_ADIS16400 is not set
+# CONFIG_ADIS16460 is not set
+# CONFIG_ADIS16475 is not set
+# CONFIG_ADIS16480 is not set
+# CONFIG_BMI160_I2C is not set
+# CONFIG_BMI160_SPI is not set
+# CONFIG_FXOS8700_I2C is not set
+# CONFIG_FXOS8700_SPI is not set
+# CONFIG_KMX61 is not set
+# CONFIG_INV_ICM42600_I2C is not set
+# CONFIG_INV_ICM42600_SPI is not set
+# CONFIG_INV_MPU6050_I2C is not set
+# CONFIG_INV_MPU6050_SPI is not set
+# CONFIG_IIO_ST_LSM6DSX is not set
+# CONFIG_IIO_ST_LSM9DS0 is not set
+# CONFIG_IIO_ST_ASM330LHH is not set
+# end of Inertial measurement units
+
+#
+# Light sensors
+#
+# CONFIG_ADJD_S311 is not set
+# CONFIG_ADUX1020 is not set
+# CONFIG_AL3010 is not set
+# CONFIG_AL3320A is not set
+# CONFIG_APDS9300 is not set
+# CONFIG_APDS9960 is not set
+# CONFIG_AS73211 is not set
+# CONFIG_BH1750 is not set
+# CONFIG_BH1780 is not set
+# CONFIG_CM32181 is not set
+# CONFIG_CM3232 is not set
+# CONFIG_CM3323 is not set
+# CONFIG_CM3605 is not set
+# CONFIG_CM36651 is not set
+# CONFIG_GP2AP002 is not set
+# CONFIG_GP2AP020A00F is not set
+# CONFIG_SENSORS_ISL29018 is not set
+# CONFIG_SENSORS_ISL29028 is not set
+# CONFIG_ISL29125 is not set
+# CONFIG_JSA1212 is not set
+# CONFIG_RPR0521 is not set
+# CONFIG_LTR501 is not set
+# CONFIG_LV0104CS is not set
+# CONFIG_MAX44000 is not set
+# CONFIG_MAX44009 is not set
+# CONFIG_NOA1305 is not set
+# CONFIG_OPT3001 is not set
+# CONFIG_PA12203001 is not set
+# CONFIG_SI1133 is not set
+# CONFIG_SI1145 is not set
+# CONFIG_STK3310 is not set
+# CONFIG_ST_UVIS25 is not set
+# CONFIG_TCS3414 is not set
+# CONFIG_TCS3472 is not set
+# CONFIG_SENSORS_TSL2563 is not set
+# CONFIG_TSL2583 is not set
+# CONFIG_TSL2591 is not set
+# CONFIG_TSL2772 is not set
+# CONFIG_TSL4531 is not set
+# CONFIG_US5182D is not set
+# CONFIG_VCNL4000 is not set
+# CONFIG_VCNL4035 is not set
+# CONFIG_VEML6030 is not set
+# CONFIG_VEML6070 is not set
+# CONFIG_VL6180 is not set
+# CONFIG_ZOPT2201 is not set
+# end of Light sensors
+
+#
+# Magnetometer sensors
+#
+# CONFIG_AK8974 is not set
+# CONFIG_AK8975 is not set
+# CONFIG_AK09911 is not set
+# CONFIG_BMC150_MAGN_I2C is not set
+# CONFIG_BMC150_MAGN_SPI is not set
+# CONFIG_MAG3110 is not set
+# CONFIG_MMC35240 is not set
+# CONFIG_IIO_ST_MAGN_3AXIS is not set
+# CONFIG_SENSORS_HMC5843_I2C is not set
+# CONFIG_SENSORS_HMC5843_SPI is not set
+# CONFIG_SENSORS_RM3100_I2C is not set
+# CONFIG_SENSORS_RM3100_SPI is not set
+# CONFIG_YAMAHA_YAS530 is not set
+# end of Magnetometer sensors
+
+#
+# Multiplexers
+#
+# CONFIG_IIO_MUX is not set
+# end of Multiplexers
+
+#
+# Inclinometer sensors
+#
+# end of Inclinometer sensors
+
+#
+# Triggers - standalone
+#
+# CONFIG_IIO_INTERRUPT_TRIGGER is not set
+# CONFIG_IIO_SYSFS_TRIGGER is not set
+# end of Triggers - standalone
+
+#
+# Linear and angular position sensors
+#
+# end of Linear and angular position sensors
+
+#
+# Digital potentiometers
+#
+# CONFIG_AD5110 is not set
+# CONFIG_AD5272 is not set
+# CONFIG_DS1803 is not set
+# CONFIG_MAX5432 is not set
+# CONFIG_MAX5481 is not set
+# CONFIG_MAX5487 is not set
+# CONFIG_MCP4018 is not set
+# CONFIG_MCP4131 is not set
+# CONFIG_MCP4531 is not set
+# CONFIG_MCP41010 is not set
+# CONFIG_TPL0102 is not set
+# end of Digital potentiometers
+
+#
+# Digital potentiostats
+#
+# CONFIG_LMP91000 is not set
+# end of Digital potentiostats
+
+#
+# Pressure sensors
+#
+# CONFIG_ABP060MG is not set
+# CONFIG_BMP280 is not set
+# CONFIG_DLHL60D is not set
+# CONFIG_DPS310 is not set
+# CONFIG_HP03 is not set
+# CONFIG_ICP10100 is not set
+# CONFIG_MPL115_I2C is not set
+# CONFIG_MPL115_SPI is not set
+# CONFIG_MPL3115 is not set
+# CONFIG_MS5611 is not set
+# CONFIG_MS5637 is not set
+# CONFIG_IIO_ST_PRESS is not set
+# CONFIG_T5403 is not set
+# CONFIG_HP206C is not set
+# CONFIG_ZPA2326 is not set
+# end of Pressure sensors
+
+#
+# Lightning sensors
+#
+# CONFIG_AS3935 is not set
+# end of Lightning sensors
+
+#
+# Proximity and distance sensors
+#
+# CONFIG_ISL29501 is not set
+# CONFIG_LIDAR_LITE_V2 is not set
+# CONFIG_MB1232 is not set
+# CONFIG_PING is not set
+# CONFIG_RFD77402 is not set
+# CONFIG_SRF04 is not set
+# CONFIG_SX9310 is not set
+# CONFIG_SX9500 is not set
+# CONFIG_SRF08 is not set
+# CONFIG_VCNL3020 is not set
+# CONFIG_VL53L0X_I2C is not set
+# end of Proximity and distance sensors
+
+#
+# Resolver to digital converters
+#
+# CONFIG_AD2S90 is not set
+# CONFIG_AD2S1200 is not set
+# end of Resolver to digital converters
+
+#
+# Temperature sensors
+#
+# CONFIG_LTC2983 is not set
+# CONFIG_ADS7052_TDK_THERMISTOR is not set
+# CONFIG_MAXIM_THERMOCOUPLE is not set
+# CONFIG_MLX90614 is not set
+# CONFIG_MLX90632 is not set
+# CONFIG_TMP006 is not set
+# CONFIG_TMP007 is not set
+# CONFIG_TMP117 is not set
+# CONFIG_TSYS01 is not set
+# CONFIG_TSYS02D is not set
+# CONFIG_MAX31856 is not set
+# end of Temperature sensors
+
+# CONFIG_NTB is not set
+# CONFIG_VME_BUS is not set
+CONFIG_PWM=y
+CONFIG_PWM_SYSFS=y
+# CONFIG_PWM_DEBUG is not set
+# CONFIG_PWM_ATMEL_TCB is not set
+# CONFIG_PWM_DWC is not set
+# CONFIG_PWM_FSL_FTM is not set
+# CONFIG_PWM_PCA9685 is not set
+# CONFIG_PWM_QTI_LPG is not set
+
+#
+# IRQ chip support
+#
+CONFIG_IRQCHIP=y
+CONFIG_ARM_GIC=y
+CONFIG_ARM_GIC_MAX_NR=1
+CONFIG_ARM_GIC_V2M=y
+CONFIG_ARM_GIC_V3=y
+CONFIG_ARM_GIC_V3_ITS=y
+CONFIG_ARM_GIC_V3_ITS_PCI=y
+# CONFIG_AL_FIC is not set
+# CONFIG_QCOM_SHOW_RESUME_IRQ is not set
+CONFIG_PARTITION_PERCPU=y
+CONFIG_QCOM_MPM=y
+CONFIG_QCOM_PDC=y
+# end of IRQ chip support
+
+# CONFIG_IPACK_BUS is not set
+CONFIG_RESET_CONTROLLER=y
+# CONFIG_RESET_QCOM_AOSS is not set
+# CONFIG_RESET_QCOM_PDC is not set
+# CONFIG_RESET_SCMI is not set
+# CONFIG_RESET_TI_SYSCON is not set
+
+#
+# PHY Subsystem
+#
+CONFIG_GENERIC_PHY=y
+CONFIG_GENERIC_PHY_MIPI_DPHY=y
+# CONFIG_PHY_XGENE is not set
+# CONFIG_PHY_CAN_TRANSCEIVER is not set
+# CONFIG_BCM_KONA_USB2_PHY is not set
+# CONFIG_PHY_CADENCE_TORRENT is not set
+# CONFIG_PHY_CADENCE_DPHY is not set
+# CONFIG_PHY_CADENCE_SIERRA is not set
+# CONFIG_PHY_CADENCE_SALVO is not set
+# CONFIG_PHY_FSL_IMX8MQ_USB is not set
+# CONFIG_PHY_MIXEL_MIPI_DPHY is not set
+# CONFIG_PHY_PXA_28NM_HSIC is not set
+# CONFIG_PHY_PXA_28NM_USB2 is not set
+# CONFIG_PHY_CPCAP_USB is not set
+# CONFIG_PHY_MAPPHONE_MDM6600 is not set
+# CONFIG_PHY_OCELOT_SERDES is not set
+# CONFIG_PHY_QCOM_APQ8064_SATA is not set
+# CONFIG_PHY_QCOM_IPQ4019_USB is not set
+# CONFIG_PHY_QCOM_IPQ806X_SATA is not set
+# CONFIG_PHY_QCOM_PCIE2 is not set
+# CONFIG_PHY_QCOM_QMP is not set
+# CONFIG_PHY_QCOM_QUSB2 is not set
+# CONFIG_PHY_QCOM_UFS is not set
+CONFIG_PHY_QCOM_USB_SNPS_FEMTO_V2=y
+CONFIG_PHY_QCOM_USB_HS_28NM=y
+CONFIG_PHY_QCOM_USB_SS=y
+# CONFIG_PHY_QCOM_IPQ806X_USB is not set
+# end of PHY Subsystem
+
+CONFIG_POWERCAP=y
+# CONFIG_IDLE_INJECT is not set
+# CONFIG_DTPM is not set
+# CONFIG_MCB is not set
+
+#
+# Performance monitor support
+#
+# CONFIG_ARM_CCI_PMU is not set
+# CONFIG_ARM_CCN is not set
+# CONFIG_ARM_CMN is not set
+CONFIG_ARM_PMU=y
+# CONFIG_ARM_DSU_PMU is not set
+# CONFIG_QCOM_LLCC_PMU is not set
+# CONFIG_ARM_SPE_PMU is not set
+# end of Performance monitor support
+
+CONFIG_RAS=y
+# CONFIG_USB4 is not set
+
+#
+# Android
+#
+CONFIG_ANDROID=y
+CONFIG_ANDROID_BINDER_IPC=y
+CONFIG_ANDROID_BINDERFS=y
+CONFIG_ANDROID_BINDER_DEVICES="binder,hwbinder,vndbinder"
+# CONFIG_ANDROID_BINDER_IPC_SELFTEST is not set
+CONFIG_ANDROID_DEBUG_SYMBOLS=y
+CONFIG_ANDROID_VENDOR_HOOKS=y
+CONFIG_ANDROID_KABI_RESERVE=y
+CONFIG_ANDROID_VENDOR_OEM_DATA=y
+# end of Android
+
+CONFIG_TRACE_GPU_MEM=y
+CONFIG_LIBNVDIMM=y
+CONFIG_BLK_DEV_PMEM=y
+CONFIG_ND_BLK=y
+CONFIG_ND_CLAIM=y
+CONFIG_ND_BTT=y
+CONFIG_BTT=y
+CONFIG_OF_PMEM=y
+CONFIG_DAX_DRIVER=y
+CONFIG_DAX=y
+# CONFIG_DEV_DAX is not set
+CONFIG_NVMEM=y
+CONFIG_NVMEM_SYSFS=y
+CONFIG_QCOM_QFPROM=y
+CONFIG_NVMEM_SPMI_SDAM=y
+CONFIG_NVMEM_RMEM=y
+
+#
+# HW tracing support
+#
+# CONFIG_STM is not set
+# CONFIG_INTEL_TH is not set
+# end of HW tracing support
+
+# CONFIG_FPGA is not set
+# CONFIG_FSI is not set
+# CONFIG_TEE is not set
+CONFIG_PM_OPP=y
+# CONFIG_SIOX is not set
+# CONFIG_SLIMBUS is not set
+CONFIG_INTERCONNECT=y
+# CONFIG_INTERCONNECT_TEST is not set
+CONFIG_INTERCONNECT_QCOM=y
+CONFIG_INTERCONNECT_QCOM_QOS_RPM=y
+CONFIG_INTERCONNECT_QCOM_MONACO=y
+# CONFIG_INTERCONNECT_QCOM_MSM8916 is not set
+# CONFIG_INTERCONNECT_QCOM_MSM8939 is not set
+# CONFIG_INTERCONNECT_QCOM_MSM8974 is not set
+# CONFIG_INTERCONNECT_QCOM_OSM_L3 is not set
+# CONFIG_INTERCONNECT_QCOM_QCS404 is not set
+# CONFIG_INTERCONNECT_QCOM_EPSS_L3 is not set
+# CONFIG_INTERCONNECT_QCOM_SDM660 is not set
+# CONFIG_INTERCONNECT_QCOM_SCUBA is not set
+CONFIG_INTERCONNECT_QCOM_RPM=y
+# CONFIG_INTERCONNECT_QCOM_KALAMA is not set
+# CONFIG_INTERCONNECT_QCOM_CROW is not set
+# CONFIG_INTERCONNECT_QCOM_SDXBAAGHA is not set
+# CONFIG_INTERCONNECT_QCOM_BENGAL is not set
+# CONFIG_INTERCONNECT_QCOM_SA410M is not set
+# CONFIG_INTERCONNECT_QCOM_DEBUG is not set
+# CONFIG_COUNTER is not set
+# CONFIG_MOST is not set
+# end of Device Drivers
+
+#
+# File systems
+#
+CONFIG_DCACHE_WORD_ACCESS=y
+# CONFIG_VALIDATE_FS_PARSER is not set
+CONFIG_FS_IOMAP=y
+# CONFIG_EXT2_FS is not set
+# CONFIG_EXT3_FS is not set
+CONFIG_EXT4_FS=y
+CONFIG_EXT4_USE_FOR_EXT2=y
+CONFIG_EXT4_FS_POSIX_ACL=y
+CONFIG_EXT4_FS_SECURITY=y
+# CONFIG_EXT4_DEBUG is not set
+CONFIG_JBD2=y
+# CONFIG_JBD2_DEBUG is not set
+CONFIG_FS_MBCACHE=y
+# CONFIG_REISERFS_FS is not set
+# CONFIG_JFS_FS is not set
+# CONFIG_XFS_FS is not set
+# CONFIG_GFS2_FS is not set
+# CONFIG_OCFS2_FS is not set
+# CONFIG_BTRFS_FS is not set
+# CONFIG_NILFS2_FS is not set
+CONFIG_F2FS_FS=y
+CONFIG_F2FS_STAT_FS=y
+CONFIG_F2FS_FS_XATTR=y
+CONFIG_F2FS_FS_POSIX_ACL=y
+CONFIG_F2FS_FS_SECURITY=y
+# CONFIG_F2FS_CHECK_FS is not set
+# CONFIG_F2FS_FAULT_INJECTION is not set
+CONFIG_F2FS_FS_COMPRESSION=y
+CONFIG_F2FS_FS_LZO=y
+CONFIG_F2FS_FS_LZORLE=y
+CONFIG_F2FS_FS_LZ4=y
+CONFIG_F2FS_FS_LZ4HC=y
+CONFIG_F2FS_FS_ZSTD=y
+CONFIG_F2FS_IOSTAT=y
+CONFIG_F2FS_UNFAIR_RWSEM=y
+# CONFIG_FS_DAX is not set
+CONFIG_FS_POSIX_ACL=y
+CONFIG_EXPORTFS=y
+# CONFIG_EXPORTFS_BLOCK_OPS is not set
+CONFIG_FILE_LOCKING=y
+CONFIG_FS_ENCRYPTION=y
+CONFIG_FS_ENCRYPTION_ALGS=y
+CONFIG_FS_ENCRYPTION_INLINE_CRYPT=y
+CONFIG_FS_VERITY=y
+# CONFIG_FS_VERITY_DEBUG is not set
+CONFIG_FS_VERITY_BUILTIN_SIGNATURES=y
+CONFIG_FSNOTIFY=y
+# CONFIG_DNOTIFY is not set
+CONFIG_INOTIFY_USER=y
+# CONFIG_FANOTIFY is not set
+CONFIG_QUOTA=y
+# CONFIG_QUOTA_NETLINK_INTERFACE is not set
+CONFIG_PRINT_QUOTA_WARNING=y
+# CONFIG_QUOTA_DEBUG is not set
+CONFIG_QUOTA_TREE=y
+# CONFIG_QFMT_V1 is not set
+CONFIG_QFMT_V2=y
+CONFIG_QUOTACTL=y
+# CONFIG_AUTOFS4_FS is not set
+# CONFIG_AUTOFS_FS is not set
+CONFIG_FUSE_FS=y
+# CONFIG_CUSE is not set
+CONFIG_VIRTIO_FS=y
+CONFIG_FUSE_BPF=y
+CONFIG_OVERLAY_FS=y
+# CONFIG_OVERLAY_FS_REDIRECT_DIR is not set
+CONFIG_OVERLAY_FS_REDIRECT_ALWAYS_FOLLOW=y
+# CONFIG_OVERLAY_FS_INDEX is not set
+# CONFIG_OVERLAY_FS_XINO_AUTO is not set
+# CONFIG_OVERLAY_FS_METACOPY is not set
+CONFIG_INCREMENTAL_FS=y
+
+#
+# Caches
+#
+# CONFIG_FSCACHE is not set
+# end of Caches
+
+#
+# CD-ROM/DVD Filesystems
+#
+# CONFIG_ISO9660_FS is not set
+# CONFIG_UDF_FS is not set
+# end of CD-ROM/DVD Filesystems
+
+#
+# DOS/FAT/EXFAT/NT Filesystems
+#
+CONFIG_FAT_FS=y
+CONFIG_MSDOS_FS=y
+CONFIG_VFAT_FS=y
+CONFIG_FAT_DEFAULT_CODEPAGE=437
+CONFIG_FAT_DEFAULT_IOCHARSET="iso8859-1"
+# CONFIG_FAT_DEFAULT_UTF8 is not set
+CONFIG_EXFAT_FS=y
+CONFIG_EXFAT_DEFAULT_IOCHARSET="utf8"
+# CONFIG_NTFS_FS is not set
+# CONFIG_NTFS3_FS is not set
+# end of DOS/FAT/EXFAT/NT Filesystems
+
+#
+# Pseudo filesystems
+#
+CONFIG_PROC_FS=y
+# CONFIG_PROC_KCORE is not set
+CONFIG_PROC_SYSCTL=y
+CONFIG_PROC_PAGE_MONITOR=y
+# CONFIG_PROC_CHILDREN is not set
+CONFIG_KERNFS=y
+CONFIG_SYSFS=y
+CONFIG_TMPFS=y
+CONFIG_TMPFS_POSIX_ACL=y
+CONFIG_TMPFS_XATTR=y
+# CONFIG_TMPFS_INODE64 is not set
+CONFIG_ARCH_SUPPORTS_HUGETLBFS=y
+# CONFIG_HUGETLBFS is not set
+CONFIG_MEMFD_CREATE=y
+CONFIG_ARCH_HAS_GIGANTIC_PAGE=y
+CONFIG_CONFIGFS_FS=y
+# CONFIG_EFIVAR_FS is not set
+# end of Pseudo filesystems
+
+CONFIG_MISC_FILESYSTEMS=y
+# CONFIG_ORANGEFS_FS is not set
+# CONFIG_ADFS_FS is not set
+# CONFIG_AFFS_FS is not set
+# CONFIG_ECRYPT_FS is not set
+# CONFIG_HFS_FS is not set
+# CONFIG_HFSPLUS_FS is not set
+# CONFIG_BEFS_FS is not set
+# CONFIG_BFS_FS is not set
+# CONFIG_EFS_FS is not set
+# CONFIG_CRAMFS is not set
+# CONFIG_SQUASHFS is not set
+# CONFIG_VXFS_FS is not set
+# CONFIG_MINIX_FS is not set
+# CONFIG_OMFS_FS is not set
+# CONFIG_HPFS_FS is not set
+# CONFIG_QNX4FS_FS is not set
+# CONFIG_QNX6FS_FS is not set
+# CONFIG_ROMFS_FS is not set
+CONFIG_PSTORE=y
+CONFIG_PSTORE_DEFAULT_KMSG_BYTES=10240
+CONFIG_PSTORE_DEFLATE_COMPRESS=y
+# CONFIG_PSTORE_LZO_COMPRESS is not set
+# CONFIG_PSTORE_LZ4_COMPRESS is not set
+# CONFIG_PSTORE_LZ4HC_COMPRESS is not set
+# CONFIG_PSTORE_842_COMPRESS is not set
+# CONFIG_PSTORE_ZSTD_COMPRESS is not set
+CONFIG_PSTORE_COMPRESS=y
+CONFIG_PSTORE_DEFLATE_COMPRESS_DEFAULT=y
+CONFIG_PSTORE_COMPRESS_DEFAULT="deflate"
+CONFIG_PSTORE_CONSOLE=y
+CONFIG_PSTORE_PMSG=y
+CONFIG_PSTORE_RAM=y
+# CONFIG_PSTORE_BLK is not set
+# CONFIG_SYSV_FS is not set
+# CONFIG_UFS_FS is not set
+CONFIG_EROFS_FS=y
+# CONFIG_EROFS_FS_DEBUG is not set
+CONFIG_EROFS_FS_XATTR=y
+CONFIG_EROFS_FS_POSIX_ACL=y
+CONFIG_EROFS_FS_SECURITY=y
+CONFIG_EROFS_FS_ZIP=y
+# CONFIG_EROFS_FS_ZIP_LZMA is not set
+CONFIG_EROFS_FS_PCPU_KTHREAD=y
+CONFIG_EROFS_FS_PCPU_KTHREAD_HIPRI=y
+CONFIG_NETWORK_FILESYSTEMS=y
+# CONFIG_NFS_FS is not set
+# CONFIG_NFSD is not set
+# CONFIG_CEPH_FS is not set
+# CONFIG_CIFS is not set
+# CONFIG_SMB_SERVER is not set
+# CONFIG_CODA_FS is not set
+# CONFIG_AFS_FS is not set
+CONFIG_NLS=y
+CONFIG_NLS_DEFAULT="iso8859-1"
+CONFIG_NLS_CODEPAGE_437=y
+CONFIG_NLS_CODEPAGE_737=y
+CONFIG_NLS_CODEPAGE_775=y
+CONFIG_NLS_CODEPAGE_850=y
+CONFIG_NLS_CODEPAGE_852=y
+CONFIG_NLS_CODEPAGE_855=y
+CONFIG_NLS_CODEPAGE_857=y
+CONFIG_NLS_CODEPAGE_860=y
+CONFIG_NLS_CODEPAGE_861=y
+CONFIG_NLS_CODEPAGE_862=y
+CONFIG_NLS_CODEPAGE_863=y
+CONFIG_NLS_CODEPAGE_864=y
+CONFIG_NLS_CODEPAGE_865=y
+CONFIG_NLS_CODEPAGE_866=y
+CONFIG_NLS_CODEPAGE_869=y
+CONFIG_NLS_CODEPAGE_936=y
+CONFIG_NLS_CODEPAGE_950=y
+CONFIG_NLS_CODEPAGE_932=y
+CONFIG_NLS_CODEPAGE_949=y
+CONFIG_NLS_CODEPAGE_874=y
+CONFIG_NLS_ISO8859_8=y
+CONFIG_NLS_CODEPAGE_1250=y
+CONFIG_NLS_CODEPAGE_1251=y
+CONFIG_NLS_ASCII=y
+CONFIG_NLS_ISO8859_1=y
+CONFIG_NLS_ISO8859_2=y
+CONFIG_NLS_ISO8859_3=y
+CONFIG_NLS_ISO8859_4=y
+CONFIG_NLS_ISO8859_5=y
+CONFIG_NLS_ISO8859_6=y
+CONFIG_NLS_ISO8859_7=y
+CONFIG_NLS_ISO8859_9=y
+CONFIG_NLS_ISO8859_13=y
+CONFIG_NLS_ISO8859_14=y
+CONFIG_NLS_ISO8859_15=y
+CONFIG_NLS_KOI8_R=y
+CONFIG_NLS_KOI8_U=y
+CONFIG_NLS_MAC_ROMAN=y
+CONFIG_NLS_MAC_CELTIC=y
+CONFIG_NLS_MAC_CENTEURO=y
+CONFIG_NLS_MAC_CROATIAN=y
+CONFIG_NLS_MAC_CYRILLIC=y
+CONFIG_NLS_MAC_GAELIC=y
+CONFIG_NLS_MAC_GREEK=y
+CONFIG_NLS_MAC_ICELAND=y
+CONFIG_NLS_MAC_INUIT=y
+CONFIG_NLS_MAC_ROMANIAN=y
+CONFIG_NLS_MAC_TURKISH=y
+CONFIG_NLS_UTF8=y
+# CONFIG_DLM is not set
+CONFIG_UNICODE=y
+# CONFIG_UNICODE_NORMALIZATION_SELFTEST is not set
+CONFIG_IO_WQ=y
+# end of File systems
+
+#
+# Security options
+#
+CONFIG_KEYS=y
+# CONFIG_KEYS_REQUEST_CACHE is not set
+# CONFIG_PERSISTENT_KEYRINGS is not set
+# CONFIG_BIG_KEYS is not set
+# CONFIG_ENCRYPTED_KEYS is not set
+# CONFIG_KEY_DH_OPERATIONS is not set
+# CONFIG_SECURITY_DMESG_RESTRICT is not set
+CONFIG_SECURITY=y
+CONFIG_SECURITYFS=y
+CONFIG_SECURITY_NETWORK=y
+# CONFIG_SECURITY_NETWORK_XFRM is not set
+# CONFIG_SECURITY_PATH is not set
+CONFIG_LSM_MMAP_MIN_ADDR=32768
+CONFIG_HAVE_HARDENED_USERCOPY_ALLOCATOR=y
+CONFIG_HARDENED_USERCOPY=y
+# CONFIG_HARDENED_USERCOPY_FALLBACK is not set
+# CONFIG_HARDENED_USERCOPY_PAGESPAN is not set
+# CONFIG_FORTIFY_SOURCE is not set
+CONFIG_STATIC_USERMODEHELPER=y
+CONFIG_STATIC_USERMODEHELPER_PATH=""
+CONFIG_SECURITY_SELINUX=y
+# CONFIG_SECURITY_SELINUX_BOOTPARAM is not set
+# CONFIG_SECURITY_SELINUX_DISABLE is not set
+CONFIG_SECURITY_SELINUX_DEVELOP=y
+CONFIG_SECURITY_SELINUX_AVC_STATS=y
+CONFIG_SECURITY_SELINUX_CHECKREQPROT_VALUE=0
+CONFIG_SECURITY_SELINUX_SIDTAB_HASH_BITS=9
+CONFIG_SECURITY_SELINUX_SID2STR_CACHE_SIZE=256
+# CONFIG_SECURITY_SMACK is not set
+# CONFIG_SECURITY_TOMOYO is not set
+# CONFIG_SECURITY_APPARMOR is not set
+# CONFIG_SECURITY_LOADPIN is not set
+# CONFIG_SECURITY_YAMA is not set
+# CONFIG_SECURITY_SAFESETID is not set
+# CONFIG_SECURITY_LOCKDOWN_LSM is not set
+# CONFIG_SECURITY_LANDLOCK is not set
+CONFIG_INTEGRITY=y
+# CONFIG_INTEGRITY_SIGNATURE is not set
+CONFIG_INTEGRITY_AUDIT=y
+# CONFIG_IMA is not set
+# CONFIG_IMA_SECURE_AND_OR_TRUSTED_BOOT is not set
+# CONFIG_EVM is not set
+CONFIG_DEFAULT_SECURITY_SELINUX=y
+# CONFIG_DEFAULT_SECURITY_DAC is not set
+CONFIG_LSM="landlock,lockdown,yama,loadpin,safesetid,integrity,selinux,smack,tomoyo,apparmor,bpf"
+
+#
+# Kernel hardening options
+#
+
+#
+# Memory initialization
+#
+CONFIG_INIT_STACK_NONE=y
+# CONFIG_GCC_PLUGIN_STRUCTLEAK_USER is not set
+# CONFIG_GCC_PLUGIN_STACKLEAK is not set
+CONFIG_INIT_ON_ALLOC_DEFAULT_ON=y
+# CONFIG_INIT_ON_FREE_DEFAULT_ON is not set
+CONFIG_CC_HAS_ZERO_CALL_USED_REGS=y
+# CONFIG_ZERO_CALL_USED_REGS is not set
+# end of Memory initialization
+# end of Kernel hardening options
+# end of Security options
+
+CONFIG_CRYPTO=y
+
+#
+# Crypto core or helper
+#
+CONFIG_CRYPTO_FIPS140=y
+CONFIG_CRYPTO_ALGAPI=y
+CONFIG_CRYPTO_ALGAPI2=y
+CONFIG_CRYPTO_AEAD=y
+CONFIG_CRYPTO_AEAD2=y
+CONFIG_CRYPTO_SKCIPHER=y
+CONFIG_CRYPTO_SKCIPHER2=y
+CONFIG_CRYPTO_HASH=y
+CONFIG_CRYPTO_HASH2=y
+CONFIG_CRYPTO_RNG=y
+CONFIG_CRYPTO_RNG2=y
+CONFIG_CRYPTO_RNG_DEFAULT=y
+CONFIG_CRYPTO_AKCIPHER2=y
+CONFIG_CRYPTO_AKCIPHER=y
+CONFIG_CRYPTO_KPP2=y
+CONFIG_CRYPTO_KPP=y
+CONFIG_CRYPTO_ACOMP2=y
+CONFIG_CRYPTO_MANAGER=y
+CONFIG_CRYPTO_MANAGER2=y
+# CONFIG_CRYPTO_USER is not set
+CONFIG_CRYPTO_MANAGER_DISABLE_TESTS=y
+CONFIG_CRYPTO_GF128MUL=y
+CONFIG_CRYPTO_NULL=y
+CONFIG_CRYPTO_NULL2=y
+# CONFIG_CRYPTO_PCRYPT is not set
+# CONFIG_CRYPTO_CRYPTD is not set
+CONFIG_CRYPTO_AUTHENC=y
+# CONFIG_CRYPTO_TEST is not set
+CONFIG_CRYPTO_ENGINE=y
+
+#
+# Public-key cryptography
+#
+CONFIG_CRYPTO_RSA=y
+# CONFIG_CRYPTO_DH is not set
+CONFIG_CRYPTO_ECC=y
+CONFIG_CRYPTO_ECDH=y
+# CONFIG_CRYPTO_ECDSA is not set
+# CONFIG_CRYPTO_ECRDSA is not set
+# CONFIG_CRYPTO_SM2 is not set
+# CONFIG_CRYPTO_CURVE25519 is not set
+
+#
+# Authenticated Encryption with Associated Data
+#
+CONFIG_CRYPTO_CCM=y
+CONFIG_CRYPTO_GCM=y
+CONFIG_CRYPTO_CHACHA20POLY1305=y
+# CONFIG_CRYPTO_AEGIS128 is not set
+CONFIG_CRYPTO_SEQIV=y
+CONFIG_CRYPTO_ECHAINIV=y
+
+#
+# Block modes
+#
+CONFIG_CRYPTO_CBC=y
+# CONFIG_CRYPTO_CFB is not set
+CONFIG_CRYPTO_CTR=y
+CONFIG_CRYPTO_CTS=y
+CONFIG_CRYPTO_ECB=y
+# CONFIG_CRYPTO_LRW is not set
+# CONFIG_CRYPTO_OFB is not set
+# CONFIG_CRYPTO_PCBC is not set
+CONFIG_CRYPTO_XTS=y
+# CONFIG_CRYPTO_KEYWRAP is not set
+CONFIG_CRYPTO_NHPOLY1305=y
+CONFIG_CRYPTO_ADIANTUM=y
+# CONFIG_CRYPTO_HCTR2 is not set
+CONFIG_CRYPTO_ESSIV=y
+
+#
+# Hash modes
+#
+CONFIG_CRYPTO_CMAC=y
+CONFIG_CRYPTO_HMAC=y
+CONFIG_CRYPTO_XCBC=y
+# CONFIG_CRYPTO_VMAC is not set
+
+#
+# Digest
+#
+CONFIG_CRYPTO_CRC32C=y
+CONFIG_CRYPTO_CRC32=y
+# CONFIG_CRYPTO_XXHASH is not set
+CONFIG_CRYPTO_BLAKE2B=y
+# CONFIG_CRYPTO_CRCT10DIF is not set
+CONFIG_CRYPTO_GHASH=y
+CONFIG_CRYPTO_POLY1305=y
+# CONFIG_CRYPTO_MD4 is not set
+CONFIG_CRYPTO_MD5=y
+# CONFIG_CRYPTO_MICHAEL_MIC is not set
+# CONFIG_CRYPTO_RMD160 is not set
+CONFIG_CRYPTO_SHA1=y
+CONFIG_CRYPTO_SHA256=y
+CONFIG_CRYPTO_SHA512=y
+# CONFIG_CRYPTO_SHA3 is not set
+# CONFIG_CRYPTO_SM3 is not set
+# CONFIG_CRYPTO_STREEBOG is not set
+# CONFIG_CRYPTO_WP512 is not set
+
+#
+# Ciphers
+#
+CONFIG_CRYPTO_AES=y
+# CONFIG_CRYPTO_AES_TI is not set
+# CONFIG_CRYPTO_BLOWFISH is not set
+# CONFIG_CRYPTO_CAMELLIA is not set
+# CONFIG_CRYPTO_CAST5 is not set
+# CONFIG_CRYPTO_CAST6 is not set
+CONFIG_CRYPTO_DES=y
+# CONFIG_CRYPTO_FCRYPT is not set
+CONFIG_CRYPTO_CHACHA20=y
+# CONFIG_CRYPTO_SERPENT is not set
+# CONFIG_CRYPTO_SM4 is not set
+# CONFIG_CRYPTO_TWOFISH is not set
+
+#
+# Compression
+#
+CONFIG_CRYPTO_DEFLATE=y
+CONFIG_CRYPTO_LZO=y
+# CONFIG_CRYPTO_842 is not set
+CONFIG_CRYPTO_LZ4=y
+# CONFIG_CRYPTO_LZ4HC is not set
+CONFIG_CRYPTO_ZSTD=y
+
+#
+# Random Number Generation
+#
+CONFIG_CRYPTO_ANSI_CPRNG=y
+CONFIG_CRYPTO_DRBG_MENU=y
+CONFIG_CRYPTO_DRBG_HMAC=y
+# CONFIG_CRYPTO_DRBG_HASH is not set
+# CONFIG_CRYPTO_DRBG_CTR is not set
+CONFIG_CRYPTO_DRBG=y
+CONFIG_CRYPTO_JITTERENTROPY=y
+# CONFIG_CRYPTO_USER_API_HASH is not set
+# CONFIG_CRYPTO_USER_API_SKCIPHER is not set
+# CONFIG_CRYPTO_USER_API_RNG is not set
+# CONFIG_CRYPTO_USER_API_AEAD is not set
+CONFIG_CRYPTO_HASH_INFO=y
+CONFIG_CRYPTO_HW=y
+# CONFIG_CRYPTO_DEV_ATMEL_ECC is not set
+# CONFIG_CRYPTO_DEV_ATMEL_SHA204A is not set
+# CONFIG_CRYPTO_DEV_CCP is not set
+# CONFIG_CRYPTO_DEV_NITROX_CNN55XX is not set
+# CONFIG_CRYPTO_DEV_CAVIUM_ZIP is not set
+# CONFIG_CRYPTO_DEV_QCE is not set
+# CONFIG_CRYPTO_DEV_QCEDEV is not set
+# CONFIG_CRYPTO_DEV_QCOM_MSM_QCE is not set
+# CONFIG_CRYPTO_DEV_QCOM_RNG is not set
+# CONFIG_CRYPTO_DEV_VIRTIO is not set
+# CONFIG_CRYPTO_DEV_SAFEXCEL is not set
+# CONFIG_CRYPTO_DEV_CCREE is not set
+# CONFIG_CRYPTO_DEV_HISI_SEC is not set
+# CONFIG_CRYPTO_DEV_AMLOGIC_GXL is not set
+CONFIG_ASYMMETRIC_KEY_TYPE=y
+CONFIG_ASYMMETRIC_PUBLIC_KEY_SUBTYPE=y
+CONFIG_X509_CERTIFICATE_PARSER=y
+# CONFIG_PKCS8_PRIVATE_KEY_PARSER is not set
+CONFIG_PKCS7_MESSAGE_PARSER=y
+# CONFIG_PKCS7_TEST_KEY is not set
+# CONFIG_SIGNED_PE_FILE_VERIFICATION is not set
+
+#
+# Certificates for signature checking
+#
+CONFIG_MODULE_SIG_KEY="certs/signing_key.pem"
+CONFIG_MODULE_SIG_KEY_TYPE_RSA=y
+# CONFIG_MODULE_SIG_KEY_TYPE_ECDSA is not set
+CONFIG_SYSTEM_TRUSTED_KEYRING=y
+CONFIG_SYSTEM_TRUSTED_KEYS=""
+# CONFIG_SYSTEM_EXTRA_CERTIFICATE is not set
+# CONFIG_SECONDARY_TRUSTED_KEYRING is not set
+# CONFIG_SYSTEM_BLACKLIST_KEYRING is not set
+# end of Certificates for signature checking
+
+CONFIG_BINARY_PRINTF=y
+
+#
+# Library routines
+#
+CONFIG_LINEAR_RANGES=y
+# CONFIG_PACKING is not set
+CONFIG_BITREVERSE=y
+CONFIG_HAVE_ARCH_BITREVERSE=y
+CONFIG_GENERIC_STRNCPY_FROM_USER=y
+CONFIG_GENERIC_STRNLEN_USER=y
+CONFIG_GENERIC_NET_UTILS=y
+CONFIG_GENERIC_FIND_FIRST_BIT=y
+# CONFIG_CORDIC is not set
+# CONFIG_PRIME_NUMBERS is not set
+CONFIG_RATIONAL=y
+CONFIG_GENERIC_PCI_IOMAP=y
+CONFIG_ARCH_USE_CMPXCHG_LOCKREF=y
+CONFIG_ARCH_HAS_FAST_MULTIPLIER=y
+CONFIG_ARCH_USE_SYM_ANNOTATIONS=y
+# CONFIG_INDIRECT_PIO is not set
+
+#
+# Crypto library routines
+#
+CONFIG_CRYPTO_LIB_AES=y
+CONFIG_CRYPTO_LIB_ARC4=y
+CONFIG_CRYPTO_LIB_BLAKE2S_GENERIC=y
+CONFIG_CRYPTO_ARCH_HAVE_LIB_CHACHA=y
+CONFIG_CRYPTO_LIB_CHACHA_GENERIC=y
+CONFIG_CRYPTO_LIB_CHACHA=y
+CONFIG_CRYPTO_LIB_CURVE25519_GENERIC=y
+CONFIG_CRYPTO_LIB_CURVE25519=y
+CONFIG_CRYPTO_LIB_DES=y
+CONFIG_CRYPTO_LIB_POLY1305_RSIZE=9
+CONFIG_CRYPTO_ARCH_HAVE_LIB_POLY1305=y
+CONFIG_CRYPTO_LIB_POLY1305_GENERIC=y
+CONFIG_CRYPTO_LIB_POLY1305=y
+CONFIG_CRYPTO_LIB_CHACHA20POLY1305=y
+CONFIG_CRYPTO_LIB_SHA256=y
+# end of Crypto library routines
+
+CONFIG_LIB_MEMNEQ=y
+CONFIG_TRACE_MMIO_ACCESS=y
+CONFIG_CRC_CCITT=y
+CONFIG_CRC16=y
+# CONFIG_CRC_T10DIF is not set
+# CONFIG_CRC_ITU_T is not set
+CONFIG_CRC32=y
+# CONFIG_CRC32_SELFTEST is not set
+CONFIG_CRC32_SLICEBY8=y
+# CONFIG_CRC32_SLICEBY4 is not set
+# CONFIG_CRC32_SARWATE is not set
+# CONFIG_CRC32_BIT is not set
+# CONFIG_CRC64 is not set
+# CONFIG_CRC4 is not set
+# CONFIG_CRC7 is not set
+CONFIG_LIBCRC32C=y
+CONFIG_CRC8=y
+CONFIG_XXHASH=y
+CONFIG_AUDIT_GENERIC=y
+CONFIG_AUDIT_ARCH_COMPAT_GENERIC=y
+CONFIG_AUDIT_COMPAT_GENERIC=y
+# CONFIG_RANDOM32_SELFTEST is not set
+CONFIG_ZLIB_INFLATE=y
+CONFIG_ZLIB_DEFLATE=y
+CONFIG_LZO_COMPRESS=y
+CONFIG_LZO_DECOMPRESS=y
+CONFIG_LZ4_COMPRESS=y
+CONFIG_LZ4HC_COMPRESS=y
+CONFIG_LZ4_DECOMPRESS=y
+CONFIG_ZSTD_COMPRESS=y
+CONFIG_ZSTD_DECOMPRESS=y
+CONFIG_XZ_DEC=y
+CONFIG_XZ_DEC_X86=y
+CONFIG_XZ_DEC_POWERPC=y
+CONFIG_XZ_DEC_IA64=y
+CONFIG_XZ_DEC_ARM=y
+CONFIG_XZ_DEC_ARMTHUMB=y
+CONFIG_XZ_DEC_SPARC=y
+# CONFIG_XZ_DEC_MICROLZMA is not set
+CONFIG_XZ_DEC_BCJ=y
+# CONFIG_XZ_DEC_TEST is not set
+CONFIG_DECOMPRESS_GZIP=y
+CONFIG_DECOMPRESS_LZ4=y
+CONFIG_DECOMPRESS_ZSTD=y
+CONFIG_GENERIC_ALLOCATOR=y
+CONFIG_REED_SOLOMON=y
+CONFIG_REED_SOLOMON_ENC8=y
+CONFIG_REED_SOLOMON_DEC8=y
+CONFIG_TEXTSEARCH=y
+CONFIG_TEXTSEARCH_KMP=y
+CONFIG_TEXTSEARCH_BM=y
+CONFIG_TEXTSEARCH_FSM=y
+CONFIG_INTERVAL_TREE=y
+CONFIG_XARRAY_MULTI=y
+CONFIG_ASSOCIATIVE_ARRAY=y
+CONFIG_HAS_IOMEM=y
+CONFIG_HAS_IOPORT_MAP=y
+CONFIG_HAS_DMA=y
+CONFIG_DMA_OPS=y
+CONFIG_NEED_SG_DMA_LENGTH=y
+CONFIG_NEED_DMA_MAP_STATE=y
+CONFIG_ARCH_DMA_ADDR_T_64BIT=y
+CONFIG_DMA_DECLARE_COHERENT=y
+CONFIG_ARCH_HAS_SETUP_DMA_OPS=y
+CONFIG_ARCH_HAS_TEARDOWN_DMA_OPS=y
+CONFIG_ARCH_HAS_SYNC_DMA_FOR_DEVICE=y
+CONFIG_ARCH_HAS_SYNC_DMA_FOR_CPU=y
+CONFIG_ARCH_HAS_DMA_PREP_COHERENT=y
+CONFIG_SWIOTLB=y
+CONFIG_DMA_RESTRICTED_POOL=y
+# CONFIG_SWIOTLB_NONLINEAR is not set
+CONFIG_DMA_NONCOHERENT_MMAP=y
+CONFIG_DMA_COHERENT_POOL=y
+CONFIG_DMA_REMAP=y
+CONFIG_DMA_DIRECT_REMAP=y
+CONFIG_DMA_CMA=y
+# CONFIG_DMA_PERNUMA_CMA is not set
+
+#
+# Default contiguous memory area size:
+#
+CONFIG_CMA_SIZE_MBYTES=16
+CONFIG_CMA_SIZE_SEL_MBYTES=y
+# CONFIG_CMA_SIZE_SEL_PERCENTAGE is not set
+# CONFIG_CMA_SIZE_SEL_MIN is not set
+# CONFIG_CMA_SIZE_SEL_MAX is not set
+CONFIG_CMA_ALIGNMENT=8
+# CONFIG_DMA_API_DEBUG is not set
+# CONFIG_DMA_MAP_BENCHMARK is not set
+CONFIG_SGL_ALLOC=y
+CONFIG_CPU_RMAP=y
+CONFIG_DQL=y
+CONFIG_GLOB=y
+# CONFIG_GLOB_SELFTEST is not set
+CONFIG_NLATTR=y
+CONFIG_CLZ_TAB=y
+# CONFIG_IRQ_POLL is not set
+CONFIG_MPILIB=y
+CONFIG_LIBFDT=y
+CONFIG_OID_REGISTRY=y
+CONFIG_UCS2_STRING=y
+CONFIG_HAVE_GENERIC_VDSO=y
+CONFIG_GENERIC_GETTIMEOFDAY=y
+CONFIG_GENERIC_VDSO_TIME_NS=y
+CONFIG_FONT_SUPPORT=y
+CONFIG_FONT_8x16=y
+CONFIG_FONT_AUTOSELECT=y
+CONFIG_SG_POOL=y
+CONFIG_MEMREGION=y
+CONFIG_ARCH_STACKWALK=y
+CONFIG_STACKDEPOT=y
+CONFIG_STACK_HASH_ORDER=12
+CONFIG_SBITMAP=y
+# end of Library routines
+
+CONFIG_GENERIC_LIB_DEVMEM_IS_ALLOWED=y
+
+#
+# Kernel hacking
+#
+
+#
+# printk and dmesg options
+#
+CONFIG_PRINTK_TIME=y
+CONFIG_PRINTK_CALLER=y
+# CONFIG_STACKTRACE_BUILD_ID is not set
+CONFIG_CONSOLE_LOGLEVEL_DEFAULT=7
+CONFIG_CONSOLE_LOGLEVEL_QUIET=4
+CONFIG_MESSAGE_LOGLEVEL_DEFAULT=4
+# CONFIG_BOOT_PRINTK_DELAY is not set
+# CONFIG_DYNAMIC_DEBUG is not set
+CONFIG_DYNAMIC_DEBUG_CORE=y
+CONFIG_SYMBOLIC_ERRNAME=y
+CONFIG_DEBUG_BUGVERBOSE=y
+# end of printk and dmesg options
+
+CONFIG_AS_HAS_NON_CONST_LEB128=y
+
+#
+# Compile-time checks and compiler options
+#
+# CONFIG_DEBUG_INFO is not set
+CONFIG_FRAME_WARN=2048
+# CONFIG_STRIP_ASM_SYMS is not set
+# CONFIG_READABLE_ASM is not set
+CONFIG_HEADERS_INSTALL=y
+# CONFIG_DEBUG_SECTION_MISMATCH is not set
+# CONFIG_SECTION_MISMATCH_WARN_ONLY is not set
+# CONFIG_DEBUG_FORCE_FUNCTION_ALIGN_64B is not set
+CONFIG_ARCH_WANT_FRAME_POINTERS=y
+CONFIG_FRAME_POINTER=y
+# CONFIG_VMLINUX_MAP is not set
+# CONFIG_DEBUG_FORCE_WEAK_PER_CPU is not set
+# end of Compile-time checks and compiler options
+
+#
+# Generic Kernel Debugging Instruments
+#
+CONFIG_MAGIC_SYSRQ=y
+CONFIG_MAGIC_SYSRQ_DEFAULT_ENABLE=0x1
+CONFIG_MAGIC_SYSRQ_SERIAL=y
+CONFIG_MAGIC_SYSRQ_SERIAL_SEQUENCE=""
+CONFIG_DEBUG_FS=y
+CONFIG_DEBUG_FS_ALLOW_ALL=y
+# CONFIG_DEBUG_FS_DISALLOW_MOUNT is not set
+# CONFIG_DEBUG_FS_ALLOW_NONE is not set
+CONFIG_HAVE_ARCH_KGDB=y
+# CONFIG_KGDB is not set
+CONFIG_ARCH_HAS_UBSAN_SANITIZE_ALL=y
+CONFIG_UBSAN=y
+CONFIG_UBSAN_TRAP=y
+CONFIG_CC_HAS_UBSAN_BOUNDS=y
+CONFIG_UBSAN_BOUNDS=y
+CONFIG_UBSAN_ONLY_BOUNDS=y
+# CONFIG_UBSAN_SHIFT is not set
+# CONFIG_UBSAN_DIV_ZERO is not set
+# CONFIG_UBSAN_UNREACHABLE is not set
+# CONFIG_UBSAN_BOOL is not set
+# CONFIG_UBSAN_ENUM is not set
+CONFIG_UBSAN_SANITIZE_ALL=y
+# CONFIG_TEST_UBSAN is not set
+CONFIG_HAVE_KCSAN_COMPILER=y
+# end of Generic Kernel Debugging Instruments
+
+CONFIG_DEBUG_KERNEL=y
+CONFIG_DEBUG_MISC=y
+
+#
+# Memory Debugging
+#
+CONFIG_PAGE_EXTENSION=y
+# CONFIG_DEBUG_PAGEALLOC is not set
+CONFIG_PAGE_OWNER=y
+CONFIG_PAGE_PINNER=y
+# CONFIG_PAGE_POISONING is not set
+# CONFIG_DEBUG_PAGE_REF is not set
+# CONFIG_DEBUG_RODATA_TEST is not set
+CONFIG_ARCH_HAS_DEBUG_WX=y
+# CONFIG_DEBUG_WX is not set
+CONFIG_GENERIC_PTDUMP=y
+# CONFIG_PTDUMP_DEBUGFS is not set
+# CONFIG_SPECULATIVE_PAGE_FAULT_STATS is not set
+# CONFIG_DEBUG_OBJECTS is not set
+# CONFIG_SLUB_DEBUG_ON is not set
+# CONFIG_SLUB_STATS is not set
+CONFIG_HAVE_DEBUG_KMEMLEAK=y
+# CONFIG_DEBUG_KMEMLEAK is not set
+CONFIG_DEBUG_STACK_USAGE=y
+# CONFIG_SCHED_STACK_END_CHECK is not set
+CONFIG_ARCH_HAS_DEBUG_VM_PGTABLE=y
+# CONFIG_DEBUG_VM is not set
+# CONFIG_DEBUG_VM_PGTABLE is not set
+CONFIG_ARCH_HAS_DEBUG_VIRTUAL=y
+# CONFIG_DEBUG_VIRTUAL is not set
+CONFIG_DEBUG_MEMORY_INIT=y
+# CONFIG_DEBUG_PER_CPU_MAPS is not set
+CONFIG_HAVE_ARCH_KASAN=y
+CONFIG_HAVE_ARCH_KASAN_SW_TAGS=y
+CONFIG_HAVE_ARCH_KASAN_HW_TAGS=y
+CONFIG_HAVE_ARCH_KASAN_VMALLOC=y
+CONFIG_CC_HAS_KASAN_GENERIC=y
+CONFIG_CC_HAS_KASAN_SW_TAGS=y
+CONFIG_CC_HAS_WORKING_NOSANITIZE_ADDRESS=y
+CONFIG_KASAN=y
+CONFIG_KASAN_GENERIC=y
+# CONFIG_KASAN_SW_TAGS is not set
+# CONFIG_KASAN_HW_TAGS is not set
+CONFIG_KASAN_OUTLINE=y
+# CONFIG_KASAN_INLINE is not set
+CONFIG_KASAN_STACK=y
+CONFIG_KASAN_VMALLOC=y
+# CONFIG_KASAN_MODULE_TEST is not set
+CONFIG_HAVE_ARCH_KFENCE=y
+CONFIG_KFENCE=y
+CONFIG_KFENCE_SAMPLE_INTERVAL=500
+CONFIG_KFENCE_NUM_OBJECTS=63
+CONFIG_KFENCE_STATIC_KEYS=y
+CONFIG_KFENCE_STRESS_TEST_FAULTS=0
+# end of Memory Debugging
+
+# CONFIG_DEBUG_SHIRQ is not set
+
+#
+# Debug Oops, Lockups and Hangs
+#
+CONFIG_PANIC_ON_OOPS=y
+CONFIG_PANIC_ON_OOPS_VALUE=1
+CONFIG_PANIC_TIMEOUT=10
+CONFIG_LOCKUP_DETECTOR=y
+CONFIG_SOFTLOCKUP_DETECTOR=y
+# CONFIG_BOOTPARAM_SOFTLOCKUP_PANIC is not set
+CONFIG_BOOTPARAM_SOFTLOCKUP_PANIC_VALUE=0
+CONFIG_DETECT_HUNG_TASK=y
+CONFIG_DEFAULT_HUNG_TASK_TIMEOUT=120
+# CONFIG_BOOTPARAM_HUNG_TASK_PANIC is not set
+CONFIG_BOOTPARAM_HUNG_TASK_PANIC_VALUE=0
+# CONFIG_WQ_WATCHDOG is not set
+# CONFIG_TEST_LOCKUP is not set
+# end of Debug Oops, Lockups and Hangs
+
+#
+# Scheduler Debugging
+#
+CONFIG_SCHED_DEBUG=y
+CONFIG_SCHED_INFO=y
+CONFIG_SCHEDSTATS=y
+# end of Scheduler Debugging
+
+# CONFIG_DEBUG_TIMEKEEPING is not set
+# CONFIG_DEBUG_PREEMPT is not set
+
+#
+# Lock Debugging (spinlocks, mutexes, etc...)
+#
+CONFIG_LOCK_DEBUGGING_SUPPORT=y
+# CONFIG_PROVE_LOCKING is not set
+# CONFIG_LOCK_STAT is not set
+# CONFIG_DEBUG_RT_MUTEXES is not set
+# CONFIG_DEBUG_SPINLOCK is not set
+# CONFIG_DEBUG_MUTEXES is not set
+# CONFIG_DEBUG_WW_MUTEX_SLOWPATH is not set
+# CONFIG_DEBUG_RWSEMS is not set
+# CONFIG_DEBUG_LOCK_ALLOC is not set
+# CONFIG_DEBUG_ATOMIC_SLEEP is not set
+# CONFIG_DEBUG_LOCKING_API_SELFTESTS is not set
+# CONFIG_LOCK_TORTURE_TEST is not set
+# CONFIG_WW_MUTEX_SELFTEST is not set
+# CONFIG_SCF_TORTURE_TEST is not set
+# CONFIG_CSD_LOCK_WAIT_DEBUG is not set
+# end of Lock Debugging (spinlocks, mutexes, etc...)
+
+# CONFIG_DEBUG_IRQFLAGS is not set
+CONFIG_STACKTRACE=y
+# CONFIG_WARN_ALL_UNSEEDED_RANDOM is not set
+# CONFIG_DEBUG_KOBJECT is not set
+
+#
+# Debug kernel data structures
+#
+CONFIG_DEBUG_LIST=y
+# CONFIG_DEBUG_PLIST is not set
+# CONFIG_DEBUG_SG is not set
+# CONFIG_DEBUG_NOTIFIERS is not set
+CONFIG_BUG_ON_DATA_CORRUPTION=y
+# end of Debug kernel data structures
+
+# CONFIG_DEBUG_CREDENTIALS is not set
+
+#
+# RCU Debugging
+#
+# CONFIG_RCU_SCALE_TEST is not set
+# CONFIG_RCU_TORTURE_TEST is not set
+# CONFIG_RCU_REF_SCALE_TEST is not set
+CONFIG_RCU_CPU_STALL_TIMEOUT=21
+CONFIG_RCU_TRACE=y
+# CONFIG_RCU_EQS_DEBUG is not set
+# end of RCU Debugging
+
+# CONFIG_DEBUG_WQ_FORCE_RR_CPU is not set
+# CONFIG_CPU_HOTPLUG_STATE_CONTROL is not set
+# CONFIG_LATENCYTOP is not set
+CONFIG_NOP_TRACER=y
+CONFIG_HAVE_FUNCTION_TRACER=y
+CONFIG_HAVE_FUNCTION_GRAPH_TRACER=y
+CONFIG_HAVE_DYNAMIC_FTRACE=y
+CONFIG_HAVE_DYNAMIC_FTRACE_WITH_REGS=y
+CONFIG_HAVE_FTRACE_MCOUNT_RECORD=y
+CONFIG_HAVE_SYSCALL_TRACEPOINTS=y
+CONFIG_HAVE_C_RECORDMCOUNT=y
+CONFIG_TRACE_CLOCK=y
+CONFIG_RING_BUFFER=y
+CONFIG_EVENT_TRACING=y
+CONFIG_CONTEXT_SWITCH_TRACER=y
+# CONFIG_QCOM_RTB is not set
+# CONFIG_IPC_LOGGING is not set
+CONFIG_TRACING=y
+CONFIG_TRACING_SUPPORT=y
+CONFIG_FTRACE=y
+# CONFIG_BOOTTIME_TRACING is not set
+# CONFIG_FUNCTION_TRACER is not set
+# CONFIG_STACK_TRACER is not set
+# CONFIG_IRQSOFF_TRACER is not set
+# CONFIG_PREEMPT_TRACER is not set
+# CONFIG_SCHED_TRACER is not set
+# CONFIG_HWLAT_TRACER is not set
+# CONFIG_OSNOISE_TRACER is not set
+# CONFIG_TIMERLAT_TRACER is not set
+# CONFIG_ENABLE_DEFAULT_TRACERS is not set
+# CONFIG_FTRACE_SYSCALLS is not set
+# CONFIG_TRACER_SNAPSHOT is not set
+CONFIG_BRANCH_PROFILE_NONE=y
+# CONFIG_PROFILE_ANNOTATED_BRANCHES is not set
+# CONFIG_PROFILE_ALL_BRANCHES is not set
+# CONFIG_BLK_DEV_IO_TRACE is not set
+CONFIG_KPROBE_EVENTS=y
+CONFIG_UPROBE_EVENTS=y
+CONFIG_BPF_EVENTS=y
+CONFIG_DYNAMIC_EVENTS=y
+CONFIG_PROBE_EVENTS=y
+# CONFIG_BPF_KPROBE_OVERRIDE is not set
+CONFIG_TRACING_MAP=y
+CONFIG_SYNTH_EVENTS=y
+CONFIG_HIST_TRIGGERS=y
+# CONFIG_TRACE_EVENT_INJECT is not set
+# CONFIG_TRACEPOINT_BENCHMARK is not set
+# CONFIG_RING_BUFFER_BENCHMARK is not set
+# CONFIG_TRACE_EVAL_MAP_FILE is not set
+# CONFIG_RING_BUFFER_STARTUP_TEST is not set
+# CONFIG_RING_BUFFER_VALIDATE_TIME_DELTAS is not set
+# CONFIG_PREEMPTIRQ_DELAY_TEST is not set
+# CONFIG_SYNTH_EVENT_GEN_TEST is not set
+# CONFIG_KPROBE_EVENT_GEN_TEST is not set
+# CONFIG_HIST_TRIGGERS_DEBUG is not set
+# CONFIG_SAMPLES is not set
+# CONFIG_STRICT_DEVMEM is not set
+
+#
+# arm64 Debugging
+#
+CONFIG_PID_IN_CONTEXTIDR=y
+# CONFIG_ARM64_RELOC_TEST is not set
+# CONFIG_CORESIGHT is not set
+# end of arm64 Debugging
+
+#
+# Kernel Testing and Coverage
+#
+# CONFIG_KUNIT is not set
+# CONFIG_NOTIFIER_ERROR_INJECTION is not set
+CONFIG_FUNCTION_ERROR_INJECTION=y
+# CONFIG_FAULT_INJECTION is not set
+CONFIG_ARCH_HAS_KCOV=y
+CONFIG_CC_HAS_SANCOV_TRACE_PC=y
+# CONFIG_KCOV is not set
+# CONFIG_RUNTIME_TESTING_MENU is not set
+CONFIG_ARCH_USE_MEMTEST=y
+# CONFIG_MEMTEST is not set
+# end of Kernel Testing and Coverage
+# end of Kernel hacking
+
+#
+# QTI WALT based scheduler features
+#
+# CONFIG_SCHED_WALT is not set
+# CONFIG_SCHED_CONSERVATIVE_BOOST_LPM_BIAS is not set
+# end of QTI WALT based scheduler features
diff --git a/drivers/base/core.c b/drivers/base/core.c
index cf01f3759276..8fd246f736fb 100644
--- a/drivers/base/core.c
+++ b/drivers/base/core.c
@@ -1572,7 +1572,7 @@ static void device_links_purge(struct device *dev)
 #define FW_DEVLINK_FLAGS_RPM		(FW_DEVLINK_FLAGS_ON | \
 					 DL_FLAG_PM_RUNTIME)
 
-static u32 fw_devlink_flags = FW_DEVLINK_FLAGS_ON;
+static u32 fw_devlink_flags = FW_DEVLINK_FLAGS_PERMISSIVE;
 static int __init fw_devlink_setup(char *arg)
 {
 	if (!arg)
@@ -1591,10 +1591,13 @@ static int __init fw_devlink_setup(char *arg)
 }
 early_param("fw_devlink", fw_devlink_setup);
 
-static bool fw_devlink_strict = true;
+static bool fw_devlink_strict = false;
 static int __init fw_devlink_strict_setup(char *arg)
 {
-	return strtobool(arg, &fw_devlink_strict);
+		int ret = strtobool(arg, &fw_devlink_strict);
+		fw_devlink_flags = FW_DEVLINK_FLAGS_PERMISSIVE;
+		fw_devlink_strict = false;
+		return ret;
 }
 early_param("fw_devlink.strict", fw_devlink_strict_setup);
 
diff --git a/drivers/clk/qcom/clk-alpha-pll.c b/drivers/clk/qcom/clk-alpha-pll.c
index b0692e2bda35..7e3f1a0f090b 100644
--- a/drivers/clk/qcom/clk-alpha-pll.c
+++ b/drivers/clk/qcom/clk-alpha-pll.c
@@ -312,7 +312,6 @@ static int wait_for_pll(struct clk_alpha_pll *pll, u32 mask, bool inverse,
 		udelay(1);
 	}
 
-	WARN_CLK(&pll->clkr.hw, 1, "%s failed to %s!\n", action);
 	return -ETIMEDOUT;
 }
 
diff --git a/drivers/clk/qcom/clk-debug.c b/drivers/clk/qcom/clk-debug.c
index a0e73fc1a057..a834f09a4d0f 100644
--- a/drivers/clk/qcom/clk-debug.c
+++ b/drivers/clk/qcom/clk-debug.c
@@ -15,9 +15,6 @@
 #include <linux/mfd/syscon.h>
 #include <trace/events/power.h>
 
-#define CREATE_TRACE_POINTS
-#include "trace.h"
-
 #include "clk-regmap.h"
 #include "clk-debug.h"
 #include "gdsc-debug.h"
@@ -484,7 +481,6 @@ static int clk_debug_measure_get(void *data, u64 *val)
 		disable_debug_clks(measure);
 	}
 
-	trace_clk_measure(clk_hw_get_name(hw), *val);
 exit:
 	mutex_unlock(&clk_debug_lock);
 	clk_runtime_put_debug_mux(meas);
@@ -942,9 +938,6 @@ static int clock_debug_trace(struct seq_file *s, void *unused)
 		clk_rate = clk_hw_get_rate(dclk->clk_hw);
 		vdd_level = clk_list_rate_vdd_level(dclk->clk_hw, clk_rate);
 
-		trace_clk_state(qcom_clk_hw_get_name(dclk->clk_hw),
-				clk_prepared, clk_enabled,
-				clk_rate, vdd_level);
 	}
 
 	mutex_unlock(&clk_debug_lock);
diff --git a/drivers/clk/qcom/debugcc-monaco.c b/drivers/clk/qcom/debugcc-monaco.c
index 7301936579de..4a0317457546 100644
--- a/drivers/clk/qcom/debugcc-monaco.c
+++ b/drivers/clk/qcom/debugcc-monaco.c
@@ -515,9 +515,6 @@ static int clk_debug_monaco_probe(struct platform_device *pdev)
 	for (i = 0; i < ARRAY_SIZE(debugcc_monaco_hws); i++) {
 		clk = devm_clk_register(&pdev->dev, debugcc_monaco_hws[i]);
 		if (IS_ERR(clk)) {
-			dev_err(&pdev->dev, "Unable to register %s, err:(%d)\n",
-				clk_hw_get_name(debugcc_monaco_hws[i]),
-				PTR_ERR(clk));
 			return PTR_ERR(clk);
 		}
 	}
@@ -525,9 +522,6 @@ static int clk_debug_monaco_probe(struct platform_device *pdev)
 	for (i = 0; i < ARRAY_SIZE(mux_list); i++) {
 		ret = devm_clk_register_debug_mux(&pdev->dev, mux_list[i].mux);
 		if (ret) {
-			dev_err(&pdev->dev, "Unable to register mux clk %s, err:(%d)\n",
-				qcom_clk_hw_get_name(&mux_list[i].mux->hw),
-				ret);
 			return ret;
 		}
 	}
diff --git a/drivers/clk/qcom/gdsc-regulator.c b/drivers/clk/qcom/gdsc-regulator.c
index 96ff407a64e7..06a52ebc9891 100644
--- a/drivers/clk/qcom/gdsc-regulator.c
+++ b/drivers/clk/qcom/gdsc-regulator.c
@@ -31,9 +31,6 @@
 #include "../../regulator/internal.h"
 #include "gdsc-debug.h"
 
-#define CREATE_TRACE_POINTS
-#include "trace-gdsc.h"
-
 /* GDSCR */
 #define PWR_ON_MASK		BIT(31)
 #define CLK_DIS_WAIT_MASK	(0xF << 12)
@@ -156,8 +153,6 @@ static int poll_gdsc_status(struct gdsc *sc, enum gdscr_status status)
 		}
 
 		if (val) {
-			trace_gdsc_time(sc->rdesc.name, status,
-					sc->gds_timeout - count, 0);
 			return 0;
 		}
 		/*
@@ -170,8 +165,6 @@ static int poll_gdsc_status(struct gdsc *sc, enum gdscr_status status)
 		udelay(1);
 	}
 
-	trace_gdsc_time(sc->rdesc.name, status,
-			sc->gds_timeout - count, 1);
 	return -ETIMEDOUT;
 }
 
diff --git a/drivers/clk/qcom/vdd-level.h b/drivers/clk/qcom/vdd-level.h
index 421928ed734c..df1f0c36826f 100644
--- a/drivers/clk/qcom/vdd-level.h
+++ b/drivers/clk/qcom/vdd-level.h
@@ -23,7 +23,7 @@ enum vdd_levels {
 	VDD_NUM,
 };
 
-static int vdd_corner[] = {
+int vdd_corner[] = {
 	[VDD_NONE]	= 0,
 	[VDD_MIN]	= RPMH_REGULATOR_LEVEL_MIN_SVS,
 	[VDD_LOWER_D1]	= RPMH_REGULATOR_LEVEL_LOW_SVS_D1,
diff --git a/drivers/dma-buf/heaps/qcom_dynamic_page_pool.h b/drivers/dma-buf/heaps/qcom_dynamic_page_pool.h
index a43751a31bde..eb912c6d9e12 100644
--- a/drivers/dma-buf/heaps/qcom_dynamic_page_pool.h
+++ b/drivers/dma-buf/heaps/qcom_dynamic_page_pool.h
@@ -32,7 +32,7 @@
  * We add __GFP_NOWARN for order 4 allocations since the core mm/ framework
  * makes no guarantee of these allocations succeeding.
  */
-static gfp_t order_flags[] = {HIGH_ORDER_GFP, HIGH_ORDER_GFP,
+gfp_t order_flags[] = {HIGH_ORDER_GFP, HIGH_ORDER_GFP,
 			      LOW_ORDER_GFP};
 #if defined(CONFIG_IOMMU_IO_PGTABLE_ARMV7S) && !defined(CONFIG_64BIT) && !defined(CONFIG_ARM_LPAE)
 static const unsigned int orders[] = {8, 4, 0};
diff --git a/drivers/dma/qcom/msm_gpi.c b/drivers/dma/qcom/msm_gpi.c
index a268122aaa41..2bf645ad8133 100644
--- a/drivers/dma/qcom/msm_gpi.c
+++ b/drivers/dma/qcom/msm_gpi.c
@@ -2332,9 +2332,6 @@ static void gpi_noop_tre(struct gpii_chan *gpii_chan)
 	while (local_rp != local_wp) {
 		/* dump the channel ring at the time of error */
 		tre = (struct msm_gpi_tre *)cntxt_rp;
-		GPII_ERR(gpii, gpii_chan->chid, "local_rp:0x%011x TRE: %08x %08x %08x %08x\n",
-			local_rp, tre->dword[0], tre->dword[1],
-			 tre->dword[2], tre->dword[3]);
 		tre->dword[3] &= noop_mask;
 		tre->dword[3] |= noop_tre;
 		local_rp += ch_ring->el_size;
diff --git a/drivers/firmware/Kconfig b/drivers/firmware/Kconfig
index 656293699559..e41c511318fc 100644
--- a/drivers/firmware/Kconfig
+++ b/drivers/firmware/Kconfig
@@ -250,7 +250,7 @@ config QTEE_SHM_BRIDGE
 
 config SYSFB
 	bool
-	default y
+	default n
 	depends on X86 || EFI
 
 config SYSFB_SIMPLEFB
diff --git a/drivers/firmware/psci/psci.c b/drivers/firmware/psci/psci.c
index f30575131643..2e1736eb130b 100644
--- a/drivers/firmware/psci/psci.c
+++ b/drivers/firmware/psci/psci.c
@@ -308,9 +308,18 @@ static int get_set_conduit_method(struct device_node *np)
 	return 0;
 }
 
+void psci_sys_reset_ext(void)
+{
+  invoke_psci_fn(PSCI_0_2_FN_SYSTEM_RESET, 0, 0, 0);
+}
+
 static int psci_sys_reset(struct notifier_block *nb, unsigned long action,
 			  void *data)
 {
+  return NOTIFY_DONE;
+  if (1) {
+	invoke_psci_fn(PSCI_0_2_FN_SYSTEM_OFF, 0, 0, 0);
+  } else {
 	if ((reboot_mode == REBOOT_WARM || reboot_mode == REBOOT_SOFT) &&
 	    psci_system_reset2_supported) {
 		/*
@@ -320,15 +329,14 @@ static int psci_sys_reset(struct notifier_block *nb, unsigned long action,
 		 */
 		invoke_psci_fn(PSCI_FN_NATIVE(1_1, SYSTEM_RESET2), 0, 0, 0);
 	} else {
-		invoke_psci_fn(PSCI_0_2_FN_SYSTEM_RESET, 0, 0, 0);
 	}
-
+  }
 	return NOTIFY_DONE;
 }
 
-static struct notifier_block psci_sys_reset_nb = {
+struct notifier_block psci_sys_reset_nb = {
 	.notifier_call = psci_sys_reset,
-	.priority = 129,
+	.priority = 140,
 };
 
 static void psci_sys_poweroff(void)
diff --git a/drivers/firmware/qcom_scm-smc.c b/drivers/firmware/qcom_scm-smc.c
index 34d41012c880..adfb7dd23a12 100644
--- a/drivers/firmware/qcom_scm-smc.c
+++ b/drivers/firmware/qcom_scm-smc.c
@@ -61,8 +61,6 @@ static void __scm_smc_do_quirk(const struct arm_smccc_args *smc,
 
 static void fill_wq_resume_args(struct arm_smccc_args *resume, u32 smc_call_ctx)
 {
-	memset(resume->args, 0, ARRAY_SIZE(resume->args));
-
 	resume->args[0] = ARM_SMCCC_CALL_VAL(ARM_SMCCC_STD_CALL,
 			 ARM_SMCCC_SMC_64, ARM_SMCCC_OWNER_SIP,
 			 SCM_SMC_FNID(QCOM_SCM_SVC_WAITQ, QCOM_SCM_WAITQ_RESUME));
@@ -74,8 +72,6 @@ static void fill_wq_resume_args(struct arm_smccc_args *resume, u32 smc_call_ctx)
 
 static void fill_wq_wake_ack_args(struct arm_smccc_args *wake_ack, u32 smc_call_ctx)
 {
-	memset(wake_ack->args, 0, ARRAY_SIZE(wake_ack->args));
-
 	wake_ack->args[0] = ARM_SMCCC_CALL_VAL(ARM_SMCCC_STD_CALL,
 			 ARM_SMCCC_SMC_64, ARM_SMCCC_OWNER_SIP,
 			 SCM_SMC_FNID(QCOM_SCM_SVC_WAITQ, QCOM_SCM_WAITQ_ACK));
@@ -87,8 +83,6 @@ static void fill_wq_wake_ack_args(struct arm_smccc_args *wake_ack, u32 smc_call_
 
 static void fill_get_wq_ctx_args(struct arm_smccc_args *get_wq_ctx)
 {
-	memset(get_wq_ctx->args, 0, ARRAY_SIZE(get_wq_ctx->args));
-
 	get_wq_ctx->args[0] = ARM_SMCCC_CALL_VAL(ARM_SMCCC_STD_CALL,
 			 ARM_SMCCC_SMC_64, ARM_SMCCC_OWNER_SIP,
 			 SCM_SMC_FNID(QCOM_SCM_SVC_WAITQ, QCOM_SCM_WAITQ_GET_WQ_CTX));
@@ -137,8 +131,6 @@ static int scm_smc_do_quirk(struct device *dev, struct arm_smccc_args *smc,
 			qscm = dev_get_drvdata(dev);
 			wq = qcom_scm_lookup_wq(qscm, wq_ctx);
 			if (IS_ERR_OR_NULL(wq)) {
-				pr_err("No waitqueue found for wq_ctx %d: %d\n",
-						wq_ctx, PTR_ERR(wq));
 				return PTR_ERR(wq);
 			}
 
diff --git a/drivers/firmware/qcom_scm.c b/drivers/firmware/qcom_scm.c
index f58597fbc2ec..7ec9e3318a47 100644
--- a/drivers/firmware/qcom_scm.c
+++ b/drivers/firmware/qcom_scm.c
@@ -267,7 +267,6 @@ static int qcom_scm_call_noretry(struct device *dev,
 	case SMC_CONVENTION_ARM_64:
 		return scm_smc_call(dev, desc, res, QCOM_SCM_CALL_NORETRY);
 	case SMC_CONVENTION_LEGACY:
-		BUG_ON(1); /* No current implementation */
 	default:
 		pr_err("Unknown current SCM calling convention.\n");
 		return -EINVAL;
@@ -528,6 +527,7 @@ void qcom_scm_set_download_mode(enum qcom_download_mode mode, phys_addr_t tcsr_b
 	int ret = 0;
 	struct device *dev = __scm ? __scm->dev : NULL;
 
+	qcom_scm_io_writel(__scm->dload_mode_addr, mode);
 	avail = __qcom_scm_is_call_available(dev,
 					     QCOM_SCM_SVC_BOOT,
 					     QCOM_SCM_BOOT_SET_DLOAD_MODE);
@@ -2655,7 +2655,7 @@ struct completion *qcom_scm_lookup_wq(struct qcom_scm *scm, u32 wq_ctx)
 	init_completion(wq);
 
 	err = idr_alloc_u32(&scm->waitq.idr, wq, &wq_ctx_idr,
-			    (wq_ctx_idr < U32_MAX ? : U32_MAX), GFP_ATOMIC);
+			    (wq_ctx_idr < U32_MAX ? wq_ctx_idr : U32_MAX), GFP_ATOMIC);
 	if (err < 0) {
 		devm_kfree(scm->dev, wq);
 		wq = ERR_PTR(err);
@@ -2702,8 +2702,6 @@ static void scm_irq_work(struct work_struct *work)
 
 		wq_to_wake = qcom_scm_lookup_wq(scm, wq_ctx);
 		if (IS_ERR_OR_NULL(wq_to_wake)) {
-			pr_err("No waitqueue found for wq_ctx %d: %d\n",
-					wq_ctx, PTR_ERR(wq_to_wake));
 			return;
 		}
 
@@ -2764,17 +2762,12 @@ int  scm_mem_protection_init_do(void)
 	pid_offset = offsetof(struct task_struct, pid);
 	task_name_offset = offsetof(struct task_struct, comm);
 
-	pr_debug("offset of pid is %zu, offset of comm is %zu\n",
-			pid_offset, task_name_offset);
 	desc.args[0] = pid_offset,
 	desc.args[1] = task_name_offset,
 
 	ret = qcom_scm_call(__scm ? __scm->dev : NULL, &desc, &res);
 	resp = res.result[0];
 
-	pr_debug("SCM call values: ret %d, resp %d\n",
-			ret, resp);
-
 	if (ret || resp) {
 		pr_err("SCM call failed %d, resp %d\n", ret, resp);
 		if (ret)
@@ -2891,8 +2884,7 @@ static int qcom_scm_probe(struct platform_device *pdev)
 	 * will cause the the boot stages to enter download mode, unless
 	 * disabled below by a clean shutdown/reboot.
 	 */
-	if (download_mode)
-		qcom_scm_set_download_mode(QCOM_DOWNLOAD_FULLDUMP, 0);
+	qcom_scm_set_download_mode(QCOM_DOWNLOAD_MINIDUMP, 0);
 
 	return 0;
 }
diff --git a/drivers/firmware/qtee_shmbridge.c b/drivers/firmware/qtee_shmbridge.c
index 26fc61141726..cf44f1c38c19 100644
--- a/drivers/firmware/qtee_shmbridge.c
+++ b/drivers/firmware/qtee_shmbridge.c
@@ -304,8 +304,6 @@ int32_t qtee_shmbridge_register(
 	mutex_lock(&bridge_list_head.lock);
 	ret = qtee_shmbridge_query_locked(paddr);
 	if (ret) {
-		pr_debug("%s: found 0%x already exist with shmbridge\n",
-			__func__, paddr);
 		goto bridge_exist;
 	}
 
@@ -340,8 +338,7 @@ int32_t qtee_shmbridge_register(
 		 * deregister to decrease ref_count in QTEE.
 		 */
 		if (ret == AC_ERR_SHARED_MEMORY_SINGLE_SOURCE)
-			pr_err("%s: bridge %llx exist but not registered in our map\n",
-				__func__, (uint64_t)paddr);
+		  ;
 		else {
 			ret = -EINVAL;
 			goto exit;
@@ -387,8 +384,6 @@ int32_t qtee_shmbridge_allocate_shm(size_t size, struct qtee_shm *shm)
 	}
 
 	if (size > default_bridge.size) {
-		pr_err("requestd size %zu is larger than bridge size %d\n",
-			size, default_bridge.size);
 		ret = -EINVAL;
 		goto exit;
 	}
@@ -397,7 +392,6 @@ int32_t qtee_shmbridge_allocate_shm(size_t size, struct qtee_shm *shm)
 
 	va = gen_pool_alloc(default_bridge.genpool, size);
 	if (!va) {
-		pr_err("failed to sub-allocate %zu bytes from bridge\n", size);
 		ret = -ENOMEM;
 		goto exit;
 	}
@@ -477,9 +471,6 @@ static int qtee_shmbridge_init(struct platform_device *pdev)
 	else
 		default_bridge.size = custom_bridge_size * MIN_BRIDGE_SIZE;
 
-	pr_err("qtee shmbridge registered default bridge with size %d bytes\n",
-		default_bridge.size);
-
 	default_bridge.vaddr = (void *)__get_free_pages(GFP_KERNEL|__GFP_COMP,
 				get_order(default_bridge.size));
 	if (!default_bridge.vaddr)
@@ -543,9 +534,6 @@ static int qtee_shmbridge_init(struct platform_device *pdev)
 		goto exit_deregister_default_bridge;
 	}
 
-	pr_debug("qtee shmbridge registered default bridge with size %d bytes\n",
-			default_bridge.size);
-
 	mem_protection_enabled = scm_mem_protection_init_do();
 	pr_err("MEM protection %s, %d\n",
 			(!mem_protection_enabled ? "Enabled" : "Not enabled"),
diff --git a/drivers/i2c/busses/i2c-msm-geni.c b/drivers/i2c/busses/i2c-msm-geni.c
index b0252f584f65..bd6bf0fb020a 100644
--- a/drivers/i2c/busses/i2c-msm-geni.c
+++ b/drivers/i2c/busses/i2c-msm-geni.c
@@ -98,9 +98,6 @@ if (dev) \
 	i2c_trace_log(dev, x); \
 } while (0)
 
-#define CREATE_TRACE_POINTS
-#include "i2c-qup-trace.h"
-
 #define I2C_HUB_DEF	0
 
 /* FTRACE Logging */
@@ -114,7 +111,6 @@ void i2c_trace_log(struct device *dev, const char *fmt, ...)
 
 	va_start(args, fmt);
 	vaf.va = &args;
-	trace_i2c_log_info(dev_name(dev), &vaf);
 	va_end(args);
 }
 
@@ -471,11 +467,7 @@ static int geni_i2c_bus_recovery(struct geni_i2c_dev *gi2c)
 	//Must be enabled by client "only" if required.
 	if (gi2c->bus_recovery_enable &&
 		geni_i2c_is_bus_recovery_required(gi2c)) {
-		GENI_SE_ERR(gi2c->ipcl, false, gi2c->dev,
-			"SDA Line stuck\n", gi2c->err);
 	} else {
-		GENI_SE_DBG(gi2c->ipcl, false, gi2c->dev,
-			"Bus Recovery not required/enabled\n");
 		return 0;
 	}
 
@@ -531,20 +523,12 @@ static int do_pending_cancel(struct geni_i2c_dev *gi2c)
 	geni_ios = geni_read_reg(gi2c->base, SE_GENI_IOS);
 	if ((geni_ios & 0x3) != 0x3) {
 		/* Try to restore IOS with FORCE_DEFAULT */
-		GENI_SE_ERR(gi2c->ipcl, true, gi2c->dev,
-			"%s: IOS:0x%x, bad state\n", __func__, geni_ios);
-
 		geni_write_reg(FORCE_DEFAULT,
 			gi2c->base, GENI_FORCE_DEFAULT_REG);
 		geni_ios = geni_read_reg(gi2c->base, SE_GENI_IOS);
 		if ((geni_ios & 0x3) != 0x3) {
-			GENI_SE_ERR(gi2c->ipcl, true, gi2c->dev,
-				"%s: IOS:0x%x, Fix from Slave side\n",
-				__func__, geni_ios);
 			return -EINVAL;
 		}
-		GENI_SE_ERR(gi2c->ipcl, true, gi2c->dev,
-			"%s: IOS:0x%x restored properly\n", __func__, geni_ios);
 	}
 
 	if (gi2c->se_mode == GSI_ONLY) {
@@ -1666,8 +1650,7 @@ static int geni_i2c_xfer(struct i2c_adapter *adap,
 			I2C_LOG_ERR(gi2c->ipcl, true, gi2c->dev,
 				"i2c error :%d\n", gi2c->err);
 			if (geni_i2c_bus_recovery(gi2c))
-				GENI_SE_ERR(gi2c->ipcl, true, gi2c->dev,
-				"%s:Bus Recovery failed\n", __func__);
+			  ;
 			break;
 		}
 	}
@@ -2229,7 +2212,6 @@ static int geni_i2c_suspend_late(struct device *device)
 		pm_runtime_enable(device);
 	}
 	i2c_unlock_bus(&gi2c->adap, I2C_LOCK_SEGMENT);
-	I2C_LOG_DBG(gi2c->ipcl, false, gi2c->dev, "%s ret=%d\n", __func__);
 	return 0;
 }
 #else
diff --git a/drivers/i3c/master/i3c-master-msm-geni.c b/drivers/i3c/master/i3c-master-msm-geni.c
index aca1ee439050..8531f7fccf27 100644
--- a/drivers/i3c/master/i3c-master-msm-geni.c
+++ b/drivers/i3c/master/i3c-master-msm-geni.c
@@ -428,9 +428,6 @@ if (dev) \
 	i3c_trace_log(dev, x); \
 } while (0)
 
-#define CREATE_TRACE_POINTS
-#include "i3c-qup-trace.h"
-
 /* FTRACE Logging */
 void i3c_trace_log(struct device *dev, const char *fmt, ...)
 {
diff --git a/drivers/iio/adc/qcom-spmi-adc5-gen3.c b/drivers/iio/adc/qcom-spmi-adc5-gen3.c
index 72df9eb6bd9f..a8338b3ef6ab 100644
--- a/drivers/iio/adc/qcom-spmi-adc5-gen3.c
+++ b/drivers/iio/adc/qcom-spmi-adc5-gen3.c
@@ -516,7 +516,6 @@ static void adc5_gen3_dump_register(struct adc5_chip *adc, unsigned int offset)
 			return;
 		}
 		offset += ADC_OFFSET_DUMP;
-		pr_debug("Buf[%d]: %*ph\n", i, sizeof(buf), buf);
 	}
 }
 
diff --git a/drivers/interconnect/qcom/icc-rpm.c b/drivers/interconnect/qcom/icc-rpm.c
index ffa1d16e031d..2c3565375492 100644
--- a/drivers/interconnect/qcom/icc-rpm.c
+++ b/drivers/interconnect/qcom/icc-rpm.c
@@ -217,8 +217,6 @@ int qcom_icc_rpm_set(struct icc_node *src, struct icc_node *dst)
 						sum_avg);
 
 					if (ret) {
-						pr_err("qcom_icc_rpm_smd_send_msg slv %s error %d\n",
-							qn->slv_rpm_id, ret);
 						return ret;
 					}
 				}
diff --git a/drivers/iommu/arm/arm-smmu/arm-smmu-debug.c b/drivers/iommu/arm/arm-smmu/arm-smmu-debug.c
index 35a34113e6be..869ffe5e3cde 100644
--- a/drivers/iommu/arm/arm-smmu/arm-smmu-debug.c
+++ b/drivers/iommu/arm/arm-smmu/arm-smmu-debug.c
@@ -33,24 +33,19 @@ u64 arm_smmu_debug_qtb_debugchain_dump(void __iomem *debugchain_base)
 
 void arm_smmu_debug_dump_debugchain(struct device *dev, void __iomem *debugchain_base)
 {
-	long chain_length = 0, index = 0;
+	long chain_length = 0;
 	u64 val;
 
 	chain_length = arm_smmu_debug_qtb_debugchain_load(debugchain_base);
-	dev_info(dev, "Dumping Debug chain: Length : %d\n", chain_length);
 	/* First read is to dump away the 0xDEADBEEF value */
 	arm_smmu_debug_qtb_debugchain_dump(debugchain_base);
 	do {
 		val = arm_smmu_debug_qtb_debugchain_dump(debugchain_base);
-		dev_info(dev, "Debug chain: Index :%ld, val : 0x%lx\n", index++, val);
 	} while (chain_length--);
 }
 
 void arm_smmu_debug_dump_qtb_regs(struct device *dev, void __iomem *tbu_base)
 {
-	dev_info(dev, "QSMSTATUS: 0x%lx IDLESTATUS: 0x%lx\n",
-			readl_relaxed(tbu_base + Qtb500_QtbNsDbgQsmStatus),
-			readl_relaxed(tbu_base + Qtb500_QtbNsDbgIdleStatus));
 }
 
 u32 arm_smmu_debug_tbu_testbus_select(void __iomem *tbu_base,
@@ -137,10 +132,6 @@ static void arm_smmu_debug_dump_tbu_qns4_testbus(struct device *dev,
 		reg = arm_smmu_debug_tbu_testbus_select(tbu_base, READ, 0);
 		reg = (reg & ~TBU_QNS4_BRIDGE_MASK) | i << 0;
 		arm_smmu_debug_tbu_testbus_select(tbu_base, WRITE, reg);
-		dev_info(dev, "testbus_sel: 0x%lx Index: %d val: 0x%llx\n",
-			arm_smmu_debug_tbu_testbus_select(tbu_base,
-						READ, 0), i,
-			arm_smmu_debug_tbu_testbus_output(tbu_base));
 	}
 }
 
@@ -158,13 +149,8 @@ void arm_smmu_debug_dump_tbu_testbus(struct device *dev, void __iomem *tbu_base,
 			int tbu_testbus_sel)
 {
 	if (tbu_testbus_sel & TBU_CLK_GATE_CONTROLLER_TESTBUS_SEL) {
-		dev_info(dev, "Dumping TBU clk gate controller:\n");
 		arm_smmu_debug_program_tbu_testbus(tbu_base,
 				TBU_CLK_GATE_CONTROLLER_TESTBUS);
-		dev_info(dev, "testbus_sel: 0x%lx val: 0x%llx\n",
-			arm_smmu_debug_tbu_testbus_select(tbu_base,
-						READ, 0),
-			arm_smmu_debug_tbu_testbus_output(tbu_base));
 	}
 
 	if (tbu_testbus_sel & TBU_QNS4_A2Q_TESTBUS_SEL) {
@@ -185,40 +171,24 @@ void arm_smmu_debug_dump_tbu_testbus(struct device *dev, void __iomem *tbu_base,
 		dev_info(dev, "Dumping multi master qchannel:\n");
 		arm_smmu_debug_program_tbu_testbus(tbu_base,
 				TBU_MULTIMASTER_QCHANNEL_TESTBUS);
-		dev_info(dev, "testbus_sel: 0x%lx val: 0x%llx\n",
-			arm_smmu_debug_tbu_testbus_select(tbu_base,
-						READ, 0),
-			arm_smmu_debug_tbu_testbus_output(tbu_base));
 	}
 
 	if (tbu_testbus_sel & TBU_CLK_GATE_CONTROLLER_EXT_TESTBUS_SEL) {
 		dev_info(dev, "Dumping tbu clk gate controller ext:\n");
 		arm_smmu_debug_program_tbu_testbus(tbu_base,
 				TBU_CLK_GATE_CONTROLLER_EXT_TESTBUS);
-		dev_info(dev, "testbus_sel: 0x%lx val: 0x%llx\n",
-			arm_smmu_debug_tbu_testbus_select(tbu_base,
-						READ, 0),
-			arm_smmu_debug_tbu_testbus_output(tbu_base));
 	}
 
 	if (tbu_testbus_sel & TBU_LOW_POWER_STATUS_TESTBUS_SEL) {
 		dev_info(dev, "Dumping tbu low power status:\n");
 		arm_smmu_debug_program_tbu_testbus(tbu_base,
 				TBU_LOW_POWER_STATUS_TESTBUS);
-		dev_info(dev, "testbus_sel: 0x%lx val: 0x%llx\n",
-			arm_smmu_debug_tbu_testbus_select(tbu_base,
-						READ, 0),
-			arm_smmu_debug_tbu_testbus_output(tbu_base));
 	}
 
 	if (tbu_testbus_sel & TBU_QNS4_VLD_RDY_SEL) {
 		dev_info(dev, "Dumping tbu qns4 vld rdy:\n");
 		arm_smmu_debug_program_tbu_testbus(tbu_base,
 				TBU_QNS4_VLD_RDY);
-		dev_info(dev, "testbus_sel: 0x%lx val: 0x%llx\n",
-			arm_smmu_debug_tbu_testbus_select(tbu_base,
-						READ, 0),
-			arm_smmu_debug_tbu_testbus_output(tbu_base));
 	}
 }
 
@@ -237,11 +207,6 @@ static void arm_smmu_debug_program_tcu_testbus(struct device *dev,
 		reg |= i << shift;
 		arm_smmu_debug_tcu_testbus_select(phys_addr, tcu_base,
 				PTW_AND_CACHE_TESTBUS, WRITE, reg);
-		if (print)
-			dev_info(dev, "testbus_sel: 0x%lx Index: %d val: 0x%lx\n",
-				 arm_smmu_debug_tcu_testbus_select(phys_addr,
-				 tcu_base, PTW_AND_CACHE_TESTBUS, READ, 0), i,
-				 arm_smmu_debug_tcu_testbus_output(phys_addr));
 	}
 }
 
@@ -282,10 +247,6 @@ void arm_smmu_debug_dump_tcu_testbus(struct device *dev, phys_addr_t phys_addr,
 						TCU_PTW_TESTBUS_SEL2,
 						TCU_PTW_TESTBUS_SEL2 + 1, 0,
 						false);
-			dev_info(dev, "testbus_sel: 0x%lx Index: %d val: 0x%lx\n",
-				 arm_smmu_debug_tcu_testbus_select(phys_addr,
-				 tcu_base, PTW_AND_CACHE_TESTBUS, READ, 0), i,
-				 arm_smmu_debug_tcu_testbus_output(phys_addr));
 		}
 	}
 
@@ -301,9 +262,6 @@ void arm_smmu_debug_dump_tcu_testbus(struct device *dev, phys_addr_t phys_addr,
 	/* program ARM_SMMU_TESTBUS_SEL_HLOS1_NS to select TCU clk testbus*/
 	arm_smmu_debug_tcu_testbus_select(phys_addr, tcu_base,
 			CLK_TESTBUS, WRITE, TCU_CLK_TESTBUS_SEL);
-	dev_info(dev, "Programming Tcu clk gate controller: testbus_sel: 0x%lx\n",
-		arm_smmu_debug_tcu_testbus_select(phys_addr, tcu_base,
-						CLK_TESTBUS, READ, 0));
 }
 
 void arm_smmu_debug_set_tnx_tcr_cntl(void __iomem *tbu_base, u64 val)
diff --git a/drivers/iommu/arm/arm-smmu/arm-smmu-qcom.c b/drivers/iommu/arm/arm-smmu/arm-smmu-qcom.c
index b586b38d2b60..96a2ea2a1095 100644
--- a/drivers/iommu/arm/arm-smmu/arm-smmu-qcom.c
+++ b/drivers/iommu/arm/arm-smmu/arm-smmu-qcom.c
@@ -1840,7 +1840,7 @@ static ssize_t arm_smmu_debug_capturebus_config_read(struct file *file,
 		scnprintf(buf + strlen(buf), buf_len - strlen(buf),
 				"Match_%d : 0x%0llx\n", i+1, match[i]);
 	}
-	scnprintf(buf + strlen(buf), buf_len - strlen(buf), "0x%0lx\n", val);
+	scnprintf(buf + strlen(buf), buf_len - strlen(buf), "0x%0lx\n", (long)val);
 
 	buflen = min(count, strlen(buf));
 	if (copy_to_user(ubuf, buf, buflen)) {
diff --git a/drivers/iommu/dma-mapping-fast.c b/drivers/iommu/dma-mapping-fast.c
index 075dfbf98e1f..3d41c2b1a57e 100644
--- a/drivers/iommu/dma-mapping-fast.c
+++ b/drivers/iommu/dma-mapping-fast.c
@@ -943,8 +943,6 @@ static void fast_smmu_reserve_msi_iova(struct device *dev, struct dma_fast_smmu_
 			msi_size);
 		goto out;
 	}
-	dev_dbg(dev, "iova allocator reserved 0x%lx-0x%lx for MSI\n", msi_iova_base,
-		msi_iova_base + msi_size);
 	spin_unlock_irqrestore(&fast->lock, flags);
 
 	ret = iommu_get_msi_cookie(fast->domain, msi_iova_base);
diff --git a/drivers/iommu/qcom-io-pgtable-arm.c b/drivers/iommu/qcom-io-pgtable-arm.c
index ce8e40612e37..74765341b920 100644
--- a/drivers/iommu/qcom-io-pgtable-arm.c
+++ b/drivers/iommu/qcom-io-pgtable-arm.c
@@ -933,7 +933,7 @@ static size_t arm_lpae_split_blk_unmap(struct arm_lpae_io_pgtable *data,
 
 		qcom_io_pgtable_log_new_table(data->pgtable_log_ops,
 					data->iop.cookie, tablep,
-					iova & ~(prev_block_size - 1) + 0xDEA,
+(					      iova & ~(prev_block_size - 1)) + 0xDEA,
 					prev_block_size);
 		return num_entries * size;
 	}
diff --git a/drivers/mailbox/msm_qmp.c b/drivers/mailbox/msm_qmp.c
index 535cc332f500..43ede73b65b6 100644
--- a/drivers/mailbox/msm_qmp.c
+++ b/drivers/mailbox/msm_qmp.c
@@ -877,14 +877,12 @@ static int qmp_shim_send_data(struct mbox_chan *chan, void *data)
 
 	/* Mailbox framework should only have one packet in flight per client */
 	if (defer_pkt->size) {
-		QMP_ERR(mdev->ilc, "dropping msg:%s\n", pkt->data);
 		spin_unlock_irqrestore(&mbox->tx_lock, flags);
 		return -EINVAL;
 	}
 
 	defer_pkt->size = pkt->size;
 	memcpy(defer_pkt->data, pkt->data, pkt->size);
-	QMP_INFO(mdev->ilc, "scheduling worker to send msg:%s\n", pkt->data);
 	schedule_work(&mbox->tx_work);
 	spin_unlock_irqrestore(&mbox->tx_lock, flags);
 	return 0;
diff --git a/drivers/pinctrl/qcom/pinctrl-msm.c b/drivers/pinctrl/qcom/pinctrl-msm.c
index e7f057e6d977..e5893b982e7b 100644
--- a/drivers/pinctrl/qcom/pinctrl-msm.c
+++ b/drivers/pinctrl/qcom/pinctrl-msm.c
@@ -1585,7 +1585,6 @@ static int msm_pinctrl_hibernation_suspend(void)
     /* Save direction conn registers for hmss */
 	for (i = 0; i < soc->ntiles; i++) {
 		tile_addr = pctrl->regs[i] + soc->dir_conn_addr[i];
-		pr_err("The tile addr generated is 0x%lx\n", (u64)tile_addr);
 		for (j = 0; j < 8; j++)
 			pctrl->msm_tile_regs[i].dir_con_regs[j] =
 				readl_relaxed(tile_addr + j*4);
@@ -1632,7 +1631,6 @@ static void msm_pinctrl_hibernation_resume(void)
 
 	for (i = 0; i < soc->ntiles; i++) {
 		tile_addr = pctrl->regs[i] + soc->dir_conn_addr[i];
-		pr_err("The tile addr generated is 0x%lx\n", (u64)tile_addr);
 		for (j = 0; j < 8; j++)
 			writel_relaxed(pctrl->msm_tile_regs[i].dir_con_regs[j],
 					tile_addr + j*4);
diff --git a/drivers/power/reset/msm-poweroff.c b/drivers/power/reset/msm-poweroff.c
index d07120ef4615..8f31925178ec 100644
--- a/drivers/power/reset/msm-poweroff.c
+++ b/drivers/power/reset/msm-poweroff.c
@@ -563,6 +563,10 @@ static int msm_restart_probe(struct platform_device *pdev)
 
 	pm_power_off = do_msm_poweroff;
 	restart_nb.notifier_call = do_msm_restart;
+	{
+	  extern void psci_sys_reset_ext(void);
+	  psci_sys_reset_ext();
+	}
 	restart_nb.priority = 200;
 	register_restart_handler(&restart_nb);
 
diff --git a/drivers/power/supply/qcom/Makefile b/drivers/power/supply/qcom/Makefile
index ffa7bd440cb5..27036e6613ae 100644
--- a/drivers/power/supply/qcom/Makefile
+++ b/drivers/power/supply/qcom/Makefile
@@ -7,7 +7,7 @@ qpnp-qnovo5-main-y += qpnp-qnovo5.o battery.o pmic-voter.o smb5-lib.o smb5-iio.o
 obj-$(CONFIG_QPNP_QG)	+= qcom-qpnp-qg.o
 qcom-qpnp-qg-y	+= qpnp-qg.o battery-profile-loader.o pmic-voter.o qg-util.o qg-soc.o qg-sdam.o qg-battery-profile.o qg-profile-lib.o fg-alg.o
 obj-$(CONFIG_QPNP_SMBLITE) += qpnp-smblite-main.o
-qpnp-smblite-main-y += step-chg-jeita.o battery.o qpnp-smblite.o smblite-lib.o pmic-voter-compat.o storm-watch.o battery-profile-loader.o schgm-flashlite.o smblite-iio.o smbx-get-chan.o smblite-remote-bms.o smblite-shim.o
+qpnp-smblite-main-y += step-chg-jeita.o battery.o qpnp-smblite.o smblite-lib.o pmic-voter-compat.o storm-watch.o battery-profile-loader.o schgm-flashlite.o smblite-iio.o smbx-get-chan.o smblite-remote-bms.o smblite-shim.o gvotable.o logbuffer.o
 obj-$(CONFIG_SMB1398_CHARGER)           += qcom-smb1398-charger.o
 qcom-smb1398-charger-y += smb1398-charger.o pmic-voter.o
 obj-$(CONFIG_SMB1355_SLAVE_CHARGER)	+= qcom-smb1355-charger.o
@@ -19,7 +19,7 @@ obj-$(CONFIG_QTI_QBG)   += qti-qbg-main.o
 qti-qbg-main-y  += qti-qbg.o qbg-sdam.o qbg-battery-profile.o battery-profile-loader.o
 
 # This gives the drivers access to the logbuffer.h and gvotable.h header
-subdir-ccflags-y += -I$(KERNEL_SRC)/../google-modules/bms
+subdir-ccflags-y += -I. -Imisc
 
 EXTRA_SYMBOLS += $(OUT_DIR)/../google-modules/bms/misc/Module.symvers
 
diff --git a/drivers/power/supply/qcom/gvotable.c b/drivers/power/supply/qcom/gvotable.c
new file mode 100644
index 000000000000..507ddae1bcff
--- /dev/null
+++ b/drivers/power/supply/qcom/gvotable.c
@@ -0,0 +1,1536 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Copyright 2019-2022 Google LLC
+ */
+
+#include <linux/init.h>
+#include <linux/list.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/slab.h>
+#include <linux/string.h>
+#include <linux/stringhash.h>
+#include "misc/gvotable.h"
+
+#ifdef CONFIG_DEBUG_FS
+# include <linux/debugfs.h>
+# include <linux/seq_file.h>
+#endif
+
+#define VOTES_HISTORY_DEPTH  1
+#define MAX_NAME_LEN        16
+#define MAX_VOTE2STR_LEN    16
+
+#define DEBUGFS_CAST_VOTE_REASON "DEBUGFS"
+#define DEBUGFS_FORCE_VOTE_REASON "DEBUGFS_FORCE"
+
+static const char default_reason[] = "Default";
+#ifdef CONFIG_DEBUG_FS
+static struct dentry *debugfs_root;
+#endif
+
+static DEFINE_MUTEX(gvotable_lock);
+static LIST_HEAD(gvotables);
+
+/* a ballot is associated to a reason */
+struct ballot {
+	bool enabled;
+	u32 reason_hash;
+	char reason[GVOTABLE_MAX_REASON_LEN];
+
+	u32 idx;
+	void *vote[VOTES_HISTORY_DEPTH];
+	int vote_size;	/* !=0 when copy is requested */
+
+	u32 num_votes;
+
+	struct list_head list;
+};
+
+struct gvotable_election {
+	u32 hash;
+
+	int	vote_size;	/* actual vote size */
+	bool	use_alloc;	/* if true, use kalloc() for result and votes */
+
+	char name[MAX_NAME_LEN];
+	bool	has_name;	/* only elections with names are visible */
+
+	struct mutex cb_lock;	/* see lock_result(), lock_election() */
+	struct mutex re_lock;	/* see lock_result(), lock_election() */
+	void	*owner;
+
+	void	*result;	/* current result and reason */
+	char	reason[GVOTABLE_MAX_REASON_LEN];
+	bool	result_is_valid;
+
+	void	*data;		/* _get_data() */
+
+	gvotable_callback_fn callback;
+	int (*cmp)(void *a, void *b);
+
+	bool	auto_callback;	/* allow disabling callbacks (internal) */
+	void	*default_vote;
+	int	has_default_vote;	/* -1 no, 1 yes */
+
+	void	*force_result;
+	bool	force_result_is_enabled;
+
+	struct list_head votes; /* actual ballots */
+	u32 num_voters;	/* number of ballots */
+
+	u32 num_votes;	/* number of votes */
+
+	gvotable_v2sfn_t vote2str;
+	bool	is_int_type;	/* int-type debugfs entries */
+	bool	is_bool_type;
+
+	/* some int-type votables must not have the force_int_* debugfs entry */
+	bool	disable_force_int_entry;
+};
+
+#define gvotable_lock_result(el) mutex_lock(&(el)->re_lock)
+#define gvotable_unlock_result(el) mutex_unlock(&(el)->re_lock)
+
+#define CONFIG_DEBUG_GVOTABLE_LOCKS
+#ifdef CONFIG_DEBUG_GVOTABLE_LOCKS
+static void gvotable_lock_election(struct gvotable_election *el)
+{
+	int ret;
+
+	ret = mutex_trylock(&el->cb_lock);
+	if (WARN(ret == 0 && el->owner == get_current(),
+		 "%s cannot call this function from the callback\n",
+		 el->has_name ? el->name : "<>"))
+		mutex_lock(&el->cb_lock);
+
+	el->owner = get_current();
+	gvotable_lock_result(el);
+}
+#else
+static inline void gvotable_lock_election(struct gvotable_election *el)
+{
+	mutex_lock(&(el)->cb_lock);
+	mutex_lock(&(el)->re_lock);
+}
+#endif
+
+#define gvotable_unlock_callback(el) mutex_unlock(&(el)->cb_lock)
+
+static inline void gvotable_unlock_election(struct gvotable_election *el)
+{
+	mutex_unlock(&(el)->re_lock);
+	mutex_unlock(&(el)->cb_lock);
+}
+
+struct election_slot {
+	struct gvotable_election *el;
+	struct list_head list;
+	struct dentry *de;
+};
+
+int gvotable_comparator_uint_max(void *l, void *r)
+{
+	unsigned int a = *((unsigned int *)&l);
+	unsigned int b = *((unsigned int *)&r);
+
+	if (a > b)
+		return 1;
+	else if (a < b)
+		return (-1);
+	else
+		return 0;
+}
+EXPORT_SYMBOL_GPL(gvotable_comparator_uint_max);
+
+static int gvotable_comparator_int(void *l, void *r)
+{
+	int a = *((int *)&l);
+	int b = *((int *)&r);
+
+	if (a > b)
+		return 1;
+	else if (a < b)
+		return (-1);
+	else
+		return 0;
+}
+
+/* compares l and r as integers */
+int gvotable_comparator_int_max(void *a, void *b)
+{
+	return -gvotable_comparator_int(a, b);
+}
+EXPORT_SYMBOL_GPL(gvotable_comparator_int_max);
+
+/* compares l and r as integers */
+int gvotable_comparator_int_min(void *a, void *b)
+{
+	return gvotable_comparator_int(a, b);
+}
+EXPORT_SYMBOL_GPL(gvotable_comparator_int_min);
+
+/* compares l and r as integers */
+int gvotable_comparator_uint_min(void *a, void *b)
+{
+	return -gvotable_comparator_uint_max(a, b);
+}
+EXPORT_SYMBOL_GPL(gvotable_comparator_uint_min);
+
+/* Always add new elements on head of the list */
+int gvotable_comparator_most_recent(void *a, void *b)
+{
+	return (-1);
+}
+EXPORT_SYMBOL_GPL(gvotable_comparator_most_recent);
+
+/* Always add new element on tail of the list */
+int gvotable_comparator_least_recent(void *a, void *b)
+{
+	return 1;
+}
+EXPORT_SYMBOL_GPL(gvotable_comparator_least_recent);
+
+/*
+ * bool elections return 0 when there are NO votes active and a 1 value when
+ * there is at least one vote.
+ */
+static int gvotable_comparator_bool(void *a, void *b)
+{
+	return gvotable_comparator_most_recent(a, b);
+}
+
+/* NONE add to the head of the list */
+static int gvotable_comparator_none(void *a, void *b)
+{
+	return gvotable_comparator_most_recent(a, b);
+}
+
+int gvotable_v2s_int(char *str,  size_t len, const void *vote)
+{
+	return scnprintf(str, len, "%ld", (unsigned long)vote);
+}
+EXPORT_SYMBOL_GPL(gvotable_v2s_int);
+
+int gvotable_v2s_uint(char *str, size_t len, const void *vote)
+{
+	return scnprintf(str, len, "%lu", (unsigned long)vote);
+}
+EXPORT_SYMBOL_GPL(gvotable_v2s_uint);
+
+int gvotable_v2s_uint_hex(char *str, size_t len, const void *vote)
+{
+	return scnprintf(str, len, "0x%lx", (unsigned long)vote);
+}
+EXPORT_SYMBOL_GPL(gvotable_v2s_uint_hex);
+
+/* GVotable internal hashing function */
+static u32 gvotable_internal_hash(const char *str)
+{
+	return full_name_hash(NULL, str, strlen(str));
+}
+
+static void gvotable_internal_update_reason(struct gvotable_election *el,
+					    const char *new_reason)
+{
+	strscpy(el->reason, new_reason, GVOTABLE_MAX_REASON_LEN);
+}
+
+static void gvotable_internal_copy_result(struct gvotable_election *el,
+					  void **result,
+					  void *new_result)
+{
+	if (el->use_alloc)
+		memcpy(*result, new_result, el->vote_size);
+	else
+		*result = new_result;
+}
+
+static void gvotable_internal_update_result(struct gvotable_election *el,
+					    void *new_result)
+{
+	gvotable_internal_copy_result(el, &el->result, new_result);
+	el->result_is_valid = true;
+}
+
+#define GVOTABLE_BOOL_TRUE_VALUE	((void *)1)
+#define GVOTABLE_BOOL_FALSE_VALUE	((void *)0)
+
+/*
+ * Determine the new result for the election, return true if the el->callback
+ * needs to be called for the election false otherwise. MUST return false if
+ * the el->callback is invalid (NULL).
+ * requires &->re_lock and &->cb_lock
+ */
+static bool gvotable_internal_run_election(struct gvotable_election *el)
+{
+	struct ballot *ballot;
+	bool callback_required = false;
+
+	if (el->force_result_is_enabled)
+		return false;
+
+	/* the first VALID ballot, the default vote or invalid result */
+	list_for_each_entry(ballot, &el->votes, list) {
+		if (!ballot->enabled)
+			continue;
+
+		/* Update reason if needed TODO: call *_set_result() */
+		if (!el->result_is_valid ||
+		    strncmp(el->reason, ballot->reason,
+			    GVOTABLE_MAX_REASON_LEN)) {
+			gvotable_internal_update_reason(el, ballot->reason);
+			callback_required = el->auto_callback;
+		}
+
+		/* Update result if needed TODO: call *_set_result() */
+		if (callback_required ||
+		    el->cmp(el->result, ballot->vote[ballot->idx]) != 0) {
+			void *new_result;
+
+			/* any-type elections have a default int-type value */
+			if (el->is_bool_type)
+				new_result = GVOTABLE_BOOL_TRUE_VALUE;
+			else
+				new_result = ballot->vote[ballot->idx];
+
+			gvotable_internal_update_result(el, new_result);
+			callback_required = el->auto_callback;
+		}
+
+		/* updated also in gvotable_internal_update_result() */
+		el->result_is_valid = true;
+		goto exit_done;
+	}
+
+	/*
+	 * Could not find a vote: use default if when set.
+	 * bool-type elections always have a default int-type default vote.
+	 */
+	if (el->has_default_vote == 1) {
+		/* TODO: call *_set_result() */
+		if (!el->result_is_valid ||
+		    strncmp(el->reason, default_reason,
+			    GVOTABLE_MAX_REASON_LEN)) {
+			gvotable_internal_update_reason(el, default_reason);
+			callback_required = el->auto_callback;
+		}
+
+		/* TODO: call *_set_result() */
+		if (callback_required ||
+		    el->cmp(el->result, el->default_vote) != 0) {
+			gvotable_internal_update_result(el, el->default_vote);
+			callback_required = el->auto_callback;
+		}
+
+		/* updated also in gvotable_internal_update_result() */
+		el->result_is_valid = true;
+	} else {
+		callback_required = el->result_is_valid && el->auto_callback;
+		el->result_is_valid = false;
+		el->reason[0] = 0; /* default to null reason */
+	}
+
+exit_done:
+	return callback_required && el->callback;
+}
+
+/* requires &gvotable_lock */
+static struct election_slot *gvotable_find_internal(const char *name)
+{
+	struct election_slot *slot;
+	struct gvotable_election *el;
+	unsigned int hash;
+
+	if (!name)
+		return NULL;
+
+	hash = gvotable_internal_hash(name);
+
+	list_for_each_entry(slot, &gvotables, list) {
+		el = slot->el;
+		if (hash == el->hash && el->has_name &&
+		    (strncmp(el->name, name, MAX_NAME_LEN) == 0))
+			return slot;
+	}
+
+	return NULL;
+}
+
+/* requires &gvotable_lock */
+static struct election_slot *gvotable_find_internal_ptr(struct gvotable_election *el)
+{
+	struct election_slot *slot;
+
+	list_for_each_entry(slot, &gvotables, list)
+		if (slot->el == el)
+			return slot;
+
+	return NULL;
+}
+
+/* requires &gvotable_lock */
+static void gvotable_add_internal(struct election_slot *slot)
+{
+	list_add(&slot->list, &gvotables);
+}
+
+/* requires &gvotable_lock */
+static void gvotable_delete_internal(struct election_slot *slot)
+{
+	list_del(&slot->list);
+	kfree(slot);
+}
+
+/* reader lock on election */
+static struct ballot *gvotable_ballot_find_internal(struct gvotable_election *el,
+						    const char *reason)
+{
+	struct ballot *ballot;
+	u32 reason_hash;
+
+	reason_hash = gvotable_internal_hash(reason);
+
+	list_for_each_entry(ballot, &el->votes, list) {
+		if (reason_hash == ballot->reason_hash &&
+		    (strncmp(ballot->reason, reason,
+			     GVOTABLE_MAX_REASON_LEN) == 0))
+			return ballot;
+	}
+	return NULL;
+}
+
+int gvotable_election_for_each(struct gvotable_election *el,
+			       gvotable_foreach_callback_fn callback_fn,
+			       void *cb_data)
+{
+	struct ballot *ballot;
+	int ret = 0;
+
+	if (el->force_result_is_enabled) {
+		ret = callback_fn(cb_data, DEBUGFS_FORCE_VOTE_REASON,
+				  el->force_result);
+		return ret;
+	}
+
+	/* TODO: LOCK list? */
+	list_for_each_entry(ballot, &el->votes, list) {
+		if (!ballot->enabled)
+			continue;
+
+		ret = callback_fn(cb_data, ballot->reason,
+				  ballot->vote[ballot->idx]);
+		if (ret < 0)
+			break;
+	}
+
+	return ret;
+}
+EXPORT_SYMBOL_GPL(gvotable_election_for_each);
+
+#ifdef CONFIG_DEBUG_FS
+static int gvotable_debugfs_create_el_int(struct election_slot *slot);
+static void gvotable_debugfs_create_el(struct election_slot *slot);
+static void gvotable_debugfs_delete_el(struct election_slot *slot);
+#else
+static int gvotable_debugfs_create_el_int(struct election_slot *slot)
+{
+}
+
+static void gvotable_debugfs_create_el(struct election_slot *slot)
+{
+}
+
+static void gvotable_debugfs_delete_el(struct election_slot *slot)
+{
+}
+#endif
+
+/* Allow redefining the allocator: required for testing */
+#ifndef gvotable_kzalloc
+#define gvotable_kzalloc(p, f) kzalloc(sizeof(*(p)), f)
+#endif
+
+/* Allow redefining the allocator: required for testing */
+#ifndef gvotable_needs_alloc
+#define gvotable_needs_alloc(vote_size) \
+	((vote_size) > sizeof(((struct ballot *)0)->vote[0]))
+#endif
+
+struct gvotable_election *
+gvotable_create_election(const char *name, int vote_size,
+			 int (*cmp_fn)(void *, void *),
+			 gvotable_callback_fn callback_fn,
+			 void *data)
+{
+	struct gvotable_election *el = NULL;
+	struct election_slot *slot;
+
+	if (!cmp_fn)
+		cmp_fn = gvotable_comparator_none;
+
+	mutex_lock(&gvotable_lock);
+
+	if (name && gvotable_find_internal(name))
+		goto done_exit;
+
+	slot = gvotable_kzalloc(slot, GFP_KERNEL);
+	if (!slot)
+		goto done_exit;
+
+	slot->el = gvotable_kzalloc(slot->el, GFP_KERNEL);
+	if (!slot->el) {
+		kfree(slot);
+		goto done_exit;
+	}
+
+	mutex_init(&slot->el->re_lock);
+	mutex_init(&slot->el->cb_lock);
+	INIT_LIST_HEAD(&slot->el->votes);
+	slot->el->callback	= callback_fn;
+	slot->el->auto_callback	= true;
+	slot->el->cmp		= cmp_fn;
+	slot->el->data		= data;
+	slot->el->has_default_vote = -1;
+	slot->el->vote_size	= vote_size;
+	slot->el->use_alloc	= gvotable_needs_alloc(vote_size);
+
+	/* preallocate result */
+	if (slot->el->use_alloc) {
+		slot->el->result = kzalloc(vote_size, GFP_KERNEL);
+		if (!slot->el->result) {
+			kfree(slot->el);
+			kfree(slot);
+			goto done_exit;
+		}
+	}
+
+	if (name) {
+		slot->el->has_name = true;
+		slot->el->hash     = gvotable_internal_hash(name);
+		strscpy(slot->el->name, name, MAX_NAME_LEN);
+
+		gvotable_debugfs_create_el(slot);
+	}
+
+	gvotable_add_internal(slot);
+	el = slot->el;
+
+done_exit:
+	mutex_unlock(&gvotable_lock);
+	return el;
+}
+EXPORT_SYMBOL_GPL(gvotable_create_election);
+
+struct gvotable_election *
+gvotable_create_int_election(const char *name,
+			     int (*cmp_fn)(void *, void *),
+			     gvotable_callback_fn cb_fn,
+			     void *data)
+{
+	struct gvotable_election *el;
+
+	el =  gvotable_create_election(name, sizeof(int), cmp_fn, cb_fn, data);
+	if (!el)
+		return NULL;
+
+	el->is_int_type = true;
+	if (name) {
+		struct election_slot *slot;
+
+		slot = gvotable_find_internal(name);
+		if (slot)
+			gvotable_debugfs_create_el_int(slot);
+	}
+
+	return el;
+}
+EXPORT_SYMBOL_GPL(gvotable_create_int_election);
+
+/*
+ * "bool" elections return 1 when there is at least one vote active and 0
+ * otherwise. Actual votes are ignored and the result is always the state
+ * of the votes.
+ */
+struct gvotable_election *
+gvotable_create_bool_election(const char *name, gvotable_callback_fn cb_fn,
+			      void *data)
+{
+	struct gvotable_election *el;
+
+	el =  gvotable_create_election(name, sizeof(int),
+				       gvotable_comparator_bool, cb_fn, data);
+	if (!el)
+		return NULL;
+
+	/* the fist call to set_default doesn't run election */
+	gvotable_set_default(el, GVOTABLE_BOOL_FALSE_VALUE);
+	/* run the election to update the actual vote */
+	gvotable_internal_run_election(el);
+	el->is_bool_type = true;
+	return el;
+}
+EXPORT_SYMBOL_GPL(gvotable_create_bool_election);
+
+/*
+ * Destroying an election involves removing all ballots and removing the
+ * election (and all its links) from the election slot.
+ * TODO: calls to the election API should validate the *el pointer with
+ * find_internal before accessing the election.
+ */
+int gvotable_destroy_election(struct gvotable_election *el)
+{
+	struct ballot *tmp, *ballot;
+	struct election_slot *slot;
+
+	if (!el)
+		return -EINVAL;
+
+	gvotable_lock_result(el);
+
+	/* TODO: mark el as pending deletion and fail all operations */
+	list_for_each_entry_safe(ballot, tmp, &el->votes, list) {
+		if (ballot->vote_size) {
+			int i;
+
+			for (i = 0; i < VOTES_HISTORY_DEPTH; i++) {
+				kfree(ballot->vote[i]);
+				ballot->vote[i] = NULL;
+			}
+		}
+
+		kfree(ballot);
+	}
+
+	gvotable_unlock_result(el);
+
+	/* Find slots associated with this handle and remove them */
+	mutex_lock(&gvotable_lock);
+	slot = gvotable_find_internal_ptr(el);
+	while (slot) {
+		gvotable_debugfs_delete_el(slot);
+		gvotable_delete_internal(slot);
+		slot = gvotable_find_internal_ptr(el);
+	}
+	mutex_unlock(&gvotable_lock);
+
+	if (el->use_alloc)
+		kfree(el->result);
+	kfree(el);
+	return 0;
+}
+EXPORT_SYMBOL_GPL(gvotable_destroy_election);
+
+/*
+ * Get a public election
+ * TODO: the election can be destroyed while in use so SW needs to mark the
+ * election as invalid somehow. One way to do this is to use find_internal()
+ * to validate the election before accessing the fields (must make an
+ * exception with nameless elections)
+ */
+struct gvotable_election *gvotable_election_get_handle(const char *name)
+{
+	struct election_slot *slot;
+
+	if (!name)
+		return NULL;
+
+	mutex_lock(&gvotable_lock);
+	slot = gvotable_find_internal(name);
+	mutex_unlock(&gvotable_lock);
+
+	return (slot) ? slot->el : NULL;
+}
+EXPORT_SYMBOL_GPL(gvotable_election_get_handle);
+
+int gvotable_disable_force_int_entry(struct gvotable_election *el)
+{
+	if (!el || el->has_name)
+		return -EINVAL;
+
+	el->disable_force_int_entry = true;
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(gvotable_disable_force_int_entry);
+
+/* Set name of an election (makes election available for lookup) */
+int gvotable_election_set_name(struct gvotable_election *el, const char *name)
+{
+	struct election_slot *slot;
+
+	if (!el || !name)
+		return -EINVAL;
+
+	mutex_lock(&gvotable_lock);
+	if (el->has_name || gvotable_find_internal(name)) {
+		mutex_unlock(&gvotable_lock);
+		return -EEXIST;
+	}
+
+	el->has_name = true;
+	el->hash = gvotable_internal_hash(name);
+	strscpy(el->name, name, MAX_NAME_LEN);
+
+	/* el->has_name ==> find internal will now find the election */
+	slot = gvotable_find_internal(name);
+	if (slot) {
+		gvotable_debugfs_create_el(slot);
+		if (slot->el->is_int_type)
+			gvotable_debugfs_create_el_int(slot);
+	}
+
+	mutex_unlock(&gvotable_lock);
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(gvotable_election_set_name);
+
+void gvotable_set_vote2str(struct gvotable_election *el,
+			   gvotable_v2sfn_t vote2str)
+{
+	el->vote2str = vote2str;
+}
+EXPORT_SYMBOL_GPL(gvotable_set_vote2str);
+
+static int gvotable_run_callback(struct gvotable_election *el)
+{
+	int ret;
+
+	if (el->result_is_valid)
+		ret = el->callback(el, el->reason, el->result);
+	else
+		ret = el->callback(el, NULL, NULL);
+
+	return ret;
+}
+
+/* Set the default value, rerun the election when the value changes */
+int gvotable_set_default(struct gvotable_election *el, void *default_val)
+{
+	bool changed;
+	int ret = 0;
+
+	/* boolean elections don't allow changing the default value */
+	if (!el || el->is_bool_type)
+		return -EINVAL;
+
+	gvotable_lock_election(el);
+
+	changed = el->has_default_vote == 1 && el->default_vote != default_val;
+	el->default_vote = default_val;
+
+	if (changed) {
+		if (gvotable_internal_run_election(el)) {
+			gvotable_unlock_result(el);
+			ret = gvotable_run_callback(el);
+		}
+	} else {
+		gvotable_unlock_result(el);
+	}
+
+	el->has_default_vote = 1;
+	gvotable_unlock_callback(el);
+	return ret;
+}
+EXPORT_SYMBOL_GPL(gvotable_set_default);
+
+/* no need for locks */
+int gvotable_get_default(struct gvotable_election *el, void **result)
+{
+	if (!el || !el->has_default_vote)
+		return -EINVAL;
+
+	gvotable_lock_election(el);
+	gvotable_internal_copy_result(el, result, el->default_vote);
+	gvotable_unlock_election(el);
+
+	return 0;
+}
+
+/* Enable or disable usage of a default value for a given election */
+int gvotable_use_default(struct gvotable_election *el, bool default_is_enabled)
+{
+	int ret = 0;
+
+	/* boolean elections don't allow changing the default value */
+	if (!el || el->is_bool_type)
+		return -EINVAL;
+
+	gvotable_lock_election(el);
+
+	el->has_default_vote = default_is_enabled;
+	if (gvotable_internal_run_election(el)) {
+		gvotable_unlock_result(el);
+		ret = gvotable_run_callback(el);
+	} else {
+		gvotable_unlock_result(el);
+	}
+
+	gvotable_unlock_callback(el);
+	return ret;
+}
+EXPORT_SYMBOL_GPL(gvotable_use_default);
+
+/* Retrieve data for an election */
+void *gvotable_get_data(struct gvotable_election *el)
+{
+	return el ? el->data : NULL;
+}
+EXPORT_SYMBOL_GPL(gvotable_get_data);
+
+/* NULL (0) is  a valid value when votes are integers */
+static int gvotable_get_current_result_unlocked(struct gvotable_election *el,
+						const void **result)
+{
+	if (el->force_result_is_enabled)
+		*result = el->force_result;
+	else if (el->result_is_valid)
+		*result = el->result;
+	else
+		return -EAGAIN;
+
+	return 0;
+}
+
+int gvotable_get_current_vote(struct gvotable_election *el, const void **vote)
+{
+	int ret;
+
+	if (!el || !vote)
+		return -EINVAL;
+
+	gvotable_lock_result(el);
+	ret = gvotable_get_current_result_unlocked(el, vote);
+	gvotable_unlock_result(el);
+
+	return ret;
+}
+EXPORT_SYMBOL_GPL(gvotable_get_current_vote);
+
+int gvotable_get_current_int_vote(struct gvotable_election *el)
+{
+	const void *ptr;
+	int ret;
+
+	ret = gvotable_get_current_vote(el, &ptr);
+	return (ret) ? ret : (uintptr_t)ptr;
+}
+EXPORT_SYMBOL_GPL(gvotable_get_current_int_vote);
+
+/* copy the actual current vote */
+int gvotable_copy_current_result(struct gvotable_election *el, void *vote,
+				 int vote_size)
+{
+	const void *tmp;
+	int ret;
+
+	if (!el || !vote)
+		return -EINVAL;
+	if (vote_size != el->vote_size)
+		return -ERANGE;
+
+	gvotable_lock_result(el);
+	ret = gvotable_get_current_result_unlocked(el, &tmp);
+	if (ret == 0)
+		memcpy(vote, tmp, vote_size);
+	gvotable_unlock_result(el);
+
+	return ret;
+}
+EXPORT_SYMBOL_GPL(gvotable_copy_current_result);
+
+static int gvotable_get_current_reason_unlocked(struct gvotable_election *el,
+						char *reason, int max_len)
+{
+	char *r = NULL;
+
+	if (el->force_result_is_enabled)
+		r = DEBUGFS_FORCE_VOTE_REASON;
+	else if (el->result_is_valid)
+		r = el->reason;
+
+	return r ? strscpy(reason, r, max_len) : -EAGAIN;
+}
+
+/* Retrieve current reason for election result. */
+int gvotable_get_current_reason(struct gvotable_election *el, char *reason,
+				int max_len)
+{
+	int len;
+
+	if (!el || !reason)
+		return -EINVAL;
+
+	gvotable_lock_result(el);
+	len = gvotable_get_current_reason_unlocked(el, reason, max_len);
+	gvotable_unlock_result(el);
+	return len;
+}
+EXPORT_SYMBOL_GPL(gvotable_get_current_reason);
+
+/* Get vote associated with a specific reason */
+int gvotable_get_vote(struct gvotable_election *el, const char *reason,
+		      void **vote)
+{
+	struct ballot *ballot;
+
+	if (!el || !reason || !vote)
+		return -EINVAL;
+
+	gvotable_lock_result(el);
+	ballot = gvotable_ballot_find_internal(el, reason);
+	if (!ballot) {
+		gvotable_unlock_result(el);
+		*vote = NULL;
+		return (el->is_bool_type) ? 0 : -ENODEV;
+	}
+
+	if (!el->is_bool_type && !ballot->enabled) {
+		gvotable_unlock_result(el);
+		return -EINVAL;
+	}
+
+	*vote = ballot->vote[ballot->idx];
+
+	gvotable_unlock_result(el);
+	return 0;
+}
+EXPORT_SYMBOL_GPL(gvotable_get_vote);
+
+int gvotable_get_int_vote(struct gvotable_election *el, const char *reason)
+{
+	void *ptr;
+	int ret;
+
+	ret = gvotable_get_vote(el, reason, &ptr);
+	return ret ? ret : (uintptr_t)ptr;
+}
+EXPORT_SYMBOL_GPL(gvotable_get_int_vote);
+
+/* Determine the reason is enabled */
+int gvotable_is_enabled(struct gvotable_election *el, const char *reason,
+			bool *enabled)
+{
+	struct ballot *ballot;
+
+	if (!el || !reason || !enabled)
+		return -EINVAL;
+
+	gvotable_lock_result(el);
+	ballot = gvotable_ballot_find_internal(el, reason);
+	if (!ballot) {
+		gvotable_unlock_result(el);
+		return -ENODEV;
+	}
+
+	*enabled = ballot->enabled;
+	gvotable_unlock_result(el);
+	return 0;
+}
+EXPORT_SYMBOL_GPL(gvotable_is_enabled);
+
+/* requires &el->re_lock */
+static int gvotable_update_ballot(struct ballot *ballot, void *vote,
+				  bool enabled)
+{
+	const int idx = (ballot->idx + 1) % VOTES_HISTORY_DEPTH;
+
+	ballot->enabled = enabled;
+
+	if (ballot->vote_size == 0) {
+		ballot->vote[idx] = vote;
+		goto exit_done;
+	}
+
+	if (!ballot->vote[idx]) {
+		ballot->vote[idx] = kzalloc(ballot->vote_size, GFP_KERNEL);
+		if (!ballot->vote[idx])
+			return -ENOMEM;
+	}
+
+	memcpy(ballot->vote[idx], vote, ballot->vote_size);
+
+exit_done:
+	ballot->idx = idx;
+	ballot->num_votes++;
+	return 0;
+}
+
+/* requires &el->re_lock */
+static void gvotable_add_ballot(struct gvotable_election *el,
+				struct ballot *ballot,
+				bool enabled)
+{
+	struct ballot *last, *tmp;
+	void *vote = ballot->vote[ballot->idx];
+
+	/* If this is the only element, just add */
+	if (list_empty(&el->votes)) {
+		list_add(&ballot->list, &el->votes);
+		return;
+	}
+
+	/* disabled elements go to the end */
+	if (enabled) {
+		/* most recent (-1), least recent (1), min */
+		list_for_each_entry(tmp, &el->votes, list) {
+			if (el->cmp(vote, tmp->vote[tmp->idx]) < 0) {
+				/* Add new element before current one */
+				list_add_tail(&ballot->list, &tmp->list);
+				return;
+			}
+		}
+	}
+
+	/* Add element after the last one */
+	last = list_last_entry(&el->votes, struct ballot, list);
+	list_add(&ballot->list, &last->list);
+
+	el->num_votes++;
+}
+
+int gvotable_recast_ballot(struct gvotable_election *el, const char *reason,
+			   bool enabled)
+{
+	struct ballot *ballot;
+	int ret;
+
+	gvotable_lock_election(el);
+
+	ballot = gvotable_ballot_find_internal(el, reason);
+	if (!ballot) {
+		gvotable_unlock_election(el);
+		return -EINVAL;
+	}
+
+	list_del(&ballot->list);
+	ret = gvotable_update_ballot(ballot, ballot->vote[ballot->idx],
+				     enabled);
+	if (ret < 0) {
+		gvotable_unlock_election(el);
+		return ret;
+	}
+
+	gvotable_add_ballot(el, ballot, enabled);
+
+	if (gvotable_internal_run_election(el)) {
+		gvotable_unlock_result(el);
+		ret = gvotable_run_callback(el);
+	} else {
+		gvotable_unlock_result(el);
+	}
+
+	gvotable_unlock_callback(el);
+	return ret;
+}
+EXPORT_SYMBOL_GPL(gvotable_recast_ballot);
+
+#define gvotable_ballot_size_ok(size) ((size) <= sizeof(void *))
+
+int gvotable_run_election(struct gvotable_election *el, bool force_callback)
+{
+	bool callback;
+	int ret = 0;
+
+	/*
+	 * In theory this should be calling gvotable_internal_run_election() even if the result
+	 * doesn't change yet. In practice this is NOT necessary since the lock should ensure that
+	 * you call the callback with the right value.
+	 */
+	gvotable_lock_election(el);
+	callback = gvotable_internal_run_election(el);
+	gvotable_unlock_result(el);
+
+	if (!el->callback)
+		goto exit_done;
+
+	if (el->force_result_is_enabled) {
+		ret = el->callback(el, DEBUGFS_FORCE_VOTE_REASON, el->force_result);
+		goto exit_done;
+	}
+
+	if (callback || force_callback)
+		ret = gvotable_run_callback(el);
+
+exit_done:
+	gvotable_unlock_callback(el);
+	return ret;
+}
+EXPORT_SYMBOL_GPL(gvotable_run_election);
+
+/*
+ * overrides result and reason for "none" type votables.
+ * This can only be called while in the callback for "none" votables.
+ * NOTE: the API is not great
+ */
+int gvotable_election_set_result(struct gvotable_election *el,
+				 const char *reason, void *result)
+{
+	if (!el || !reason || reason[0] == 0)
+		return -EINVAL;
+	/* a NULL vote is ok when we are not using copy */
+	if (el->use_alloc && !result)
+		return -EINVAL;
+	if (el->cmp != gvotable_comparator_none) {
+		WARN_ONCE(1, "Setting the result is not supported for a votable of this type");
+		return -EINVAL;
+	}
+
+	gvotable_internal_update_reason(el, reason);
+	gvotable_internal_update_result(el, result);
+	return 0;
+}
+EXPORT_SYMBOL_GPL(gvotable_election_set_result);
+
+int gvotable_cast_vote(struct gvotable_election *el, const char *reason,
+		       void *vote, bool enabled)
+{
+	bool allocated = false;
+	struct ballot *ballot;
+	int ret;
+
+	if (!el || !reason || reason[0] == 0)
+		return -EINVAL;
+	/* a NULL vote is ok when we are not using copy */
+	if (el->use_alloc && !vote)
+		return -EINVAL;
+
+	gvotable_lock_election(el);
+
+	ballot = gvotable_ballot_find_internal(el, reason);
+	if (!ballot) {
+		ballot = gvotable_kzalloc(ballot, GFP_KERNEL);
+		if (!ballot) {
+			gvotable_unlock_election(el);
+			return -ENOMEM;
+		}
+
+		ballot->reason_hash = gvotable_internal_hash(reason);
+		strscpy(ballot->reason, reason, GVOTABLE_MAX_REASON_LEN);
+		if (el->use_alloc)
+			ballot->vote_size = el->vote_size;
+		el->num_voters++;
+		allocated = true;
+	} else if (enabled) {
+		list_del(&ballot->list);
+	}
+
+	if (el->is_bool_type)
+		vote = (void *)(unsigned long)enabled;
+
+	ret = gvotable_update_ballot(ballot, vote, enabled);
+	if (ret < 0) {
+		if (allocated)
+			kfree(ballot);
+
+		gvotable_unlock_election(el);
+		return ret;
+	}
+
+	/* an existing vote is disabled in place */
+	if (allocated || enabled)
+		gvotable_add_ballot(el, ballot, enabled);
+
+	if (gvotable_internal_run_election(el)) {
+		gvotable_unlock_result(el);
+		ret = gvotable_run_callback(el);
+	} else {
+		gvotable_unlock_result(el);
+	}
+
+	gvotable_unlock_callback(el);
+	return ret;
+}
+EXPORT_SYMBOL_GPL(gvotable_cast_vote);
+
+#ifdef CONFIG_DEBUG_FS
+
+#define GVOTABLE_DEBUG_ATTRIBUTE(name, fn_read, fn_write) \
+static const struct file_operations name = {	\
+	.open	= simple_open,			\
+	.llseek	= no_llseek,			\
+	.read	= fn_read,			\
+	.write	= fn_write,			\
+}
+
+/* requires lock on election */
+static int gvotable_dump_election(char *buf, size_t len,
+				  struct gvotable_election *el)
+{
+	gvotable_v2sfn_t vote2str = el->vote2str;
+	char reason[GVOTABLE_MAX_REASON_LEN];
+	int rc, count = 0;
+	const void *vote;
+
+	count += scnprintf(&buf[count], len - count, "%s:",
+			   el->has_name ? el->name : " :");
+
+	rc = gvotable_get_current_reason_unlocked(el, reason, sizeof(reason));
+	if (rc < 0)
+		count += scnprintf(&buf[count], len - count, " <%d>", rc);
+	else
+		count += scnprintf(&buf[count], len - count, " current=%s",
+				   reason);
+
+	rc = gvotable_get_current_result_unlocked(el, &vote);
+	if (rc < 0) {
+		count += scnprintf(&buf[count], len - count, " <%d>", rc);
+	} else {
+		count += scnprintf(&buf[count], len - count, " v=");
+		if (vote2str)
+			count += vote2str(&buf[count], len - count, vote);
+		else
+			count += scnprintf(&buf[count], len - count, "<>");
+	}
+
+	/* bool elections always have a default (0) vote */
+	if (!el->is_bool_type && el->has_default_vote == 1) {
+		count += scnprintf(&buf[count], len - count, " d=");
+		if (vote2str)
+			count += vote2str(&buf[count], len - count,
+					  el->default_vote);
+		else
+			count += scnprintf(&buf[count], len - count, "<>");
+	}
+
+	count += scnprintf(&buf[count], len - count, "\n");
+	return count;
+}
+
+/* requires &gvotable_lock */
+static int gvotable_list_elections(char *buf, size_t len)
+{
+	struct election_slot *slot;
+	int count = 0;
+
+	if (list_empty(&gvotables))
+		return 0;
+
+	list_for_each_entry(slot, &gvotables, list) {
+		gvotable_lock_result(slot->el);
+
+		count += gvotable_dump_election(&buf[count], len - count,
+					     slot->el);
+
+		gvotable_unlock_result(slot->el);
+	}
+
+	return count;
+}
+
+static ssize_t debugfs_list_elections(struct file *filp,
+				      char __user *user_buf,
+				      size_t count, loff_t *ppos)
+{
+	const int buf_size = 4096;
+	char *buf;
+	int len;
+
+	buf = kzalloc(buf_size, GFP_KERNEL);
+	if (!buf)
+		return -ENOMEM;
+
+	mutex_lock(&gvotable_lock);
+	len = gvotable_list_elections(buf, buf_size);
+	if (!len)
+		len = scnprintf(buf, buf_size, "data not available\n");
+	mutex_unlock(&gvotable_lock);
+
+	count = simple_read_from_buffer(user_buf, count, ppos, buf, len);
+
+	kfree(buf);
+	return count;
+}
+GVOTABLE_DEBUG_ATTRIBUTE(debugfs_elections_fops, debugfs_list_elections, NULL);
+
+/* requires lock on election */
+static int gvotable_dump_ballot(char *buf, size_t len, struct ballot *ballot,
+				gvotable_v2sfn_t vote2str)
+{
+	int count = 0;
+
+	count += scnprintf(&buf[count], len - count, " %s", ballot->reason);
+	count += scnprintf(&buf[count], len - count, " en=%d val=",
+			   ballot->enabled);
+	count += vote2str(&buf[count], len - count, ballot->vote[ballot->idx]);
+	count += scnprintf(&buf[count], len - count, " #votes=%d",
+			   ballot->num_votes);
+
+	return count;
+}
+
+/* requires lock on election */
+static int gvotable_list_ballots(char *buf, size_t len,
+				 struct gvotable_election *el,
+				 gvotable_v2sfn_t vote2str)
+{
+	struct ballot *ballot;
+	int count = 0;
+
+	if (!vote2str)
+		vote2str = el->vote2str;
+	if (!el || !vote2str)
+		return -EINVAL;
+
+	list_for_each_entry(ballot, &el->votes, list) {
+		count += scnprintf(&buf[count], len - count, "%s:",
+				   el->has_name ? el->name : " :");
+		count += gvotable_dump_ballot(&buf[count], len - count, ballot,
+					      vote2str);
+		count += scnprintf(&buf[count], len - count, "\n");
+	}
+
+	return count;
+}
+
+static ssize_t debugfs_list_ballots(struct file *filp,
+				    char __user *user_buf,
+				    size_t count, loff_t *ppos)
+{
+	struct election_slot *slot = filp->private_data;
+	const int buf_size = 4096;
+	char *buf;
+	int len;
+
+	buf = kzalloc(buf_size, GFP_KERNEL);
+	if (!buf)
+		return -ENOMEM;
+
+	gvotable_lock_result(slot->el);
+
+	len = gvotable_list_ballots(buf, buf_size, slot->el, NULL);
+	if (len < 0) {
+		len = scnprintf(buf, buf_size, "data not available (%d)\n",
+				len);
+	} else {
+		len += gvotable_dump_election(&buf[len], buf_size - len,
+					      slot->el);
+	}
+
+	gvotable_unlock_result(slot->el);
+
+	count = simple_read_from_buffer(user_buf, count, ppos, buf, len);
+
+	kfree(buf);
+
+	return count;
+}
+
+GVOTABLE_DEBUG_ATTRIBUTE(debugfs_ballots_fops, debugfs_list_ballots, NULL);
+
+static ssize_t debugfs_enable_vote(struct file *filp,
+				   const char __user *user_buf,
+				   size_t count, loff_t *ppos)
+{
+	struct election_slot *slot = filp->private_data;
+	char reason[GVOTABLE_MAX_REASON_LEN] = { 0 };
+	int ret;
+
+	ret = simple_write_to_buffer(reason, sizeof(reason), ppos, user_buf,
+				     count);
+	if (ret < 0)
+		return -EFAULT;
+
+	ret = gvotable_recast_ballot(slot->el, reason, true);
+	if (ret < 0) {
+		pr_err("cannot recast %s (%d)\n", reason, ret);
+		return ret;
+	}
+
+	return count;
+}
+
+GVOTABLE_DEBUG_ATTRIBUTE(debugs_enable_vote_fops, NULL, debugfs_enable_vote);
+
+static ssize_t debugfs_disable_vote(struct file *filp,
+				    const char __user *user_buf,
+				    size_t count, loff_t *ppos)
+{
+	struct election_slot *slot = filp->private_data;
+	char reason[GVOTABLE_MAX_REASON_LEN] = { 0 };
+	int ret;
+
+	ret = simple_write_to_buffer(reason, sizeof(reason), ppos, user_buf,
+				     count);
+	if (ret < 0)
+		return -EFAULT;
+
+	ret = gvotable_recast_ballot(slot->el, reason, false);
+	if (ret < 0) {
+		pr_err("cannot recast %s (%d)\n", reason, ret);
+		return ret;
+	}
+
+	return count;
+}
+
+GVOTABLE_DEBUG_ATTRIBUTE(debugs_disable_vote_fops, NULL, debugfs_disable_vote);
+
+/* TODO: only enable for int votes */
+static int debugfs_cast_int_vote(void *data, u64 val)
+{
+	struct election_slot *slot = data;
+	bool enabled = false;
+	int ret;
+
+	ret = gvotable_is_enabled(slot->el, DEBUGFS_CAST_VOTE_REASON,
+				  &enabled);
+	if (ret < 0)
+		pr_debug("vote not present\n");
+
+	return gvotable_cast_vote(slot->el, DEBUGFS_CAST_VOTE_REASON,
+				  (void *)val, enabled);
+}
+
+DEFINE_SIMPLE_ATTRIBUTE(debugfs_cast_int_vote_fops, NULL,
+			debugfs_cast_int_vote, "%llu\n");
+
+/* TODO: only enable for int votes */
+static int debugfs_force_int_value(void *data, u64 val)
+{
+	struct election_slot *slot = data;
+	u64 pre_val = (u64)slot->el->force_result;
+	int ret = 0;
+
+	gvotable_lock_election(slot->el);
+
+	slot->el->force_result = (void *)val;
+	gvotable_unlock_result(slot->el);
+
+	if (!slot->el->callback)
+		goto exit_done;
+
+	if (slot->el->force_result_is_enabled && (pre_val != val))
+		ret = slot->el->callback(slot->el, DEBUGFS_FORCE_VOTE_REASON,
+					 slot->el->force_result);
+
+exit_done:
+	gvotable_unlock_callback(slot->el);
+	return ret;
+}
+
+DEFINE_SIMPLE_ATTRIBUTE(debugfs_force_int_value_fops, NULL,
+			debugfs_force_int_value, "%llu\n");
+
+static int debugfs_force_int_active(void *data, u64 val)
+{
+	struct election_slot *slot = data;
+	int ret = 0;
+
+	gvotable_lock_election(slot->el);
+
+	slot->el->force_result_is_enabled = !!val;
+	gvotable_unlock_result(slot->el);
+
+	if (!slot->el->callback)
+		goto exit_done;
+
+	if (slot->el->force_result_is_enabled)
+		ret = slot->el->callback(slot->el, DEBUGFS_FORCE_VOTE_REASON,
+					 slot->el->force_result);
+	else
+		ret = gvotable_run_callback(slot->el);
+
+exit_done:
+	gvotable_unlock_callback(slot->el);
+	return ret;
+}
+
+DEFINE_SIMPLE_ATTRIBUTE(debugfs_force_int_active_fops, NULL,
+			debugfs_force_int_active, "%llu\n");
+
+static void gvotable_debugfs_cleanup(void)
+{
+	debugfs_remove_recursive(debugfs_root);
+	debugfs_root = NULL;
+}
+
+static int gvotable_debugfs_create_el_int(struct election_slot *slot)
+{
+	if (!slot->de)
+		return -ENOENT;
+
+	debugfs_create_file("cast_int_vote", 0200, slot->de, slot,
+			    &debugfs_cast_int_vote_fops);
+
+	if (!slot->el->disable_force_int_entry) {
+		debugfs_create_file("force_int_value", 0200, slot->de, slot,
+				&debugfs_force_int_value_fops);
+		debugfs_create_file("force_int_active", 0200, slot->de, slot,
+				&debugfs_force_int_active_fops);
+	}
+
+	return 0;
+}
+
+static void gvotable_debugfs_create_el(struct election_slot *slot)
+{
+	/* TODO: add anon to a special directory */
+	if (!slot->el->has_name)
+		return;
+
+	if (!debugfs_root) {
+		debugfs_root = debugfs_create_dir("gvotables", 0);
+		if (!debugfs_root) {
+			pr_err("cannot create gvotables debug directory\n");
+			return;
+		}
+
+		/* add: list all the elections including the anon ones */
+		debugfs_create_file("elections", 0444, debugfs_root, NULL,
+				    &debugfs_elections_fops);
+
+		pr_err("gvotables debug directory OK\n");
+	}
+
+	slot->de = debugfs_create_dir(slot->el->name, debugfs_root);
+	if (!slot->de) {
+		pr_err("cannot create debugfs entry for slot=%p\n", slot);
+		return;
+	}
+
+	debugfs_create_file("status", 0444, slot->de, slot,
+			    &debugfs_ballots_fops);
+	debugfs_create_file("enable_vote", 0200, slot->de, slot,
+			    &debugs_enable_vote_fops);
+	debugfs_create_file("disable_vote", 0200, slot->de, slot,
+			    &debugs_disable_vote_fops);
+}
+
+static void gvotable_debugfs_delete_el(struct election_slot *slot)
+{
+	if (!slot->de)
+		return;
+
+	debugfs_remove_recursive(slot->de);
+	slot->de = NULL;
+}
+#else /* CONFIG_DEBUG_FS */
+static inline void gvotable_debugfs_cleanup(void)
+{
+}
+#endif
+
+static int __init gvotable_init(void)
+{
+	return 0;
+}
+
+static void __exit gvotable_exit(void)
+{
+	struct election_slot *slot, *tmp;
+
+	gvotable_debugfs_cleanup();
+	list_for_each_entry_safe(slot, tmp, &gvotables, list) {
+		pr_debug("Destroying %p\n", slot->el);
+		gvotable_destroy_election(slot->el);
+	}
+}
+
+module_init(gvotable_init);
+module_exit(gvotable_exit);
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("Luigi Zevola <zevola@google.com>");
+MODULE_DESCRIPTION("Election library for shared resources");
+MODULE_VERSION("0.01");
diff --git a/drivers/power/supply/qcom/logbuffer.c b/drivers/power/supply/qcom/logbuffer.c
new file mode 100644
index 000000000000..92e2fbe2beb2
--- /dev/null
+++ b/drivers/power/supply/qcom/logbuffer.c
@@ -0,0 +1,266 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Copyright 2019-2022 Google LLC
+ */
+
+#define pr_fmt(fmt) KBUILD_MODNAME ": " fmt
+
+#include <linux/module.h>
+#include <linux/mutex.h>
+#include <linux/rtc.h>
+#include <linux/sched/clock.h>
+#include <linux/seq_file.h>
+#include <linux/suspend.h>
+#include <linux/slab.h>
+#include <linux/syscore_ops.h>
+#include <linux/vmalloc.h>
+#include <linux/miscdevice.h>
+#include "logbuffer.h"
+
+#include <uapi/linux/time.h>
+
+#define LOG_BUFFER_ENTRIES      1024
+#define LOG_BUFFER_ENTRY_SIZE   256
+#define ID_LENGTH		50
+
+struct logbuffer {
+	int logbuffer_head;
+	int logbuffer_tail;
+	spinlock_t logbuffer_lock;	/* protect from multiple _log() */
+	u8 *buffer;
+	char id[ID_LENGTH];
+
+	struct miscdevice misc;
+	char name[50];
+	uint suspend_count;
+};
+
+/* Driver suspended count. */
+static uint driver_suspended_count;
+/* Log index for logbuffer_logk */
+static atomic_t log_index = ATOMIC_INIT(0);
+
+static void __logbuffer_log(struct logbuffer *instance,
+			    const char *tmpbuffer, bool record_utc)
+{
+	u64 ts_nsec = local_clock();
+	unsigned long rem_nsec = do_div(ts_nsec, 1000000000);
+
+	if (record_utc) {
+		struct timespec64 ts;
+		struct rtc_time tm;
+
+		ktime_get_real_ts64(&ts);
+		rtc_time64_to_tm(ts.tv_sec, &tm);
+		scnprintf(instance->buffer + (instance->logbuffer_head *
+			  LOG_BUFFER_ENTRY_SIZE),
+			  LOG_BUFFER_ENTRY_SIZE,
+			  "[%5lu.%06lu] %d-%02d-%02d %02d:%02d:%02d.%09lu UTC",
+			  (unsigned long)ts_nsec, rem_nsec / 1000,
+			  tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday,
+			  tm.tm_hour, tm.tm_min, tm.tm_sec, ts.tv_nsec);
+	} else {
+		scnprintf(instance->buffer + (instance->logbuffer_head *
+			  LOG_BUFFER_ENTRY_SIZE),
+			  LOG_BUFFER_ENTRY_SIZE, "[%5lu.%06lu] %s",
+			  (unsigned long)ts_nsec, rem_nsec / 1000,
+			  tmpbuffer);
+	}
+
+	instance->logbuffer_head = (instance->logbuffer_head + 1)
+			% LOG_BUFFER_ENTRIES;
+	if (instance->logbuffer_head == instance->logbuffer_tail) {
+		instance->logbuffer_tail = (instance->logbuffer_tail + 1) %
+					   LOG_BUFFER_ENTRIES;
+	}
+}
+
+void logbuffer_vlog(struct logbuffer *instance, const char *fmt,
+		    va_list args)
+{
+	char tmpbuffer[LOG_BUFFER_ENTRY_SIZE];
+	unsigned long flags;
+
+	if (!instance)
+		return;
+
+	/*
+	 * Empty log msgs are passed from TCPM to log RTC. The RTC is printed
+	 * if thats the first message printed after resume.
+	 */
+	if (fmt)
+		vsnprintf(tmpbuffer, sizeof(tmpbuffer), fmt, args);
+
+	spin_lock_irqsave(&instance->logbuffer_lock, flags);
+	if (instance->logbuffer_head < 0 ||
+	    instance->logbuffer_head >= LOG_BUFFER_ENTRIES) {
+		pr_warn("Bad log buffer index %d\n", instance->logbuffer_head);
+		goto abort;
+	}
+
+	/* Print UTC at the start of the buffer */
+	if (instance->logbuffer_head == instance->logbuffer_tail ||
+	    instance->logbuffer_head == LOG_BUFFER_ENTRIES - 1) {
+		__logbuffer_log(instance, tmpbuffer, true);
+	/* Print UTC when logging after suspend */
+	} else if (driver_suspended_count != instance->suspend_count) {
+		__logbuffer_log(instance, tmpbuffer, true);
+		instance->suspend_count = driver_suspended_count;
+	} else if (!fmt) {
+		goto abort;
+	}
+
+	__logbuffer_log(instance, tmpbuffer, false);
+
+abort:
+	spin_unlock_irqrestore(&instance->logbuffer_lock, flags);
+}
+EXPORT_SYMBOL_GPL(logbuffer_vlog);
+
+void logbuffer_log(struct logbuffer *instance, const char *fmt, ...)
+{
+	va_list args;
+
+	va_start(args, fmt);
+	logbuffer_vlog(instance, fmt, args);
+	va_end(args);
+}
+EXPORT_SYMBOL_GPL(logbuffer_log);
+
+void logbuffer_logk(struct logbuffer *instance, int loglevel, const char *fmt, ...)
+{
+	char log[LOG_BUFFER_ENTRY_SIZE];
+	unsigned int index;
+	va_list args;
+
+	if (!fmt || !instance)
+		return;
+
+	index = atomic_inc_return(&log_index);
+
+	va_start(args, fmt);
+	scnprintf(log, LOG_BUFFER_ENTRY_SIZE, "[%5u] %s", index, fmt);
+	logbuffer_vlog(instance, log, args);
+	scnprintf(log, LOG_BUFFER_ENTRY_SIZE, "%s: [%5u] %s\n", instance->name, index, fmt);
+	vprintk_emit(0, loglevel, NULL, log, args);
+	va_end(args);
+}
+EXPORT_SYMBOL_GPL(logbuffer_logk);
+
+static int logbuffer_seq_show(struct seq_file *s, void *v)
+{
+	struct logbuffer *instance = (struct logbuffer *)s->private;
+	int tail;
+
+	spin_lock_irq(&instance->logbuffer_lock);
+	tail = instance->logbuffer_tail;
+	while (tail != instance->logbuffer_head) {
+		seq_printf(s, "%s\n", instance->buffer +
+			   (tail * LOG_BUFFER_ENTRY_SIZE));
+		tail = (tail + 1) % LOG_BUFFER_ENTRIES;
+	}
+
+	spin_unlock_irq(&instance->logbuffer_lock);
+
+	return 0;
+}
+
+static int logbuffer_dev_open(struct inode *inode, struct file *file)
+{
+	struct logbuffer *instance =
+		container_of(file->private_data, struct logbuffer, misc);
+
+	inode->i_private = instance;
+	file->private_data = NULL;
+	return single_open(file, logbuffer_seq_show, inode->i_private);
+}
+
+static const struct file_operations logbuffer_dev_operations = {
+	.owner = THIS_MODULE,
+	.open = logbuffer_dev_open,
+	.read = seq_read,
+	.release = single_release,
+};
+
+struct logbuffer *logbuffer_register(const char *name)
+{
+	struct logbuffer *instance;
+	int ret;
+
+	instance = kzalloc(sizeof(*instance), GFP_KERNEL);
+	if (!instance)
+		return ERR_PTR(-ENOMEM);
+
+	instance->buffer = vzalloc(LOG_BUFFER_ENTRIES * LOG_BUFFER_ENTRY_SIZE);
+	if (!instance->buffer) {
+		instance = ERR_PTR(-ENOMEM);
+		goto free_instance;
+	}
+
+	strscpy(instance->name, "logbuffer_", sizeof(instance->name));
+	strlcat(instance->name, name, sizeof(instance->name));
+	instance->misc.minor = MISC_DYNAMIC_MINOR;
+	instance->misc.name = instance->name;
+	instance->misc.fops = &logbuffer_dev_operations;
+
+	ret = misc_register(&instance->misc);
+	if (ret) {
+		pr_err("Logbuffer error while doing misc_register ret=%d\n", ret);
+		goto free_buffer;
+	}
+
+	strscpy(instance->id, name, sizeof(instance->id));
+
+	spin_lock_init(&instance->logbuffer_lock);
+
+	pr_info("id:%s registered\n", name);
+	return instance;
+
+free_buffer:
+	vfree(instance->buffer);
+free_instance:
+	kfree(instance);
+
+	return ERR_PTR(-ENOMEM);
+}
+EXPORT_SYMBOL_GPL(logbuffer_register);
+
+void logbuffer_unregister(struct logbuffer *instance)
+{
+	if (!instance)
+		return;
+
+	misc_deregister(&instance->misc);
+
+	vfree(instance->buffer);
+	pr_info("id:%s unregistered\n", instance->id);
+	kfree(instance);
+}
+EXPORT_SYMBOL_GPL(logbuffer_unregister);
+
+static int logbuffer_suspend(void)
+{
+	driver_suspended_count += 1;
+	return 0;
+}
+
+static struct syscore_ops logbuffer_ops = {
+	.suspend        = logbuffer_suspend,
+};
+
+static int __init logbuffer_dev_init(void)
+{
+	register_syscore_ops(&logbuffer_ops);
+	driver_suspended_count = 0;
+	return 0;
+}
+
+static void logbuffer_dev_exit(void)
+{
+	unregister_syscore_ops(&logbuffer_ops);
+}
+early_initcall(logbuffer_dev_init);
+module_exit(logbuffer_dev_exit);
+
+MODULE_LICENSE("GPL");
+MODULE_DESCRIPTION("Google BMS logbuffer");
diff --git a/drivers/power/supply/qcom/logbuffer.h b/drivers/power/supply/qcom/logbuffer.h
new file mode 100644
index 000000000000..f05ec34ac5b5
--- /dev/null
+++ b/drivers/power/supply/qcom/logbuffer.h
@@ -0,0 +1,27 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Copyright 2019-2022 Google LLC
+ */
+
+#ifndef __GOOGLE_LOGBUFFER_H_
+#define __GOOGLE_LOGBUFFER_H_
+
+#include <linux/stdarg.h>
+
+struct logbuffer;
+
+void logbuffer_log(struct logbuffer *instance, const char *fmt, ...);
+void logbuffer_logk(struct logbuffer *instance, int loglevel, const char *fmt, ...);
+void logbuffer_vlog(struct logbuffer *instance, const char *fmt,
+		    va_list args);
+/*
+ * Registers a new log buffer entry.
+ * param name: name of the file in the /d/logbuffer/ directory.
+ * returns the pointer to the logbuffer metadata.
+ */
+struct logbuffer *logbuffer_register(const char *name);
+
+void logbuffer_unregister(struct logbuffer *instance);
+
+#endif /* __GOOGLE_LOGBUFFER_H_ */
+
diff --git a/drivers/power/supply/qcom/misc/gvotable.h b/drivers/power/supply/qcom/misc/gvotable.h
new file mode 100644
index 000000000000..0bd547ba4249
--- /dev/null
+++ b/drivers/power/supply/qcom/misc/gvotable.h
@@ -0,0 +1,121 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Copyright 2019-2022 Google LLC
+ */
+
+#ifndef __GOOGLE_GVOTABLE_H_
+#define __GOOGLE_GVOTABLE_H_
+
+#include <linux/types.h>
+#include <linux/mutex.h>
+
+#define GVOTABLE_MAX_REASON_LEN		32
+
+#define GVOTABLE_PTR_TO_INT(v)		((int)(uintptr_t)(v))
+
+struct gvotable_election;
+
+typedef int (*gvotable_cmp_fn)(void *a, void *b);
+typedef int (*gvotable_callback_fn)(struct gvotable_election *el,
+				    const char *reason,
+				    void *vote);
+
+struct gvotable_election *
+gvotable_create_election(const char *name, int vote_size,
+			 int  (*cmp_fn)(void *, void *),
+			 gvotable_callback_fn callback_fn,
+			 void *data);
+
+#define _GVOTABLE_EPC(a, ...) a ## __VA_ARGS__
+#define GVOTABLE__ELECTION_HELPER(t) \
+	_GVOTABLE_EPC(_GVOTABLE_EPC(gvotable_create_, t)_election)(name, cmp_fn, cb_fn, data)
+
+/* NOTE: cannot change the data after init to avoid adding a lock for it */
+struct gvotable_election *
+gvotable_create_int_election(const char *name, gvotable_cmp_fn cmp_fn,
+			     gvotable_callback_fn callback_fn,
+			     void *data);
+
+struct gvotable_election *
+gvotable_create_bool_election(const char *name, gvotable_callback_fn cb_fn,
+			      void *data);
+
+int gvotable_destroy_election(struct gvotable_election *el);
+
+struct gvotable_election *gvotable_election_get_handle(const char *name);
+
+/* TODO: redesign this API  */
+typedef int (*gvotable_foreach_callback_fn)(void *data, const char *reason,
+					    void *vote);
+int gvotable_election_for_each(struct gvotable_election *el,
+			       gvotable_foreach_callback_fn callback_fn,
+			       void *callback_data);
+int gvotable_election_set_result(struct gvotable_election *el,
+				 const char *reason, void *vote);
+
+void *gvotable_get_data(struct gvotable_election *el);
+
+int gvotable_get_current_reason(struct gvotable_election *el, char *reason,
+				int max_reason_len);
+
+int gvotable_set_default(struct gvotable_election *el, void *default_val);
+int gvotable_get_default(struct gvotable_election *el, void **default_val);
+
+int gvotable_election_set_name(struct gvotable_election *el, const char *name);
+
+int gvotable_use_default(struct gvotable_election *el, bool default_is_enabled);
+
+int gvotable_cast_vote(struct gvotable_election *el, const char *reason,
+		       void *vote, bool enabled);
+static inline int gvotable_cast_int_vote(struct gvotable_election *el,
+					 const char *reason, int vote,
+					 bool enabled)
+{
+	return gvotable_cast_vote(el, reason, (void *)(long)vote, enabled);
+}
+static inline int gvotable_cast_long_vote(struct gvotable_election *el,
+					  const char *reason, long vote,
+					  bool enabled)
+{
+	return gvotable_cast_vote(el, reason, (void *)vote, enabled);
+}
+static inline int gvotable_cast_bool_vote(struct gvotable_election *el,
+					  const char *reason, bool vote)
+{
+	return gvotable_cast_vote(el, reason, 0, vote);
+}
+
+int gvotable_recast_ballot(struct gvotable_election *el, const char *reason,
+			   bool enabled);
+int gvotable_run_election(struct gvotable_election *el, bool force_callback);
+
+
+int gvotable_get_vote(struct gvotable_election *el, const char *reason,
+		      void **vote);
+int gvotable_get_int_vote(struct gvotable_election *el, const char *reason);
+
+int gvotable_is_enabled(struct gvotable_election *el, const char *reason,
+			bool *enabled);
+
+int gvotable_get_current_int_vote(struct gvotable_election *el);
+int gvotable_get_current_vote(struct gvotable_election *el, const void **vote);
+int gvotable_copy_current_result(struct gvotable_election *el, void *vote,
+				 int vote_size);
+
+int gvotable_comparator_uint_max(void *a, void *b);
+int gvotable_comparator_uint_min(void *a, void *b);
+int gvotable_comparator_int_max(void *a, void *b);
+int gvotable_comparator_int_min(void *a, void *b);
+int gvotable_comparator_most_recent(void *a, void *b);
+int gvotable_comparator_least_recent(void *a, void *b);
+
+/* dump, debug */
+typedef int (*gvotable_v2sfn_t)(char *str, size_t len, const void *);
+int gvotable_v2s_int(char *str,  size_t len, const void *vote);
+int gvotable_v2s_uint(char *str, size_t len, const void *vote);
+int gvotable_v2s_uint_hex(char *str, size_t len, const void *vote);
+void gvotable_set_vote2str(struct gvotable_election *el,
+			   gvotable_v2sfn_t vote2str);
+int gvotable_disable_force_int_entry(struct gvotable_election *el);
+
+#endif /* __GOOGLE_GVOTABLE_H_*/
diff --git a/drivers/power/supply/qcom/pmic-voter-compat.c b/drivers/power/supply/qcom/pmic-voter-compat.c
index b3307be1f49e..b1be6e07889c 100644
--- a/drivers/power/supply/qcom/pmic-voter-compat.c
+++ b/drivers/power/supply/qcom/pmic-voter-compat.c
@@ -17,7 +17,7 @@
 #include <linux/kernel.h>
 #include <linux/list.h>
 #include <linux/slab.h>
-#include <misc/gvotable.h>
+#include "misc/gvotable.h"
 #include <linux/pmic-voter.h>
 
 #define V2EL(x) ((struct gvotable_election *)(v))
diff --git a/drivers/power/supply/qcom/qbg-battery-profile.c b/drivers/power/supply/qcom/qbg-battery-profile.c
index 6e8dc1dad8b1..fcb5d1cb9303 100644
--- a/drivers/power/supply/qcom/qbg-battery-profile.c
+++ b/drivers/power/supply/qcom/qbg-battery-profile.c
@@ -513,8 +513,6 @@ int qbg_batterydata_init(struct device_node *profile_node,
 
 	battery->battery_class = class_create(THIS_MODULE, "qbg_battery");
 	if (IS_ERR_OR_NULL(battery->battery_class)) {
-		pr_err("Failed to create qbg-battery class (%d)\n",
-			PTR_ERR(battery->battery_class));
 		rc = -ENODEV;
 		goto delete_cdev;
 	}
@@ -523,8 +521,6 @@ int qbg_batterydata_init(struct device_node *profile_node,
 						battery->dev_no, NULL,
 						"qbg_battery");
 	if (IS_ERR_OR_NULL(battery->battery_device)) {
-		pr_err("Failed to create battery_device device (%d)\n",
-			PTR_ERR(battery->battery_device));
 		rc = -ENODEV;
 		goto destroy_class;
 	}
@@ -596,7 +592,6 @@ int qbg_lookup_soc_ocv(struct qbg_battery_data *battery, int *pon_soc, int ocv,
 	}
 
 	if (*pon_soc == -EINVAL) {
-		pr_debug("%d ocv wasn't found in the LUT returning 100%\n", ocv);
 		*pon_soc = 10000;
 	}
 
diff --git a/drivers/power/supply/qcom/qti-qbg.c b/drivers/power/supply/qcom/qti-qbg.c
index c79ad961c9c7..c6001e77be70 100644
--- a/drivers/power/supply/qcom/qti-qbg.c
+++ b/drivers/power/supply/qcom/qti-qbg.c
@@ -1435,8 +1435,6 @@ static int qbg_load_battery_profile(struct qti_qbg *chip)
 	if (!rc)
 		chip->recharge_vflt_delta_mv = temp[0];
 
-	qbg_dbg(chip, QBG_DEBUG_SDAM, "Recharge SOC=% Recharge-Vflt=%duV Recharge-Ibat=%dmA\n",
-		chip->recharge_soc, chip->recharge_vflt_delta_mv, chip->recharge_iterm_ma);
 
 	rc = parse_step_chg_jeita_params(chip, profile_node);
 out:
@@ -1684,7 +1682,6 @@ static int qbg_get_pon_reading(struct qti_qbg *chip, unsigned int *ocv,
 		*ocv = VBAT_0PCT_OCV;
 
 	*ibat = ibat_data * IBATT_10A_LSB * ICHG_FS_10A;
-	qbg_dbg(chip, QBG_DEBUG_PON, "ocv:%u ibat:%u\n", ocv, ibat);
 
 	return 0;
 }
@@ -1693,7 +1690,6 @@ static int qbg_determine_pon_soc(struct qti_qbg *chip)
 {
 	int rc, batt_temp;
 	union power_supply_propval prop = {0, };
-	unsigned long time_diff = 0;
 	unsigned int pon_ocv;
 	time64_t rtc_sec;
 
@@ -1746,9 +1742,6 @@ static int qbg_determine_pon_soc(struct qti_qbg *chip)
 	chip->pon_soc = DIV_ROUND_CLOSEST(chip->pon_soc, 100);
 	chip->soc = chip->pon_soc;
 
-	qbg_dbg(chip, QBG_DEBUG_PON, "Shutdown: SOC=%d OCV=%duV Ibat:%duA timediff=%lusecs, time_now=%lusecs\n",
-			chip->pon_soc, chip->pon_ocv, chip->pon_ibat, time_diff, rtc_sec);
-
 	return 0;
 }
 
@@ -1783,8 +1776,6 @@ static int qbg_init_psy(struct qti_qbg *chip)
 	chip->qbg_psy = devm_power_supply_register(chip->dev, &qbg_psy_desc,
 						&qbg_psy_cfg);
 	if (IS_ERR_OR_NULL(chip->qbg_psy)) {
-		pr_err("Failed to register qbg_psy, rc = %d\n",
-				PTR_ERR(chip->qbg_psy));
 		return PTR_ERR(chip->qbg_psy);
 	}
 
@@ -2284,8 +2275,6 @@ static long qbg_device_ioctl(struct file *file, unsigned int cmd,
 		config.essential_param_revid = chip->essential_param_revid;
 		for (i = 0; i < QBG_STATE_MAX; i++) {
 			config.sample_time_us[i] = chip->sample_time_us[i];
-			qbg_dbg(chip, QBG_DEBUG_DEVICE, "QBGIOCXCFG: sample_time_us[%d]:%u\n",
-					i, config.sample_time_us[i]);
 		}
 
 		if (config.batt_id != chip->batt_profile_id) {
@@ -2340,8 +2329,6 @@ static long qbg_device_ioctl(struct file *file, unsigned int cmd,
 			pr_err("Failed to write essential params, rc=%d\n", rc);
 			return -EFAULT;
 		}
-		qbg_dbg(chip, QBG_DEBUG_SDAM, "Essential params written, time:%lu secs\n",
-					rtc_sec);
 
 		break;
 	case QBGIOCXSTEPCHGCFG:
@@ -2944,13 +2931,10 @@ static int qbg_restore(struct device *dev)
 	/* Init & clear SDAM to kick-start QBG sampling */
 	ret = qbg_init_sdam(chip);
 	if (ret < 0) {
-		dev_err(dev, "Failed to init qbg sdam rc = %d\n");
 		return ret;
 	}
 
 	ret = qbg_register_interrupts(chip);
-	if (ret < 0)
-		dev_err(dev, "Failed to register qbg interrupt rc = %d\n");
 
 	return ret;
 }
diff --git a/drivers/power/supply/qcom/smblite-lib.c b/drivers/power/supply/qcom/smblite-lib.c
index 022b4ebe67ce..ecb9838a66ab 100644
--- a/drivers/power/supply/qcom/smblite-lib.c
+++ b/drivers/power/supply/qcom/smblite-lib.c
@@ -1706,8 +1706,6 @@ int smblite_lib_set_concurrent_config(struct smb_charger *chg, bool enable)
 	if (enable) {
 		/* Check if USB is connected */
 		if (!usb_present) {
-			smblite_lib_dbg(chg, PR_MISC,
-				"Failed to enable concurrent mode USB disconnected\n", rc);
 			goto failure;
 		}
 
diff --git a/drivers/power/supply/qcom/smblite-remote-bms.c b/drivers/power/supply/qcom/smblite-remote-bms.c
index f3f7074578cd..f07075163fef 100644
--- a/drivers/power/supply/qcom/smblite-remote-bms.c
+++ b/drivers/power/supply/qcom/smblite-remote-bms.c
@@ -429,7 +429,6 @@ static int seb_notifier_cb(struct notifier_block *nb,
 
 		rc = remote_bms_get_data(bms);
 		if (rc < 0) {
-			pr_err("Couldn't request runtime data from QBG, rc=%d\n");
 			return rc;
 		}
 		pr_debug("Slate-UP, requested first data from QBG\n");
@@ -466,9 +465,6 @@ static int seb_notifier_cb(struct notifier_block *nb,
 		return -EINVAL;
 	}
 
-	pr_debug("Remote-fg data received: event:%d command:%d num_params:%d\n",
-			event, command, num_params);
-
 	buf_size = SEB_BUF_HEADER_SIZE + (num_params * SEB_EACH_PARAM_SIZE);
 	if (buf_size > SEB_RX_BUF_SIZE) {
 		pr_err("Received more parameters from remote-fg, processing only till %d bytes\n",
diff --git a/drivers/power/supply/qcom/step-chg-jeita.c b/drivers/power/supply/qcom/step-chg-jeita.c
index 05d58c77cae3..44ab2d0d9c9f 100644
--- a/drivers/power/supply/qcom/step-chg-jeita.c
+++ b/drivers/power/supply/qcom/step-chg-jeita.c
@@ -510,13 +510,6 @@ static int get_step_chg_jeita_setting_from_profile(struct step_chg_info *chip)
 				chip->jeita_fcc_scaling = true;
 		}
 
-		pr_debug("jeita-fcc-scaling: enabled = %d, jeita-fcc-scaling-temp-threshold = [%d, %d], jeita-scaling-min-fcc-ua = %ld, jeita-scaling-max_fcc_ua = %ld,jeita-fcc-step-size = %ld\n",
-			chip->jeita_fcc_scaling,
-			chip->jeita_fcc_scaling_temp_threshold[0],
-			chip->jeita_fcc_scaling_temp_threshold[1],
-			jeita_scaling_min_fcc_ua, chip->jeita_max_fcc_ua,
-			chip->jeita_fcc_step_size
-			);
 	}
 
 	return rc;
diff --git a/drivers/rpmsg/qcom_glink_native.c b/drivers/rpmsg/qcom_glink_native.c
index 5ac3f81ba8da..33314026df5a 100644
--- a/drivers/rpmsg/qcom_glink_native.c
+++ b/drivers/rpmsg/qcom_glink_native.c
@@ -1254,8 +1254,6 @@ static int qcom_glink_rx_data_zero_copy(struct qcom_glink *glink, size_t avail)
 		goto advance_rx;
 	}
 	if (intent->size) {
-		CH_ERR(channel, "zero copy req wrong intent liid:%d size:%d\n",
-		       liid, intent->size);
 		goto advance_rx;
 	}
 
diff --git a/drivers/rpmsg/qcom_glink_rpm.c b/drivers/rpmsg/qcom_glink_rpm.c
index 37ae14da3d32..ff4618982d1f 100644
--- a/drivers/rpmsg/qcom_glink_rpm.c
+++ b/drivers/rpmsg/qcom_glink_rpm.c
@@ -312,7 +312,6 @@ struct qcom_glink *glink_rpm_register(struct device *parent,
 		goto err_put_dev;
 	}
 
-	pr_info("%s: msg_ram: %x, msg_ram_size: %d\n", &msg_ram, msg_ram_size);
 	ret = glink_rpm_parse_toc(dev, msg_ram, msg_ram_size,
 				  rx_pipe, tx_pipe);
 	if (ret)
diff --git a/drivers/soc/qcom/Makefile b/drivers/soc/qcom/Makefile
index 7359bda80d94..2066e296681d 100644
--- a/drivers/soc/qcom/Makefile
+++ b/drivers/soc/qcom/Makefile
@@ -60,6 +60,7 @@ obj-$(CONFIG_GIC_INTERRUPT_ROUTING) += gic_intr_routing.o
 obj-$(CONFIG_QCOM_RIMPS) += qcom_rimps.o
 obj-$(CONFIG_QCOM_TLMM_VM_IRQCHIP) += qcom_tlmm_vm_irqchip.o
 obj-$(CONFIG_QCOM_APR) += apr.o
+obj-y += sw5100_bms.o
 obj-$(CONFIG_QCOM_EUD) += eud.o
 obj-$(CONFIG_QCOM_LLCC) += llcc-qcom.o
 obj-$(CONFIG_QCOM_MEMORY_DUMP_V2) += memory_dump_v2.o
diff --git a/drivers/soc/qcom/battery-profile-loader.h b/drivers/soc/qcom/battery-profile-loader.h
new file mode 100644
index 000000000000..b1a3e5703125
--- /dev/null
+++ b/drivers/soc/qcom/battery-profile-loader.h
@@ -0,0 +1,106 @@
+/* SPDX-License-Identifier: GPL-2.0-only */
+/*
+ * Copyright (c) 2013-2014, 2016-2020 The Linux Foundation. All rights reserved.
+ * Copyright (c) 2022, Qualcomm Innovation Center, Inc. All rights reserved.
+ */
+
+#ifndef __BATTERY_PROFILE_LOADER_H
+#define __BATTERY_PROFILE_LOADER_H
+
+#include <linux/of.h>
+
+#define MAX_BATT_ID_NUM		4
+#define DEGC_SCALE		10
+
+struct batt_ids {
+	int kohm[MAX_BATT_ID_NUM];
+	int num;
+};
+
+/**
+ * struct soh_range -
+ * @batt_age_level:	Battery age level (e.g. 0, 1 etc.,)
+ * @soh_min:		Minimum SOH (state of health) level that this battery
+ *			profile can support.
+ * @soh_max:		Maximum SOH (state of health) level that this battery
+ *			profile can support.
+ */
+struct soh_range {
+	int	batt_age_level;
+	int	soh_min;
+	int	soh_max;
+};
+
+/**
+ * of_batterydata_get_best_profile() - Find matching battery data device node
+ * @batterydata_container_node: pointer to the battery-data container device
+ *		node containing the profile nodes.
+ * @batt_id_kohm: Battery ID in KOhms for which we want to find the profile.
+ * @batt_type: Battery type which we want to force load the profile.
+ *
+ * This routine returns a device_node pointer to the closest match battery data
+ * from device tree based on the battery id reading.
+ */
+struct device_node *of_batterydata_get_best_profile(
+		const struct device_node *batterydata_container_node,
+		int batt_id_kohm, const char *batt_type);
+
+/**
+ * of_batterydata_get_best_profile_and_id() - Find matching battery data
+ * device node and ID
+ * @batterydata_container_node: pointer to the battery-data container device
+ *		node containing the profile nodes.
+ * @batt_id_kohm: Battery ID in KOhms for which we want to find the profile.
+ * @batt_type: Battery type which we want to force load the profile.
+ * @profile_id_kohm: Battery profile ID in KOhms closest to batt_id_kohm
+ *
+ * This routine returns a device_node pointer to the closest match battery data
+ * from device tree based on the battery id reading.
+ */
+struct device_node *of_batterydata_get_best_profile_and_id(
+		const struct device_node *batterydata_container_node,
+		int batt_id_kohm, const char *batt_type, int *profile_id_kohm);
+
+/**
+ * of_batterydata_get_best_aged_profile() - Find best aged battery profile
+ * @batterydata_container_node: pointer to the battery-data container device
+ *		node containing the profile nodes.
+ * @batt_id_kohm: Battery ID in KOhms for which we want to find the profile.
+ * @batt_age_level: Battery age level.
+ * @avail_age_level: Available battery age level.
+ *
+ * This routine returns a device_node pointer to the closest match battery data
+ * from device tree based on the battery id reading and age level.
+ */
+struct device_node *of_batterydata_get_best_aged_profile(
+		const struct device_node *batterydata_container_node,
+		int batt_id_kohm, int batt_age_level, int *avail_age_level);
+
+/**
+ * of_batterydata_get_aged_profile_count() - Gets the number of aged profiles
+ * @batterydata_node: pointer to the battery-data container device
+ *		node containing the profile nodes.
+ * @batt_id_kohm: Battery ID in KOhms for which we want to find the profile.
+ * @count: Number of aged profiles available to support SOH based profile
+ * loading.
+ *
+ * This routine returns zero if valid number of aged profiles are available.
+ */
+int of_batterydata_get_aged_profile_count(
+		const struct device_node *batterydata_node,
+		int batt_id_kohm, int *count);
+
+/**
+ * of_batterydata_read_soh_aged_profiles() - Reads the data from aged profiles
+ * @batterydata_node: pointer to the battery-data container device
+ *		node containing the profile nodes.
+ * @batt_id_kohm: Battery ID in KOhms for which we want to find the profile.
+ * @soh_data: SOH data from the profile if it is found to be valid.
+ *
+ * This routine returns zero if SOH data of aged profiles is valid.
+ */
+int of_batterydata_read_soh_aged_profiles(
+		const struct device_node *batterydata_node,
+		int batt_id_kohm, struct soh_range *soh_data);
+
+#endif /* __BATTERY_PROFILE_LOADER_H */
diff --git a/drivers/soc/qcom/battery.h b/drivers/soc/qcom/battery.h
new file mode 100644
index 000000000000..1a6062fbcde2
--- /dev/null
+++ b/drivers/soc/qcom/battery.h
@@ -0,0 +1,24 @@
+/* SPDX-License-Identifier: GPL-2.0-only */
+/*
+ * Copyright (c) 2017, 2019-2020 The Linux Foundation. All rights reserved.
+ * Copyright (c) 2022, Qualcomm Innovation Center, Inc. All rights reserved.
+ */
+#ifndef __BATTERY_H
+#define __BATTERY_H
+
+struct charger_param {
+	u32 fcc_step_delay_ms;
+	u32 fcc_step_size_ua;
+	u32 fcc_step_start_ua;
+	u32 smb_version;
+	u32 hvdcp2_max_icl_ua;
+	u32 hvdcp3_max_icl_ua;
+	u32 qc4_max_icl_ua;
+	u32 forced_main_fcc;
+	int (*iio_read)(struct device *dev, int iio_chan, int *val);
+	int (*iio_write)(struct device *dev, int iio_chan, int val);
+};
+
+int qcom_batt_init(struct device *dev, struct charger_param *param);
+void qcom_batt_deinit(void);
+#endif /* __BATTERY_H */
diff --git a/drivers/soc/qcom/boot_stats.c b/drivers/soc/qcom/boot_stats.c
index b8ff3edcd8ac..931f6843c9e2 100644
--- a/drivers/soc/qcom/boot_stats.c
+++ b/drivers/soc/qcom/boot_stats.c
@@ -542,7 +542,7 @@ static int __init boot_stats_init(void)
 	if (boot_marker_enabled()) {
 		ret = init_bootkpi();
 		if (ret) {
-			pr_err("boot_stats: BootKPI init failed %d\n");
+		  pr_err("boot_stats: BootKPI init failed %d\n", ret);
 			return ret;
 		}
 #ifdef CONFIG_MSM_BOOT_TIME_MARKER
diff --git a/drivers/soc/qcom/crm.c b/drivers/soc/qcom/crm.c
index 694e1280c7af..7b8d663556b7 100644
--- a/drivers/soc/qcom/crm.c
+++ b/drivers/soc/qcom/crm.c
@@ -22,9 +22,6 @@
 
 #include <soc/qcom/crm.h>
 
-#define CREATE_TRACE_POINTS
-#include "trace-crm.h"
-
 #define CRM_DRV_IPC_LOG_SIZE		2
 #define MAX_NAME_LENGTH			20
 
@@ -403,8 +400,6 @@ int crm_channel_switch_complete(const struct crm_drv *drv, u32 ch)
 	if (!retry)
 		ret = -EBUSY;
 
-	trace_crm_switch_channel(drv->name, ch, ret);
-
 	return ret;
 }
 
@@ -461,7 +456,6 @@ static void crm_flush_cache(struct crm_drv *drv, struct crm_vcd *vcd, u32 ch, u3
 		for (j = 0; j < vcd->num_pwr_states; j++) {
 			reg = crm_get_pwr_state_reg(j);
 			write_crm_reg(drv, reg, ch, vcd_type, i, vcd->cache[i][j]);
-			trace_crm_write_vcd_votes(drv->name, vcd_type, i, j, vcd->cache[i][j]);
 		}
 	}
 }
@@ -557,7 +551,6 @@ static irqreturn_t crm_vote_complete_irq(int irq, void *p)
 					continue;
 
 				write_crm_reg(drv, IRQ_CLEAR, 0, j, k, IRQ_CLEAR_BIT);
-				trace_crm_irq(drv->name, j, k, irq_status);
 
 				votes = &vcd->sw_votes[k];
 				if (!votes->in_progress) {
@@ -647,7 +640,6 @@ static int crm_send_cmd(struct crm_drv *drv, u32 vcd_type, const struct crm_cmd
 	}
 
 	spin_unlock_irqrestore(&drv->lock, flags);
-	trace_crm_write_vcd_votes(drv->name, vcd_type, resource_idx, pwr_state, data);
 
 	if (compl && wait) {
 		time_left = CRM_TIMEOUT_MS;
@@ -677,7 +669,6 @@ static void crm_cache_vcd_votes(struct crm_drv *drv, u32 vcd_type, const struct
 
 	spin_unlock(&drv->cache_lock);
 
-	trace_crm_cache_vcd_votes(drv->name, vcd_type, resource_idx, pwr_state, data);
 }
 
 static bool crm_is_invalid_cmd(struct crm_drv *drv, u32 vcd_type, const struct crm_cmd *cmd)
diff --git a/drivers/soc/qcom/dcvs/bwmon.c b/drivers/soc/qcom/dcvs/bwmon.c
index 9b28ae3a5d1a..ae534c443655 100644
--- a/drivers/soc/qcom/dcvs/bwmon.c
+++ b/drivers/soc/qcom/dcvs/bwmon.c
@@ -21,9 +21,7 @@
 #include <linux/log2.h>
 #include <linux/sizes.h>
 #include <soc/qcom/dcvs.h>
-#include <trace/hooks/sched.h>
 #include "bwmon.h"
-#include "trace-dcvs.h"
 
 static LIST_HEAD(hwmon_list);
 static DEFINE_SPINLOCK(list_lock);
@@ -402,11 +400,6 @@ static int __bw_hwmon_sw_sample_end(struct bw_hwmon *hwmon)
 	node->wake = wake;
 	node->sampled = true;
 
-	trace_bw_hwmon_meas(dev_name(hwmon->dev),
-				mbps,
-				us,
-				wake);
-
 	return wake;
 }
 
@@ -434,11 +427,6 @@ static int __bw_hwmon_hw_sample_end(struct bw_hwmon *hwmon)
 	node->wake = wake;
 	node->sampled = true;
 
-	trace_bw_hwmon_meas(dev_name(hwmon->dev),
-				mbps,
-				node->sample_ms * USEC_PER_MSEC,
-				wake);
-
 	return 1;
 }
 
@@ -642,19 +630,6 @@ static unsigned long get_bw_and_set_irq(struct hwmon_node *node,
 	if (node->ab_scale < 100)
 		new_bw = mult_frac(new_bw, node->ab_scale, 100);
 	freq_mbps->ab = roundup(new_bw, node->bw_step);
-	trace_bw_hwmon_update(dev_name(node->hw->dev),
-				freq_mbps->ab,
-				freq_mbps->ib,
-				hw->up_wake_mbps,
-				hw->down_wake_mbps);
-
-	trace_bw_hwmon_debug(dev_name(node->hw->dev),
-				req_mbps,
-				meas_mbps_zone,
-				node->hist_max_mbps,
-				node->hist_mem,
-				node->hyst_mbps,
-				node->hyst_en);
 	return req_mbps;
 }
 
@@ -688,7 +663,7 @@ static bool bwmon_update_cur_freq(struct hwmon_node *node)
 }
 
 static const u64 HALF_TICK_NS = (NSEC_PER_SEC / HZ) >> 1;
-static void bwmon_jiffies_update_cb(void *unused, void *extra)
+void bwmon_jiffies_update_cb(void *unused, void *extra)
 {
 	struct bw_hwmon *hw;
 	struct hwmon_node *node;
@@ -1813,8 +1788,6 @@ static int qcom_bwmon_driver_probe(struct platform_device *pdev)
 			mutex_unlock(&bwmon_lock);
 			return -ENOMEM;
 		}
-		register_trace_android_vh_jiffies_update(
-						bwmon_jiffies_update_cb, NULL);
 	}
 	mutex_unlock(&bwmon_lock);
 	ret = start_monitor(&m->hw);
diff --git a/drivers/soc/qcom/dcvs/dcvs.c b/drivers/soc/qcom/dcvs/dcvs.c
index fbe940a5b788..81b876f95db7 100644
--- a/drivers/soc/qcom/dcvs/dcvs.c
+++ b/drivers/soc/qcom/dcvs/dcvs.c
@@ -146,8 +146,6 @@ static ssize_t store_boost_freq(struct kobject *kobj,
 	}
 	mutex_unlock(&path->voter_lock);
 
-	trace_qcom_dcvs_boost(hw->type, path->type, hw->boost_freq,
-				new_freq.ib, new_freq.ab);
 
 	return count;
 }
@@ -172,7 +170,7 @@ static ssize_t show_cur_freq(struct kobject *kobj,
 			cur_freq = max(cur_freq, path->percpu_cur_freqs[cpu]);
 	}
 
-	return scnprintf(buf, PAGE_SIZE, "%lu\n", cur_freq);
+	return scnprintf(buf, PAGE_SIZE, "%lu\n", (long)cur_freq);
 }
 
 static ssize_t show_available_frequencies(struct kobject *kobj,
@@ -183,7 +181,7 @@ static ssize_t show_available_frequencies(struct kobject *kobj,
 
 	for (i = 0; i < hw->table_len; i++)
 		cnt += scnprintf(buf + cnt, PAGE_SIZE - cnt, "%lu ",
-				hw->freq_table[i]);
+				 (long)hw->freq_table[i]);
 
 	if (cnt)
 		cnt--;
@@ -330,9 +328,6 @@ static int qcom_dcvs_sp_update(const char *name, struct dcvs_freq *votes,
 		mutex_unlock(&path->voter_lock);
 		if (ret < 0)
 			return ret;
-		trace_qcom_dcvs_update(name, hw_type, path->type, votes[i].ib,
-					new_freq.ib, votes[i].ab, new_freq.ab,
-					path->hw->boost_freq);
 	}
 
 	return ret;
@@ -371,8 +366,6 @@ static int qcom_dcvs_fp_update(const char *name, struct dcvs_freq *votes,
 		new_freqs[i].ib = get_target_freq(path, votes[i].ib);
 		if (new_freqs[i].ib != path->cur_freq.ib)
 			commit_mask |= BIT(i);
-		trace_qcom_dcvs_update(name, hw_type, path->type, votes[i].ib,
-					new_freqs[i].ib, 0, 0, 0);
 	}
 
 	if (commit_mask)
@@ -420,8 +413,6 @@ static int qcom_dcvs_percpu_update(const char *name, struct dcvs_freq *votes,
 			if (ret < 0)
 				return ret;
 		}
-		trace_qcom_dcvs_update(name, hw_type, path->type, votes[i].ib,
-					new_freq.ib, 0, 0, 0);
 	}
 
 	return ret;
diff --git a/drivers/soc/qcom/dcvs/trace-dcvs.c b/drivers/soc/qcom/dcvs/trace-dcvs.c
index f5ac37a9e87e..b3e1573543c8 100644
--- a/drivers/soc/qcom/dcvs/trace-dcvs.c
+++ b/drivers/soc/qcom/dcvs/trace-dcvs.c
@@ -5,13 +5,3 @@
 
 #include <soc/qcom/dcvs.h>
 
-#define CREATE_TRACE_POINTS
-#include "trace-dcvs.h"
-
-EXPORT_TRACEPOINT_SYMBOL(qcom_dcvs_update);
-EXPORT_TRACEPOINT_SYMBOL(qcom_dcvs_boost);
-EXPORT_TRACEPOINT_SYMBOL(memlat_dev_meas);
-EXPORT_TRACEPOINT_SYMBOL(memlat_dev_update);
-EXPORT_TRACEPOINT_SYMBOL(bw_hwmon_meas);
-EXPORT_TRACEPOINT_SYMBOL(bw_hwmon_update);
-EXPORT_TRACEPOINT_SYMBOL(bw_hwmon_debug);
diff --git a/drivers/soc/qcom/fg-alg.h b/drivers/soc/qcom/fg-alg.h
new file mode 100644
index 000000000000..72843172614a
--- /dev/null
+++ b/drivers/soc/qcom/fg-alg.h
@@ -0,0 +1,171 @@
+/* SPDX-License-Identifier: GPL-2.0-only */
+/*
+ * Copyright (c) 2016-2020, The Linux Foundation. All rights reserved.
+ * Copyright (c) 2022, Qualcomm Innovation Center, Inc. All rights reserved.
+ */
+
+#ifndef __FG_ALG_H__
+#define __FG_ALG_H__
+
+#include "battery-profile-loader.h"
+#include "step-chg-jeita.h"
+
+#define BUCKET_COUNT		8
+#define BUCKET_SOC_PCT		(256 / BUCKET_COUNT)
+#define MAX_CC_STEPS		20
+#define MAX_TTF_SAMPLES		10
+
+#define is_between(left, right, value) \
+		(((left) >= (right) && (left) >= (value) \
+			&& (value) >= (right)) \
+		|| ((left) <= (right) && (left) <= (value) \
+			&& (value) <= (right)))
+struct cycle_counter {
+	void		*data;
+	char		str_buf[BUCKET_COUNT * 8];
+	bool		started[BUCKET_COUNT];
+	u16		count[BUCKET_COUNT];
+	u8		last_soc[BUCKET_COUNT];
+	int		id;
+	int		last_bucket;
+	struct mutex	lock;
+	int (*restore_count)(void *data, u16 *buf, int num_bytes);
+	int (*store_count)(void *data, u16 *buf, int id, int num_bytes);
+};
+
+struct cl_params {
+	int	min_start_soc;
+	int	max_start_soc;
+	int	max_temp;
+	int	min_temp;
+	int	max_cap_inc;
+	int	max_cap_dec;
+	int	max_cap_limit;
+	int	min_cap_limit;
+	int	skew_decipct;
+	int	min_delta_batt_soc;
+	int	ibat_flt_thr_ma;
+	bool	cl_wt_enable;
+};
+
+struct cap_learning {
+	void			*data;
+	int			init_cc_soc_sw;
+	int			cc_soc_max;
+	int			init_batt_soc;
+	int			init_batt_soc_cp;
+	int64_t			nom_cap_uah;
+	int64_t			init_cap_uah;
+	int64_t			final_cap_uah;
+	int64_t			learned_cap_uah;
+	int64_t			delta_cap_uah;
+	bool			active;
+	struct mutex		lock;
+	struct cl_params	dt;
+	bool (*ok_to_begin)(void *data);
+	int (*get_learned_capacity)(void *data, int64_t *learned_cap_uah);
+	int (*store_learned_capacity)(void *data, int64_t learned_cap_uah);
+	int (*get_cc_soc)(void *data, int *cc_soc_sw);
+	int (*prime_cc_soc)(void *data, u32 cc_soc_sw);
+};
+
+enum ttf_mode {
+	TTF_MODE_NORMAL = 0,
+	TTF_MODE_QNOVO,
+	TTF_MODE_VBAT_STEP_CHG,
+	TTF_MODE_OCV_STEP_CHG,
+};
+
+enum ttf_param {
+	TTF_MSOC = 0,
+	TTF_VBAT,
+	TTF_OCV,
+	TTF_IBAT,
+	TTF_FCC,
+	TTF_MODE,
+	TTF_ITERM,
+	TTF_RBATT,
+	TTF_VFLOAT,
+	TTF_CHG_TYPE,
+	TTF_CHG_STATUS,
+	TTF_TTE_VALID,
+	TTF_CHG_DONE,
+};
+
+struct ttf_circ_buf {
+	int	arr[MAX_TTF_SAMPLES];
+	int	size;
+	int	head;
+};
+
+struct ttf_cc_step_data {
+	int arr[MAX_CC_STEPS];
+	int sel;
+};
+
+struct ttf_pt {
+	s32 x;
+	s32 y;
+};
+
+struct step_chg_data {
+	int ocv;
+	int soc;
+};
+
+struct ttf {
+	void			*data;
+	struct ttf_circ_buf	ibatt;
+	struct ttf_circ_buf	vbatt;
+	struct ttf_cc_step_data	cc_step;
+	struct mutex		lock;
+	struct step_chg_data	*step_chg_data;
+	struct range_data	*step_chg_cfg;
+	bool			step_chg_cfg_valid;
+	bool			ocv_step_chg_cfg_valid;
+	bool			clear_ibatt;
+	int			step_chg_num_params;
+	int			mode;
+	int			last_ttf;
+	int			input_present;
+	int			iterm_delta;
+	int			period_ms;
+	s64			last_ms;
+	struct delayed_work	ttf_work;
+	int (*get_ttf_param)(void *data, enum ttf_param, int *val);
+	int (*awake_voter)(void *data, bool vote);
+};
+
+struct soh_profile {
+	struct device_node *bp_node;
+	struct power_supply *bms_psy;
+	struct iio_channel *iio_chan_list;
+	struct soh_range *soh_data;
+	int batt_id_kohms;
+	int profile_count;
+	int last_soh;
+	int last_batt_age_level;
+	bool initialized;
+};
+
+int restore_cycle_count(struct cycle_counter *counter);
+void clear_cycle_count(struct cycle_counter *counter);
+void cycle_count_update(struct cycle_counter *counter, int batt_soc,
+		int charge_status, bool charge_done, bool input_present);
+int get_cycle_count(struct cycle_counter *counter, int *count);
+int get_cycle_counts(struct cycle_counter *counter, const char **buf);
+int cycle_count_init(struct cycle_counter *counter);
+void cap_learning_abort(struct cap_learning *cl);
+void cap_learning_update(struct cap_learning *cl, int batt_temp,
+		int batt_soc, int charge_status, bool charge_done,
+		bool input_present, bool qnovo_en);
+int cap_learning_init(struct cap_learning *cl);
+int cap_learning_post_profile_init(struct cap_learning *cl,
+		int64_t nom_cap_uah);
+void ttf_update(struct ttf *ttf, bool input_present);
+int ttf_get_time_to_empty(struct ttf *ttf, int *val);
+int ttf_get_time_to_full(struct ttf *ttf, int *val);
+int ttf_tte_init(struct ttf *ttf);
+int soh_profile_init(struct device *dev, struct soh_profile *sp);
+int soh_profile_update(struct soh_profile *sp, int soh);
+#endif
diff --git a/drivers/soc/qcom/gbms_power_supply.h b/drivers/soc/qcom/gbms_power_supply.h
new file mode 100644
index 000000000000..ee1af02d1fb1
--- /dev/null
+++ b/drivers/soc/qcom/gbms_power_supply.h
@@ -0,0 +1,136 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Google Battery Management System
+ *
+ * Copyright 2020 Google, LLC
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#ifndef __GBMS_POWER_SUPPLY_H__
+#define __GBMS_POWER_SUPPLY_H__
+
+#include <linux/power_supply.h>
+
+enum {
+	GBMS_TAPER_CONTROL_OFF = 0,
+	GBMS_TAPER_CONTROL_ON,
+};
+
+enum gbms_property {
+	/* I am not proud of this */
+	GBMS_PROP_LOCAL_EXTENSIONS = POWER_SUPPLY_PROP_SERIAL_NUMBER + 100,
+
+	GBMS_PROP_ADAPTER_DETAILS,	/* GBMS Adapter Details */
+	GBMS_PROP_BATT_CE_CTRL,		/* GBMS plugged (replace with GBMS_PROP_CHARGING_ENABLED) */
+	GBMS_PROP_CAPACITY_RAW,		/* GBMS used for ssoc */
+	GBMS_PROP_CHARGING_ENABLED,	/* GBMS cpm control */
+	GBMS_PROP_CHARGE_CHARGER_STATE,	/* GBMS charge, need uint64 */
+	GBMS_PROP_CHARGE_DISABLE,	/* GBMS disconnect */
+	GBMS_PROP_DEAD_BATTERY,		/* GBMS during boot */
+	GBMS_PROP_INPUT_CURRENT_LIMITED, /* can be device prop */
+	GBMS_PROP_TAPER_CONTROL,	/* GBMS DC, needs for last tier */
+	GBMS_PROP_HEALTH_ACT_IMPEDANCE,	/* GBMS activation impedance, qualified */
+	GBMS_PROP_HEALTH_IMPEDANCE,	/* GBMS impedance, qualified */
+	GBMS_PROP_RESISTANCE,		/* GBMS battery resistance, unqualified */
+	GBMS_PROP_RESISTANCE_RAW,	/* GBMS battery resistance, unqualified, u16 */
+	GBMS_PROP_RESISTANCE_AVG,	/* GBMS google_resistance */
+	GBMS_PROP_BATTERY_AGE,		/* GBMS time in field */
+	GBMS_PROP_CAPACITY_FADE_RATE,	/* GBMS capaciy fade rate */
+	GBMS_PROP_CHARGE_FULL_ESTIMATE,	/* GBMS google_capacity */
+	GBMS_PROP_POGO_VOUT_ENABLED,	/* GBMS gogo vout enabled */
+};
+
+union gbms_propval {
+	union power_supply_propval prop;
+	int64_t int64val;
+};
+
+#define gbms_propval_int64val(psp) \
+	container_of(psp, union gbms_propval, prop)->int64val
+
+static inline int gpsy_set_int64_prop(struct power_supply *psy,
+				      enum gbms_property psp,
+				      union gbms_propval val,
+				      const char *prop_name)
+{
+	int ret = 0;
+
+	if (!psy)
+		return -EINVAL;
+
+	pr_debug("set %s for '%s' to %lld\n", prop_name,
+		 psy->desc->name, (long long)val.int64val);
+
+	ret = power_supply_set_property(psy, (enum power_supply_property)psp,
+				        &val.prop);
+	if (ret < 0)
+		pr_err("failed to set %s for '%s', ret=%d\n",
+		       prop_name, psy->desc->name, ret);
+
+	return ret;
+}
+
+#define GPSY_SET_INT64_PROP(psy, psp, val) \
+	gpsy_set_int64_prop(psy, psp, (union gbms_propval) \
+			   { .int64val = (int64_t)(val) }, #psp)
+
+static inline int64_t gpsy_get_int64_prop(struct power_supply *psy,
+					  enum gbms_property psp,
+					  const char *prop_name,
+					  int *err)
+{
+	union gbms_propval val;
+
+	if (!psy) {
+		*err = -EINVAL;
+		return *err;
+	}
+
+	*err = power_supply_get_property(psy, (enum power_supply_property)psp,
+					 &val.prop);
+	if (*err < 0) {
+		pr_err("failed to get %s from '%s', ret=%d\n",
+		       prop_name, psy->desc->name, *err);
+		return *err;
+	}
+
+	pr_debug("get %s for '%s' => %lld\n", prop_name,
+		 psy->desc->name, (long long)val.int64val);
+
+	return val.int64val;
+}
+
+#define GPSY_GET_INT64_PROP(psy, psp, err) \
+	gpsy_get_int64_prop(psy, psp, #psp, err)
+
+
+/* GBMS properties -------------------------------------------------------- */
+
+struct gbms_desc {
+	struct power_supply_desc psy_dsc;
+	bool forward;
+
+	/* bgms properties */
+	int (*get_property)(struct power_supply *psy, enum gbms_property psp,
+			    union gbms_propval *val);
+	int (*set_property)(struct power_supply *psy, enum gbms_property psp,
+			    const union gbms_propval *val);
+	int (*property_is_writeable)(struct power_supply *psy,
+				     enum gbms_property psp);
+};
+
+extern int gbms_set_property(struct power_supply *psy, enum gbms_property psp,
+			     const union gbms_propval *val);
+extern int gbms_get_property(struct power_supply *psy, enum gbms_property psp,
+			     union gbms_propval *val);
+
+#endif /* __GBMS_POWER_SUPPLY_H__ */
diff --git a/drivers/soc/qcom/gbms_storage.h b/drivers/soc/qcom/gbms_storage.h
new file mode 100644
index 000000000000..8a14cc37c700
--- /dev/null
+++ b/drivers/soc/qcom/gbms_storage.h
@@ -0,0 +1,231 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Google Battery Management System
+ *
+ * Copyright (C) 2018 Google Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#ifndef __GBMS_STORAGE_H__
+#define __GBMS_STORAGE_H__
+
+/*
+ * GBMS Storage API
+ * The API provides functions to access to data stored in the persistent and
+ * semi-persistent storage of a device in a cross-platform and
+ * location-independent fashion. Clients in kernel and userspace use this
+ * directly and indirectly to retrieve battery serial number, cell chemistry
+ * type, cycle bin count, battery lifetime history and other battery related
+ * data.
+ */
+
+#define GBMS_STORAGE_ADDR_INVALID	-1
+#define GBMS_STORAGE_INDEX_INVALID	-1
+
+/* Battery Google Part Number */
+#define GBMS_BGPN_LEN	10
+/* Battery device info length */
+#define GBMS_DINF_LEN	16
+/* Battery manufacturer info length */
+#define GBMS_MINF_LEN	30
+/* Gauge Model State Restore */
+#define GBMS_GMSR_LEN	23
+
+/* TODO: link to the structure used to save this*/
+#define BATT_ONE_HIST_LEN	12
+/* TODO: this depends on the EEPROM size */
+#define BATT_MAX_HIST_CNT	75
+
+#define GBMS_CCBIN_BUCKET_COUNT	10
+
+/* Adds BPST and STRD */
+#define GBMS_LOTR_DEFAULT 0xff
+#define GBMS_LOTR_V1 1
+
+/* Date of manufacturing and first use */
+#define BATT_EEPROM_TAG_XYMD_LEN 3
+
+/*
+ * Tags are u32 constants: hardcoding as hex since characters constants of more
+ * than one byte such as 'BGCE' are frown upon.
+ */
+typedef uint32_t gbms_tag_t;
+
+enum gbms_tags {
+	GBMS_TAG_ACIM = 0x4143494d, /* Activation Impedance */
+	GBMS_TAG_AYMD = 0x41594d44,
+	GBMS_TAG_BCNT = 0x42434e54,
+	GBMS_TAG_BGCE = 0x42474345,
+	GBMS_TAG_BGPN = 0x4247504e,
+	GBMS_TAG_BPST = 0x42505354, /* LOTRV1: health or spare */
+	GBMS_TAG_BRES = 0x42524553,
+	GBMS_TAG_BRID = 0x42524944,
+	GBMS_TAG_CELC = 0x43454C43,
+	GBMS_TAG_CLHI = 0x424C4849,
+	GBMS_TAG_CMPC = 0x434d5043,
+	GBMS_TAG_CNHS = 0x434E4853,
+	GBMS_TAG_DINF = 0x44494e46,
+	GBMS_TAG_DSNM = 0x44534e4d,
+	GBMS_TAG_DXAC = 0x44584143,
+	GBMS_TAG_GCFE = 0x47434645,
+	GBMS_TAG_GMSR = 0x474d5352,
+	GBMS_TAG_HCNT = 0x48434e54,
+	GBMS_TAG_HIST = 0x48495354,
+	GBMS_TAG_LOTR = 0x4C4F5452,
+	GBMS_TAG_MINF = 0x4d494e46,
+	GBMS_TAG_MXSN = 0x4d58534e,
+	GBMS_TAG_MXCN = 0x4d58434e,
+	GBMS_TAG_MYMD = 0x4d594d44,
+	GBMS_TAG_THAS = 0x54484153,
+
+	/* User Space Read/Write scratch */
+	GBMS_TAG_RS32 = 0x52533332,
+	GBMS_TAG_RSBM = 0x5253424d,
+	GBMS_TAG_RSBR = 0x52534252,
+	GBMS_TAG_SUFG = 0x53554647, /* shutdown by user_request flag */
+
+	/* Reboot scratch */
+	GBMS_TAG_RRS0 = 0x52525330,
+	GBMS_TAG_RRS1 = 0x52525331,
+	GBMS_TAG_RRS2 = 0x52525332,
+	GBMS_TAG_RRS3 = 0x52525333,
+	GBMS_TAG_RRS4 = 0x52525334,
+	GBMS_TAG_RRS5 = 0x52525335,
+	GBMS_TAG_RRS6 = 0x52525336,
+	GBMS_TAG_RRS7 = 0x52525337,
+
+	GBMS_TAG_RAVG = 0x52415647,
+	GBMS_TAG_RFCN = 0x5246434e,
+	GBMS_TAG_SELC = 0x53454C43,
+	GBMS_TAG_SNUM = 0x534e554d,
+
+	GBMS_TAG_STRD = 0x53545244, /* LOTRV1: Swelling data */
+	GBMS_TAG_RSOC = 0x52534F43,
+};
+
+/*
+ * struct gbms_storage_desc - callbacks for a GBMS storage provider.
+ *
+ * Fields not used should be initialized with NULL. The provider name and the
+ * iter callback are optional but strongly recommended. The write, fetch, store
+ * and flush callbacks are optional, descriptors with a non NULL write/store
+ * callback should have a non NULL read/fetch callback.
+ *
+ * The iterator callback (iter) is used to list the tags stored in the provider
+ * and can be used to detect duplicates. The list of tags exported from iter
+ * can be expected to be static (i.e. tags can be enumerated once on
+ * registration).
+ *
+ * The read and write callbacks transfer the data associated with a tag. The
+ * calls must return -ENOENT when called with a tag that is not known to the
+ * provider, a negative number on every other error or the number of bytes
+ * read or written to the device. The tag lookup for the read and write
+ * callbacks must be very efficient (i.e. consider implementation that use hash
+ * or switch statements).
+ *
+ * Fetch and store callbacks are used to grant non-mediated access to a range
+ * of consecutive addresses in storage space. The implementation must return a
+ * negative number on error or the number of bytes transferred with the
+ * operation. Support caching of the tag data location requires non NULL fetch
+ * and not NULL info callbacks.
+ *
+ * The read_data and write_data callbacks transfer the data associated with an
+ * enumerator. The calls must return -ENOENT when called with a tag that is not
+ * known to the provider, a negative number on every other error or the number
+ * of bytes read or written to the device during data transfers.
+ *
+ * Clients can only access keys that are available on a device (i.e. clients
+ * cannot create new tags) and the API returns -ENOENT when trying to access a
+ * tag that is not available on a device, -EGAIN while the storage is not fully
+ * initialized.
+ *
+ * @iter: callback, return the tags known from this provider
+ * @info: callback, return address and size for tags (used for caching)
+ * @read: callback, read data from a tag
+ * @write: callback, write data to a tag
+ * @fetch: callback, read up to count data bytes from an address
+ * @store: callback, write up to count data bytes to an address
+ * @flush: callback, request a fush of data to permanent storage
+ * @read_data: callback, read the elements of an enumerations
+ * @write_data: callback, write to the elements of an enumeration
+ */
+struct gbms_storage_desc {
+	int (*iter)(int index, gbms_tag_t *tag, void *ptr);
+	int (*info)(gbms_tag_t tag, size_t *addr, size_t *size, void *ptr);
+	int (*read)(gbms_tag_t tag, void *data, size_t count, void *ptr);
+	int (*write)(gbms_tag_t tag, const void *data, size_t count, void *ptr);
+	int (*fetch)(void *data, size_t addr, size_t count, void *ptr);
+	int (*store)(const void *data, size_t addr, size_t count, void *ptr);
+	int (*flush)(bool force, void *ptr);
+
+	int (*read_data)(gbms_tag_t tag, void *data, size_t count, int idx,
+			 void *ptr);
+	int (*write_data)(gbms_tag_t tag, const void *data, size_t count,
+			  int idx, void *ptr);
+};
+
+struct nvmem_device;
+
+#if IS_ENABLED(CONFIG_GOOGLE_BEE)
+
+/* defaults */
+extern int gbee_register_device(const char *name, int lotr, struct nvmem_device *nvram);
+extern void gbee_destroy_device(void);
+
+/* version 1 */
+extern int gbee_storage01_info(gbms_tag_t tag, size_t *addr, size_t *count, void *ptr);
+extern int gbee_storage01_iter(int index, gbms_tag_t *tag, void *ptr);
+
+/* defaults */
+extern int gbee_storage_info(gbms_tag_t tag, size_t *addr, size_t *count, void *ptr);
+
+#else
+
+static inline int gbee_register_device(const char *name,
+				       struct nvmem_device *nvram)
+{ return -ENODEV; }
+
+static inline void gbee_destroy_device(void) { }
+
+static inline int gbee_storage01_info(gbms_tag_t tag, size_t *addr, size_t *count, void *ptr)
+{ return -ENODEV; }
+
+static inline int gbee_storage01_iter(int index, gbms_tag_t *tag, void *ptr)
+{ return -ENODEV; }
+
+static inline int gbee_storage_info(gbms_tag_t tag, size_t *addr, size_t *count, void *ptr)
+{ return -ENODEV; }
+
+#endif
+
+extern int gbms_storage_register(struct gbms_storage_desc *desc,
+				 const char *name, void *ptr);
+extern int gbms_storage_offline(const char *name, bool flush);
+
+extern int gbms_storage_read(gbms_tag_t tag, void *data, size_t count);
+extern int gbms_storage_write(gbms_tag_t tag, const void *data, size_t count);
+
+extern int gbms_storage_read_data(gbms_tag_t tag, void *data, size_t count,
+				  int idx);
+extern int gbms_storage_write_data(gbms_tag_t tag, const void *data,
+				   size_t count, int idx);
+extern int gbms_storage_flush_all(void);
+
+/* standard device implementation that read data from an enumeration */
+
+struct gbms_storage_device;
+extern struct gbms_storage_device *
+gbms_storage_create_device(const char *name, gbms_tag_t tag);
+extern void gbms_storage_cleanup_device(struct gbms_storage_device *gdev);
+
+
+#endif /* __GBMS_STORAGE_H__ */
diff --git a/drivers/soc/qcom/gic_intr_routing.c b/drivers/soc/qcom/gic_intr_routing.c
index 8b4bb4bcb3ed..eaba67ff948c 100644
--- a/drivers/soc/qcom/gic_intr_routing.c
+++ b/drivers/soc/qcom/gic_intr_routing.c
@@ -54,7 +54,6 @@ struct gic_intr_routing_data {
 static struct gic_intr_routing_data gic_routing_data;
 
 static DEFINE_SPINLOCK(gic_class_lock);
-static DEFINE_SPINLOCK(gic_init_lock);
 
 static DECLARE_BITMAP(active_gic_class0, MAX_IRQS);
 static DECLARE_BITMAP(active_gic_class1, MAX_IRQS);
@@ -603,9 +602,6 @@ static int gic_intr_routing_probe(struct platform_device *pdev)
 			cpumask_set_cpu(class1_cpus[i],
 			&gic_routing_data.gic_routing_class1_cpus);
 
-	register_trace_android_vh_gic_v3_set_affinity(
-		trace_gic_v3_set_affinity, NULL);
-
 	register_trace_irq_handler_entry(gic_irq_handler_entry_notifer, NULL);
 	rc = cpuhp_setup_state(
 		CPUHP_AP_ONLINE_DYN, "qcom/gic_affinity_setting:online",
@@ -624,9 +620,6 @@ static int gic_intr_routing_probe(struct platform_device *pdev)
 
 static int gic_intr_routing_remove(struct platform_device *pdev)
 {
-	unregister_trace_android_vh_gic_v3_set_affinity(
-		trace_gic_v3_set_affinity, NULL);
-
 	cpuhp_remove_state(CPUHP_AP_ONLINE_DYN);
 	return 0;
 }
diff --git a/drivers/soc/qcom/google_bms.h b/drivers/soc/qcom/google_bms.h
new file mode 100644
index 000000000000..311518bb533a
--- /dev/null
+++ b/drivers/soc/qcom/google_bms.h
@@ -0,0 +1,659 @@
+/*
+ * Google Battery Management System
+ *
+ * Copyright (C) 2018 Google Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#ifndef __GOOGLE_BMS_H_
+#define __GOOGLE_BMS_H_
+
+#include <linux/minmax.h>
+#include <linux/types.h>
+#include <linux/usb/pd.h>
+#include "misc/gvotable.h"
+#include "misc/logbuffer.h"
+#include "gbms_power_supply.h"
+#include "qmath.h"
+#include "gbms_storage.h"
+
+struct device_node;
+
+#define GBMS_CHG_TEMP_NB_LIMITS_MAX 10
+#define GBMS_CHG_VOLT_NB_LIMITS_MAX 5
+#define GBMS_CHG_ALG_BUF_SZ 500
+#define GBMS_CHG_TOPOFF_NB_LIMITS_MAX 6
+#define GBMS_AACR_DATA_MAX 10
+
+struct gbms_chg_profile {
+	const char *owner_name;
+
+	int temp_nb_limits;
+	s32 temp_limits[GBMS_CHG_TEMP_NB_LIMITS_MAX];
+	int volt_nb_limits;
+	s32 volt_limits[GBMS_CHG_VOLT_NB_LIMITS_MAX];
+	int topoff_nb_limits;
+	s32 topoff_limits[GBMS_CHG_TOPOFF_NB_LIMITS_MAX];
+	/* Array of constant current limits */
+	u32 *cccm_limits;
+	/* used to fill table  */
+	u32 capacity_ma;
+
+	/* behavior */
+	u32 fv_uv_margin_dpct;
+	u32 fv_dc_ratio;
+	u32 cv_range_accuracy;
+	u32 cv_debounce_cnt;
+	u32 cv_update_interval;
+	u32 cv_tier_ov_cnt;
+	u32 cv_tier_switch_cnt;
+	/* taper step */
+	u32 fv_uv_resolution;
+	/* experimental */
+	u32 cv_otv_margin;
+
+	/* AACR feature */
+	u32 reference_cycles[GBMS_AACR_DATA_MAX];
+	u32 reference_fade10[GBMS_AACR_DATA_MAX];
+	u32 aacr_nb_limits;
+};
+
+#define WLC_BPP_THRESHOLD_UV	7000000
+#define WLC_EPP_THRESHOLD_UV	11000000
+
+#define FOREACH_CHG_EV_ADAPTER(S)		\
+	S(UNKNOWN), 	\
+	S(USB),		\
+	S(USB_SDP),	\
+	S(USB_DCP),	\
+	S(USB_CDP),	\
+	S(USB_ACA),	\
+	S(USB_C),	\
+	S(USB_PD),	\
+	S(USB_PD_DRP),	\
+	S(USB_PD_PPS),	\
+	S(USB_BRICKID),	\
+	S(USB_HVDCP),	\
+	S(USB_HVDCP3),	\
+	S(FLOAT),	\
+	S(WLC),		\
+	S(WLC_EPP),	\
+	S(WLC_SPP),	\
+	S(GPP),		\
+	S(10W),		\
+	S(L7),		\
+	S(DL),		\
+	S(WPC_EPP),	\
+	S(WPC_GPP),	\
+	S(WPC_10W),	\
+	S(WPC_BPP),	\
+	S(WPC_L7),	\
+	S(EXT),	\
+	S(EXT1),	\
+	S(EXT2),	\
+	S(EXT_UNKNOWN), \
+
+#define CHG_EV_ADAPTER_STRING(s)	#s
+#define _CHG_EV_ADAPTER_PRIMITIVE_CAT(a, ...) a ## __VA_ARGS__
+
+#define BATTERY_DEBUG_ATTRIBUTE(name, fn_read, fn_write) \
+static const struct file_operations name = {	\
+	.open	= simple_open,			\
+	.llseek	= no_llseek,			\
+	.read	= fn_read,			\
+	.write	= fn_write,			\
+}
+
+/* Enums will start with CHG_EV_ADAPTER_TYPE_ */
+#define CHG_EV_ADAPTER_ENUM(e)	\
+			_CHG_EV_ADAPTER_PRIMITIVE_CAT(CHG_EV_ADAPTER_TYPE_,e)
+
+enum chg_ev_adapter_type_t {
+	FOREACH_CHG_EV_ADAPTER(CHG_EV_ADAPTER_ENUM)
+};
+
+enum gbms_msc_states_t {
+	MSC_NONE = 0,
+	MSC_SEED,
+	MSC_DSG,
+	MSC_LAST,
+	MSC_VSWITCH,
+	MSC_VOVER,
+	MSC_PULLBACK,
+	MSC_FAST,
+	MSC_TYPE,
+	MSC_DLY,	/* in taper */
+	MSC_STEADY,	/* in taper */
+	MSC_TIERCNTING, /* in taper */
+	MSC_RAISE,	/* in taper */
+	MSC_WAIT,	/* in taper */
+	MSC_RSTC,	/* in taper */
+	MSC_NEXT,	/* in taper */
+	MSC_NYET,	/* in taper */
+	MSC_HEALTH,
+	MSC_HEALTH_PAUSE,
+	MSC_HEALTH_ALWAYS_ON,
+	MSC_STATES_COUNT,
+};
+
+union gbms_ce_adapter_details {
+	uint32_t	v;
+	struct {
+		uint8_t		ad_type;
+		uint8_t		pad;
+		uint8_t 	ad_voltage;
+		uint8_t 	ad_amperage;
+	};
+};
+
+struct gbms_ce_stats {
+	uint16_t 	voltage_in;
+	uint16_t	ssoc_in;
+	uint16_t	cc_in;
+	uint16_t 	voltage_out;
+	uint16_t 	ssoc_out;
+	uint16_t	cc_out;
+};
+
+struct ttf_tier_stat {
+	int16_t soc_in;
+	int	cc_in;
+	int	cc_total;
+	ktime_t	avg_time;
+};
+
+struct gbms_ce_tier_stats {
+	int8_t		temp_idx;
+	int8_t		vtier_idx;
+
+	int16_t		soc_in;		/* 8.8 */
+	uint16_t	cc_in;
+	uint16_t	cc_total;
+
+	uint32_t	time_fast;
+	uint32_t	time_taper;
+	uint32_t	time_other;
+
+	int16_t		temp_in;
+	int16_t		temp_min;
+	int16_t		temp_max;
+
+	int16_t		ibatt_min;
+	int16_t		ibatt_max;
+
+	uint16_t	icl_min;
+	uint16_t	icl_max;
+
+	int64_t		icl_sum;
+	int64_t		temp_sum;
+	int64_t		ibatt_sum;
+	uint32_t 	sample_count;
+
+	uint16_t 	msc_cnt[MSC_STATES_COUNT];
+	uint32_t 	msc_elap[MSC_STATES_COUNT];
+};
+
+#define GBMS_STATS_TIER_COUNT	3
+#define GBMS_SOC_STATS_LEN	101
+
+/* time to full */
+
+/* collected in charging event */
+struct ttf_soc_stats {
+	int ti[GBMS_SOC_STATS_LEN];		/* charge tier at each soc */
+	int cc[GBMS_SOC_STATS_LEN];		/* coulomb count at each soc */
+	ktime_t elap[GBMS_SOC_STATS_LEN];	/* time spent at soc */
+};
+
+/* reference data for soc estimation  */
+struct ttf_adapter_stats {
+	u32 *soc_table;
+	u32 *elap_table;
+	int table_count;
+};
+
+/* updated when the device publish the charge stats
+ * NOTE: soc_stats and tier_stats are only valid for the given chg_profile
+ * since tier, coulumb count and elap time spent at each SOC depends on the
+ * maximum amout of current that can be pushed to the battery.
+ */
+struct batt_ttf_stats {
+	ktime_t ttf_fake;
+
+	struct ttf_soc_stats soc_ref;	/* gold: soc->elap,cc */
+	int ref_temp_idx;
+	int ref_watts;
+
+	struct ttf_soc_stats soc_stats; /* rolling */
+	struct ttf_tier_stat tier_stats[GBMS_STATS_TIER_COUNT];
+
+	struct logbuffer *ttf_log;
+};
+
+/*
+ * health based charging can be enabled from userspace with a deadline
+ *
+ * initial state:
+ * 	deadline = 0, rest_state = CHG_HEALTH_INACTIVE
+ *
+ * deadline = -1 from userspace
+ *	CHG_HEALTH_* -> CHG_HEALTH_USER_DISABLED (settings disabled)
+ * on deadline = 0 from userspace
+ *	CHG_HEALTH_* -> CHG_HEALTH_USER_DISABLED (alarm, plug or misc. disabled)
+ * on deadline > 0 from userspace
+ * 	CHG_HEALTH_* -> CHG_HEALTH_ENABLED
+ *
+ *  from CHG_HEALTH_ENABLED, msc_logic_health() can change the state to
+ * 	CHG_HEALTH_ENABLED  <-> CHG_HEALTH_ACTIVE
+ * 	CHG_HEALTH_ENABLED  -> CHG_HEALTH_DISABLED
+ *
+ * from CHG_HEALTH_ACTIVE, msc_logic_health() can change the state to
+ * 	CHG_HEALTH_ACTIVE   <-> CHG_HEALTH_ENABLED
+ * 	CHG_HEALTH_ACTIVE   -> CHG_HEALTH_DISABLED
+ * 	CHG_HEALTH_ACTIVE   -> CHG_HEALTH_DONE
+ */
+enum chg_health_state {
+	CHG_HEALTH_CCLVL_DISABLED = -6,
+	CHG_HEALTH_BD_DISABLED = -5,
+	CHG_HEALTH_USER_DISABLED = -3,
+	CHG_HEALTH_DISABLED = -2,
+	CHG_HEALTH_DONE = -1,
+	CHG_HEALTH_INACTIVE = 0,
+	CHG_HEALTH_ENABLED,
+	CHG_HEALTH_ACTIVE,
+	CHG_HEALTH_PAUSE,
+};
+
+/* tier index used to log the session */
+enum gbms_stats_tier_idx_t {
+	GBMS_STATS_AC_TI_DISABLE_DIALOG = -6,
+	GBMS_STATS_AC_TI_DEFENDER = -5,
+	GBMS_STATS_AC_TI_DISABLE_SETTING_STOP = -4,
+	GBMS_STATS_AC_TI_DISABLE_MISC = -3,
+	GBMS_STATS_AC_TI_DISABLE_SETTING = -2,
+	GBMS_STATS_AC_TI_INVALID = -1,
+
+	/* Regular charge tiers 0 -> 9 */
+	GBMS_STATS_AC_TI_VALID = 10,
+	GBMS_STATS_AC_TI_DISABLED = 11,
+	GBMS_STATS_AC_TI_ENABLED = 12,
+	GBMS_STATS_AC_TI_ACTIVE = 13,
+	GBMS_STATS_AC_TI_ENABLED_AON = 14,
+	GBMS_STATS_AC_TI_ACTIVE_AON = 15,
+	GBMS_STATS_AC_TI_PAUSE = 16,
+	GBMS_STATS_AC_TI_PAUSE_AON = 17,
+	GBMS_STATS_AC_TI_V2_PREDICT = 18,
+	GBMS_STATS_AC_TI_V2_PREDICT_SUCCESS = 19,
+	GBMS_STATS_AC_TI_DONE_AON = 20,
+
+	/* Thermal stats, reported from google_charger */
+	GBMS_STATS_TH_LVL0 = 50,
+	GBMS_STATS_TH_LVL1 = 51,
+	GBMS_STATS_TH_LVL2 = 52,
+	GBMS_STATS_TH_LVL3 = 53,
+
+	/* TODO: rename, these are not really related to AC */
+	GBMS_STATS_AC_TI_FULL_CHARGE = 100,
+	GBMS_STATS_AC_TI_HIGH_SOC = 101,
+
+	/* Defender TEMP or DWELL */
+	GBMS_STATS_BD_TI_OVERHEAT_TEMP = 110,
+	GBMS_STATS_BD_TI_CUSTOM_LEVELS = 111,
+	GBMS_STATS_BD_TI_TRICKLE = 112,
+	GBMS_STATS_BD_TI_DOCK = 113,
+
+	GBMS_STATS_BD_TI_TRICKLE_CLEARED = 122,
+	GBMS_STATS_BD_TI_DOCK_CLEARED = 123,
+};
+
+/* health state */
+struct batt_chg_health {
+	int rest_soc;		/* entry criteria */
+	int rest_voltage;	/* entry criteria */
+	int always_on_soc;	/* entry criteria */
+
+	ktime_t rest_deadline;	/* full by this in seconds */
+	ktime_t dry_run_deadline; /* full by this in seconds (prediction) */
+	int rest_rate;		/* centirate once enter */
+	int rest_rate_before_trigger;
+
+	enum chg_health_state rest_state;
+	int rest_cc_max;
+	int rest_fv_uv;
+	ktime_t active_time;
+};
+
+#define CHG_HEALTH_REST_IS_ACTIVE(rest) \
+	((rest)->rest_state == CHG_HEALTH_ACTIVE)
+
+#define CHG_HEALTH_REST_IS_PAUSE(rest) \
+	((rest)->rest_state == CHG_HEALTH_PAUSE)
+
+#define CHG_HEALTH_REST_IS_AON(rest, ssoc) \
+	(((rest)->rest_state == CHG_HEALTH_ACTIVE) ? \
+	(((rest)->always_on_soc != -1) ? \
+	(ssoc >= (rest)->always_on_soc) : 0) : 0)
+
+#define CHG_HEALTH_REST_SOC(rest) (((rest)->always_on_soc != -1) ? \
+			(rest)->always_on_soc : (rest)->rest_soc)
+
+/* reset on every charge session */
+struct gbms_charging_event {
+	union gbms_ce_adapter_details	adapter_details;
+
+	/* profile used for this charge event */
+	const struct gbms_chg_profile *chg_profile;
+	/* charge event and tier tracking */
+	struct gbms_ce_stats		charging_stats;
+	struct gbms_ce_tier_stats	tier_stats[GBMS_STATS_TIER_COUNT];
+
+	/* soc tracking for time to full */
+	struct ttf_soc_stats soc_stats;
+	int last_soc;
+
+	ktime_t first_update;
+	ktime_t last_update;
+	bool bd_clear_trickle;
+
+	/* health based charging */
+	struct batt_chg_health		ce_health;	/* updated on close */
+	struct gbms_ce_tier_stats	health_stats;	/* updated in HC */
+	struct gbms_ce_tier_stats	health_pause_stats;	/* updated in HCP */
+	/* updated on sysfs write */
+	struct gbms_ce_tier_stats health_dryrun_stats;
+
+	/* other stats */
+	struct gbms_ce_tier_stats full_charge_stats;
+	struct gbms_ce_tier_stats high_soc_stats;
+
+	struct gbms_ce_tier_stats overheat_stats;
+	struct gbms_ce_tier_stats cc_lvl_stats;
+	struct gbms_ce_tier_stats trickle_stats;
+};
+
+#define GBMS_CCCM_LIMITS_SET(profile, ti, vi) \
+	profile->cccm_limits[((ti) * profile->volt_nb_limits) + (vi)]
+
+#define GBMS_CCCM_LIMITS(profile, ti, vi) \
+	(((ti) >= 0 && (vi) >= 0) ? profile->cccm_limits[((ti) * profile->volt_nb_limits) + (vi)] : 0)
+
+/* newgen charging */
+#define GBMS_CS_FLAG_BUCK_EN	BIT(0)
+#define GBMS_CS_FLAG_DONE	BIT(1)
+#define GBMS_CS_FLAG_CC		BIT(2)
+#define GBMS_CS_FLAG_CV		BIT(3)
+#define GBMS_CS_FLAG_ILIM	BIT(4)
+#define GBMS_CS_FLAG_CCLVL	BIT(5)
+#define GBMS_CS_FLAG_DIRECT_CHG	BIT(6)
+
+union gbms_charger_state {
+	uint64_t v;
+	struct {
+		uint8_t flags;
+		uint8_t pad;
+		uint8_t chg_status;
+		uint8_t chg_type;
+		uint16_t vchrg;
+		uint16_t icl;
+	} f;
+};
+
+struct device_node *gbms_batt_id_node(struct device_node *node);
+int gbms_init_chg_profile_internal(struct gbms_chg_profile *profile,
+			  struct device_node *node, const char *owner_name);
+#define gbms_init_chg_profile(p, n) \
+	gbms_init_chg_profile_internal(p, n, KBUILD_MODNAME)
+
+void gbms_init_chg_table(struct gbms_chg_profile *profile,
+			 struct device_node *node, u32 capacity);
+
+void gbms_free_chg_profile(struct gbms_chg_profile *profile);
+
+void gbms_dump_raw_profile(char *buff, size_t len, const struct gbms_chg_profile *profile, int scale);
+#define gbms_dump_chg_profile(buff, len, profile) gbms_dump_raw_profile(buff, len, profile, 1000)
+
+/* newgen charging: charge profile */
+int gbms_msc_temp_idx(const struct gbms_chg_profile *profile, int temp);
+int gbms_msc_voltage_idx(const struct gbms_chg_profile *profile, int vbatt);
+int gbms_msc_round_fv_uv(const struct gbms_chg_profile *profile,
+			   int vtier, int fv_uv, int cc_ua, bool allow_higher_fv);
+int gbms_msc_merge_tiers(const struct gbms_chg_profile *profile,
+			  int vbatt_idx, int temp_idx);
+
+/* newgen charging: charger flags  */
+uint8_t gbms_gen_chg_flags(int chg_status, int chg_type);
+/* newgen charging: read/gen charger state  */
+int gbms_read_charger_state(union gbms_charger_state *chg_state,
+			    struct power_supply *chg_psy);
+/* calculate aacr reference capacity */
+int gbms_aacr_fade10(const struct gbms_chg_profile *profile, int cycles);
+
+/* logbuffer and syslog */
+__printf(5,6)
+void gbms_logbuffer_prlog(struct logbuffer *log, int level, int debug_no_logbuffer,
+			  int debug_printk_prlog, const char *f, ...);
+
+/* debug/print */
+const char *gbms_chg_type_s(int chg_type);
+const char *gbms_chg_status_s(int chg_status);
+const char *gbms_chg_ev_adapter_s(int adapter);
+
+/* Votables */
+#define VOTABLE_MSC_CHG_DISABLE	"MSC_CHG_DISABLE"
+#define VOTABLE_MSC_PWR_DISABLE	"MSC_PWR_DISABLE"
+#define VOTABLE_MSC_INTERVAL	"MSC_INTERVAL"
+#define VOTABLE_MSC_FCC		"MSC_FCC"
+#define VOTABLE_MSC_FV		"MSC_FV"
+#define VOTABLE_FAN_LEVEL	"FAN_LEVEL"
+#define VOTABLE_DEAD_BATTERY	"DEAD_BATTERY"
+#define VOTABLE_TEMP_DRYRUN	"MSC_TEMP_DRYRUN"
+#define VOTABLE_MSC_LAST	"MSC_LAST"
+
+#define VOTABLE_CSI_STATUS	"CSI_STATUS"
+#define VOTABLE_CSI_TYPE	"CSI_TYPE"
+
+#define VOTABLE_DC_CHG_AVAIL	"DC_AVAIL"
+#define REASON_DC_DRV		"DC_DRV"
+#define REASON_MDIS		"MDIS"
+
+#define FAN_LVL_UNKNOWN		-1
+#define FAN_LVL_NOT_CARE	0
+#define FAN_LVL_LOW		1
+#define FAN_LVL_MED		2
+#define FAN_LVL_HIGH		3
+#define FAN_LVL_ALARM		4
+
+/* Binned cycle count */
+#define GBMS_CCBIN_CSTR_SIZE	(GBMS_CCBIN_BUCKET_COUNT * 6 + 2)
+
+int gbms_cycle_count_sscan_bc(u16 *ccount, int bcnt, const char *buff);
+int gbms_cycle_count_cstr_bc(char *buff, size_t size,
+					const u16 *ccount, int bcnt);
+
+#define gbms_cycle_count_sscan(cc, buff) \
+	gbms_cycle_count_sscan_bc(cc, GBMS_CCBIN_BUCKET_COUNT, buff)
+
+#define gbms_cycle_count_cstr(buff, size, cc)	\
+	gbms_cycle_count_cstr_bc(buff, size, cc, GBMS_CCBIN_BUCKET_COUNT)
+
+
+/* Time to full */
+int ttf_soc_cstr(char *buff, int size, const struct ttf_soc_stats *soc_stats,
+		 int start, int end);
+
+int ttf_soc_estimate(ktime_t *res,
+		     const struct batt_ttf_stats *stats,
+		     const struct gbms_charging_event *ce_data,
+		     qnum_t soc, qnum_t last);
+
+void ttf_soc_init(struct ttf_soc_stats *dst);
+
+int ttf_tier_cstr(char *buff, int size, const struct ttf_tier_stat *t_stat);
+
+int ttf_tier_estimate(ktime_t *res,
+		      const struct batt_ttf_stats *ttf_stats,
+		      int temp_idx, int vbatt_idx,
+		      int capacity, int full_capacity);
+
+int ttf_stats_init(struct batt_ttf_stats *stats,
+		   struct device *device,
+		   int capacity_ma);
+
+void ttf_stats_update(struct batt_ttf_stats *stats,
+	 	      struct gbms_charging_event *ce_data,
+		      bool force);
+
+int ttf_stats_cstr(char *buff, int size, const struct batt_ttf_stats *stats,
+		   bool verbose);
+
+int ttf_stats_sscan(struct batt_ttf_stats *stats,
+		    const char *buff, size_t size);
+
+struct batt_ttf_stats *ttf_stats_dup(struct batt_ttf_stats *dst,
+				     const struct batt_ttf_stats *src);
+
+void ttf_log(const struct batt_ttf_stats *stats, const char *fmt, ...);
+
+ssize_t ttf_dump_details(char *buf, int max_size,
+			 const struct batt_ttf_stats *ttf_stats,
+			 int last_soc);
+
+int ttf_pwr_vtier_idx(const struct batt_ttf_stats *stats, int soc);
+
+int ttf_ref_cc(const struct batt_ttf_stats *stats, int soc);
+
+int ttf_pwr_ibatt(const struct gbms_ce_tier_stats *ts);
+
+void ttf_tier_reset(struct batt_ttf_stats *stats);
+
+int gbms_read_aacr_limits(struct gbms_chg_profile *profile,
+			  struct device_node *node);
+
+bool chg_state_is_disconnected(const union gbms_charger_state *chg_state);
+
+/* Voltage tier stats */
+void gbms_tier_stats_init(struct gbms_ce_tier_stats *stats, int8_t idx);
+
+void gbms_chg_stats_tier(struct gbms_ce_tier_stats *tier,
+			 int msc_state, ktime_t elap);
+
+void gbms_stats_update_tier(int temp_idx, int ibatt_ma, int temp, ktime_t elap,
+			    int cc, union gbms_charger_state *chg_state,
+			    enum gbms_msc_states_t msc_state, int soc_in,
+			    struct gbms_ce_tier_stats *tier);
+
+int gbms_tier_stats_cstr(char *buff, int size,
+			 const struct gbms_ce_tier_stats *tier_stat,
+			 bool verbose);
+
+void gbms_log_cstr_handler(struct logbuffer *log, char *buf, int len);
+
+
+
+
+/*
+ * Charger modes
+ *
+ */
+
+enum gbms_charger_modes {
+	GBMS_CHGR_MODE_CHGR_DC	= 0x20,
+
+	GBMS_USB_BUCK_ON	= 0x30,
+	GBMS_USB_OTG_ON 	= 0x31,
+	GBMS_USB_OTG_FRS_ON	= 0x32,
+
+	GBMS_CHGR_MODE_WLC_TX	= 0x40,
+
+	GBMS_CHGR_MODE_VOUT	= 0x50,
+};
+
+#define GBMS_MODE_VOTABLE "CHARGER_MODE"
+
+/* Battery Health */
+enum bhi_algo {
+	BHI_ALGO_DISABLED = 0,
+
+	BHI_ALGO_CYCLE_COUNT	= 1, /* bare, just use cycle count */
+	BHI_ALGO_ACHI		= 2, /* cap avg from history, no resistance */
+	BHI_ALGO_ACHI_B		= 3, /* same as ACHI + bounds check */
+	BHI_ALGO_ACHI_RAVG	= 4, /* same as ACHI and google_resistance */
+	BHI_ALGO_ACHI_RAVG_B	= 5, /* same as ACHI_RAVG + bounds check */
+
+	/* TODO:
+	 * BHI_ALGO_ACHI_QRES	 = 4,  cap avg from history, qual resistance
+	 * BHI_ALGO_ACHI_QRES_B	= 21,  same ACHI_QRES + bounds check
+	 * BHI_ALGO_GCAP_RAVG	= 40,  google_capacity, google_resistance
+	 * BHI_ALGO_GCAP_RAVG_B	= 41,  same as GCAP_RAVG + bounds check
+	 */
+
+	BHI_ALGO_MIX_N_MATCH 	= 6,
+	BHI_ALGO_DEBUG		= 7,
+	BHI_ALGO_MAX,
+};
+
+enum bhi_status {
+	BH_UNKNOWN = -1,
+	BH_NOMINAL,
+	BH_MARGINAL,
+	BH_NEEDS_REPLACEMENT,
+	BH_FAILED,
+};
+
+struct bhi_weight {
+	int w_ci;
+	int w_ii;
+	int w_sd;
+};
+
+/* Charging Speed */
+enum csi_type {
+	CSI_TYPE_UNKNOWN = -1,
+
+	CSI_TYPE_None = 0,		// Disconnected
+	CSI_TYPE_Fault = 1,		// Internal Failures
+	CSI_TYPE_JEITA = 2,		// HW limits (will have HOT or COLD)
+	CSI_TYPE_LongLife = 3, 		// DefenderConditions
+	CSI_TYPE_Adaptive = 4,		// AdaptiveCharging
+	CSI_TYPE_Normal = 5,		// All Good
+};
+
+enum csi_status {
+	CSI_STATUS_UNKNOWN = -1,
+
+	CSI_STATUS_Health_Cold = 10,	// battery temperature not nominal
+	CSI_STATUS_Health_Hot = 11,	// battery temperature not nominal
+	CSI_STATUS_System_Thermals = 20,// Thermal engine
+	CSI_STATUS_System_Load = 21,	// Load might eventually become thermals
+	CSI_STATUS_Adapter_Auth = 30,	// During authentication
+	CSI_STATUS_Adapter_Power = 31,	// Low power adapter
+	CSI_STATUS_Adapter_Quality = 32,// Adapter or cable (low input voltage)
+	CSI_STATUS_Defender_Temp = 40,	// TEMP Defend
+	CSI_STATUS_Defender_Dwell = 41,	// DWELL Defend
+	CSI_STATUS_Defender_Trickle = 42,
+	CSI_STATUS_Defender_Dock = 43,	// Dock Defend
+	CSI_STATUS_NotCharging = 100,	// There will be a more specific reason
+	CSI_STATUS_Charging = 200,	// All good
+};
+
+#define to_cooling_device(_dev)	\
+	container_of(_dev, struct thermal_cooling_device, device)
+
+#define DEBUG_ATTRIBUTE_WO(name) \
+static const struct file_operations name ## _fops = {	\
+	.open	= simple_open,			\
+	.llseek	= no_llseek,			\
+	.write	= name ## _store,			\
+}
+
+
+#endif  /* __GOOGLE_BMS_H_ */
diff --git a/drivers/soc/qcom/google_dc_pps.h b/drivers/soc/qcom/google_dc_pps.h
new file mode 100644
index 000000000000..402ea15a09c4
--- /dev/null
+++ b/drivers/soc/qcom/google_dc_pps.h
@@ -0,0 +1,252 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Copyright 2020 Google, LLC
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#ifndef __GOOGLE_DC_PPS_H_
+#define __GOOGLE_DC_PPS_H_
+
+#include <linux/usb/pd.h>
+#include <linux/device.h>
+#include <misc/logbuffer.h>
+
+#define PD_T_PPS_TIMEOUT		9000	/* Maximum of 10 seconds */
+#define PD_T_PPS_DEADLINE_S		7
+
+#define PPS_KEEP_ALIVE_MAX	3
+#define PPS_ERROR_RETRY_MS 	1000
+#define CHG_PPS_VOTER		"pps_chg"
+
+/*
+ * There is a similar one in tcpm.c
+ * NOTE: we don't really need to replicate the values in tcpm.c in the
+ * internal state, we just need to know to set 2 to the TCPM power supply
+ * to enable PPS.
+ */
+enum pps_psy_online_states {
+	PPS_PSY_OFFLINE = 0,
+	PPS_PSY_FIXED_ONLINE,
+	PPS_PSY_PROG_ONLINE,
+};
+
+enum pd_pps_stage {
+	PPS_NOTSUPP = -1,	/* tried and failed or disconnected */
+	PPS_DISABLED = 0,	/* default state, never tried */
+	PPS_NONE,		/* try to enable */
+	PPS_AVAILABLE,
+	PPS_ACTIVE,
+};
+
+enum pd_nr_pdo {
+	PDO_FIXED_5V = 1,
+	PDO_FIXED_HIGH_VOLTAGE,
+	PDO_PPS,
+
+	PDO_MAX_SUPP = PDO_PPS,
+	PDO_MAX = PDO_MAX_OBJECTS,	/* 7 */
+};
+
+struct pd_pps_data {
+	struct power_supply *pps_psy;
+	void *port_data;
+
+	struct wakeup_source *pps_ws;
+	bool stay_awake;
+
+	int nr_src_cap;
+	u32 *src_caps;
+	u32 snk_pdo[PDO_MAX_OBJECTS];
+	unsigned int nr_snk_pdo;
+	u32 default_pps_pdo;
+
+	int pd_online;
+	enum pd_pps_stage stage;
+	unsigned int keep_alive_cnt;
+	ktime_t last_update;
+
+	/* from TA */
+	int min_uv;
+	int max_uv;
+	int max_ua;
+
+	/* to TA */
+	int out_uv;
+	int op_ua;
+
+	/* logging client */
+	struct logbuffer *log;
+};
+
+/* TODO: device dependent */
+#define PD_SNK_MAX_MV			9000
+/* TODO: device dependent */
+#define PD_SNK_MIN_MV			5000
+
+struct tcpm_port;
+struct tcpm_port *chg_get_tcpm_port(struct power_supply *tcpm_psy);
+
+
+/* */
+#define pps_is_disabled(x) (((x) == PPS_NOTSUPP) || ((x) == PPS_DISABLED))
+
+#define pps_name(pps_psy) \
+	((pps_psy) && (pps_psy)->desc && (pps_psy)->desc->name ? \
+		(pps_psy)->desc->name : "<>")
+
+
+struct dentry;
+
+#if IS_ENABLED(CONFIG_DISABLE_GOOGLE_DC_PPS)
+
+static inline int pps_init(struct pd_pps_data *pps_data, struct device *dev,
+			   struct power_supply *pps_psy)
+{
+	return -EINVAL;
+}
+static inline int pps_init_fs(struct pd_pps_data *pps_data, struct dentry *de)
+{
+	return -EINVAL;
+}
+static inline void pps_init_state(struct pd_pps_data *pps_data) {}
+static inline void pps_free(struct pd_pps_data *pps_data) {}
+
+static inline int pps_work(struct pd_pps_data *pps, struct power_supply *tcpm_psy)
+{
+	return -EINVAL;
+}
+
+static inline int pps_ping(struct pd_pps_data *pps, struct power_supply *tcpm_psy)
+{
+	return -EINVAL;
+}
+static inline int pps_keep_alive(struct pd_pps_data *pps, struct power_supply *tcpm_psy)
+{
+	return -EINVAL;
+}
+static inline int pps_update_adapter(struct pd_pps_data *pps_data,
+				     int pending_uv, int pending_ua,
+				     struct power_supply *tcpm_psy)
+{
+	return -EINVAL;
+}
+static inline int pps_check_adapter(struct pd_pps_data *pps,
+				    int pending_uv, int pending_ua,
+				    struct power_supply *tcpm_psy)
+{
+	return -EINVAL;
+}
+
+static inline int pps_prog_offline(struct pd_pps_data *pps, struct power_supply *tcpm_psy)
+{
+	return -EINVAL;
+}
+
+static inline void pps_adjust_volt(struct pd_pps_data *pps, int mod) {}
+
+static inline int chg_switch_profile(struct pd_pps_data *pps, struct power_supply *tcpm_psy,
+				     bool more_pwr)
+{
+	return -EINVAL;
+}
+
+static inline int pps_get_apdo_max_power(struct pd_pps_data *pps, unsigned int *ta_idx,
+					 unsigned int *ta_max_vol, unsigned int *ta_max_cur,
+					 unsigned long *ta_max_pwr)
+{
+	return -EINVAL;
+}
+
+static inline bool pps_check_prog_online(struct pd_pps_data *pps_data)
+{
+	return false;
+}
+static inline bool pps_prog_check_online(struct pd_pps_data *pps_data,
+					 struct power_supply *tcpm_psy)
+{
+	return false;
+}
+
+static inline int pps_get_src_cap(struct pd_pps_data *pps, struct power_supply *tcpm_psy)
+{
+	return -EINVAL;
+}
+static inline void pps_set_logbuffer(struct pd_pps_data *pps_data, struct logbuffer *log) {}
+static inline void pps_log(struct pd_pps_data *pps, const char *fmt, ...) {}
+
+static inline struct power_supply *pps_get_tcpm_psy(struct device_node *node, size_t size)
+{
+	return NULL;
+}
+
+static inline int pps_request_pdo(struct pd_pps_data *pps_data, unsigned int ta_idx,
+				  unsigned int ta_max_vol, unsigned int ta_max_cur)
+{
+	return -EINVAL;
+}
+
+#else // PPS is enabled
+
+#define ENABLE_GOOGLE_DC_PPS
+
+int pps_init(struct pd_pps_data *pps_data, struct device *dev,
+	     struct power_supply *pps_psy);
+int pps_init_fs(struct pd_pps_data *pps_data, struct dentry *de);
+/* reset state and leave in DISABLED  */
+void pps_init_state(struct pd_pps_data *pps_data);
+/* free resources  */
+void pps_free(struct pd_pps_data *pps_data);
+
+/* Run the PPS state machine   */
+int pps_work(struct pd_pps_data *pps, struct power_supply *tcpm_psy);
+
+/* rougly equivalent */
+int pps_ping(struct pd_pps_data *pps, struct power_supply *tcpm_psy);
+int pps_keep_alive(struct pd_pps_data *pps, struct power_supply *tcpm_psy);
+
+/* update the PPS adapter */
+int pps_update_adapter(struct pd_pps_data *pps_data,
+		       int pending_uv, int pending_ua,
+		       struct power_supply *tcpm_psy);
+int pps_check_adapter(struct pd_pps_data *pps,
+		      int pending_uv, int pending_ua,
+		      struct power_supply *tcpm_psy);
+
+/* */
+int pps_prog_offline(struct pd_pps_data *pps, struct power_supply *tcpm_psy);
+
+void pps_adjust_volt(struct pd_pps_data *pps, int mod);
+
+int chg_switch_profile(struct pd_pps_data *pps, struct power_supply *tcpm_psy,
+		       bool more_pwr);
+
+int pps_get_apdo_max_power(struct pd_pps_data *pps, unsigned int *ta_idx,
+			   unsigned int *ta_max_vol, unsigned int *ta_max_cur,
+			   unsigned long *ta_max_pwr);
+
+bool pps_check_prog_online(struct pd_pps_data *pps_data);
+bool pps_prog_check_online(struct pd_pps_data *pps_data,
+			   struct power_supply *tcpm_psy);
+
+int pps_get_src_cap(struct pd_pps_data *pps, struct power_supply *tcpm_psy);
+
+void pps_set_logbuffer(struct pd_pps_data *pps_data, struct logbuffer *log);
+void pps_log(struct pd_pps_data *pps, const char *fmt, ...);
+
+/* probe */
+struct power_supply *pps_get_tcpm_psy(struct device_node *node, size_t size);
+
+int pps_request_pdo(struct pd_pps_data *pps_data, unsigned int ta_idx,
+		    unsigned int ta_max_vol, unsigned int ta_max_cur);
+
+#endif /* CONFIG_DISABLE_GOOGLE_DC_PPS */
+#endif /* __GOOGLE_DC_PPS_H_ */
diff --git a/drivers/soc/qcom/google_psy.h b/drivers/soc/qcom/google_psy.h
new file mode 100644
index 000000000000..09be5ecee3c4
--- /dev/null
+++ b/drivers/soc/qcom/google_psy.h
@@ -0,0 +1,78 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Copyright 2018 Google, LLC
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#ifndef __GOOGLE_PSY_H_
+#define __GOOGLE_PSY_H_
+
+#include <linux/printk.h>
+#include "gbms_power_supply.h"
+
+static inline int gpsy_set_prop(struct power_supply *psy,
+				      enum power_supply_property psp,
+				      union power_supply_propval val,
+				      const char *prop_name)
+{
+	int ret = 0;
+
+	if (!psy)
+		return -EINVAL;
+
+	pr_debug("set %s for '%s' to %d\n", prop_name, psy->desc->name,
+		 val.intval);
+
+	ret = power_supply_set_property(psy, psp, &val);
+	if (ret < 0) {
+		pr_err("failed to set %s for '%s', ret=%d\n",
+		       prop_name, psy->desc->name, ret);
+		return ret;
+	}
+
+	return 0;
+}
+
+#define GPSY_SET_PROP(psy, psp, val) \
+	gpsy_set_prop(psy, (enum power_supply_property)(psp), (union power_supply_propval) \
+		{ .intval = (val) }, #psp)
+
+static inline int gpsy_get_prop(struct power_supply *psy,
+			       enum power_supply_property psp,
+			       const char *prop_name,
+			       int *err)
+{
+	union power_supply_propval val;
+	int ret = 0;
+
+	ret = (psy) ? power_supply_get_property(psy, psp, &val) : -EINVAL;
+	if (err)
+		*err = ret;
+	if (ret < 0) {
+		pr_err("failed to get %s from '%s', ret=%d\n",
+		       prop_name, psy->desc->name, ret);
+		return ret;
+	}
+
+	pr_debug("get %s for '%s' => %d\n", prop_name, psy->desc->name,
+		 val.intval);
+
+	return val.intval;
+}
+
+#define GPSY_GET_PROP(psy, psp) \
+		gpsy_get_prop(psy, (enum power_supply_property)(psp), #psp, 0)
+/* use GPSY_GET_INT_PROP() for properties that can be negative */
+#define GPSY_GET_INT_PROP(psy, psp, err) \
+		gpsy_get_prop(psy, (enum power_supply_property)(psp), #psp, err)
+
+#endif	/* __GOOGLE_PSY_H_ */
diff --git a/drivers/soc/qcom/gs101_usecase.h b/drivers/soc/qcom/gs101_usecase.h
new file mode 100644
index 000000000000..cb0961aacdd8
--- /dev/null
+++ b/drivers/soc/qcom/gs101_usecase.h
@@ -0,0 +1,92 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Copyright 2021 Google, LLC
+ *
+ */
+
+#ifndef GS101_USECASE_H_
+#define GS101_USECASE_H_
+
+struct max77759_usecase_data {
+	int is_a1;
+
+	int bst_on;		/* ext boost */
+	int bst_sel;		/* 5V or 7.5V */
+	int ext_bst_ctl;	/* MW VENDOR_EXTBST_CTRL */
+	int otg_enable;		/* enter/exit from OTG cases */
+	bool rx_otg_en;		/* enable WLC_RX -> WLC_RX + OTG case */
+	bool ext_otg_only;	/* use external OTG only */
+	int pogo_ovp_en;	/* pogo ovp */
+	int pogo_ovp_en_act_low;	/* pogo ovp flags */
+	int pogo_vout_en;	/* pogo 5V vout */
+
+	int ls2_en;		/* OVP LS2, rtx case */
+	int sw_en;		/* OVP SW Enable, rtx+otg case */
+	int dc_sw_gpio;		/* WLC-DC switch enable */
+
+	int vin_is_valid;	/* MAX20339 STATUS1.vinvalid */
+	int lsw1_is_open;	/* MAX20339 STATUS2.lsw1open */
+	int lsw1_is_closed;	/* MAX20339 STATUS2.lsw1closed */
+	int ls1_en;		/* MAX20339 close LSW1 directly */
+
+	int wlc_en;		/* wlcrx/chgin coex */
+	int wlc_vbus_en;	/* b/202526678 */
+	int ext_bst_mode;	/* wlcrx+otg: b/175706836, TPS61372 P1.1+ */
+	int cpout_en;		/* wlcrx+otg: CPOUT enabled/disabled */
+	int cpout_ctl;		/* wlcrx+otg: CPOUT level 5.3V or DFLT */
+
+	int cpout21_en;		/* wlctx: CPOUT 2:1 converter enable/disable */
+
+	u8 otg_ilim;		/* TODO: TCPM to control this? */
+	u8 otg_vbyp;		/* TODO: TCPM to control this? */
+	u8 otg_orig;		/* restore value */
+	u8 otg_value;		/* CHG_CNFG_11:VBYPSET for USB OTG Voltage */
+
+	struct i2c_client *client;
+	bool init_done;
+	int use_case;
+
+	bool dcin_is_dock;
+	bool wlctx_bst_en_first;
+
+	bool wlc_otg_extbst_en;	/* Only WLC+OTG, set extbst mode to high */
+};
+
+enum gsu_usecases {
+	GSU_RAW_MODE 		= -1,	/* raw mode, default, */
+
+	GSU_MODE_STANDBY	= 0,	/* 8, PMIC mode 0 */
+	GSU_MODE_USB_CHG	= 1,	/* 1-1 wired mode 0x4, mode 0x5 */
+	GSU_MODE_USB_DC 	= 2,	/* 1-2 wired mode 0x0 */
+	GSU_MODE_USB_CHG_WLC_TX = 3,	/* 2-1, 1041, */
+	GSU_MODE_USB_DC_WLC_TX	= 4,	/* 2-2 1042, */
+
+	GSU_MODE_WLC_RX		= 5,	/* 3-1, mode 0x4, mode 0x5 */
+	GSU_MODE_WLC_DC		= 6,	/* 3-2, mode 0x0 */
+
+	GSU_MODE_USB_OTG_WLC_RX = 7,	/* 4-1, 524, */
+	GSU_MODE_USB_OTG_WLC_DC = 8,	/* 4-2, 532, */
+	GSU_MODE_USB_OTG 	= 9,	/* 5-1, 516,*/
+	GSU_MODE_USB_OTG_FRS	= 10,	/* 5-2, PMIC mode 0x0a */
+
+	GSU_MODE_WLC_TX 	= 11,	/* 6-2, 1056, */
+	GSU_MODE_USB_OTG_WLC_TX	= 12,	/* 7-2, 1060, */
+
+	GSU_MODE_USB_WLC_RX	= 13,
+
+	GSU_MODE_DOCK		= 14,
+	GSU_MODE_POGO_VOUT	= 15,
+	GSU_MODE_USB_CHG_POGO_VOUT	= 16,
+	GSU_MODE_USB_OTG_POGO_VOUT	= 17,
+};
+
+extern int gs101_wlc_en(struct max77759_usecase_data *uc_data, bool wlc_on);
+extern int gs101_to_standby(struct max77759_usecase_data *uc_data, int use_case);
+extern int gs101_to_usecase(struct max77759_usecase_data *uc_data, int use_case);
+extern int gs101_force_standby(struct max77759_usecase_data *uc_data);
+extern bool gs101_setup_usecases(struct max77759_usecase_data *uc_data,
+				 struct device_node *node);
+extern void gs101_dump_usecasase_config(struct max77759_usecase_data *uc_data);
+extern int max77759_otg_vbyp_mv_to_code(u8 *code, int vbyp);
+
+#endif
diff --git a/drivers/soc/qcom/max1720x.h b/drivers/soc/qcom/max1720x.h
new file mode 100644
index 000000000000..acd1f2e61c89
--- /dev/null
+++ b/drivers/soc/qcom/max1720x.h
@@ -0,0 +1,331 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Copyright 2019 Google, LLC
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+
+#ifndef MAX1720X_H_
+#define MAX1720X_H_
+
+#include "max1720x_battery.h"
+
+#define MAX1720X_N_OF_HISTORY_PAGES 203
+
+
+enum max1720x_register {
+	/* ModelGauge m5 Register */
+	MAX1720X_STATUS = 0x00,
+	MAX1720X_VALRTTH = 0x01,
+	MAX1720X_TALRTTH = 0x02,
+	MAX1720X_SALRTTH = 0x03,
+	MAX1720X_ATRATE = 0x04,
+	MAX1720X_REPCAP = 0x05,
+	MAX1720X_REPSOC = 0x06,
+	MAX1720X_AGE = 0x07,
+	MAX1720X_TEMP = 0x08,
+	MAX1720X_VCELL = 0x09,
+	MAX1720X_CURRENT = 0x0A,
+	MAX1720X_AVGCURRENT = 0x0B,
+	MAX1720X_QRESIDUAL = 0x0C,
+	MAX1720X_MIXSOC = 0x0D,
+	MAX1720X_AVSOC = 0x0E,
+	MAX1720X_MIXCAP = 0x0F,
+
+	MAX1720X_FULLCAP = 0x10,
+	MAX1720X_TTE = 0x11,
+	MAX1720X_QRTABLE00 = 0x12,
+	MAX1720X_FULLSOCTHR = 0x13,
+	MAX1720X_RCELL = 0x14,
+	MAX1720X_RFAST = 0x15,
+	MAX1720X_AVGTA = 0x16,
+	MAX1720X_CYCLES = 0x17,
+	MAX1720X_DESIGNCAP = 0x18,
+	MAX1720X_AVGVCELL = 0x19,
+	MAX1720X_MAXMINTEMP = 0x1A,
+	MAX1720X_MAXMINVOLT = 0x1B,
+	MAX1720X_MAXMINCURR = 0x1C,
+	MAX1720X_CONFIG = 0x1D,
+	MAX1720X_ICHGTERM = 0x1E,
+	MAX1720X_AVCAP = 0x1F,
+
+	MAX1720X_TTF = 0x20,
+	MAX1720X_DEVNAME = 0x21,
+	MAX1720X_QRTABLE10 = 0x22,
+	MAX1720X_FULLCAPNOM = 0x23,
+	MAX1720X_AIN0 = 0x27,
+	MAX1720X_LEARNCFG = 0x28,
+	MAX1720X_FILTERCFG = 0x29,
+	MAX1720X_RELAXCFG = 0x2A,
+	MAX1720X_MISCCFG = 0x2B,
+	MAX1720X_TGAIN = 0x2C,
+	Max1720x_TOff = 0x2D,
+	MAX1720X_CGAIN = 0x2E,
+	MAX1720X_COFF = 0x2F,
+
+	MAX1720X_QRTABLE20 = 0x32,
+	MAX1720X_FULLCAPREP = 0x35,
+	MAX1720X_IAVGEMPTY = 0x36,
+	MAX1720X_RCOMP0 = 0x38,
+	MAX1720X_TEMPCO = 0x39,
+	MAX1720X_VEMPTY = 0x3A,
+	MAX1720X_FSTAT = 0x3D,
+	MAX1720X_TIMER = 0x3E,
+	MAX1720X_SHDNTIMER = 0x3F,
+
+	MAX1720X_QRTABLE30 = 0x42,
+	MAX1720X_DQACC = 0x45,
+	MAX1720X_DPACC = 0x46,
+	MAX1720X_VFREMCAP = 0x4A,
+	MAX1720X_QH0 = 0x4C,
+	MAX1720X_QH = 0x4D,
+
+	MAX1720X_STATUS2 = 0xB0,
+	MAX1720X_IALRTTH = 0xB4,
+	MAX1720X_VSHDNCFG = 0xB8,
+	MAX1720X_AGEFORECAST = 0xB9,
+	MAX1720X_HIBCFG = 0xBA,
+	MAX1720X_CONFIG2 = 0xBB,
+	MAX1720X_VRIPPLE = 0xBC,
+	MAX1720X_PACKCFG = 0xBD,
+	MAX1720X_TIMERH = 0xBE,
+
+	MAX1720X_AVGCELL4 = 0xD1,
+	MAX1720X_AVGCELL3 = 0xD2,
+	MAX1720X_AVGCELL2 = 0xD3,
+	MAX1720X_AVGCELL1 = 0xD4,
+	MAX1720X_CELL4 = 0xD5,
+	MAX1720X_CELL3 = 0xD6,
+	MAX1720X_CELL2 = 0xD7,
+	MAX1720X_CELL1 = 0xD8,
+	MAX1720X_CELLX = 0xD9,
+	MAX1720X_BATT = 0xDA,
+	MAX1720X_ATQRESIDUAL = 0xDC,
+	MAX1720X_ATTTE = 0xDD,
+	MAX1720X_ATAVSOC = 0xDE,
+	MAX1720X_ATAVCAP = 0xDF,
+
+	/* Individual Registers */
+	MAX1720X_COMMAND = 0x60,
+	MAX1720X_COMMSTAT = 0x61,
+	MAX1720X_LOCK = 0x7F,
+	MAX1720X_ODSCTH = 0xF2,
+	MAX1720X_ODSCCFG = 0xF3,
+	MAX1720X_VFOCV = 0xFB,
+	MAX1720X_ALARM = 0xFD,
+	MAX1720X_VFSOC = 0xFF,
+};
+
+enum max1720x_status_bits {
+	MAX1720X_STATUS_POR = BIT(1),
+	MAX1720X_STATUS_IMN = BIT(2),
+	MAX1720X_STATUS_BST = BIT(3),
+	MAX1720X_STATUS_IMX = BIT(6),
+	MAX1720X_STATUS_DSOCI = BIT(7),
+	MAX1720X_STATUS_VMN = BIT(8),
+	MAX1720X_STATUS_TMN = BIT(9),
+	MAX1720X_STATUS_SMN = BIT(10),
+	MAX1720X_STATUS_BI = BIT(11),
+	MAX1720X_STATUS_VMX = BIT(12),
+	MAX1720X_STATUS_TMX = BIT(13),
+	MAX1720X_STATUS_SMX = BIT(14),
+	MAX1720X_STATUS_BR = BIT(15),
+};
+
+enum max1720x_commstat_bits {
+	MAX1720X_COMMSTAT_NVBUSY = BIT(1),
+	MAX1720X_COMMSTAT_NVERROR = BIT(2),
+};
+
+enum max1720x_config_bits {
+	MAX1720X_CONFIG_BER = BIT(0),
+	MAX1720X_CONFIG_BEI = BIT(1),
+	MAX1720X_CONFIG_AEN = BIT(2),
+	MAX1720X_CONFIG_FTHRM = BIT(3),
+	MAX1720X_CONFIG_ETHRM = BIT(4),
+	MAX1720X_CONFIG_COMMSH = BIT(6),
+	MAX1720X_CONFIG_SHDN = BIT(7),
+	MAX1720X_CONFIG_TEX = BIT(8),
+	MAX1720X_CONFIG_TEN = BIT(9),
+	MAX1720X_CONFIG_AINSH = BIT(10),
+	MAX1720X_CONFIG_ALRTP = BIT(11),
+	MAX1720X_CONFIG_VS = BIT(12),
+	MAX1720X_CONFIG_TS = BIT(13),
+	MAX1720X_CONFIG_SS = BIT(14),
+};
+
+enum max1720x_nnvcfg0_bits {
+	MAX1720X_NNVCFG0_ENSBS = BIT(0),
+	MAX1720X_NNVCFG0_ENHCFG = BIT(1),
+	MAX1720X_NNVCFG0_ENAF = BIT(2),
+	MAX1720X_NNVCFG0_ENMC = BIT(3),
+	MAX1720X_NNVCFG0_ENDC = BIT(4),
+	MAX1720X_NNVCFG0_ENVE = BIT(5),
+	MAX1720X_NNVCFG0_ENCG = BIT(6),
+	MAX1720X_NNVCFG0_ENICT = BIT(7),
+	MAX1720X_NNVCFG0_ENLCFG = BIT(8),
+	MAX1720X_NNVCFG0_ENRCFG = BIT(9),
+	MAX1720X_NNVCFG0_ENFCFG = BIT(10),
+	MAX1720X_NNVCFG0_ENCFG = BIT(11),
+	MAX1720X_NNVCFG0_ENX = BIT(14),
+	MAX1720X_NNVCFG0_ENOCV = BIT(15),
+};
+
+enum max1720x_command_bits {
+	MAX1720X_COMMAND_FUEL_GAUGE_RESET = 0x0001,
+	MAX1720X_COMMAND_HARDWARE_RESET = 0x000F,
+	MAX1720X_COMMAND_QUERY_REMAINING_UPDATES = 0xE2FA,
+	MAX1720X_COMMAND_COPY_NV_BLOCK = 0xE904,
+	MAX1720X_COMMAND_HISTORY_RECALL_WRITE_0 = 0xE2FB,
+	MAX1720X_COMMAND_HISTORY_RECALL_WRITE_1 = 0xE2FC,
+	MAX1720X_COMMAND_HISTORY_RECALL_VALID_0 = 0xE2FC,
+	MAX1720X_COMMAND_HISTORY_RECALL_VALID_1 = 0xE2FD,
+	MAX1720X_COMMAND_HISTORY_RECALL_VALID_2 = 0xE2FE,
+	MAX1720X_READ_HISTORY_CMD_BASE = 0xE226,
+};
+
+
+/** Nonvolatile Register Memory Map */
+enum max1720x_nvram {
+	MAX1720X_NVRAM_START = 0x80,
+	MAX1720X_NUSER18C = 0x8C,	/* reserved for QH capacity */
+	MAX1720X_NUSER18D = 0x8D,	/* reserved for QH QH  */
+	MAX1720X_NODSCTH = 0x8E,	/* CCLC */
+	MAX1720X_NODSCCFG = 0x8F,	/* CCLC */
+	MAX1720X_NLEARNCFG = 0x9F,	/* not referred here */
+	MAX1720X_NMISCCFG = 0xB2,	/* CCLC */
+	MAX1720X_NHIBCFG = 0xB4,	/* CCLC */
+	MAX1720X_NCONVGCFG = 0xB7,	/* convergence configuration */
+	MAX1720X_NNVCFG0 = 0xB8,	/* 'NCG0' with NCG1 */
+	MAX1720X_NUSER1C4 = 0xC4,	/* CCLC */
+	MAX1720X_NUSER1C5 = 0xC5,	/* CCLC */
+	MAX1720X_NTTFCFG = 0xC7,	/* Average resistance */
+	MAX1720X_NCGAIN = 0xC8,		/* ....  */
+	MAX1720X_NMANFCTRNAME0 = 0xCC,	/* SNUM */
+	MAX1720X_NMANFCTRNAME1 = 0xCD,	/* CCLC */
+	MAX1720X_NMANFCTRNAME2 = 0xCE,	/* CCLC */
+	MAX1720X_NRSENSE = 0xCF,	/* value of sense resistor */
+	MAX1720X_NUSER1D0 = 0xD0,	/* SNUM */
+	MAX1720X_NUSER1D1 = 0xD1,	/* SNUM */
+	MAX1720X_NAGEFCCFG = 0xD2,
+	MAX1720X_NUSER1D4 = 0xD4,	/* URST */
+	MAX1720X_NMANFCTRDATE = 0xD6,	/* SNUM */
+	MAX1720X_NFIRSTUSED = 0xD7,	/* CCLC */
+	MAX1720X_NSERIALNUMBER0 = 0xD8,	/* SNUM */
+	MAX1720X_NSERIALNUMBER1 = 0xD9,	/* SNUM */
+	MAX1720X_NSERIALNUMBER2 = 0xDA,	/* SNUM */
+	MAX1720X_NDEVICENAME0 = 0xDB,	/* SNUM */
+	MAX1720X_NDEVICENAME1 = 0xDC,	/* SNUM */
+	MAX1720X_NDEVICENAME2 = 0xDD,	/* SNUM */
+	MAX1720X_NDEVICENAME3 = 0xDE,	/* SNUM */
+	MAX1720X_NDEVICENAME4 = 0xDF,	/* CCLC */
+	MAX1720X_NVRAM_END = MAX1720X_NDEVICENAME4,
+
+	MAX1720X_HISTORY_START = 0xE0,
+	MAX1720X_NVRAM_HISTORY_WRITE_STATUS_START = 0xE1,
+	MAX1720X_NVRAM_HISTORY_VALID_STATUS_END = 0xE4,
+	MAX1720X_NVRAM_HISTORY_WRITE_STATUS_END = 0xEA,
+	MAX1720X_NVRAM_HISTORY_VALID_STATUS_START = 0xEB,
+	MAX1720X_NVRAM_REMAINING_UPDATES = 0xED,
+	MAX1720X_NVRAM_HISTORY_END = 0xEF,
+};
+
+#define MAX1720X_HISTORY_PAGE_SIZE \
+		(MAX1720X_NVRAM_HISTORY_END - MAX1720X_HISTORY_START + 1)
+
+#define MAX1720X_N_OF_HISTORY_FLAGS_REG				\
+	(MAX1720X_NVRAM_HISTORY_END -				\
+		MAX1720X_NVRAM_HISTORY_WRITE_STATUS_START + 1 + \
+		MAX1720X_NVRAM_HISTORY_WRITE_STATUS_END -	\
+		MAX1720X_HISTORY_START + 1)
+
+#define MAX1720X_N_OF_QRTABLES 4
+
+/** ------------------------------------------------------------------------ */
+
+static bool max1720x_is_reg(struct device *dev, unsigned int reg)
+{
+	switch (reg) {
+	case MAX1720X_COMMAND:
+	case MAX1720X_COMMSTAT:
+	case MAX1720X_LOCK:
+	case MAX1720X_ODSCTH:
+	case MAX1720X_ODSCCFG:
+	case MAX1720X_VFOCV:
+	case MAX1720X_VFSOC:
+	case MAX1720X_ALARM:
+	case 0x00 ... 0x4F:
+	case 0xB0 ... 0xDF:
+		return true;
+	}
+
+	return false;
+}
+
+static const struct regmap_config max1720x_regmap_cfg = {
+	.reg_bits = 8,
+	.val_bits = 16,
+	.val_format_endian = REGMAP_ENDIAN_NATIVE,
+	.max_register = MAX1720X_VFSOC,
+	.readable_reg = max1720x_is_reg,
+	.volatile_reg = max1720x_is_reg,
+};
+
+static bool max1720x_is_nvram_reg(struct device *dev, unsigned int reg)
+{
+	return (reg >= MAX1720X_NVRAM_START &&
+		reg <= MAX1720X_NVRAM_HISTORY_END);
+}
+
+const struct regmap_config max1720x_regmap_nvram_cfg = {
+	.reg_bits = 8,
+	.val_bits = 16,
+	.val_format_endian = REGMAP_ENDIAN_NATIVE,
+	.max_register = MAX1720X_NVRAM_HISTORY_END,
+	.readable_reg = max1720x_is_nvram_reg,
+	.volatile_reg = max1720x_is_nvram_reg,
+};
+
+/** ------------------------------------------------------------------------ */
+
+static const struct max17x0x_reg max1720x[] = {
+	[MAX17X0X_TAG_avgc] = { ATOM_INIT_REG16(MAX1720X_AVGCURRENT)},
+	[MAX17X0X_TAG_cnfg] = { ATOM_INIT_REG16(MAX1720X_CONFIG)},
+	[MAX17X0X_TAG_mmdv] = { ATOM_INIT_REG16(MAX1720X_MAXMINVOLT)},
+	[MAX17X0X_TAG_vcel] = { ATOM_INIT_REG16(MAX1720X_VCELL)},
+	[MAX17X0X_TAG_temp] = { ATOM_INIT_REG16(MAX1720X_TEMP)},
+	[MAX17X0X_TAG_curr] = { ATOM_INIT_REG16(MAX1720X_CURRENT)},
+	[MAX17X0X_TAG_mcap] = { ATOM_INIT_REG16(MAX1720X_MIXCAP)},
+	[MAX17X0X_TAG_avgr] = { ATOM_INIT_REG16(MAX1720X_NTTFCFG)},
+	[MAX17X0X_TAG_vfsoc] = { ATOM_INIT_REG16(MAX1720X_VFSOC)},
+	[MAX17X0X_TAG_vfocv] = { ATOM_INIT_REG16(MAX1720X_VFOCV)},
+
+	[MAX17X0X_TAG_BCNT] = { ATOM_INIT_MAP(0x8e, 0x8f, 0xb2, 0xb4, 0xc4,
+					      0xc5, 0xcd, 0xce, 0xd7, 0xdf) },
+	[MAX17X0X_TAG_SNUM] = { ATOM_INIT_MAP(0xcc, 0xd8, 0xd9, 0xda, 0xd6,
+					      0xdb, 0xdc, 0xdd, 0xde, 0xd1,
+					      0xd0) },
+
+	[MAX17X0X_TAG_HSTY] = { ATOM_INIT_SET(0xe0, 0xe1, 0xe4, 0xea, 0xeb,
+					      0xed, 0xef) },
+	[MAX17X0X_TAG_BCEA] = { ATOM_INIT_SET(MAX1720X_NUSER1D4,
+					      MAX1720X_NAGEFCCFG,
+					      MAX1720X_NMISCCFG) },
+	[MAX17X0X_TAG_rset] = { ATOM_INIT_SET16(MAX1720X_CONFIG2,
+					MAX1720X_COMMAND_FUEL_GAUGE_RESET,
+					700)},
+	[MAX17X0X_TAG_BRES] = { ATOM_INIT_SET(MAX1720X_NTTFCFG,
+					      MAX1720X_NUSER1D4) },
+};
+
+
+#endif
\ No newline at end of file
diff --git a/drivers/soc/qcom/max1720x_battery.h b/drivers/soc/qcom/max1720x_battery.h
new file mode 100644
index 000000000000..24814e382a91
--- /dev/null
+++ b/drivers/soc/qcom/max1720x_battery.h
@@ -0,0 +1,301 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Google Battery Management System
+ *
+ * Copyright 2020 Google, LLC
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#ifndef MAX1720X_BATTERY_H_
+#define MAX1720X_BATTERY_H_
+
+#include <linux/device.h>
+#include <linux/regmap.h>
+#include <linux/math64.h>
+
+#define MAX1720X_GAUGE_TYPE	0
+#define MAX1730X_GAUGE_TYPE	1
+#define MAX_M5_GAUGE_TYPE	2
+
+#define EEPROM_SN	0
+#define MAX1720X_SN	1
+
+/* multiply by 2 when task period = 351 ms */
+static inline int reg_to_micro_amp_h(s16 val, u16 rsense, int lsb)
+{
+	/* LSB: 5.0Vh/RSENSE ; Rsense LSB is 10 */
+	return div_s64((s64) val * 500000, rsense) * lsb;
+}
+
+/* divide by 2 when task period = 351 ms */
+static inline s16 micro_amp_h_to_reg(int val, u16 rsense, int lsb)
+{
+	/* LSB: 5.0Vh/RSENSE ; Rsense LSB is 10 */
+	return div_s64((s64)(val / lsb) * rsense, 500000);
+}
+
+static inline int reg_to_micro_volt(u16 val)
+{
+	/* LSB: 0.078125mV */
+	return div_u64((u64) val * 78125, 1000);
+}
+
+enum max17x0x_reg_tags {
+	MAX17X0X_TAG_avgc,
+	MAX17X0X_TAG_cnfg,
+	MAX17X0X_TAG_mmdv,
+	MAX17X0X_TAG_vcel,
+	MAX17X0X_TAG_temp,
+	MAX17X0X_TAG_curr,
+	MAX17X0X_TAG_mcap,
+	MAX17X0X_TAG_avgr,
+	MAX17X0X_TAG_vfsoc,
+	MAX17X0X_TAG_vfocv,
+
+	MAX17X0X_TAG_BCNT,
+	MAX17X0X_TAG_SNUM,
+	MAX17X0X_TAG_HSTY,
+	MAX17X0X_TAG_BCEA,
+	MAX17X0X_TAG_rset,
+	MAX17X0X_TAG_BRES,
+};
+
+enum max17x0x_reg_types {
+	GBMS_ATOM_TYPE_MAP = 0,
+	GBMS_ATOM_TYPE_REG = 1,
+	GBMS_ATOM_TYPE_ZONE = 2,
+	GBMS_ATOM_TYPE_SET = 3,
+};
+
+/* this is a map for u16 registers */
+#define ATOM_INIT_MAP(...)			\
+	.type = GBMS_ATOM_TYPE_MAP,		\
+	.size = 2 * sizeof((u8[]){__VA_ARGS__}),\
+	.map = (u8[]){__VA_ARGS__}
+
+#define ATOM_INIT_REG16(r)		\
+	.type = GBMS_ATOM_TYPE_REG,	\
+	.size = 2,			\
+	.reg = r
+
+#define ATOM_INIT_ZONE(start, sz)	\
+	.type = GBMS_ATOM_TYPE_ZONE,	\
+	.size = sz,			\
+	.base = start
+
+/* a set has no storage and cannot be used in load/store */
+#define ATOM_INIT_SET(...)		\
+	.type = GBMS_ATOM_TYPE_SET,	\
+	.size = 0,			\
+	.map = (u8[]){__VA_ARGS__}
+
+#define ATOM_INIT_SET16(...)		\
+	.type = GBMS_ATOM_TYPE_SET,	\
+	.size = 0,			\
+	.map16 = (u16[]){__VA_ARGS__}
+
+struct max17x0x_reg {
+	int type;
+	int size;
+	union {
+		unsigned int base;
+		unsigned int reg;
+		const u16 *map16;
+		const u8 *map;
+	};
+};
+
+struct max17x0x_cache_data {
+	struct max17x0x_reg atom;
+	u16 *cache_data;
+};
+
+#define NB_REGMAP_MAX 256
+
+struct max17x0x_reglog {
+	u16 data[NB_REGMAP_MAX];
+	DECLARE_BITMAP(valid, NB_REGMAP_MAX);
+	int errors[NB_REGMAP_MAX];
+	int count[NB_REGMAP_MAX];
+};
+
+struct max17x0x_regtags {
+	const struct max17x0x_reg *map;
+	unsigned int max;
+};
+
+struct max17x0x_regmap {
+	struct regmap *regmap;
+	struct max17x0x_regtags regtags;
+	struct max17x0x_reglog *reglog;
+};
+
+int max1720x_get_capacity(struct i2c_client *client, int *iic_raw);
+int max1720x_get_voltage_now(struct i2c_client *client, int *iic_raw);
+int max17x0x_sw_reset(struct i2c_client *client);
+
+/* */
+#ifdef CONFIG_MAX1720X_REGLOG_LOG
+static inline void max17x0x_reglog_log(struct max17x0x_reglog *reglog,
+				       unsigned int reg, u16 data, int rtn)
+{
+	if (!reglog)
+		return;
+
+	reglog->count[reg] += 1;
+	if (rtn != 0) {
+		reglog->errors[reg] += 1;
+	} else {
+		__set_bit(reg, reglog->valid);
+		reglog->data[reg] = data;
+	}
+
+}
+
+#else
+static inline void max17x0x_reglog_log(struct max17x0x_reglog *reglog,
+				       unsigned int reg, u16 data, int rtn)
+{
+
+}
+#endif
+
+static inline int max17x0x_regmap_read(const struct max17x0x_regmap *map,
+				       unsigned int reg,
+				       u16 *val,
+				       const char *name)
+{
+	int rtn;
+	unsigned int tmp;
+
+	if (!map->regmap) {
+		pr_err("Failed to read %s, no regmap\n", name);
+		return -EIO;
+	}
+
+	rtn = regmap_read(map->regmap, reg, &tmp);
+	if (rtn)
+		pr_err("Failed to read %s\n", name);
+	else
+		*val = tmp;
+
+	return rtn;
+}
+
+#define REGMAP_READ(regmap, what, dst) \
+	max17x0x_regmap_read(regmap, what, dst, #what)
+
+static inline int max17x0x_regmap_write(const struct max17x0x_regmap *map,
+				       unsigned int reg,
+				       u16 data,
+				       const char *name)
+{
+	int rtn;
+
+	if (!map->regmap) {
+		pr_err("Failed to write %s, no regmap\n", name);
+		return -EIO;
+	}
+
+	rtn = regmap_write(map->regmap, reg, data);
+	if (rtn)
+		pr_err("Failed to write %s\n", name);
+
+	max17x0x_reglog_log(map->reglog, reg, data, rtn);
+
+	return rtn;
+}
+
+#define REGMAP_WRITE(regmap, what, value) \
+	max17x0x_regmap_write(regmap, what, value, #what)
+
+#define WAIT_VERIFY	(10 * USEC_PER_MSEC) /* 10 msec */
+static inline int max1720x_regmap_writeverify(const struct max17x0x_regmap *map,
+					unsigned int reg,
+					u16 data,
+					const char *name)
+{
+	int tmp, ret, retries;
+
+	if (!map->regmap) {
+		pr_err("Failed to write %s, no regmap\n", name);
+		return -EINVAL;
+	}
+
+	for (retries = 3; retries > 0; retries--) {
+		ret = regmap_write(map->regmap, reg, data);
+		if (ret < 0)
+			continue;
+
+		usleep_range(WAIT_VERIFY, WAIT_VERIFY + 100);
+
+		ret = regmap_read(map->regmap, reg, &tmp);
+		if (ret < 0)
+			continue;
+
+		if (tmp == data)
+			return 0;
+	}
+
+	return -EIO;
+}
+
+#define REGMAP_WRITE_VERIFY(regmap, what, value) \
+	max1720x_regmap_writeverify(regmap, what, value, #what)
+
+enum max1720x_drift_algo_version {
+	MAX1720X_DA_VER_NONE = -1,	/* MW RC2 */
+	MAX1720X_DA_VER_ORIG = 0,	/* MW A0, max1720x */
+	MAX1720X_DA_VER_MWA1 = 1,	/* MW A1 RC1 */
+	MAX1720X_DA_VER_MWA2 = 2,	/* MW A2 RC1 */
+};
+
+#define max1720x_check_drift_enabled(dd) \
+		((dd)->algo_ver >= MAX1720X_DA_VER_ORIG)
+#define max1720x_check_drift_on_soc(dd) \
+		((dd)->algo_ver == MAX1720X_DA_VER_MWA1)
+#define max1720x_check_drift_delay(dd) \
+		((dd)->algo_ver == MAX1720X_DA_VER_MWA1 ? 351 : 0)
+
+/* fix to capacity estimation */
+struct max1720x_drift_data {
+	u16 rsense;
+	enum max1720x_drift_algo_version algo_ver;
+
+	u16 design_capacity;
+	int cycle_band;
+	int cycle_fade;
+	int cycle_stable;
+	int ini_rcomp0;
+	int ini_tempco;
+	int ini_filtercfg;
+};
+
+struct max1720x_dyn_filtercfg {
+	s32 temp;
+	s32 hysteresis;
+	u16 curr_val;
+	u16 default_val;
+	u16 adjust_val;
+	struct mutex lock;
+};
+
+extern int max1720x_fixup_comp(struct max1720x_drift_data *ddata,
+			       struct max17x0x_regmap *map,
+			       int plugged);
+extern int max1720x_fixup_dxacc(struct max1720x_drift_data *ddata,
+				struct max17x0x_regmap *map,
+				int cycle_count,
+				int plugged,
+				int lsb);
+
+#endif
diff --git a/drivers/soc/qcom/max1730x.h b/drivers/soc/qcom/max1730x.h
new file mode 100644
index 000000000000..58df593fefb3
--- /dev/null
+++ b/drivers/soc/qcom/max1730x.h
@@ -0,0 +1,171 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Copyright 2019 Google, LLC
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#ifndef MAX1730X_H_
+#define MAX1730X_H_
+
+#include <linux/device.h>
+#include <linux/regmap.h>
+#include "max1720x.h"
+
+#define MAX1730X_N_OF_HISTORY_PAGES 100
+
+#define MAX1730X_GAUGE_PASS1	0x404
+#define MAX1730X_NVPRTTH1_CHARGING	0x0008
+#define MAX1730X_NPROTCFG_PASS1		0x6EA3
+#define MAX1730X_NPROTCFG_PASS2		0x0A04
+
+enum max1730x_register {
+	MAX1730X_MAXMINVOLT = 0x08,
+	MAX1730X_MAXMINTEMP = 0x09,
+	MAX1730X_MAXMINCURR = 0x0A,
+	MAX1730X_CONFIG = 0x0B,
+	MAX1730X_FULLCAPREP = 0x10,
+	MAX1730X_VCELL = 0x1A,
+	MAX1730X_TEMP = 0x1B,
+	MAX1730X_CURRENT = 0x1C,
+	MAX1730X_AVGCURRENT = 0x1D,
+	MAX1730X_MIXCAP = 0x2B,
+	MAX1730X_FULLCAP = 0x35,
+	MAX1730X_LEARNCFG = 0xA1,
+	MAX1730X_MAXPEAKPWR = 0xA4,
+	MAX1730X_SUSPEAKPWR = 0xA5,
+	MAX1730X_PACKRESISTANCE = 0xA6,
+	MAX1730X_SYSRESISTANCE = 0xA7,
+	MAX1730X_MINSYSVOLTAGE = 0xA8,
+	MAX1730X_MPPCURRENT = 0xA9,
+	MAX1730X_SPPCURRENT = 0xAA,
+	MAX1730X_CONFIG2 = 0xAB,
+	MAX1730X_IALRTTH = 0xAC,
+	MAX1730X_MINVOLT = 0xAD,
+	MAX1730X_MINCURR = 0xAE,
+	MAX1730X_NVPRTTH1BAK = 0xD6,
+	MAX1730X_NPROTCFG = 0xD7,
+
+};
+
+enum max1730x_nvram {
+	MAX1730X_NVRAM_START 	= 0x80,
+	MAX1730X_NMANFCTRNAME0	= 0xCC,
+	MAX1730X_NMANFCTRNAME1	= 0xCD,
+	MAX1730X_NVPRTTH1 	= 0xD0,
+	MAX1730X_NDPLIMIT	= 0xE0,
+	MAX1730X_NSCOCVLIM	= 0xE1,
+
+	MAX1730X_NVRAM_END 	= 0xEF,
+	MAX1730X_HISTORY_START 	= 0xF0,
+	MAX1730X_HISTORY_WRITE_STATUS_START = 0xF2,
+	MAX1730X_HISTORY_VALID_STATUS_END = 0xFB,
+	MAX1730X_HISTORY_WRITE_STATUS_END = 0xFE,
+	MAX1730X_HISTORY_END	= 0xFF,
+};
+
+enum max1730x_command_bits {
+	MAX1730X_COMMAND_FUEL_GAUGE_RESET = 0x8000,
+	MAX1730X_READ_HISTORY_CMD_BASE = 0xE22E,
+	MAX1730X_COMMAND_HISTORY_RECALL_WRITE_0 = 0xE29C,
+	MAX1730X_COMMAND_HISTORY_RECALL_VALID_0 = 0xE29C,
+	MAX1730X_COMMAND_HISTORY_RECALL_VALID_1 = 0xE29D,
+};
+
+#define MAX1730X_HISTORY_PAGE_SIZE \
+	(MAX1730X_HISTORY_END - MAX1730X_HISTORY_START + 1)
+
+#define MAX1730X_N_OF_HISTORY_FLAGS_REG \
+	(MAX1730X_HISTORY_END - \
+		MAX1730X_HISTORY_END + 1 + \
+		MAX1730X_HISTORY_VALID_STATUS_END - \
+		MAX1730X_HISTORY_START + 1)
+
+/** ------------------------------------------------------------------------ */
+
+static bool max1730x_is_reg(struct device *dev, unsigned int reg)
+{
+	switch (reg) {
+	case MAX1720X_COMMAND:
+	case MAX1720X_COMMSTAT:
+	case MAX1720X_LOCK:
+	case MAX1720X_ODSCTH:
+	case MAX1720X_ODSCCFG:
+	case MAX1720X_VFOCV:
+	case MAX1720X_VFSOC:
+	case 0x00 ... 0x4F:
+	case 0xA0 ... 0xAE:
+	case 0xB0 ... 0xDF:
+	case 0xF0:
+	case 0xF5:
+		return true;
+	}
+
+	return false;
+}
+
+static const struct regmap_config max1730x_regmap_cfg = {
+	.reg_bits = 8,
+	.val_bits = 16,
+	.val_format_endian = REGMAP_ENDIAN_NATIVE,
+	.max_register = MAX1720X_VFSOC,
+	.readable_reg = max1730x_is_reg,
+	.volatile_reg = max1730x_is_reg,
+};
+
+static bool max1730x_is_nvram_reg(struct device *dev, unsigned int reg)
+{
+	return (reg >= MAX1730X_NVRAM_START &&
+		reg <= MAX1730X_HISTORY_END);
+}
+
+const struct regmap_config max1730x_regmap_nvram_cfg = {
+	.reg_bits = 8,
+	.val_bits = 16,
+	.val_format_endian = REGMAP_ENDIAN_NATIVE,
+	.max_register = MAX1730X_HISTORY_END,
+	.readable_reg = max1730x_is_nvram_reg,
+	.volatile_reg = max1730x_is_nvram_reg,
+};
+
+/** ------------------------------------------------------------------------ */
+
+/* see b/119416045 for layout */
+static const struct max17x0x_reg max1730x[] = {
+	[MAX17X0X_TAG_avgc] = { ATOM_INIT_REG16(MAX1730X_AVGCURRENT)},
+	[MAX17X0X_TAG_cnfg] = { ATOM_INIT_REG16(MAX1730X_CONFIG)},
+	[MAX17X0X_TAG_mmdv] = { ATOM_INIT_REG16(MAX1730X_MAXMINVOLT)},
+	[MAX17X0X_TAG_vcel] = { ATOM_INIT_REG16(MAX1730X_VCELL)},
+	[MAX17X0X_TAG_temp] = { ATOM_INIT_REG16(MAX1730X_TEMP)},
+	[MAX17X0X_TAG_curr] = { ATOM_INIT_REG16(MAX1730X_CURRENT)},
+	[MAX17X0X_TAG_mcap] = { ATOM_INIT_REG16(MAX1730X_MIXCAP)},
+	[MAX17X0X_TAG_avgr] = { ATOM_INIT_REG16(MAX1730X_NMANFCTRNAME1) },
+	[MAX17X0X_TAG_vfsoc] = { ATOM_INIT_REG16(MAX1720X_VFSOC)},
+	[MAX17X0X_TAG_vfocv] = { ATOM_INIT_REG16(MAX1720X_VFOCV)},
+
+	[MAX17X0X_TAG_BCNT] = { ATOM_INIT_MAP(0x8e, 0x8f, 0x9d, 0x9e, 0x9f,
+					      0xb2, 0xb4, 0xb6, 0xc7, 0xe2)},
+	[MAX17X0X_TAG_SNUM] = { ATOM_INIT_MAP(0xce, 0xe6, 0xe7, 0xe8, 0xe9,
+					      0xea, 0xeb, 0xec, 0xed, 0xee,
+					      0xef) },
+
+	[MAX17X0X_TAG_HSTY] = { ATOM_INIT_SET(0xf0, 0xf2, 0xfb, 0xfe, 0xff) },
+	[MAX17X0X_TAG_BCEA] = { ATOM_INIT_SET(MAX1730X_NMANFCTRNAME0,
+					      MAX1730X_NDPLIMIT,
+					      MAX1730X_NSCOCVLIM) },
+	[MAX17X0X_TAG_rset] = { ATOM_INIT_SET16(MAX1730X_CONFIG2,
+					MAX1730X_COMMAND_FUEL_GAUGE_RESET,
+					700)},
+	[MAX17X0X_TAG_BRES] = { ATOM_INIT_SET(MAX1730X_NMANFCTRNAME1,
+					      MAX1730X_NMANFCTRNAME0) },
+};
+
+#endif
\ No newline at end of file
diff --git a/drivers/soc/qcom/max77759.h b/drivers/soc/qcom/max77759.h
new file mode 100644
index 000000000000..a1b8257eae9d
--- /dev/null
+++ b/drivers/soc/qcom/max77759.h
@@ -0,0 +1,152 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Copyright 2020 Google, LLC
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#ifndef MAX77759_H_
+#define MAX77759_H_
+
+#include <linux/i2c.h>
+#include <linux/interrupt.h>
+
+#define SCNPRINTF(...) scnprintf(__VA_ARGS__)
+#include "max77759_regs.h"
+
+#define MAX77759_CHG_INT_COUNT 2
+
+#define MAX77759_PMIC_REV_A0		0x01
+#define MAX77759_PMIC_REV_A1		0x02
+
+#define MAX77759_PMIC_PMIC_ID_MW	0x3b
+
+int max777x9_pmic_get_id(struct i2c_client *client, u8 *id, u8 *rev);
+int max777x9_pmic_reg_read(struct i2c_client *client,
+			   u8 addr, u8 *val, int len);
+int max777x9_pmic_reg_write(struct i2c_client *client,
+			    u8 addr, const u8 *val, int len);
+int max777x9_pmic_reg_update(struct i2c_client *client,
+			     u8 reg, u8 mask, u8 value);
+/* write to a register */
+int max77759_chg_reg_write(struct i2c_client *client, u8 reg, u8 value);
+/* read a register */
+int max77759_chg_reg_read(struct i2c_client *client, u8 reg, u8 *value);
+/* update a register */
+int max77759_chg_reg_update(struct i2c_client *client, u8 reg, u8 mask, u8 value);
+/* change the mode register */
+int max77759_chg_mode_write(struct i2c_client *client, enum max77759_charger_modes mode);
+/* change the insel register */
+int max77759_chg_insel_write(struct i2c_client *client, u8 mask, u8 value);
+/* read the insel register */
+int max77759_chg_insel_read(struct i2c_client *client, u8 *value);
+
+#if IS_ENABLED(CONFIG_PMIC_MAX77729)
+extern int max77759_read_batt_conn(struct i2c_client *client, int *temp);
+extern int max77759_read_usb_temp(struct i2c_client *client, int *temp);
+extern int max77759_read_batt_id(struct i2c_client *client, unsigned int *id);
+#else
+static inline int max77759_read_batt_conn(struct i2c_client *client, int *temp)
+{
+	return -ENODEV;
+}
+static inline int max77759_read_usb_temp(struct i2c_client *client, int *temp)
+{
+	return -ENODEV;
+}
+static inline int max77759_read_batt_id(struct i2c_client *client,
+					unsigned int *id)
+{
+	return -ENODEV;
+}
+#endif
+
+/* ----------------------------------------------------------------------------
+ * GS101 usecases
+ * Platform specific, will need to be moved outside the driver.
+ *
+ * Case	USB_chg USB_otg	WLC_chg	WLC_TX	PMIC_Charger	Ext_B	LSx	Name
+ * ----------------------------------------------------------------------------
+ * 1-1	1	0	x	0	IF-PMIC-VBUS	0	0/0	USB_CHG
+ * 1-2	2	0	x	0	DC VBUS		0	0/0	USB_DC
+ * 2-1	1	0	0	1	IF-PMIC-VBUS	2	0/1	USB_CHG_WLC_TX
+ * 2-2	2	0	0	1	DC CHG		2	0/1	USB_DC_WLC_TX
+ * 3-1	0	0	1	0	IF-PMIC-WCIN	0	0/0	WLC_RX
+ * 3-2	0	0	2	0	DC WCIN		0	0/0	WLC_DC
+ * 4-1	0	1	1	0	IF-PMIC-WCIN	1	1/0	USB_OTG_WLC_RX
+ * 4-2	0	1	2	0	DC WCIN		1	1/0	USB_OTG_WLC_DC
+ * 5-1	0	1	0	0	0		1	1/0	USB_OTG
+ * 5-2	0	1	0	0	OTG 5V		0	0/0	USB_OTG_FRS
+ * 6-2	0	0	0	1	0		2	0/1	WLC_TX
+ * 7-2	0	1	0	1	MW OTG 5V	2	0/1	USB_OTG_WLC_TX
+ * 8	0	0	0	0	0		0	0/0	IDLE
+ * ----------------------------------------------------------------------------
+ *
+ * Ext_Boost = 0 off, 1 = OTG 5V, 2 = WTX 7.5
+ * USB_chg = 0 off, 1 = on, 2 = PPS
+ * WLC_chg = 0 off, 1 = on, 2 = PPS
+ */
+struct max77759_foreach_cb_data {
+	struct gvotable_election *el;
+
+	const char *reason;
+
+	int chgr_on;	/* CC_MAX != 0 */
+	bool stby_on;	/* on disconnect, mode=0 */
+	bool charge_done;
+
+	int chgin_off;	/* input_suspend, mode=0 */
+	int wlcin_off;	/* input_suspend, mode=0 */
+	int usb_wlc;	/* input_suspend, mode=0 */
+
+	/* wlc_on is the same as wlc_rx */
+	bool buck_on;	/* wired power in (chgin_on) from TCPCI */
+
+	bool otg_on;	/* power out, usually external */
+	bool frs_on;	/* power out, fast role swap (internal) */
+
+	bool wlc_rx;	/* charging wireless */
+	bool wlc_tx;	/* battery share */
+
+	bool dc_on;	/* DC requested - wired or wireless */
+
+	bool boost_on;	/* Compat: old for WLC program */
+	bool uno_on;	/* Compat: old for WLC program */
+
+	u8 raw_value;	/* hard override */
+	bool use_raw;
+
+	bool pogo_vout;	/* pogo 5v vout */
+
+	u8 reg;
+
+	struct gvotable_election *dc_avail_votable;	/* DC_AVAIL */
+};
+
+/* internal system values */
+enum {
+	/* Charging disabled (go to mode 0) */
+	GBMS_CHGR_MODE_STBY_ON		= 0x10 + MAX77759_CHGR_MODE_ALL_OFF,
+	/* USB inflow off */
+	GBMS_CHGR_MODE_CHGIN_OFF	= 0x11 + MAX77759_CHGR_MODE_ALL_OFF,
+	/* WCIN inflow off */
+	GBMS_CHGR_MODE_WLCIN_OFF	= 0x12 + MAX77759_CHGR_MODE_ALL_OFF,
+	/* USB + WLC_RX mode */
+	GBMS_CHGR_MODE_USB_WLC_RX	= 0x13 + MAX77759_CHGR_MODE_ALL_OFF,
+
+	/* charging enabled (charging current != 0) */
+	GBMS_CHGR_MODE_CHGR_BUCK_ON	= 0x10 + MAX77759_CHGR_MODE_CHGR_BUCK_ON,
+	/* Compat: old for programmging */
+	GBMS_CHGR_MODE_BOOST_UNO_ON	= 0x10 + MAX77759_CHGR_MODE_BOOST_UNO_ON,
+};
+
+
+#endif
diff --git a/drivers/soc/qcom/max77759_A1_regs.h b/drivers/soc/qcom/max77759_A1_regs.h
new file mode 100644
index 000000000000..4f99e3f84688
--- /dev/null
+++ b/drivers/soc/qcom/max77759_A1_regs.h
@@ -0,0 +1,7488 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * machine generated DO NOT MODIFY
+ * source MW_regmap_082720.csv
+ * 2020-09-01
+ */
+
+#ifndef MAX77759_A1_REG_H_
+#define MAX77759_A1_REG_H_
+
+#include <linux/bits.h>
+
+#define MAX77759_BFF(name, h, l) \
+static inline uint8_t _ ## name ## _set(uint8_t r, uint8_t v) \
+{ \
+	return ((r & ~GENMASK(h, l)) | v << l); \
+} \
+\
+static inline uint8_t _ ## name ## _get(uint8_t r) \
+{ \
+	return ((r & GENMASK(h, l)) >> l); \
+}
+
+
+#define FIELD2VALUE(field,value) \
+	(((value) & field##_MASK) >> field##_SHIFT)
+#define VALUE2FIELD(field,       value) \
+	(((value) << field##_SHIFT) & field##_MASK)
+
+
+
+/* section:  PMIC  */
+
+/*
+ * PMIC_ID,0x0,0b00111011,0x3b
+ * ID[7:0],,,,,,
+ */
+#define MAX77759_PMIC_PMIC_ID	0x0
+
+/*
+ * PMIC_REVISION,0x1,0b00000010,0x02
+ * VER[4:0],,,,,REV[2:0],
+ */
+#define MAX77759_PMIC_PMIC_REVISION	0x1
+
+#define MAX77759_PMIC_PMIC_REVISION_VER_SHIFT	3
+#define MAX77759_PMIC_PMIC_REVISION_VER_MASK	(0x1f << 3)
+#define MAX77759_PMIC_PMIC_REVISION_VER_CLEAR	(~(0x1f << 3))
+#define MAX77759_PMIC_PMIC_REVISION_REV_SHIFT	0
+#define MAX77759_PMIC_PMIC_REVISION_REV_MASK	(0x7 << 0)
+#define MAX77759_PMIC_PMIC_REVISION_REV_CLEAR	(~(0x7 << 0))
+
+MAX77759_BFF(pmic_pmic_revision_ver,7,3)
+MAX77759_BFF(pmic_pmic_revision_rev,2,0)
+static inline const char *
+max77759_pmic_pmic_revision_cstr(char *buff, size_t len, int val)
+{
+#ifdef SCNPRINTF
+	int i = 0;
+
+	i += SCNPRINTF(&buff[i], len - i, " VER=%x",
+		FIELD2VALUE(MAX77759_PMIC_PMIC_REVISION_VER, val));
+	i += SCNPRINTF(&buff[i], len - i, " REV=%x",
+		FIELD2VALUE(MAX77759_PMIC_PMIC_REVISION_REV, val));
+#else
+	buff[0] = 0;
+#endif
+	return buff;
+}
+
+/*
+ * OTP_REVISION,0x2,0b00000000,0x00
+ * OTP_REV[7:0],,,,,,
+ */
+#define MAX77759_PMIC_OTP_REVISION	0x2
+
+/*
+ * INTSRC,0x22,0b00000000,0x00
+ * SPR_7_4[3:0],,,,MAXQ_INT,SPR_3,TOPSYS_INT
+ */
+#define MAX77759_PMIC_INTSRC	0x22
+#define MAX77759_PMIC_INTSRC_MAXQ_INT	(0x1 << 3)
+#define MAX77759_PMIC_INTSRC_SPR_3	(0x1 << 2)
+#define MAX77759_PMIC_INTSRC_TOPSYS_INT	(0x1 << 1)
+#define MAX77759_PMIC_INTSRC_CHGR_INT	(0x1 << 0)
+
+#define MAX77759_PMIC_INTSRC_SPR_7_4_SHIFT	4
+#define MAX77759_PMIC_INTSRC_SPR_7_4_MASK	(0xf << 4)
+#define MAX77759_PMIC_INTSRC_SPR_7_4_CLEAR	(~(0xf << 4))
+#define MAX77759_PMIC_INTSRC_MAXQ_INT_SHIFT	3
+#define MAX77759_PMIC_INTSRC_MAXQ_INT_MASK	(0x1 << 3)
+#define MAX77759_PMIC_INTSRC_MAXQ_INT_CLEAR	(~(0x1 << 3))
+#define MAX77759_PMIC_INTSRC_SPR_3_SHIFT	2
+#define MAX77759_PMIC_INTSRC_SPR_3_MASK	(0x1 << 2)
+#define MAX77759_PMIC_INTSRC_SPR_3_CLEAR	(~(0x1 << 2))
+#define MAX77759_PMIC_INTSRC_TOPSYS_INT_SHIFT	1
+#define MAX77759_PMIC_INTSRC_TOPSYS_INT_MASK	(0x1 << 1)
+#define MAX77759_PMIC_INTSRC_TOPSYS_INT_CLEAR	(~(0x1 << 1))
+#define MAX77759_PMIC_INTSRC_CHGR_INT_SHIFT	0
+#define MAX77759_PMIC_INTSRC_CHGR_INT_MASK	(0x1 << 0)
+#define MAX77759_PMIC_INTSRC_CHGR_INT_CLEAR	(~(0x1 << 0))
+
+MAX77759_BFF(pmic_intsrc_spr_7_4,7,4)
+MAX77759_BFF(pmic_intsrc_maxq_int,3,3)
+MAX77759_BFF(pmic_intsrc_spr_3,2,2)
+MAX77759_BFF(pmic_intsrc_topsys_int,1,1)
+MAX77759_BFF(pmic_intsrc_chgr_int,0,0)
+static inline const char *
+max77759_pmic_intsrc_cstr(char *buff, size_t len, int val)
+{
+#ifdef SCNPRINTF
+	int i = 0;
+
+	i += SCNPRINTF(&buff[i], len - i, " SPR_7_4=%x",
+		FIELD2VALUE(MAX77759_PMIC_INTSRC_SPR_7_4, val));
+	i += SCNPRINTF(&buff[i], len - i, " MAXQ_INT=%x",
+		FIELD2VALUE(MAX77759_PMIC_INTSRC_MAXQ_INT, val));
+	i += SCNPRINTF(&buff[i], len - i, " SPR_3=%x",
+		FIELD2VALUE(MAX77759_PMIC_INTSRC_SPR_3, val));
+	i += SCNPRINTF(&buff[i], len - i, " TOPSYS_INT=%x",
+		FIELD2VALUE(MAX77759_PMIC_INTSRC_TOPSYS_INT, val));
+	i += SCNPRINTF(&buff[i], len - i, " CHGR_INT=%x",
+		FIELD2VALUE(MAX77759_PMIC_INTSRC_CHGR_INT, val));
+#else
+	buff[0] = 0;
+#endif
+	return buff;
+}
+
+/*
+ * INTSRCMASK,0x23,0b11111111,0xff
+ * SPR_7_4[3:0],,,,MAXQ_INT_M,SPR_3,TOPSYS_INT_M
+ */
+#define MAX77759_PMIC_INTSRCMASK	0x23
+#define MAX77759_PMIC_INTSRCMASK_MAXQ_INT_M	(0x1 << 3)
+#define MAX77759_PMIC_INTSRCMASK_SPR_3	(0x1 << 2)
+#define MAX77759_PMIC_INTSRCMASK_TOPSYS_INT_M	(0x1 << 1)
+#define MAX77759_PMIC_INTSRCMASK_CHGR_INT_M	(0x1 << 0)
+
+#define MAX77759_PMIC_INTSRCMASK_SPR_7_4_SHIFT	4
+#define MAX77759_PMIC_INTSRCMASK_SPR_7_4_MASK	(0xf << 4)
+#define MAX77759_PMIC_INTSRCMASK_SPR_7_4_CLEAR	(~(0xf << 4))
+#define MAX77759_PMIC_INTSRCMASK_MAXQ_INT_M_SHIFT	3
+#define MAX77759_PMIC_INTSRCMASK_MAXQ_INT_M_MASK	(0x1 << 3)
+#define MAX77759_PMIC_INTSRCMASK_MAXQ_INT_M_CLEAR	(~(0x1 << 3))
+#define MAX77759_PMIC_INTSRCMASK_SPR_3_SHIFT	2
+#define MAX77759_PMIC_INTSRCMASK_SPR_3_MASK	(0x1 << 2)
+#define MAX77759_PMIC_INTSRCMASK_SPR_3_CLEAR	(~(0x1 << 2))
+#define MAX77759_PMIC_INTSRCMASK_TOPSYS_INT_M_SHIFT	1
+#define MAX77759_PMIC_INTSRCMASK_TOPSYS_INT_M_MASK	(0x1 << 1)
+#define MAX77759_PMIC_INTSRCMASK_TOPSYS_INT_M_CLEAR	(~(0x1 << 1))
+#define MAX77759_PMIC_INTSRCMASK_CHGR_INT_M_SHIFT	0
+#define MAX77759_PMIC_INTSRCMASK_CHGR_INT_M_MASK	(0x1 << 0)
+#define MAX77759_PMIC_INTSRCMASK_CHGR_INT_M_CLEAR	(~(0x1 << 0))
+
+MAX77759_BFF(pmic_intsrcmask_spr_7_4,7,4)
+MAX77759_BFF(pmic_intsrcmask_maxq_int_m,3,3)
+MAX77759_BFF(pmic_intsrcmask_spr_3,2,2)
+MAX77759_BFF(pmic_intsrcmask_topsys_int_m,1,1)
+MAX77759_BFF(pmic_intsrcmask_chgr_int_m,0,0)
+static inline const char *
+max77759_pmic_intsrcmask_cstr(char *buff, size_t len, int val)
+{
+#ifdef SCNPRINTF
+	int i = 0;
+
+	i += SCNPRINTF(&buff[i], len - i, " SPR_7_4=%x",
+		FIELD2VALUE(MAX77759_PMIC_INTSRCMASK_SPR_7_4, val));
+	i += SCNPRINTF(&buff[i], len - i, " MAXQ_INT_M=%x",
+		FIELD2VALUE(MAX77759_PMIC_INTSRCMASK_MAXQ_INT_M, val));
+	i += SCNPRINTF(&buff[i], len - i, " SPR_3=%x",
+		FIELD2VALUE(MAX77759_PMIC_INTSRCMASK_SPR_3, val));
+	i += SCNPRINTF(&buff[i], len - i, " TOPSYS_INT_M=%x",
+		FIELD2VALUE(MAX77759_PMIC_INTSRCMASK_TOPSYS_INT_M, val));
+	i += SCNPRINTF(&buff[i], len - i, " CHGR_INT_M=%x",
+		FIELD2VALUE(MAX77759_PMIC_INTSRCMASK_CHGR_INT_M, val));
+#else
+	buff[0] = 0;
+#endif
+	return buff;
+}
+
+/*
+ * TOPSYS_INT,0x24,0b00000000,0x00
+ * SPR_7,TSHDN_INT,SYSOVLO_INT,SYSUVLO_INT,SPR_3_0[3:0],,
+ */
+#define MAX77759_PMIC_TOPSYS_INT	0x24
+#define MAX77759_PMIC_TOPSYS_INT_SPR_7	(0x1 << 7)
+#define MAX77759_PMIC_TOPSYS_INT_TSHDN_INT	(0x1 << 6)
+#define MAX77759_PMIC_TOPSYS_INT_SYSOVLO_INT	(0x1 << 5)
+#define MAX77759_PMIC_TOPSYS_INT_SYSUVLO_INT	(0x1 << 4)
+
+#define MAX77759_PMIC_TOPSYS_INT_SPR_7_SHIFT	7
+#define MAX77759_PMIC_TOPSYS_INT_SPR_7_MASK	(0x1 << 7)
+#define MAX77759_PMIC_TOPSYS_INT_SPR_7_CLEAR	(~(0x1 << 7))
+#define MAX77759_PMIC_TOPSYS_INT_TSHDN_INT_SHIFT	6
+#define MAX77759_PMIC_TOPSYS_INT_TSHDN_INT_MASK	(0x1 << 6)
+#define MAX77759_PMIC_TOPSYS_INT_TSHDN_INT_CLEAR	(~(0x1 << 6))
+#define MAX77759_PMIC_TOPSYS_INT_SYSOVLO_INT_SHIFT	5
+#define MAX77759_PMIC_TOPSYS_INT_SYSOVLO_INT_MASK	(0x1 << 5)
+#define MAX77759_PMIC_TOPSYS_INT_SYSOVLO_INT_CLEAR	(~(0x1 << 5))
+#define MAX77759_PMIC_TOPSYS_INT_SYSUVLO_INT_SHIFT	4
+#define MAX77759_PMIC_TOPSYS_INT_SYSUVLO_INT_MASK	(0x1 << 4)
+#define MAX77759_PMIC_TOPSYS_INT_SYSUVLO_INT_CLEAR	(~(0x1 << 4))
+#define MAX77759_PMIC_TOPSYS_INT_SPR_3_0_SHIFT	0
+#define MAX77759_PMIC_TOPSYS_INT_SPR_3_0_MASK	(0xf << 0)
+#define MAX77759_PMIC_TOPSYS_INT_SPR_3_0_CLEAR	(~(0xf << 0))
+
+MAX77759_BFF(pmic_topsys_int_spr_7,7,7)
+MAX77759_BFF(pmic_topsys_int_tshdn_int,6,6)
+MAX77759_BFF(pmic_topsys_int_sysovlo_int,5,5)
+MAX77759_BFF(pmic_topsys_int_sysuvlo_int,4,4)
+MAX77759_BFF(pmic_topsys_int_spr_3_0,3,0)
+static inline const char *
+max77759_pmic_topsys_int_cstr(char *buff, size_t len, int val)
+{
+#ifdef SCNPRINTF
+	int i = 0;
+
+	i += SCNPRINTF(&buff[i], len - i, " SPR_7=%x",
+		FIELD2VALUE(MAX77759_PMIC_TOPSYS_INT_SPR_7, val));
+	i += SCNPRINTF(&buff[i], len - i, " TSHDN_INT=%x",
+		FIELD2VALUE(MAX77759_PMIC_TOPSYS_INT_TSHDN_INT, val));
+	i += SCNPRINTF(&buff[i], len - i, " SYSOVLO_INT=%x",
+		FIELD2VALUE(MAX77759_PMIC_TOPSYS_INT_SYSOVLO_INT, val));
+	i += SCNPRINTF(&buff[i], len - i, " SYSUVLO_INT=%x",
+		FIELD2VALUE(MAX77759_PMIC_TOPSYS_INT_SYSUVLO_INT, val));
+	i += SCNPRINTF(&buff[i], len - i, " SPR_3_0=%x",
+		FIELD2VALUE(MAX77759_PMIC_TOPSYS_INT_SPR_3_0, val));
+#else
+	buff[0] = 0;
+#endif
+	return buff;
+}
+
+/*
+ * TOPSYS_INT_MASK,0x26,0b11111111,0xff
+ * SPR_7,TSHDN_INT_M,SYSOVLO_INT_M,SYSUVLO_INT_M,SPR_3_1[2:0],,
+ */
+#define MAX77759_PMIC_TOPSYS_INT_MASK	0x26
+#define MAX77759_PMIC_TOPSYS_INT_MASK_SPR_7	(0x1 << 7)
+#define MAX77759_PMIC_TOPSYS_INT_MASK_TSHDN_INT_M	(0x1 << 6)
+#define MAX77759_PMIC_TOPSYS_INT_MASK_SYSOVLO_INT_M	(0x1 << 5)
+#define MAX77759_PMIC_TOPSYS_INT_MASK_SYSUVLO_INT_M	(0x1 << 4)
+#define MAX77759_PMIC_TOPSYS_INT_MASK_FSHIP_NOT_RD	(0x1 << 0)
+
+#define MAX77759_PMIC_TOPSYS_INT_MASK_SPR_7_SHIFT	7
+#define MAX77759_PMIC_TOPSYS_INT_MASK_SPR_7_MASK	(0x1 << 7)
+#define MAX77759_PMIC_TOPSYS_INT_MASK_SPR_7_CLEAR	(~(0x1 << 7))
+#define MAX77759_PMIC_TOPSYS_INT_MASK_TSHDN_INT_M_SHIFT	6
+#define MAX77759_PMIC_TOPSYS_INT_MASK_TSHDN_INT_M_MASK	(0x1 << 6)
+#define MAX77759_PMIC_TOPSYS_INT_MASK_TSHDN_INT_M_CLEAR	(~(0x1 << 6))
+#define MAX77759_PMIC_TOPSYS_INT_MASK_SYSOVLO_INT_M_SHIFT	5
+#define MAX77759_PMIC_TOPSYS_INT_MASK_SYSOVLO_INT_M_MASK	(0x1 << 5)
+#define MAX77759_PMIC_TOPSYS_INT_MASK_SYSOVLO_INT_M_CLEAR	(~(0x1 << 5))
+#define MAX77759_PMIC_TOPSYS_INT_MASK_SYSUVLO_INT_M_SHIFT	4
+#define MAX77759_PMIC_TOPSYS_INT_MASK_SYSUVLO_INT_M_MASK	(0x1 << 4)
+#define MAX77759_PMIC_TOPSYS_INT_MASK_SYSUVLO_INT_M_CLEAR	(~(0x1 << 4))
+#define MAX77759_PMIC_TOPSYS_INT_MASK_SPR_3_1_SHIFT	1
+#define MAX77759_PMIC_TOPSYS_INT_MASK_SPR_3_1_MASK	(0x7 << 1)
+#define MAX77759_PMIC_TOPSYS_INT_MASK_SPR_3_1_CLEAR	(~(0x7 << 1))
+#define MAX77759_PMIC_TOPSYS_INT_MASK_FSHIP_NOT_RD_SHIFT	0
+#define MAX77759_PMIC_TOPSYS_INT_MASK_FSHIP_NOT_RD_MASK	(0x1 << 0)
+#define MAX77759_PMIC_TOPSYS_INT_MASK_FSHIP_NOT_RD_CLEAR	(~(0x1 << 0))
+
+MAX77759_BFF(pmic_topsys_int_mask_spr_7,7,7)
+MAX77759_BFF(pmic_topsys_int_mask_tshdn_int_m,6,6)
+MAX77759_BFF(pmic_topsys_int_mask_sysovlo_int_m,5,5)
+MAX77759_BFF(pmic_topsys_int_mask_sysuvlo_int_m,4,4)
+MAX77759_BFF(pmic_topsys_int_mask_spr_3_1,3,1)
+MAX77759_BFF(pmic_topsys_int_mask_fship_not_rd,0,0)
+static inline const char *
+max77759_pmic_topsys_int_mask_cstr(char *buff, size_t len, int val)
+{
+#ifdef SCNPRINTF
+	int i = 0;
+
+	i += SCNPRINTF(&buff[i], len - i, " SPR_7=%x",
+		FIELD2VALUE(MAX77759_PMIC_TOPSYS_INT_MASK_SPR_7, val));
+	i += SCNPRINTF(&buff[i], len - i, " TSHDN_INT_M=%x",
+		FIELD2VALUE(MAX77759_PMIC_TOPSYS_INT_MASK_TSHDN_INT_M, val));
+	i += SCNPRINTF(&buff[i], len - i, " SYSOVLO_INT_M=%x",
+		FIELD2VALUE(MAX77759_PMIC_TOPSYS_INT_MASK_SYSOVLO_INT_M, val));
+	i += SCNPRINTF(&buff[i], len - i, " SYSUVLO_INT_M=%x",
+		FIELD2VALUE(MAX77759_PMIC_TOPSYS_INT_MASK_SYSUVLO_INT_M, val));
+	i += SCNPRINTF(&buff[i], len - i, " SPR_3_1=%x",
+		FIELD2VALUE(MAX77759_PMIC_TOPSYS_INT_MASK_SPR_3_1, val));
+	i += SCNPRINTF(&buff[i], len - i, " FSHIP_NOT_RD=%x",
+		FIELD2VALUE(MAX77759_PMIC_TOPSYS_INT_MASK_FSHIP_NOT_RD, val));
+#else
+	buff[0] = 0;
+#endif
+	return buff;
+}
+
+/*
+ * I2C_CNFG,0x40,0b00000000,0x00
+ * SPR_7,PAIR[2:0],,,SPR_3_1[2:0],,
+ */
+#define MAX77759_PMIC_I2C_CNFG	0x40
+#define MAX77759_PMIC_I2C_CNFG_SPR_7	(0x1 << 7)
+#define MAX77759_PMIC_I2C_CNFG_HS_EXT_EN	(0x1 << 0)
+
+#define MAX77759_PMIC_I2C_CNFG_SPR_7_SHIFT	7
+#define MAX77759_PMIC_I2C_CNFG_SPR_7_MASK	(0x1 << 7)
+#define MAX77759_PMIC_I2C_CNFG_SPR_7_CLEAR	(~(0x1 << 7))
+#define MAX77759_PMIC_I2C_CNFG_PAIR_SHIFT	4
+#define MAX77759_PMIC_I2C_CNFG_PAIR_MASK	(0x7 << 4)
+#define MAX77759_PMIC_I2C_CNFG_PAIR_CLEAR	(~(0x7 << 4))
+#define MAX77759_PMIC_I2C_CNFG_SPR_3_1_SHIFT	1
+#define MAX77759_PMIC_I2C_CNFG_SPR_3_1_MASK	(0x7 << 1)
+#define MAX77759_PMIC_I2C_CNFG_SPR_3_1_CLEAR	(~(0x7 << 1))
+#define MAX77759_PMIC_I2C_CNFG_HS_EXT_EN_SHIFT	0
+#define MAX77759_PMIC_I2C_CNFG_HS_EXT_EN_MASK	(0x1 << 0)
+#define MAX77759_PMIC_I2C_CNFG_HS_EXT_EN_CLEAR	(~(0x1 << 0))
+
+MAX77759_BFF(pmic_i2c_cnfg_spr_7,7,7)
+MAX77759_BFF(pmic_i2c_cnfg_pair,6,4)
+MAX77759_BFF(pmic_i2c_cnfg_spr_3_1,3,1)
+MAX77759_BFF(pmic_i2c_cnfg_hs_ext_en,0,0)
+static inline const char *
+max77759_pmic_i2c_cnfg_cstr(char *buff, size_t len, int val)
+{
+#ifdef SCNPRINTF
+	int i = 0;
+
+	i += SCNPRINTF(&buff[i], len - i, " SPR_7=%x",
+		FIELD2VALUE(MAX77759_PMIC_I2C_CNFG_SPR_7, val));
+	i += SCNPRINTF(&buff[i], len - i, " PAIR=%x",
+		FIELD2VALUE(MAX77759_PMIC_I2C_CNFG_PAIR, val));
+	i += SCNPRINTF(&buff[i], len - i, " SPR_3_1=%x",
+		FIELD2VALUE(MAX77759_PMIC_I2C_CNFG_SPR_3_1, val));
+	i += SCNPRINTF(&buff[i], len - i, " HS_EXT_EN=%x",
+		FIELD2VALUE(MAX77759_PMIC_I2C_CNFG_HS_EXT_EN, val));
+#else
+	buff[0] = 0;
+#endif
+	return buff;
+}
+
+/*
+ * SWRESET,0x50,0b00000000,0x00
+ * VIO_OK_MASK,IC_RST_MASK,SWR_RST[5:0],,,,
+ */
+#define MAX77759_PMIC_SWRESET	0x50
+#define MAX77759_PMIC_SWRESET_VIO_OK_MASK	(0x1 << 7)
+#define MAX77759_PMIC_SWRESET_IC_RST_MASK	(0x1 << 6)
+
+#define MAX77759_PMIC_SWRESET_VIO_OK_MASK_SHIFT	7
+#define MAX77759_PMIC_SWRESET_VIO_OK_MASK_MASK	(0x1 << 7)
+#define MAX77759_PMIC_SWRESET_VIO_OK_MASK_CLEAR	(~(0x1 << 7))
+#define MAX77759_PMIC_SWRESET_IC_RST_MASK_SHIFT	6
+#define MAX77759_PMIC_SWRESET_IC_RST_MASK_MASK	(0x1 << 6)
+#define MAX77759_PMIC_SWRESET_IC_RST_MASK_CLEAR	(~(0x1 << 6))
+#define MAX77759_PMIC_SWRESET_SWR_RST_SHIFT	0
+#define MAX77759_PMIC_SWRESET_SWR_RST_MASK	(0x3f << 0)
+#define MAX77759_PMIC_SWRESET_SWR_RST_CLEAR	(~(0x3f << 0))
+
+MAX77759_BFF(pmic_swreset_vio_ok_mask,7,7)
+MAX77759_BFF(pmic_swreset_ic_rst_mask,6,6)
+MAX77759_BFF(pmic_swreset_swr_rst,5,0)
+static inline const char *
+max77759_pmic_swreset_cstr(char *buff, size_t len, int val)
+{
+#ifdef SCNPRINTF
+	int i = 0;
+
+	i += SCNPRINTF(&buff[i], len - i, " VIO_OK_MASK=%x",
+		FIELD2VALUE(MAX77759_PMIC_SWRESET_VIO_OK_MASK, val));
+	i += SCNPRINTF(&buff[i], len - i, " IC_RST_MASK=%x",
+		FIELD2VALUE(MAX77759_PMIC_SWRESET_IC_RST_MASK, val));
+	i += SCNPRINTF(&buff[i], len - i, " SWR_RST=%x",
+		FIELD2VALUE(MAX77759_PMIC_SWRESET_SWR_RST, val));
+#else
+	buff[0] = 0;
+#endif
+	return buff;
+}
+
+/*
+ * CONTROL_FG,0x51,0b00010000,0x10
+ * SPR_7_5[2:0],,,TSHDN_DIS,SPR_3_0[1:0],,THMIO_MUX[1:0]
+ */
+#define MAX77759_PMIC_CONTROL_FG	0x51
+#define MAX77759_PMIC_CONTROL_FG_TSHDN_DIS	(0x1 << 4)
+
+#define MAX77759_PMIC_CONTROL_FG_SPR_7_5_SHIFT	5
+#define MAX77759_PMIC_CONTROL_FG_SPR_7_5_MASK	(0x7 << 5)
+#define MAX77759_PMIC_CONTROL_FG_SPR_7_5_CLEAR	(~(0x7 << 5))
+#define MAX77759_PMIC_CONTROL_FG_TSHDN_DIS_SHIFT	4
+#define MAX77759_PMIC_CONTROL_FG_TSHDN_DIS_MASK	(0x1 << 4)
+#define MAX77759_PMIC_CONTROL_FG_TSHDN_DIS_CLEAR	(~(0x1 << 4))
+#define MAX77759_PMIC_CONTROL_FG_SPR_3_0_SHIFT	2
+#define MAX77759_PMIC_CONTROL_FG_SPR_3_0_MASK	(0x3 << 2)
+#define MAX77759_PMIC_CONTROL_FG_SPR_3_0_CLEAR	(~(0x3 << 2))
+#define MAX77759_PMIC_CONTROL_FG_THMIO_MUX_SHIFT	0
+#define MAX77759_PMIC_CONTROL_FG_THMIO_MUX_MASK	(0x3 << 0)
+#define MAX77759_PMIC_CONTROL_FG_THMIO_MUX_CLEAR	(~(0x3 << 0))
+
+MAX77759_BFF(pmic_control_fg_spr_7_5,7,5)
+MAX77759_BFF(pmic_control_fg_tshdn_dis,4,4)
+MAX77759_BFF(pmic_control_fg_spr_3_0,3,2)
+MAX77759_BFF(pmic_control_fg_thmio_mux,1,0)
+static inline const char *
+max77759_pmic_control_fg_cstr(char *buff, size_t len, int val)
+{
+#ifdef SCNPRINTF
+	int i = 0;
+
+	i += SCNPRINTF(&buff[i], len - i, " SPR_7_5=%x",
+		FIELD2VALUE(MAX77759_PMIC_CONTROL_FG_SPR_7_5, val));
+	i += SCNPRINTF(&buff[i], len - i, " TSHDN_DIS=%x",
+		FIELD2VALUE(MAX77759_PMIC_CONTROL_FG_TSHDN_DIS, val));
+	i += SCNPRINTF(&buff[i], len - i, " SPR_3_0=%x",
+		FIELD2VALUE(MAX77759_PMIC_CONTROL_FG_SPR_3_0, val));
+	i += SCNPRINTF(&buff[i], len - i, " THMIO_MUX=%x",
+		FIELD2VALUE(MAX77759_PMIC_CONTROL_FG_THMIO_MUX, val));
+#else
+	buff[0] = 0;
+#endif
+	return buff;
+}
+
+/*
+ * DEVICE_ID,0x60,0b01011001,0x59
+ * DeviceID[7:0],,,,,,
+ */
+#define MAX77759_PMIC_DEVICE_ID	0x60
+
+/*
+ * DEVICE_REV,0x61,0b00000010,0x02
+ * DeviceRev[7:0],,,,,,
+ */
+#define MAX77759_PMIC_DEVICE_REV	0x61
+
+/*
+ * FW_REV,0x62,0b00000000,0x00
+ * FwRev[7:0],,,,,,
+ */
+#define MAX77759_PMIC_FW_REV	0x62
+
+/*
+ * FW_SUB_REV,0x63,0b00000000,0x00
+ * FwSubRev[7:0],,,,,,
+ */
+#define MAX77759_PMIC_FW_SUB_REV	0x63
+
+/*
+ * UIC_INT1,0x64,0b00000000,0x00
+ * APCmdResI,SysMsgI,UIC_INT1I[3:0],,,,GPIO6I
+ */
+#define MAX77759_PMIC_UIC_INT1	0x64
+#define MAX77759_PMIC_UIC_INT1_APCMDRESI	(0x1 << 7)
+#define MAX77759_PMIC_UIC_INT1_SYSMSGI	(0x1 << 6)
+#define MAX77759_PMIC_UIC_INT1_GPIO6I	(0x1 << 1)
+#define MAX77759_PMIC_UIC_INT1_GPIO5I	(0x1 << 0)
+
+#define MAX77759_PMIC_UIC_INT1_APCMDRESI_SHIFT	7
+#define MAX77759_PMIC_UIC_INT1_APCMDRESI_MASK	(0x1 << 7)
+#define MAX77759_PMIC_UIC_INT1_APCMDRESI_CLEAR	(~(0x1 << 7))
+#define MAX77759_PMIC_UIC_INT1_SYSMSGI_SHIFT	6
+#define MAX77759_PMIC_UIC_INT1_SYSMSGI_MASK	(0x1 << 6)
+#define MAX77759_PMIC_UIC_INT1_SYSMSGI_CLEAR	(~(0x1 << 6))
+#define MAX77759_PMIC_UIC_INT1_UIC_INT1I_SHIFT	2
+#define MAX77759_PMIC_UIC_INT1_UIC_INT1I_MASK	(0xf << 2)
+#define MAX77759_PMIC_UIC_INT1_UIC_INT1I_CLEAR	(~(0xf << 2))
+#define MAX77759_PMIC_UIC_INT1_GPIO6I_SHIFT	1
+#define MAX77759_PMIC_UIC_INT1_GPIO6I_MASK	(0x1 << 1)
+#define MAX77759_PMIC_UIC_INT1_GPIO6I_CLEAR	(~(0x1 << 1))
+#define MAX77759_PMIC_UIC_INT1_GPIO5I_SHIFT	0
+#define MAX77759_PMIC_UIC_INT1_GPIO5I_MASK	(0x1 << 0)
+#define MAX77759_PMIC_UIC_INT1_GPIO5I_CLEAR	(~(0x1 << 0))
+
+MAX77759_BFF(pmic_uic_int1_apcmdresi,7,7)
+MAX77759_BFF(pmic_uic_int1_sysmsgi,6,6)
+MAX77759_BFF(pmic_uic_int1_uic_int1i,5,2)
+MAX77759_BFF(pmic_uic_int1_gpio6i,1,1)
+MAX77759_BFF(pmic_uic_int1_gpio5i,0,0)
+static inline const char *
+max77759_pmic_uic_int1_cstr(char *buff, size_t len, int val)
+{
+#ifdef SCNPRINTF
+	int i = 0;
+
+	i += SCNPRINTF(&buff[i], len - i, " APCMDRESI=%x",
+		FIELD2VALUE(MAX77759_PMIC_UIC_INT1_APCMDRESI, val));
+	i += SCNPRINTF(&buff[i], len - i, " SYSMSGI=%x",
+		FIELD2VALUE(MAX77759_PMIC_UIC_INT1_SYSMSGI, val));
+	i += SCNPRINTF(&buff[i], len - i, " UIC_INT1I=%x",
+		FIELD2VALUE(MAX77759_PMIC_UIC_INT1_UIC_INT1I, val));
+	i += SCNPRINTF(&buff[i], len - i, " GPIO6I=%x",
+		FIELD2VALUE(MAX77759_PMIC_UIC_INT1_GPIO6I, val));
+	i += SCNPRINTF(&buff[i], len - i, " GPIO5I=%x",
+		FIELD2VALUE(MAX77759_PMIC_UIC_INT1_GPIO5I, val));
+#else
+	buff[0] = 0;
+#endif
+	return buff;
+}
+
+/*
+ * UIC_INT2,0x65,0b00000000,0x00
+ * UIC_INT2I[7:0],,,,,,
+ */
+#define MAX77759_PMIC_UIC_INT2	0x65
+
+/*
+ * UIC_INT3,0x66,0b00000000,0x00
+ * UIC_INT3I[7:0],,,,,,
+ */
+#define MAX77759_PMIC_UIC_INT3	0x66
+
+/*
+ * UIC_INT4,0x67,0b00000000,0x00
+ * UIC_INT4I[7:0],,,,,,
+ */
+#define MAX77759_PMIC_UIC_INT4	0x67
+
+/*
+ * UIC_STATUS1,0x68,0b00000000,0x00
+ * UIC_STATUS1[7:0],,,,,,
+ */
+#define MAX77759_PMIC_UIC_STATUS1	0x68
+
+/*
+ * UIC_STATUS2,0x69,0b00000000,0x00
+ * SysMsg[7:0],,,,,,
+ */
+#define MAX77759_PMIC_UIC_STATUS2	0x69
+
+/*
+ * UIC_STATUS3,0x6A,0b00000000,0x00
+ * UIC_STATUS3[7:0],,,,,,
+ */
+#define MAX77759_PMIC_UIC_STATUS3	0x6A
+
+/*
+ * UIC_STATUS4,0x6B,0b00000000,0x00
+ * UIC_STATUS4[7:0],,,,,,
+ */
+#define MAX77759_PMIC_UIC_STATUS4	0x6B
+
+/*
+ * UIC_STATUS5,0x6C,0b00000000,0x00
+ * UIC_STATUS5[5:0],,,,,,ShB_MUX_EN
+ */
+#define MAX77759_PMIC_UIC_STATUS5	0x6C
+#define MAX77759_PMIC_UIC_STATUS5_SHB_MUX_EN	(0x1 << 1)
+#define MAX77759_PMIC_UIC_STATUS5_I2C_MUX_EN	(0x1 << 0)
+
+#define MAX77759_PMIC_UIC_STATUS5_UIC_STATUS5_SHIFT	2
+#define MAX77759_PMIC_UIC_STATUS5_UIC_STATUS5_MASK	(0x3f << 2)
+#define MAX77759_PMIC_UIC_STATUS5_UIC_STATUS5_CLEAR	(~(0x3f << 2))
+#define MAX77759_PMIC_UIC_STATUS5_SHB_MUX_EN_SHIFT	1
+#define MAX77759_PMIC_UIC_STATUS5_SHB_MUX_EN_MASK	(0x1 << 1)
+#define MAX77759_PMIC_UIC_STATUS5_SHB_MUX_EN_CLEAR	(~(0x1 << 1))
+#define MAX77759_PMIC_UIC_STATUS5_I2C_MUX_EN_SHIFT	0
+#define MAX77759_PMIC_UIC_STATUS5_I2C_MUX_EN_MASK	(0x1 << 0)
+#define MAX77759_PMIC_UIC_STATUS5_I2C_MUX_EN_CLEAR	(~(0x1 << 0))
+
+MAX77759_BFF(pmic_uic_status5_uic_status5,7,2)
+MAX77759_BFF(pmic_uic_status5_shb_mux_en,1,1)
+MAX77759_BFF(pmic_uic_status5_i2c_mux_en,0,0)
+static inline const char *
+max77759_pmic_uic_status5_cstr(char *buff, size_t len, int val)
+{
+#ifdef SCNPRINTF
+	int i = 0;
+
+	i += SCNPRINTF(&buff[i], len - i, " UIC_STATUS5=%x",
+		FIELD2VALUE(MAX77759_PMIC_UIC_STATUS5_UIC_STATUS5, val));
+	i += SCNPRINTF(&buff[i], len - i, " SHB_MUX_EN=%x",
+		FIELD2VALUE(MAX77759_PMIC_UIC_STATUS5_SHB_MUX_EN, val));
+	i += SCNPRINTF(&buff[i], len - i, " I2C_MUX_EN=%x",
+		FIELD2VALUE(MAX77759_PMIC_UIC_STATUS5_I2C_MUX_EN, val));
+#else
+	buff[0] = 0;
+#endif
+	return buff;
+}
+
+/*
+ * UIC_STATUS6,0x6D,0b00000000,0x00
+ * UIC_STATUS6[7:0],,,,,,
+ */
+#define MAX77759_PMIC_UIC_STATUS6	0x6D
+
+/*
+ * UIC_STATUS7,0x6E,0b00000000,0x00
+ * UIC_STATUS7[7:0],,,,,,
+ */
+#define MAX77759_PMIC_UIC_STATUS7	0x6E
+
+/*
+ * UIC_STATUS8,0x6F,0b00000000,0x00
+ * UIC_STATUS8[7:0],,,,,,
+ */
+#define MAX77759_PMIC_UIC_STATUS8	0x6F
+
+/*
+ * UIC_INT1_M,0x70,0b10111111,0xbf
+ * APCmdResM,SysMsgM,UIC_INT1_M[3:0],,,,GPIO6M
+ */
+#define MAX77759_PMIC_UIC_INT1_M	0x70
+#define MAX77759_PMIC_UIC_INT1_M_APCMDRESM	(0x1 << 7)
+#define MAX77759_PMIC_UIC_INT1_M_SYSMSGM	(0x1 << 6)
+#define MAX77759_PMIC_UIC_INT1_M_GPIO6M	(0x1 << 1)
+#define MAX77759_PMIC_UIC_INT1_M_GPIO5M	(0x1 << 0)
+
+#define MAX77759_PMIC_UIC_INT1_M_APCMDRESM_SHIFT	7
+#define MAX77759_PMIC_UIC_INT1_M_APCMDRESM_MASK	(0x1 << 7)
+#define MAX77759_PMIC_UIC_INT1_M_APCMDRESM_CLEAR	(~(0x1 << 7))
+#define MAX77759_PMIC_UIC_INT1_M_SYSMSGM_SHIFT	6
+#define MAX77759_PMIC_UIC_INT1_M_SYSMSGM_MASK	(0x1 << 6)
+#define MAX77759_PMIC_UIC_INT1_M_SYSMSGM_CLEAR	(~(0x1 << 6))
+#define MAX77759_PMIC_UIC_INT1_M_UIC_INT1_M_SHIFT	2
+#define MAX77759_PMIC_UIC_INT1_M_UIC_INT1_M_MASK	(0xf << 2)
+#define MAX77759_PMIC_UIC_INT1_M_UIC_INT1_M_CLEAR	(~(0xf << 2))
+#define MAX77759_PMIC_UIC_INT1_M_GPIO6M_SHIFT	1
+#define MAX77759_PMIC_UIC_INT1_M_GPIO6M_MASK	(0x1 << 1)
+#define MAX77759_PMIC_UIC_INT1_M_GPIO6M_CLEAR	(~(0x1 << 1))
+#define MAX77759_PMIC_UIC_INT1_M_GPIO5M_SHIFT	0
+#define MAX77759_PMIC_UIC_INT1_M_GPIO5M_MASK	(0x1 << 0)
+#define MAX77759_PMIC_UIC_INT1_M_GPIO5M_CLEAR	(~(0x1 << 0))
+
+MAX77759_BFF(pmic_uic_int1_m_apcmdresm,7,7)
+MAX77759_BFF(pmic_uic_int1_m_sysmsgm,6,6)
+MAX77759_BFF(pmic_uic_int1_m_uic_int1_m,5,2)
+MAX77759_BFF(pmic_uic_int1_m_gpio6m,1,1)
+MAX77759_BFF(pmic_uic_int1_m_gpio5m,0,0)
+static inline const char *
+max77759_pmic_uic_int1_m_cstr(char *buff, size_t len, int val)
+{
+#ifdef SCNPRINTF
+	int i = 0;
+
+	i += SCNPRINTF(&buff[i], len - i, " APCMDRESM=%x",
+		FIELD2VALUE(MAX77759_PMIC_UIC_INT1_M_APCMDRESM, val));
+	i += SCNPRINTF(&buff[i], len - i, " SYSMSGM=%x",
+		FIELD2VALUE(MAX77759_PMIC_UIC_INT1_M_SYSMSGM, val));
+	i += SCNPRINTF(&buff[i], len - i, " UIC_INT1_M=%x",
+		FIELD2VALUE(MAX77759_PMIC_UIC_INT1_M_UIC_INT1_M, val));
+	i += SCNPRINTF(&buff[i], len - i, " GPIO6M=%x",
+		FIELD2VALUE(MAX77759_PMIC_UIC_INT1_M_GPIO6M, val));
+	i += SCNPRINTF(&buff[i], len - i, " GPIO5M=%x",
+		FIELD2VALUE(MAX77759_PMIC_UIC_INT1_M_GPIO5M, val));
+#else
+	buff[0] = 0;
+#endif
+	return buff;
+}
+
+/*
+ * UIC_INT2_M,0x71,0b11111111,0xff
+ * UIC_INT2_M[7:0],,,,,,
+ */
+#define MAX77759_PMIC_UIC_INT2_M	0x71
+
+/*
+ * UIC_INT3_M,0x72,0b11111111,0xff
+ * UIC_INT3_M[7:0],,,,,,
+ */
+#define MAX77759_PMIC_UIC_INT3_M	0x72
+
+/*
+ * UIC_INT4_M,0x73,0b11111111,0xff
+ * UIC_INT4_M[7:0],,,,,,
+ */
+#define MAX77759_PMIC_UIC_INT4_M	0x73
+
+/*
+ * AP_DATAOUT0,0x81,0b00000000,0x00
+ * AP_REQUEST_OPCODE[7:0],,,,,,
+ */
+#define MAX77759_PMIC_AP_DATAOUT0	0x81
+
+/*
+ * AP_DATAOUT1,0x82,0b00000000,0x00
+ * OPCODE_DATAOUT_01[7:0],,,,,,
+ */
+#define MAX77759_PMIC_AP_DATAOUT1	0x82
+
+/*
+ * AP_DATAOUT2,0x83,0b00000000,0x00
+ * OPCODE_DATAOUT_02[7:0],,,,,,
+ */
+#define MAX77759_PMIC_AP_DATAOUT2	0x83
+
+/*
+ * AP_DATAOUT3,0x84,0b00000000,0x00
+ * OPCODE_DATAOUT_03[7:0],,,,,,
+ */
+#define MAX77759_PMIC_AP_DATAOUT3	0x84
+
+/*
+ * AP_DATAOUT4,0x85,0b00000000,0x00
+ * OPCODE_DATAOUT_04[7:0],,,,,,
+ */
+#define MAX77759_PMIC_AP_DATAOUT4	0x85
+
+/*
+ * AP_DATAOUT5,0x86,0b00000000,0x00
+ * OPCODE_DATAOUT_05[7:0],,,,,,
+ */
+#define MAX77759_PMIC_AP_DATAOUT5	0x86
+
+/*
+ * AP_DATAOUT6,0x87,0b00000000,0x00
+ * OPCODE_DATAOUT_06[7:0],,,,,,
+ */
+#define MAX77759_PMIC_AP_DATAOUT6	0x87
+
+/*
+ * AP_DATAOUT7,0x88,0b00000000,0x00
+ * OPCODE_DATAOUT_07[7:0],,,,,,
+ */
+#define MAX77759_PMIC_AP_DATAOUT7	0x88
+
+/*
+ * AP_DATAOUT8,0x89,0b00000000,0x00
+ * OPCODE_DATAOUT_08[7:0],,,,,,
+ */
+#define MAX77759_PMIC_AP_DATAOUT8	0x89
+
+/*
+ * AP_DATAOUT9,0x8A,0b00000000,0x00
+ * OPCODE_DATAOUT_09[7:0],,,,,,
+ */
+#define MAX77759_PMIC_AP_DATAOUT9	0x8A
+
+/*
+ * AP_DATAOUT10,0x8B,0b00000000,0x00
+ * OPCODE_DATAOUT_10[7:0],,,,,,
+ */
+#define MAX77759_PMIC_AP_DATAOUT10	0x8B
+
+/*
+ * AP_DATAOUT11,0x8C,0b00000000,0x00
+ * OPCODE_DATAOUT_11[7:0],,,,,,
+ */
+#define MAX77759_PMIC_AP_DATAOUT11	0x8C
+
+/*
+ * AP_DATAOUT12,0x8D,0b00000000,0x00
+ * OPCODE_DATAOUT_12[7:0],,,,,,
+ */
+#define MAX77759_PMIC_AP_DATAOUT12	0x8D
+
+/*
+ * AP_DATAOUT13,0x8E,0b00000000,0x00
+ * OPCODE_DATAOUT_13[7:0],,,,,,
+ */
+#define MAX77759_PMIC_AP_DATAOUT13	0x8E
+
+/*
+ * AP_DATAOUT14,0x8F,0b00000000,0x00
+ * OPCODE_DATAOUT_14[7:0],,,,,,
+ */
+#define MAX77759_PMIC_AP_DATAOUT14	0x8F
+
+/*
+ * AP_DATAOUT15,0x90,0b00000000,0x00
+ * OPCODE_DATAOUT_15[7:0],,,,,,
+ */
+#define MAX77759_PMIC_AP_DATAOUT15	0x90
+
+/*
+ * AP_DATAOUT16,0x91,0b00000000,0x00
+ * OPCODE_DATAOUT_16[7:0],,,,,,
+ */
+#define MAX77759_PMIC_AP_DATAOUT16	0x91
+
+/*
+ * AP_DATAOUT17,0x92,0b00000000,0x00
+ * OPCODE_DATAOUT_17[7:0],,,,,,
+ */
+#define MAX77759_PMIC_AP_DATAOUT17	0x92
+
+/*
+ * AP_DATAOUT18,0x93,0b00000000,0x00
+ * OPCODE_DATAOUT_18[7:0],,,,,,
+ */
+#define MAX77759_PMIC_AP_DATAOUT18	0x93
+
+/*
+ * AP_DATAOUT19,0x94,0b00000000,0x00
+ * OPCODE_DATAOUT_19[7:0],,,,,,
+ */
+#define MAX77759_PMIC_AP_DATAOUT19	0x94
+
+/*
+ * AP_DATAOUT20,0x95,0b00000000,0x00
+ * OPCODE_DATAOUT_20[7:0],,,,,,
+ */
+#define MAX77759_PMIC_AP_DATAOUT20	0x95
+
+/*
+ * AP_DATAOUT21,0x96,0b00000000,0x00
+ * OPCODE_DATAOUT_21[7:0],,,,,,
+ */
+#define MAX77759_PMIC_AP_DATAOUT21	0x96
+
+/*
+ * AP_DATAOUT22,0x97,0b00000000,0x00
+ * OPCODE_DATAOUT_22[7:0],,,,,,
+ */
+#define MAX77759_PMIC_AP_DATAOUT22	0x97
+
+/*
+ * AP_DATAOUT23,0x98,0b00000000,0x00
+ * OPCODE_DATAOUT_23[7:0],,,,,,
+ */
+#define MAX77759_PMIC_AP_DATAOUT23	0x98
+
+/*
+ * AP_DATAOUT24,0x99,0b00000000,0x00
+ * OPCODE_DATAOUT_24[7:0],,,,,,
+ */
+#define MAX77759_PMIC_AP_DATAOUT24	0x99
+
+/*
+ * AP_DATAOUT25,0x9A,0b00000000,0x00
+ * OPCODE_DATAOUT_25[7:0],,,,,,
+ */
+#define MAX77759_PMIC_AP_DATAOUT25	0x9A
+
+/*
+ * AP_DATAOUT26,0x9B,0b00000000,0x00
+ * OPCODE_DATAOUT_26[7:0],,,,,,
+ */
+#define MAX77759_PMIC_AP_DATAOUT26	0x9B
+
+/*
+ * AP_DATAOUT27,0x9C,0b00000000,0x00
+ * OPCODE_DATAOUT_27[7:0],,,,,,
+ */
+#define MAX77759_PMIC_AP_DATAOUT27	0x9C
+
+/*
+ * AP_DATAOUT28,0x9D,0b00000000,0x00
+ * OPCODE_DATAOUT_28[7:0],,,,,,
+ */
+#define MAX77759_PMIC_AP_DATAOUT28	0x9D
+
+/*
+ * AP_DATAOUT29,0x9E,0b00000000,0x00
+ * OPCODE_DATAOUT_29[7:0],,,,,,
+ */
+#define MAX77759_PMIC_AP_DATAOUT29	0x9E
+
+/*
+ * AP_DATAOUT30,0x9F,0b00000000,0x00
+ * OPCODE_DATAOUT_30[7:0],,,,,,
+ */
+#define MAX77759_PMIC_AP_DATAOUT30	0x9F
+
+/*
+ * AP_DATAOUT31,0xA0,0b00000000,0x00
+ * OPCODE_DATAOUT_31[7:0],,,,,,
+ */
+#define MAX77759_PMIC_AP_DATAOUT31	0xA0
+
+/*
+ * AP_DATAOUT32,0xA1,0b00000000,0x00
+ * OPCODE_DATAOUT_32[7:0],,,,,,
+ */
+#define MAX77759_PMIC_AP_DATAOUT32	0xA1
+
+/*
+ * AP_DATAIN0,0xB1,0b00000000,0x00
+ * MAXQ_RESPONSE_OPCODE[7:0],,,,,,
+ */
+#define MAX77759_PMIC_AP_DATAIN0	0xB1
+
+/*
+ * AP_DATAIN1,0xB2,0b00000000,0x00
+ * OPCODE_DATAIN_01[7:0],,,,,,
+ */
+#define MAX77759_PMIC_AP_DATAIN1	0xB2
+
+/*
+ * AP_DATAIN2,0xB3,0b00000000,0x00
+ * OPCODE_DATAIN_02[7:0],,,,,,
+ */
+#define MAX77759_PMIC_AP_DATAIN2	0xB3
+
+/*
+ * AP_DATAIN3,0xB4,0b00000000,0x00
+ * OPCODE_DATAIN_03[7:0],,,,,,
+ */
+#define MAX77759_PMIC_AP_DATAIN3	0xB4
+
+/*
+ * AP_DATAIN4,0xB5,0b00000000,0x00
+ * OPCODE_DATAIN_04[7:0],,,,,,
+ */
+#define MAX77759_PMIC_AP_DATAIN4	0xB5
+
+/*
+ * AP_DATAIN5,0xB6,0b00000000,0x00
+ * OPCODE_DATAIN_05[7:0],,,,,,
+ */
+#define MAX77759_PMIC_AP_DATAIN5	0xB6
+
+/*
+ * AP_DATAIN6,0xB7,0b00000000,0x00
+ * OPCODE_DATAIN_06[7:0],,,,,,
+ */
+#define MAX77759_PMIC_AP_DATAIN6	0xB7
+
+/*
+ * AP_DATAIN7,0xB8,0b00000000,0x00
+ * OPCODE_DATAIN_07[7:0],,,,,,
+ */
+#define MAX77759_PMIC_AP_DATAIN7	0xB8
+
+/*
+ * AP_DATAIN8,0xB9,0b00000000,0x00
+ * OPCODE_DATAIN_08[7:0],,,,,,
+ */
+#define MAX77759_PMIC_AP_DATAIN8	0xB9
+
+/*
+ * AP_DATAIN9,0xBA,0b00000000,0x00
+ * OPCODE_DATAIN_09[7:0],,,,,,
+ */
+#define MAX77759_PMIC_AP_DATAIN9	0xBA
+
+/*
+ * AP_DATAIN10,0xBB,0b00000000,0x00
+ * OPCODE_DATAIN_10[7:0],,,,,,
+ */
+#define MAX77759_PMIC_AP_DATAIN10	0xBB
+
+/*
+ * AP_DATAIN11,0xBC,0b00000000,0x00
+ * OPCODE_DATAIN_11[7:0],,,,,,
+ */
+#define MAX77759_PMIC_AP_DATAIN11	0xBC
+
+/*
+ * AP_DATAIN12,0xBD,0b00000000,0x00
+ * OPCODE_DATAIN_12[7:0],,,,,,
+ */
+#define MAX77759_PMIC_AP_DATAIN12	0xBD
+
+/*
+ * AP_DATAIN13,0xBE,0b00000000,0x00
+ * OPCODE_DATAIN_13[7:0],,,,,,
+ */
+#define MAX77759_PMIC_AP_DATAIN13	0xBE
+
+/*
+ * AP_DATAIN14,0xBF,0b00000000,0x00
+ * OPCODE_DATAIN_14[7:0],,,,,,
+ */
+#define MAX77759_PMIC_AP_DATAIN14	0xBF
+
+/*
+ * AP_DATAIN15,0xC0,0b00000000,0x00
+ * OPCODE_DATAIN_15[7:0],,,,,,
+ */
+#define MAX77759_PMIC_AP_DATAIN15	0xC0
+
+/*
+ * AP_DATAIN16,0xC1,0b00000000,0x00
+ * OPCODE_DATAIN_16[7:0],,,,,,
+ */
+#define MAX77759_PMIC_AP_DATAIN16	0xC1
+
+/*
+ * AP_DATAIN17,0xC2,0b00000000,0x00
+ * OPCODE_DATAIN_17[7:0],,,,,,
+ */
+#define MAX77759_PMIC_AP_DATAIN17	0xC2
+
+/*
+ * AP_DATAIN18,0xC3,0b00000000,0x00
+ * OPCODE_DATAIN_18[7:0],,,,,,
+ */
+#define MAX77759_PMIC_AP_DATAIN18	0xC3
+
+/*
+ * AP_DATAIN19,0xC4,0b00000000,0x00
+ * OPCODE_DATAIN_19[7:0],,,,,,
+ */
+#define MAX77759_PMIC_AP_DATAIN19	0xC4
+
+/*
+ * AP_DATAIN20,0xC5,0b00000000,0x00
+ * OPCODE_DATAIN_20[7:0],,,,,,
+ */
+#define MAX77759_PMIC_AP_DATAIN20	0xC5
+
+/*
+ * AP_DATAIN21,0xC6,0b00000000,0x00
+ * OPCODE_DATAIN_21[7:0],,,,,,
+ */
+#define MAX77759_PMIC_AP_DATAIN21	0xC6
+
+/*
+ * AP_DATAIN22,0xC7,0b00000000,0x00
+ * OPCODE_DATAIN_22[7:0],,,,,,
+ */
+#define MAX77759_PMIC_AP_DATAIN22	0xC7
+
+/*
+ * AP_DATAIN23,0xC8,0b00000000,0x00
+ * OPCODE_DATAIN_23[7:0],,,,,,
+ */
+#define MAX77759_PMIC_AP_DATAIN23	0xC8
+
+/*
+ * AP_DATAIN24,0xC9,0b00000000,0x00
+ * OPCODE_DATAIN_24[7:0],,,,,,
+ */
+#define MAX77759_PMIC_AP_DATAIN24	0xC9
+
+/*
+ * AP_DATAIN25,0xCA,0b00000000,0x00
+ * OPCODE_DATAIN_25[7:0],,,,,,
+ */
+#define MAX77759_PMIC_AP_DATAIN25	0xCA
+
+/*
+ * AP_DATAIN26,0xCB,0b00000000,0x00
+ * OPCODE_DATAIN_26[7:0],,,,,,
+ */
+#define MAX77759_PMIC_AP_DATAIN26	0xCB
+
+/*
+ * AP_DATAIN27,0xCC,0b00000000,0x00
+ * OPCODE_DATAIN_27[7:0],,,,,,
+ */
+#define MAX77759_PMIC_AP_DATAIN27	0xCC
+
+/*
+ * AP_DATAIN28,0xCD,0b00000000,0x00
+ * OPCODE_DATAIN_28[7:0],,,,,,
+ */
+#define MAX77759_PMIC_AP_DATAIN28	0xCD
+
+/*
+ * AP_DATAIN29,0xCE,0b00000000,0x00
+ * OPCODE_DATAIN_29[7:0],,,,,,
+ */
+#define MAX77759_PMIC_AP_DATAIN29	0xCE
+
+/*
+ * AP_DATAIN30,0xCF,0b00000000,0x00
+ * OPCODE_DATAIN_30[7:0],,,,,,
+ */
+#define MAX77759_PMIC_AP_DATAIN30	0xCF
+
+/*
+ * AP_DATAIN31,0xD0,0b00000000,0x00
+ * OPCODE_DATAIN_31[7:0],,,,,,
+ */
+#define MAX77759_PMIC_AP_DATAIN31	0xD0
+
+/*
+ * AP_DATAIN32,0xD1,0b00000000,0x00
+ * OPCODE_DATAIN_32[7:0],,,,,,
+ */
+#define MAX77759_PMIC_AP_DATAIN32	0xD1
+
+/*
+ * UIC_SWRST,0xE0,0b00000000,0x00
+ * UIC_SWRST[7:0],,,,,,
+ */
+#define MAX77759_PMIC_UIC_SWRST	0xE0
+
+/* section:  Charger  */
+
+/*
+ * CHG_INT,0xB0,0b00000000,0x00
+ * AICL_I,CHGIN_I,WCIN_I,CHG_I,BAT_I,INLIM_I,THM2_I
+ */
+#define MAX77759_CHG_INT	0xB0
+#define MAX77759_CHG_INT_AICL_I	(0x1 << 7)
+#define MAX77759_CHG_INT_CHGIN_I	(0x1 << 6)
+#define MAX77759_CHG_INT_WCIN_I	(0x1 << 5)
+#define MAX77759_CHG_INT_CHG_I	(0x1 << 4)
+#define MAX77759_CHG_INT_BAT_I	(0x1 << 3)
+#define MAX77759_CHG_INT_INLIM_I	(0x1 << 2)
+#define MAX77759_CHG_INT_THM2_I	(0x1 << 1)
+#define MAX77759_CHG_INT_BYP_I	(0x1 << 0)
+
+#define MAX77759_CHG_INT_AICL_I_SHIFT	7
+#define MAX77759_CHG_INT_AICL_I_MASK	(0x1 << 7)
+#define MAX77759_CHG_INT_AICL_I_CLEAR	(~(0x1 << 7))
+#define MAX77759_CHG_INT_CHGIN_I_SHIFT	6
+#define MAX77759_CHG_INT_CHGIN_I_MASK	(0x1 << 6)
+#define MAX77759_CHG_INT_CHGIN_I_CLEAR	(~(0x1 << 6))
+#define MAX77759_CHG_INT_WCIN_I_SHIFT	5
+#define MAX77759_CHG_INT_WCIN_I_MASK	(0x1 << 5)
+#define MAX77759_CHG_INT_WCIN_I_CLEAR	(~(0x1 << 5))
+#define MAX77759_CHG_INT_CHG_I_SHIFT	4
+#define MAX77759_CHG_INT_CHG_I_MASK	(0x1 << 4)
+#define MAX77759_CHG_INT_CHG_I_CLEAR	(~(0x1 << 4))
+#define MAX77759_CHG_INT_BAT_I_SHIFT	3
+#define MAX77759_CHG_INT_BAT_I_MASK	(0x1 << 3)
+#define MAX77759_CHG_INT_BAT_I_CLEAR	(~(0x1 << 3))
+#define MAX77759_CHG_INT_INLIM_I_SHIFT	2
+#define MAX77759_CHG_INT_INLIM_I_MASK	(0x1 << 2)
+#define MAX77759_CHG_INT_INLIM_I_CLEAR	(~(0x1 << 2))
+#define MAX77759_CHG_INT_THM2_I_SHIFT	1
+#define MAX77759_CHG_INT_THM2_I_MASK	(0x1 << 1)
+#define MAX77759_CHG_INT_THM2_I_CLEAR	(~(0x1 << 1))
+#define MAX77759_CHG_INT_BYP_I_SHIFT	0
+#define MAX77759_CHG_INT_BYP_I_MASK	(0x1 << 0)
+#define MAX77759_CHG_INT_BYP_I_CLEAR	(~(0x1 << 0))
+
+MAX77759_BFF(chg_int_aicl_i,7,7)
+MAX77759_BFF(chg_int_chgin_i,6,6)
+MAX77759_BFF(chg_int_wcin_i,5,5)
+MAX77759_BFF(chg_int_chg_i,4,4)
+MAX77759_BFF(chg_int_bat_i,3,3)
+MAX77759_BFF(chg_int_inlim_i,2,2)
+MAX77759_BFF(chg_int_thm2_i,1,1)
+MAX77759_BFF(chg_int_byp_i,0,0)
+static inline const char *
+max77759_chg_int_cstr(char *buff, size_t len, int val)
+{
+#ifdef SCNPRINTF
+	int i = 0;
+
+	i += SCNPRINTF(&buff[i], len - i, " AICL_I=%x",
+		FIELD2VALUE(MAX77759_CHG_INT_AICL_I, val));
+	i += SCNPRINTF(&buff[i], len - i, " CHGIN_I=%x",
+		FIELD2VALUE(MAX77759_CHG_INT_CHGIN_I, val));
+	i += SCNPRINTF(&buff[i], len - i, " WCIN_I=%x",
+		FIELD2VALUE(MAX77759_CHG_INT_WCIN_I, val));
+	i += SCNPRINTF(&buff[i], len - i, " CHG_I=%x",
+		FIELD2VALUE(MAX77759_CHG_INT_CHG_I, val));
+	i += SCNPRINTF(&buff[i], len - i, " BAT_I=%x",
+		FIELD2VALUE(MAX77759_CHG_INT_BAT_I, val));
+	i += SCNPRINTF(&buff[i], len - i, " INLIM_I=%x",
+		FIELD2VALUE(MAX77759_CHG_INT_INLIM_I, val));
+	i += SCNPRINTF(&buff[i], len - i, " THM2_I=%x",
+		FIELD2VALUE(MAX77759_CHG_INT_THM2_I, val));
+	i += SCNPRINTF(&buff[i], len - i, " BYP_I=%x",
+		FIELD2VALUE(MAX77759_CHG_INT_BYP_I, val));
+#else
+	buff[0] = 0;
+#endif
+	return buff;
+}
+
+/*
+ * CHG_INT2,0xB1,0b00000000,0x00
+ * INSEL_I,SYS_UVLO1_I,SYS_UVLO2_I,BAT_OILO_I,CHG_STA_CC_I,CHG_STA_CV_I,CHG_STA_TO_I
+ */
+#define MAX77759_CHG_INT2	0xB1
+#define MAX77759_CHG_INT2_INSEL_I	(0x1 << 7)
+#define MAX77759_CHG_INT2_SYS_UVLO1_I	(0x1 << 6)
+#define MAX77759_CHG_INT2_SYS_UVLO2_I	(0x1 << 5)
+#define MAX77759_CHG_INT2_BAT_OILO_I	(0x1 << 4)
+#define MAX77759_CHG_INT2_CHG_STA_CC_I	(0x1 << 3)
+#define MAX77759_CHG_INT2_CHG_STA_CV_I	(0x1 << 2)
+#define MAX77759_CHG_INT2_CHG_STA_TO_I	(0x1 << 1)
+#define MAX77759_CHG_INT2_CHG_STA_DONE_I	(0x1 << 0)
+
+#define MAX77759_CHG_INT2_INSEL_I_SHIFT	7
+#define MAX77759_CHG_INT2_INSEL_I_MASK	(0x1 << 7)
+#define MAX77759_CHG_INT2_INSEL_I_CLEAR	(~(0x1 << 7))
+#define MAX77759_CHG_INT2_SYS_UVLO1_I_SHIFT	6
+#define MAX77759_CHG_INT2_SYS_UVLO1_I_MASK	(0x1 << 6)
+#define MAX77759_CHG_INT2_SYS_UVLO1_I_CLEAR	(~(0x1 << 6))
+#define MAX77759_CHG_INT2_SYS_UVLO2_I_SHIFT	5
+#define MAX77759_CHG_INT2_SYS_UVLO2_I_MASK	(0x1 << 5)
+#define MAX77759_CHG_INT2_SYS_UVLO2_I_CLEAR	(~(0x1 << 5))
+#define MAX77759_CHG_INT2_BAT_OILO_I_SHIFT	4
+#define MAX77759_CHG_INT2_BAT_OILO_I_MASK	(0x1 << 4)
+#define MAX77759_CHG_INT2_BAT_OILO_I_CLEAR	(~(0x1 << 4))
+#define MAX77759_CHG_INT2_CHG_STA_CC_I_SHIFT	3
+#define MAX77759_CHG_INT2_CHG_STA_CC_I_MASK	(0x1 << 3)
+#define MAX77759_CHG_INT2_CHG_STA_CC_I_CLEAR	(~(0x1 << 3))
+#define MAX77759_CHG_INT2_CHG_STA_CV_I_SHIFT	2
+#define MAX77759_CHG_INT2_CHG_STA_CV_I_MASK	(0x1 << 2)
+#define MAX77759_CHG_INT2_CHG_STA_CV_I_CLEAR	(~(0x1 << 2))
+#define MAX77759_CHG_INT2_CHG_STA_TO_I_SHIFT	1
+#define MAX77759_CHG_INT2_CHG_STA_TO_I_MASK	(0x1 << 1)
+#define MAX77759_CHG_INT2_CHG_STA_TO_I_CLEAR	(~(0x1 << 1))
+#define MAX77759_CHG_INT2_CHG_STA_DONE_I_SHIFT	0
+#define MAX77759_CHG_INT2_CHG_STA_DONE_I_MASK	(0x1 << 0)
+#define MAX77759_CHG_INT2_CHG_STA_DONE_I_CLEAR	(~(0x1 << 0))
+
+MAX77759_BFF(chg_int2_insel_i,7,7)
+MAX77759_BFF(chg_int2_sys_uvlo1_i,6,6)
+MAX77759_BFF(chg_int2_sys_uvlo2_i,5,5)
+MAX77759_BFF(chg_int2_bat_oilo_i,4,4)
+MAX77759_BFF(chg_int2_chg_sta_cc_i,3,3)
+MAX77759_BFF(chg_int2_chg_sta_cv_i,2,2)
+MAX77759_BFF(chg_int2_chg_sta_to_i,1,1)
+MAX77759_BFF(chg_int2_chg_sta_done_i,0,0)
+static inline const char *
+max77759_chg_int2_cstr(char *buff, size_t len, int val)
+{
+#ifdef SCNPRINTF
+	int i = 0;
+
+	i += SCNPRINTF(&buff[i], len - i, " INSEL_I=%x",
+		FIELD2VALUE(MAX77759_CHG_INT2_INSEL_I, val));
+	i += SCNPRINTF(&buff[i], len - i, " SYS_UVLO1_I=%x",
+		FIELD2VALUE(MAX77759_CHG_INT2_SYS_UVLO1_I, val));
+	i += SCNPRINTF(&buff[i], len - i, " SYS_UVLO2_I=%x",
+		FIELD2VALUE(MAX77759_CHG_INT2_SYS_UVLO2_I, val));
+	i += SCNPRINTF(&buff[i], len - i, " BAT_OILO_I=%x",
+		FIELD2VALUE(MAX77759_CHG_INT2_BAT_OILO_I, val));
+	i += SCNPRINTF(&buff[i], len - i, " CHG_STA_CC_I=%x",
+		FIELD2VALUE(MAX77759_CHG_INT2_CHG_STA_CC_I, val));
+	i += SCNPRINTF(&buff[i], len - i, " CHG_STA_CV_I=%x",
+		FIELD2VALUE(MAX77759_CHG_INT2_CHG_STA_CV_I, val));
+	i += SCNPRINTF(&buff[i], len - i, " CHG_STA_TO_I=%x",
+		FIELD2VALUE(MAX77759_CHG_INT2_CHG_STA_TO_I, val));
+	i += SCNPRINTF(&buff[i], len - i, " CHG_STA_DONE_I=%x",
+		FIELD2VALUE(MAX77759_CHG_INT2_CHG_STA_DONE_I, val));
+#else
+	buff[0] = 0;
+#endif
+	return buff;
+}
+
+/*
+ * CHG_INT_MASK,0xB2,0b11111111,0xff
+ * AICL_M,CHGIN_M,WCIN_M,CHG_M,BAT_M,INLIM_M,THM2_M
+ */
+#define MAX77759_CHG_INT_MASK	0xB2
+#define MAX77759_CHG_INT_MASK_AICL_M	(0x1 << 7)
+#define MAX77759_CHG_INT_MASK_CHGIN_M	(0x1 << 6)
+#define MAX77759_CHG_INT_MASK_WCIN_M	(0x1 << 5)
+#define MAX77759_CHG_INT_MASK_CHG_M	(0x1 << 4)
+#define MAX77759_CHG_INT_MASK_BAT_M	(0x1 << 3)
+#define MAX77759_CHG_INT_MASK_INLIM_M	(0x1 << 2)
+#define MAX77759_CHG_INT_MASK_THM2_M	(0x1 << 1)
+#define MAX77759_CHG_INT_MASK_BYP_M	(0x1 << 0)
+
+#define MAX77759_CHG_INT_MASK_AICL_M_SHIFT	7
+#define MAX77759_CHG_INT_MASK_AICL_M_MASK	(0x1 << 7)
+#define MAX77759_CHG_INT_MASK_AICL_M_CLEAR	(~(0x1 << 7))
+#define MAX77759_CHG_INT_MASK_CHGIN_M_SHIFT	6
+#define MAX77759_CHG_INT_MASK_CHGIN_M_MASK	(0x1 << 6)
+#define MAX77759_CHG_INT_MASK_CHGIN_M_CLEAR	(~(0x1 << 6))
+#define MAX77759_CHG_INT_MASK_WCIN_M_SHIFT	5
+#define MAX77759_CHG_INT_MASK_WCIN_M_MASK	(0x1 << 5)
+#define MAX77759_CHG_INT_MASK_WCIN_M_CLEAR	(~(0x1 << 5))
+#define MAX77759_CHG_INT_MASK_CHG_M_SHIFT	4
+#define MAX77759_CHG_INT_MASK_CHG_M_MASK	(0x1 << 4)
+#define MAX77759_CHG_INT_MASK_CHG_M_CLEAR	(~(0x1 << 4))
+#define MAX77759_CHG_INT_MASK_BAT_M_SHIFT	3
+#define MAX77759_CHG_INT_MASK_BAT_M_MASK	(0x1 << 3)
+#define MAX77759_CHG_INT_MASK_BAT_M_CLEAR	(~(0x1 << 3))
+#define MAX77759_CHG_INT_MASK_INLIM_M_SHIFT	2
+#define MAX77759_CHG_INT_MASK_INLIM_M_MASK	(0x1 << 2)
+#define MAX77759_CHG_INT_MASK_INLIM_M_CLEAR	(~(0x1 << 2))
+#define MAX77759_CHG_INT_MASK_THM2_M_SHIFT	1
+#define MAX77759_CHG_INT_MASK_THM2_M_MASK	(0x1 << 1)
+#define MAX77759_CHG_INT_MASK_THM2_M_CLEAR	(~(0x1 << 1))
+#define MAX77759_CHG_INT_MASK_BYP_M_SHIFT	0
+#define MAX77759_CHG_INT_MASK_BYP_M_MASK	(0x1 << 0)
+#define MAX77759_CHG_INT_MASK_BYP_M_CLEAR	(~(0x1 << 0))
+
+MAX77759_BFF(chg_int_mask_aicl_m,7,7)
+MAX77759_BFF(chg_int_mask_chgin_m,6,6)
+MAX77759_BFF(chg_int_mask_wcin_m,5,5)
+MAX77759_BFF(chg_int_mask_chg_m,4,4)
+MAX77759_BFF(chg_int_mask_bat_m,3,3)
+MAX77759_BFF(chg_int_mask_inlim_m,2,2)
+MAX77759_BFF(chg_int_mask_thm2_m,1,1)
+MAX77759_BFF(chg_int_mask_byp_m,0,0)
+static inline const char *
+max77759_chg_int_mask_cstr(char *buff, size_t len, int val)
+{
+#ifdef SCNPRINTF
+	int i = 0;
+
+	i += SCNPRINTF(&buff[i], len - i, " AICL_M=%x",
+		FIELD2VALUE(MAX77759_CHG_INT_MASK_AICL_M, val));
+	i += SCNPRINTF(&buff[i], len - i, " CHGIN_M=%x",
+		FIELD2VALUE(MAX77759_CHG_INT_MASK_CHGIN_M, val));
+	i += SCNPRINTF(&buff[i], len - i, " WCIN_M=%x",
+		FIELD2VALUE(MAX77759_CHG_INT_MASK_WCIN_M, val));
+	i += SCNPRINTF(&buff[i], len - i, " CHG_M=%x",
+		FIELD2VALUE(MAX77759_CHG_INT_MASK_CHG_M, val));
+	i += SCNPRINTF(&buff[i], len - i, " BAT_M=%x",
+		FIELD2VALUE(MAX77759_CHG_INT_MASK_BAT_M, val));
+	i += SCNPRINTF(&buff[i], len - i, " INLIM_M=%x",
+		FIELD2VALUE(MAX77759_CHG_INT_MASK_INLIM_M, val));
+	i += SCNPRINTF(&buff[i], len - i, " THM2_M=%x",
+		FIELD2VALUE(MAX77759_CHG_INT_MASK_THM2_M, val));
+	i += SCNPRINTF(&buff[i], len - i, " BYP_M=%x",
+		FIELD2VALUE(MAX77759_CHG_INT_MASK_BYP_M, val));
+#else
+	buff[0] = 0;
+#endif
+	return buff;
+}
+
+/*
+ * CHG_INT2_MASK,0xB3,0b11111111,0xff
+ * INSEL_M,SYS_UVLO1_M,SYS_UVLO2_M,BAT_OILO_M,CHG_STA_CC_M,CHG_STA_CV_M,CHG_STA_TO_M
+ */
+#define MAX77759_CHG_INT2_MASK	0xB3
+#define MAX77759_CHG_INT2_MASK_INSEL_M	(0x1 << 7)
+#define MAX77759_CHG_INT2_MASK_SYS_UVLO1_M	(0x1 << 6)
+#define MAX77759_CHG_INT2_MASK_SYS_UVLO2_M	(0x1 << 5)
+#define MAX77759_CHG_INT2_MASK_BAT_OILO_M	(0x1 << 4)
+#define MAX77759_CHG_INT2_MASK_CHG_STA_CC_M	(0x1 << 3)
+#define MAX77759_CHG_INT2_MASK_CHG_STA_CV_M	(0x1 << 2)
+#define MAX77759_CHG_INT2_MASK_CHG_STA_TO_M	(0x1 << 1)
+#define MAX77759_CHG_INT2_MASK_CHG_STA_DONE_M	(0x1 << 0)
+
+#define MAX77759_CHG_INT2_MASK_INSEL_M_SHIFT	7
+#define MAX77759_CHG_INT2_MASK_INSEL_M_MASK	(0x1 << 7)
+#define MAX77759_CHG_INT2_MASK_INSEL_M_CLEAR	(~(0x1 << 7))
+#define MAX77759_CHG_INT2_MASK_SYS_UVLO1_M_SHIFT	6
+#define MAX77759_CHG_INT2_MASK_SYS_UVLO1_M_MASK	(0x1 << 6)
+#define MAX77759_CHG_INT2_MASK_SYS_UVLO1_M_CLEAR	(~(0x1 << 6))
+#define MAX77759_CHG_INT2_MASK_SYS_UVLO2_M_SHIFT	5
+#define MAX77759_CHG_INT2_MASK_SYS_UVLO2_M_MASK	(0x1 << 5)
+#define MAX77759_CHG_INT2_MASK_SYS_UVLO2_M_CLEAR	(~(0x1 << 5))
+#define MAX77759_CHG_INT2_MASK_BAT_OILO_M_SHIFT	4
+#define MAX77759_CHG_INT2_MASK_BAT_OILO_M_MASK	(0x1 << 4)
+#define MAX77759_CHG_INT2_MASK_BAT_OILO_M_CLEAR	(~(0x1 << 4))
+#define MAX77759_CHG_INT2_MASK_CHG_STA_CC_M_SHIFT	3
+#define MAX77759_CHG_INT2_MASK_CHG_STA_CC_M_MASK	(0x1 << 3)
+#define MAX77759_CHG_INT2_MASK_CHG_STA_CC_M_CLEAR	(~(0x1 << 3))
+#define MAX77759_CHG_INT2_MASK_CHG_STA_CV_M_SHIFT	2
+#define MAX77759_CHG_INT2_MASK_CHG_STA_CV_M_MASK	(0x1 << 2)
+#define MAX77759_CHG_INT2_MASK_CHG_STA_CV_M_CLEAR	(~(0x1 << 2))
+#define MAX77759_CHG_INT2_MASK_CHG_STA_TO_M_SHIFT	1
+#define MAX77759_CHG_INT2_MASK_CHG_STA_TO_M_MASK	(0x1 << 1)
+#define MAX77759_CHG_INT2_MASK_CHG_STA_TO_M_CLEAR	(~(0x1 << 1))
+#define MAX77759_CHG_INT2_MASK_CHG_STA_DONE_M_SHIFT	0
+#define MAX77759_CHG_INT2_MASK_CHG_STA_DONE_M_MASK	(0x1 << 0)
+#define MAX77759_CHG_INT2_MASK_CHG_STA_DONE_M_CLEAR	(~(0x1 << 0))
+
+MAX77759_BFF(chg_int2_mask_insel_m,7,7)
+MAX77759_BFF(chg_int2_mask_sys_uvlo1_m,6,6)
+MAX77759_BFF(chg_int2_mask_sys_uvlo2_m,5,5)
+MAX77759_BFF(chg_int2_mask_bat_oilo_m,4,4)
+MAX77759_BFF(chg_int2_mask_chg_sta_cc_m,3,3)
+MAX77759_BFF(chg_int2_mask_chg_sta_cv_m,2,2)
+MAX77759_BFF(chg_int2_mask_chg_sta_to_m,1,1)
+MAX77759_BFF(chg_int2_mask_chg_sta_done_m,0,0)
+static inline const char *
+max77759_chg_int2_mask_cstr(char *buff, size_t len, int val)
+{
+#ifdef SCNPRINTF
+	int i = 0;
+
+	i += SCNPRINTF(&buff[i], len - i, " INSEL_M=%x",
+		FIELD2VALUE(MAX77759_CHG_INT2_MASK_INSEL_M, val));
+	i += SCNPRINTF(&buff[i], len - i, " SYS_UVLO1_M=%x",
+		FIELD2VALUE(MAX77759_CHG_INT2_MASK_SYS_UVLO1_M, val));
+	i += SCNPRINTF(&buff[i], len - i, " SYS_UVLO2_M=%x",
+		FIELD2VALUE(MAX77759_CHG_INT2_MASK_SYS_UVLO2_M, val));
+	i += SCNPRINTF(&buff[i], len - i, " BAT_OILO_M=%x",
+		FIELD2VALUE(MAX77759_CHG_INT2_MASK_BAT_OILO_M, val));
+	i += SCNPRINTF(&buff[i], len - i, " CHG_STA_CC_M=%x",
+		FIELD2VALUE(MAX77759_CHG_INT2_MASK_CHG_STA_CC_M, val));
+	i += SCNPRINTF(&buff[i], len - i, " CHG_STA_CV_M=%x",
+		FIELD2VALUE(MAX77759_CHG_INT2_MASK_CHG_STA_CV_M, val));
+	i += SCNPRINTF(&buff[i], len - i, " CHG_STA_TO_M=%x",
+		FIELD2VALUE(MAX77759_CHG_INT2_MASK_CHG_STA_TO_M, val));
+	i += SCNPRINTF(&buff[i], len - i, " CHG_STA_DONE_M=%x",
+		FIELD2VALUE(MAX77759_CHG_INT2_MASK_CHG_STA_DONE_M, val));
+#else
+	buff[0] = 0;
+#endif
+	return buff;
+}
+
+/*
+ * CHG_INT_OK,0xB4,0b10011111,0x9f
+ * AICL_OK,CHGIN_OK,WCIN_OK,CHG_OK,BAT_OK,INLIM_OK,THM2_OK
+ */
+#define MAX77759_CHG_INT_OK	0xB4
+#define MAX77759_CHG_INT_OK_AICL_OK	(0x1 << 7)
+#define MAX77759_CHG_INT_OK_CHGIN_OK	(0x1 << 6)
+#define MAX77759_CHG_INT_OK_WCIN_OK	(0x1 << 5)
+#define MAX77759_CHG_INT_OK_CHG_OK	(0x1 << 4)
+#define MAX77759_CHG_INT_OK_BAT_OK	(0x1 << 3)
+#define MAX77759_CHG_INT_OK_INLIM_OK	(0x1 << 2)
+#define MAX77759_CHG_INT_OK_THM2_OK	(0x1 << 1)
+#define MAX77759_CHG_INT_OK_BYP_OK	(0x1 << 0)
+
+#define MAX77759_CHG_INT_OK_AICL_OK_SHIFT	7
+#define MAX77759_CHG_INT_OK_AICL_OK_MASK	(0x1 << 7)
+#define MAX77759_CHG_INT_OK_AICL_OK_CLEAR	(~(0x1 << 7))
+#define MAX77759_CHG_INT_OK_CHGIN_OK_SHIFT	6
+#define MAX77759_CHG_INT_OK_CHGIN_OK_MASK	(0x1 << 6)
+#define MAX77759_CHG_INT_OK_CHGIN_OK_CLEAR	(~(0x1 << 6))
+#define MAX77759_CHG_INT_OK_WCIN_OK_SHIFT	5
+#define MAX77759_CHG_INT_OK_WCIN_OK_MASK	(0x1 << 5)
+#define MAX77759_CHG_INT_OK_WCIN_OK_CLEAR	(~(0x1 << 5))
+#define MAX77759_CHG_INT_OK_CHG_OK_SHIFT	4
+#define MAX77759_CHG_INT_OK_CHG_OK_MASK	(0x1 << 4)
+#define MAX77759_CHG_INT_OK_CHG_OK_CLEAR	(~(0x1 << 4))
+#define MAX77759_CHG_INT_OK_BAT_OK_SHIFT	3
+#define MAX77759_CHG_INT_OK_BAT_OK_MASK	(0x1 << 3)
+#define MAX77759_CHG_INT_OK_BAT_OK_CLEAR	(~(0x1 << 3))
+#define MAX77759_CHG_INT_OK_INLIM_OK_SHIFT	2
+#define MAX77759_CHG_INT_OK_INLIM_OK_MASK	(0x1 << 2)
+#define MAX77759_CHG_INT_OK_INLIM_OK_CLEAR	(~(0x1 << 2))
+#define MAX77759_CHG_INT_OK_THM2_OK_SHIFT	1
+#define MAX77759_CHG_INT_OK_THM2_OK_MASK	(0x1 << 1)
+#define MAX77759_CHG_INT_OK_THM2_OK_CLEAR	(~(0x1 << 1))
+#define MAX77759_CHG_INT_OK_BYP_OK_SHIFT	0
+#define MAX77759_CHG_INT_OK_BYP_OK_MASK	(0x1 << 0)
+#define MAX77759_CHG_INT_OK_BYP_OK_CLEAR	(~(0x1 << 0))
+
+MAX77759_BFF(chg_int_ok_aicl_ok,7,7)
+MAX77759_BFF(chg_int_ok_chgin_ok,6,6)
+MAX77759_BFF(chg_int_ok_wcin_ok,5,5)
+MAX77759_BFF(chg_int_ok_chg_ok,4,4)
+MAX77759_BFF(chg_int_ok_bat_ok,3,3)
+MAX77759_BFF(chg_int_ok_inlim_ok,2,2)
+MAX77759_BFF(chg_int_ok_thm2_ok,1,1)
+MAX77759_BFF(chg_int_ok_byp_ok,0,0)
+static inline const char *
+max77759_chg_int_ok_cstr(char *buff, size_t len, int val)
+{
+#ifdef SCNPRINTF
+	int i = 0;
+
+	i += SCNPRINTF(&buff[i], len - i, " AICL_OK=%x",
+		FIELD2VALUE(MAX77759_CHG_INT_OK_AICL_OK, val));
+	i += SCNPRINTF(&buff[i], len - i, " CHGIN_OK=%x",
+		FIELD2VALUE(MAX77759_CHG_INT_OK_CHGIN_OK, val));
+	i += SCNPRINTF(&buff[i], len - i, " WCIN_OK=%x",
+		FIELD2VALUE(MAX77759_CHG_INT_OK_WCIN_OK, val));
+	i += SCNPRINTF(&buff[i], len - i, " CHG_OK=%x",
+		FIELD2VALUE(MAX77759_CHG_INT_OK_CHG_OK, val));
+	i += SCNPRINTF(&buff[i], len - i, " BAT_OK=%x",
+		FIELD2VALUE(MAX77759_CHG_INT_OK_BAT_OK, val));
+	i += SCNPRINTF(&buff[i], len - i, " INLIM_OK=%x",
+		FIELD2VALUE(MAX77759_CHG_INT_OK_INLIM_OK, val));
+	i += SCNPRINTF(&buff[i], len - i, " THM2_OK=%x",
+		FIELD2VALUE(MAX77759_CHG_INT_OK_THM2_OK, val));
+	i += SCNPRINTF(&buff[i], len - i, " BYP_OK=%x",
+		FIELD2VALUE(MAX77759_CHG_INT_OK_BYP_OK, val));
+#else
+	buff[0] = 0;
+#endif
+	return buff;
+}
+
+/*
+ * CHG_DETAILS_00,0xB5,0b00000000,0x00
+ * RSVD,CHGIN_DTLS[1:0],,WCIN_DTLS[1:0],,SPSN_DTLS[1:0],
+ */
+#define MAX77759_CHG_DETAILS_00	0xB5
+#define MAX77759_CHG_DETAILS_00_RSVD	(0x1 << 7)
+#define MAX77759_CHG_DETAILS_00_TREG	(0x1 << 0)
+
+#define MAX77759_CHG_DETAILS_00_RSVD_SHIFT	7
+#define MAX77759_CHG_DETAILS_00_RSVD_MASK	(0x1 << 7)
+#define MAX77759_CHG_DETAILS_00_RSVD_CLEAR	(~(0x1 << 7))
+#define MAX77759_CHG_DETAILS_00_CHGIN_DTLS_SHIFT	5
+#define MAX77759_CHG_DETAILS_00_CHGIN_DTLS_MASK	(0x3 << 5)
+#define MAX77759_CHG_DETAILS_00_CHGIN_DTLS_CLEAR	(~(0x3 << 5))
+#define MAX77759_CHG_DETAILS_00_WCIN_DTLS_SHIFT	3
+#define MAX77759_CHG_DETAILS_00_WCIN_DTLS_MASK	(0x3 << 3)
+#define MAX77759_CHG_DETAILS_00_WCIN_DTLS_CLEAR	(~(0x3 << 3))
+#define MAX77759_CHG_DETAILS_00_SPSN_DTLS_SHIFT	1
+#define MAX77759_CHG_DETAILS_00_SPSN_DTLS_MASK	(0x3 << 1)
+#define MAX77759_CHG_DETAILS_00_SPSN_DTLS_CLEAR	(~(0x3 << 1))
+#define MAX77759_CHG_DETAILS_00_TREG_SHIFT	0
+#define MAX77759_CHG_DETAILS_00_TREG_MASK	(0x1 << 0)
+#define MAX77759_CHG_DETAILS_00_TREG_CLEAR	(~(0x1 << 0))
+
+MAX77759_BFF(chg_details_00_rsvd,7,7)
+MAX77759_BFF(chg_details_00_chgin_dtls,6,5)
+MAX77759_BFF(chg_details_00_wcin_dtls,4,3)
+MAX77759_BFF(chg_details_00_spsn_dtls,2,1)
+MAX77759_BFF(chg_details_00_treg,0,0)
+static inline const char *
+max77759_chg_details_00_cstr(char *buff, size_t len, int val)
+{
+#ifdef SCNPRINTF
+	int i = 0;
+
+	i += SCNPRINTF(&buff[i], len - i, " RSVD=%x",
+		FIELD2VALUE(MAX77759_CHG_DETAILS_00_RSVD, val));
+	i += SCNPRINTF(&buff[i], len - i, " CHGIN_DTLS=%x",
+		FIELD2VALUE(MAX77759_CHG_DETAILS_00_CHGIN_DTLS, val));
+	i += SCNPRINTF(&buff[i], len - i, " WCIN_DTLS=%x",
+		FIELD2VALUE(MAX77759_CHG_DETAILS_00_WCIN_DTLS, val));
+	i += SCNPRINTF(&buff[i], len - i, " SPSN_DTLS=%x",
+		FIELD2VALUE(MAX77759_CHG_DETAILS_00_SPSN_DTLS, val));
+	i += SCNPRINTF(&buff[i], len - i, " TREG=%x",
+		FIELD2VALUE(MAX77759_CHG_DETAILS_00_TREG, val));
+#else
+	buff[0] = 0;
+#endif
+	return buff;
+}
+
+/*
+ * CHG_DETAILS_01,0xB6,0b11111000,0xf8
+ * VDROOP2_OK,BAT_DTLS[2:0],,,CHG_DTLS[3:0],,
+ */
+#define MAX77759_CHG_DETAILS_01	0xB6
+#define MAX77759_CHG_DETAILS_01_VDROOP2_OK	(0x1 << 7)
+
+#define MAX77759_CHG_DETAILS_01_VDROOP2_OK_SHIFT	7
+#define MAX77759_CHG_DETAILS_01_VDROOP2_OK_MASK	(0x1 << 7)
+#define MAX77759_CHG_DETAILS_01_VDROOP2_OK_CLEAR	(~(0x1 << 7))
+#define MAX77759_CHG_DETAILS_01_BAT_DTLS_SHIFT	4
+#define MAX77759_CHG_DETAILS_01_BAT_DTLS_MASK	(0x7 << 4)
+#define MAX77759_CHG_DETAILS_01_BAT_DTLS_CLEAR	(~(0x7 << 4))
+#define MAX77759_CHG_DETAILS_01_CHG_DTLS_SHIFT	0
+#define MAX77759_CHG_DETAILS_01_CHG_DTLS_MASK	(0xf << 0)
+#define MAX77759_CHG_DETAILS_01_CHG_DTLS_CLEAR	(~(0xf << 0))
+
+MAX77759_BFF(chg_details_01_vdroop2_ok,7,7)
+MAX77759_BFF(chg_details_01_bat_dtls,6,4)
+MAX77759_BFF(chg_details_01_chg_dtls,3,0)
+static inline const char *
+max77759_chg_details_01_cstr(char *buff, size_t len, int val)
+{
+#ifdef SCNPRINTF
+	int i = 0;
+
+	i += SCNPRINTF(&buff[i], len - i, " VDROOP2_OK=%x",
+		FIELD2VALUE(MAX77759_CHG_DETAILS_01_VDROOP2_OK, val));
+	i += SCNPRINTF(&buff[i], len - i, " BAT_DTLS=%x",
+		FIELD2VALUE(MAX77759_CHG_DETAILS_01_BAT_DTLS, val));
+	i += SCNPRINTF(&buff[i], len - i, " CHG_DTLS=%x",
+		FIELD2VALUE(MAX77759_CHG_DETAILS_01_CHG_DTLS, val));
+#else
+	buff[0] = 0;
+#endif
+	return buff;
+}
+
+/*
+ * CHG_DETAILS_02,0xB7,0b00000000,0x00
+ * RSVD[1:0],,CHGIN_STS,WCIN_STS,BYP_DTLS[3:0],,
+ */
+#define MAX77759_CHG_DETAILS_02	0xB7
+#define MAX77759_CHG_DETAILS_02_CHGIN_STS	(0x1 << 5)
+#define MAX77759_CHG_DETAILS_02_WCIN_STS	(0x1 << 4)
+
+#define MAX77759_CHG_DETAILS_02_RSVD_SHIFT	6
+#define MAX77759_CHG_DETAILS_02_RSVD_MASK	(0x3 << 6)
+#define MAX77759_CHG_DETAILS_02_RSVD_CLEAR	(~(0x3 << 6))
+#define MAX77759_CHG_DETAILS_02_CHGIN_STS_SHIFT	5
+#define MAX77759_CHG_DETAILS_02_CHGIN_STS_MASK	(0x1 << 5)
+#define MAX77759_CHG_DETAILS_02_CHGIN_STS_CLEAR	(~(0x1 << 5))
+#define MAX77759_CHG_DETAILS_02_WCIN_STS_SHIFT	4
+#define MAX77759_CHG_DETAILS_02_WCIN_STS_MASK	(0x1 << 4)
+#define MAX77759_CHG_DETAILS_02_WCIN_STS_CLEAR	(~(0x1 << 4))
+#define MAX77759_CHG_DETAILS_02_BYP_DTLS_SHIFT	0
+#define MAX77759_CHG_DETAILS_02_BYP_DTLS_MASK	(0xf << 0)
+#define MAX77759_CHG_DETAILS_02_BYP_DTLS_CLEAR	(~(0xf << 0))
+
+MAX77759_BFF(chg_details_02_rsvd,7,6)
+MAX77759_BFF(chg_details_02_chgin_sts,5,5)
+MAX77759_BFF(chg_details_02_wcin_sts,4,4)
+MAX77759_BFF(chg_details_02_byp_dtls,3,0)
+static inline const char *
+max77759_chg_details_02_cstr(char *buff, size_t len, int val)
+{
+#ifdef SCNPRINTF
+	int i = 0;
+
+	i += SCNPRINTF(&buff[i], len - i, " RSVD=%x",
+		FIELD2VALUE(MAX77759_CHG_DETAILS_02_RSVD, val));
+	i += SCNPRINTF(&buff[i], len - i, " CHGIN_STS=%x",
+		FIELD2VALUE(MAX77759_CHG_DETAILS_02_CHGIN_STS, val));
+	i += SCNPRINTF(&buff[i], len - i, " WCIN_STS=%x",
+		FIELD2VALUE(MAX77759_CHG_DETAILS_02_WCIN_STS, val));
+	i += SCNPRINTF(&buff[i], len - i, " BYP_DTLS=%x",
+		FIELD2VALUE(MAX77759_CHG_DETAILS_02_BYP_DTLS, val));
+#else
+	buff[0] = 0;
+#endif
+	return buff;
+}
+
+/*
+ * CHG_DETAILS_03,0xB8,0b00000010,0x02
+ * FSHIP_EXIT_DTLS[1:0],,MD_DTLS[1:0],,RSVD,THM_DTLS[2:0],
+ */
+#define MAX77759_CHG_DETAILS_03	0xB8
+#define MAX77759_CHG_DETAILS_03_RSVD	(0x1 << 3)
+
+#define MAX77759_CHG_DETAILS_03_FSHIP_EXIT_DTLS_SHIFT	6
+#define MAX77759_CHG_DETAILS_03_FSHIP_EXIT_DTLS_MASK	(0x3 << 6)
+#define MAX77759_CHG_DETAILS_03_FSHIP_EXIT_DTLS_CLEAR	(~(0x3 << 6))
+#define MAX77759_CHG_DETAILS_03_MD_DTLS_SHIFT	4
+#define MAX77759_CHG_DETAILS_03_MD_DTLS_MASK	(0x3 << 4)
+#define MAX77759_CHG_DETAILS_03_MD_DTLS_CLEAR	(~(0x3 << 4))
+#define MAX77759_CHG_DETAILS_03_RSVD_SHIFT	3
+#define MAX77759_CHG_DETAILS_03_RSVD_MASK	(0x1 << 3)
+#define MAX77759_CHG_DETAILS_03_RSVD_CLEAR	(~(0x1 << 3))
+#define MAX77759_CHG_DETAILS_03_THM_DTLS_SHIFT	0
+#define MAX77759_CHG_DETAILS_03_THM_DTLS_MASK	(0x7 << 0)
+#define MAX77759_CHG_DETAILS_03_THM_DTLS_CLEAR	(~(0x7 << 0))
+
+MAX77759_BFF(chg_details_03_fship_exit_dtls,7,6)
+MAX77759_BFF(chg_details_03_md_dtls,5,4)
+MAX77759_BFF(chg_details_03_rsvd,3,3)
+MAX77759_BFF(chg_details_03_thm_dtls,2,0)
+static inline const char *
+max77759_chg_details_03_cstr(char *buff, size_t len, int val)
+{
+#ifdef SCNPRINTF
+	int i = 0;
+
+	i += SCNPRINTF(&buff[i], len - i, " FSHIP_EXIT_DTLS=%x",
+		FIELD2VALUE(MAX77759_CHG_DETAILS_03_FSHIP_EXIT_DTLS, val));
+	i += SCNPRINTF(&buff[i], len - i, " MD_DTLS=%x",
+		FIELD2VALUE(MAX77759_CHG_DETAILS_03_MD_DTLS, val));
+	i += SCNPRINTF(&buff[i], len - i, " RSVD=%x",
+		FIELD2VALUE(MAX77759_CHG_DETAILS_03_RSVD, val));
+	i += SCNPRINTF(&buff[i], len - i, " THM_DTLS=%x",
+		FIELD2VALUE(MAX77759_CHG_DETAILS_03_THM_DTLS, val));
+#else
+	buff[0] = 0;
+#endif
+	return buff;
+}
+
+/*
+ * CHG_CNFG_00,0xB9,0b00000100,0x04
+ * WDTCLR[1:0],,CP_EN,BYPV_RAMP_BYPASS,MODE[3:0],,
+ */
+#define MAX77759_CHG_CNFG_00	0xB9
+#define MAX77759_CHG_CNFG_00_CP_EN	(0x1 << 5)
+#define MAX77759_CHG_CNFG_00_BYPV_RAMP_BYPASS	(0x1 << 4)
+
+#define MAX77759_CHG_CNFG_00_WDTCLR_SHIFT	6
+#define MAX77759_CHG_CNFG_00_WDTCLR_MASK	(0x3 << 6)
+#define MAX77759_CHG_CNFG_00_WDTCLR_CLEAR	(~(0x3 << 6))
+#define MAX77759_CHG_CNFG_00_CP_EN_SHIFT	5
+#define MAX77759_CHG_CNFG_00_CP_EN_MASK	(0x1 << 5)
+#define MAX77759_CHG_CNFG_00_CP_EN_CLEAR	(~(0x1 << 5))
+#define MAX77759_CHG_CNFG_00_BYPV_RAMP_BYPASS_SHIFT	4
+#define MAX77759_CHG_CNFG_00_BYPV_RAMP_BYPASS_MASK	(0x1 << 4)
+#define MAX77759_CHG_CNFG_00_BYPV_RAMP_BYPASS_CLEAR	(~(0x1 << 4))
+#define MAX77759_CHG_CNFG_00_MODE_SHIFT	0
+#define MAX77759_CHG_CNFG_00_MODE_MASK	(0xf << 0)
+#define MAX77759_CHG_CNFG_00_MODE_CLEAR	(~(0xf << 0))
+
+MAX77759_BFF(chg_cnfg_00_wdtclr,7,6)
+MAX77759_BFF(chg_cnfg_00_cp_en,5,5)
+MAX77759_BFF(chg_cnfg_00_bypv_ramp_bypass,4,4)
+MAX77759_BFF(chg_cnfg_00_mode,3,0)
+static inline const char *
+max77759_chg_cnfg_00_cstr(char *buff, size_t len, int val)
+{
+#ifdef SCNPRINTF
+	int i = 0;
+
+	i += SCNPRINTF(&buff[i], len - i, " WDTCLR=%x",
+		FIELD2VALUE(MAX77759_CHG_CNFG_00_WDTCLR, val));
+	i += SCNPRINTF(&buff[i], len - i, " CP_EN=%x",
+		FIELD2VALUE(MAX77759_CHG_CNFG_00_CP_EN, val));
+	i += SCNPRINTF(&buff[i], len - i, " BYPV_RAMP_BYPASS=%x",
+		FIELD2VALUE(MAX77759_CHG_CNFG_00_BYPV_RAMP_BYPASS, val));
+	i += SCNPRINTF(&buff[i], len - i, " MODE=%x",
+		FIELD2VALUE(MAX77759_CHG_CNFG_00_MODE, val));
+#else
+	buff[0] = 0;
+#endif
+	return buff;
+}
+
+/*
+ * CHG_CNFG_01,0xBA,0b10011001,0x99
+ * PQEN,LSEL,CHG_RSTRT[1:0],,RECYCLE_EN,FCHGTIME[2:0],
+ */
+#define MAX77759_CHG_CNFG_01	0xBA
+#define MAX77759_CHG_CNFG_01_PQEN	(0x1 << 7)
+#define MAX77759_CHG_CNFG_01_LSEL	(0x1 << 6)
+#define MAX77759_CHG_CNFG_01_RECYCLE_EN	(0x1 << 3)
+
+#define MAX77759_CHG_CNFG_01_PQEN_SHIFT	7
+#define MAX77759_CHG_CNFG_01_PQEN_MASK	(0x1 << 7)
+#define MAX77759_CHG_CNFG_01_PQEN_CLEAR	(~(0x1 << 7))
+#define MAX77759_CHG_CNFG_01_LSEL_SHIFT	6
+#define MAX77759_CHG_CNFG_01_LSEL_MASK	(0x1 << 6)
+#define MAX77759_CHG_CNFG_01_LSEL_CLEAR	(~(0x1 << 6))
+#define MAX77759_CHG_CNFG_01_CHG_RSTRT_SHIFT	4
+#define MAX77759_CHG_CNFG_01_CHG_RSTRT_MASK	(0x3 << 4)
+#define MAX77759_CHG_CNFG_01_CHG_RSTRT_CLEAR	(~(0x3 << 4))
+#define MAX77759_CHG_CNFG_01_RECYCLE_EN_SHIFT	3
+#define MAX77759_CHG_CNFG_01_RECYCLE_EN_MASK	(0x1 << 3)
+#define MAX77759_CHG_CNFG_01_RECYCLE_EN_CLEAR	(~(0x1 << 3))
+#define MAX77759_CHG_CNFG_01_FCHGTIME_SHIFT	0
+#define MAX77759_CHG_CNFG_01_FCHGTIME_MASK	(0x7 << 0)
+#define MAX77759_CHG_CNFG_01_FCHGTIME_CLEAR	(~(0x7 << 0))
+
+MAX77759_BFF(chg_cnfg_01_pqen,7,7)
+MAX77759_BFF(chg_cnfg_01_lsel,6,6)
+MAX77759_BFF(chg_cnfg_01_chg_rstrt,5,4)
+MAX77759_BFF(chg_cnfg_01_recycle_en,3,3)
+MAX77759_BFF(chg_cnfg_01_fchgtime,2,0)
+static inline const char *
+max77759_chg_cnfg_01_cstr(char *buff, size_t len, int val)
+{
+#ifdef SCNPRINTF
+	int i = 0;
+
+	i += SCNPRINTF(&buff[i], len - i, " PQEN=%x",
+		FIELD2VALUE(MAX77759_CHG_CNFG_01_PQEN, val));
+	i += SCNPRINTF(&buff[i], len - i, " LSEL=%x",
+		FIELD2VALUE(MAX77759_CHG_CNFG_01_LSEL, val));
+	i += SCNPRINTF(&buff[i], len - i, " CHG_RSTRT=%x",
+		FIELD2VALUE(MAX77759_CHG_CNFG_01_CHG_RSTRT, val));
+	i += SCNPRINTF(&buff[i], len - i, " RECYCLE_EN=%x",
+		FIELD2VALUE(MAX77759_CHG_CNFG_01_RECYCLE_EN, val));
+	i += SCNPRINTF(&buff[i], len - i, " FCHGTIME=%x",
+		FIELD2VALUE(MAX77759_CHG_CNFG_01_FCHGTIME, val));
+#else
+	buff[0] = 0;
+#endif
+	return buff;
+}
+
+/*
+ * CHG_CNFG_02,0xBB,0b00000111,0x07
+ * SPR_7_6[1:0],,CHGCC[5:0],,,,
+ */
+#define MAX77759_CHG_CNFG_02	0xBB
+
+#define MAX77759_CHG_CNFG_02_SPR_7_6_SHIFT	6
+#define MAX77759_CHG_CNFG_02_SPR_7_6_MASK	(0x3 << 6)
+#define MAX77759_CHG_CNFG_02_SPR_7_6_CLEAR	(~(0x3 << 6))
+#define MAX77759_CHG_CNFG_02_CHGCC_SHIFT	0
+#define MAX77759_CHG_CNFG_02_CHGCC_MASK	(0x3f << 0)
+#define MAX77759_CHG_CNFG_02_CHGCC_CLEAR	(~(0x3f << 0))
+
+MAX77759_BFF(chg_cnfg_02_spr_7_6,7,6)
+MAX77759_BFF(chg_cnfg_02_chgcc,5,0)
+static inline const char *
+max77759_chg_cnfg_02_cstr(char *buff, size_t len, int val)
+{
+#ifdef SCNPRINTF
+	int i = 0;
+
+	i += SCNPRINTF(&buff[i], len - i, " SPR_7_6=%x",
+		FIELD2VALUE(MAX77759_CHG_CNFG_02_SPR_7_6, val));
+	i += SCNPRINTF(&buff[i], len - i, " CHGCC=%x",
+		FIELD2VALUE(MAX77759_CHG_CNFG_02_CHGCC, val));
+#else
+	buff[0] = 0;
+#endif
+	return buff;
+}
+
+/*
+ * CHG_CNFG_03,0xBC,0b10011001,0x99
+ * SYS_TRACK_DIS,AUTO_FSHIP_MODE_EN,TO_TIME[2:0],,,TO_ITH[2:0],
+ */
+#define MAX77759_CHG_CNFG_03	0xBC
+#define MAX77759_CHG_CNFG_03_SYS_TRACK_DIS	(0x1 << 7)
+#define MAX77759_CHG_CNFG_03_AUTO_FSHIP_MODE_EN	(0x1 << 6)
+
+#define MAX77759_CHG_CNFG_03_SYS_TRACK_DIS_SHIFT	7
+#define MAX77759_CHG_CNFG_03_SYS_TRACK_DIS_MASK	(0x1 << 7)
+#define MAX77759_CHG_CNFG_03_SYS_TRACK_DIS_CLEAR	(~(0x1 << 7))
+#define MAX77759_CHG_CNFG_03_AUTO_FSHIP_MODE_EN_SHIFT	6
+#define MAX77759_CHG_CNFG_03_AUTO_FSHIP_MODE_EN_MASK	(0x1 << 6)
+#define MAX77759_CHG_CNFG_03_AUTO_FSHIP_MODE_EN_CLEAR	(~(0x1 << 6))
+#define MAX77759_CHG_CNFG_03_TO_TIME_SHIFT	3
+#define MAX77759_CHG_CNFG_03_TO_TIME_MASK	(0x7 << 3)
+#define MAX77759_CHG_CNFG_03_TO_TIME_CLEAR	(~(0x7 << 3))
+#define MAX77759_CHG_CNFG_03_TO_ITH_SHIFT	0
+#define MAX77759_CHG_CNFG_03_TO_ITH_MASK	(0x7 << 0)
+#define MAX77759_CHG_CNFG_03_TO_ITH_CLEAR	(~(0x7 << 0))
+
+MAX77759_BFF(chg_cnfg_03_sys_track_dis,7,7)
+MAX77759_BFF(chg_cnfg_03_auto_fship_mode_en,6,6)
+MAX77759_BFF(chg_cnfg_03_to_time,5,3)
+MAX77759_BFF(chg_cnfg_03_to_ith,2,0)
+static inline const char *
+max77759_chg_cnfg_03_cstr(char *buff, size_t len, int val)
+{
+#ifdef SCNPRINTF
+	int i = 0;
+
+	i += SCNPRINTF(&buff[i], len - i, " SYS_TRACK_DIS=%x",
+		FIELD2VALUE(MAX77759_CHG_CNFG_03_SYS_TRACK_DIS, val));
+	i += SCNPRINTF(&buff[i], len - i, " AUTO_FSHIP_MODE_EN=%x",
+		FIELD2VALUE(MAX77759_CHG_CNFG_03_AUTO_FSHIP_MODE_EN, val));
+	i += SCNPRINTF(&buff[i], len - i, " TO_TIME=%x",
+		FIELD2VALUE(MAX77759_CHG_CNFG_03_TO_TIME, val));
+	i += SCNPRINTF(&buff[i], len - i, " TO_ITH=%x",
+		FIELD2VALUE(MAX77759_CHG_CNFG_03_TO_ITH, val));
+#else
+	buff[0] = 0;
+#endif
+	return buff;
+}
+
+/*
+ * CHG_CNFG_04,0xBD,0b00010100,0x14
+ * SPR_7_6[1:0],,CHG_CV_PRM[5:0],,,,
+ */
+#define MAX77759_CHG_CNFG_04	0xBD
+
+#define MAX77759_CHG_CNFG_04_SPR_7_6_SHIFT	6
+#define MAX77759_CHG_CNFG_04_SPR_7_6_MASK	(0x3 << 6)
+#define MAX77759_CHG_CNFG_04_SPR_7_6_CLEAR	(~(0x3 << 6))
+#define MAX77759_CHG_CNFG_04_CHG_CV_PRM_SHIFT	0
+#define MAX77759_CHG_CNFG_04_CHG_CV_PRM_MASK	(0x3f << 0)
+#define MAX77759_CHG_CNFG_04_CHG_CV_PRM_CLEAR	(~(0x3f << 0))
+
+MAX77759_BFF(chg_cnfg_04_spr_7_6,7,6)
+MAX77759_BFF(chg_cnfg_04_chg_cv_prm,5,0)
+static inline const char *
+max77759_chg_cnfg_04_cstr(char *buff, size_t len, int val)
+{
+#ifdef SCNPRINTF
+	int i = 0;
+
+	i += SCNPRINTF(&buff[i], len - i, " SPR_7_6=%x",
+		FIELD2VALUE(MAX77759_CHG_CNFG_04_SPR_7_6, val));
+	i += SCNPRINTF(&buff[i], len - i, " CHG_CV_PRM=%x",
+		FIELD2VALUE(MAX77759_CHG_CNFG_04_CHG_CV_PRM, val));
+#else
+	buff[0] = 0;
+#endif
+	return buff;
+}
+
+/*
+ * CHG_CNFG_05,0xBE,0b00110110,0x36
+ * UNO_ILIM[3:0],,,,OTG_ILIM[3:0],,
+ */
+#define MAX77759_CHG_CNFG_05	0xBE
+
+#define MAX77759_CHG_CNFG_05_UNO_ILIM_SHIFT	4
+#define MAX77759_CHG_CNFG_05_UNO_ILIM_MASK	(0xf << 4)
+#define MAX77759_CHG_CNFG_05_UNO_ILIM_CLEAR	(~(0xf << 4))
+#define MAX77759_CHG_CNFG_05_OTG_ILIM_SHIFT	0
+#define MAX77759_CHG_CNFG_05_OTG_ILIM_MASK	(0xf << 0)
+#define MAX77759_CHG_CNFG_05_OTG_ILIM_CLEAR	(~(0xf << 0))
+
+MAX77759_BFF(chg_cnfg_05_uno_ilim,7,4)
+MAX77759_BFF(chg_cnfg_05_otg_ilim,3,0)
+static inline const char *
+max77759_chg_cnfg_05_cstr(char *buff, size_t len, int val)
+{
+#ifdef SCNPRINTF
+	int i = 0;
+
+	i += SCNPRINTF(&buff[i], len - i, " UNO_ILIM=%x",
+		FIELD2VALUE(MAX77759_CHG_CNFG_05_UNO_ILIM, val));
+	i += SCNPRINTF(&buff[i], len - i, " OTG_ILIM=%x",
+		FIELD2VALUE(MAX77759_CHG_CNFG_05_OTG_ILIM, val));
+#else
+	buff[0] = 0;
+#endif
+	return buff;
+}
+
+/*
+ * CHG_CNFG_06,0xBF,0b00000000,0x00
+ * SPR_7_4[3:0],,,,CHGPROT[1:0],,SPR_1_0[1:0]
+ */
+#define MAX77759_CHG_CNFG_06	0xBF
+
+#define MAX77759_CHG_CNFG_06_SPR_7_4_SHIFT	4
+#define MAX77759_CHG_CNFG_06_SPR_7_4_MASK	(0xf << 4)
+#define MAX77759_CHG_CNFG_06_SPR_7_4_CLEAR	(~(0xf << 4))
+#define MAX77759_CHG_CNFG_06_CHGPROT_SHIFT	2
+#define MAX77759_CHG_CNFG_06_CHGPROT_MASK	(0x3 << 2)
+#define MAX77759_CHG_CNFG_06_CHGPROT_CLEAR	(~(0x3 << 2))
+#define MAX77759_CHG_CNFG_06_SPR_1_0_SHIFT	0
+#define MAX77759_CHG_CNFG_06_SPR_1_0_MASK	(0x3 << 0)
+#define MAX77759_CHG_CNFG_06_SPR_1_0_CLEAR	(~(0x3 << 0))
+
+MAX77759_BFF(chg_cnfg_06_spr_7_4,7,4)
+MAX77759_BFF(chg_cnfg_06_chgprot,3,2)
+MAX77759_BFF(chg_cnfg_06_spr_1_0,1,0)
+static inline const char *
+max77759_chg_cnfg_06_cstr(char *buff, size_t len, int val)
+{
+#ifdef SCNPRINTF
+	int i = 0;
+
+	i += SCNPRINTF(&buff[i], len - i, " SPR_7_4=%x",
+		FIELD2VALUE(MAX77759_CHG_CNFG_06_SPR_7_4, val));
+	i += SCNPRINTF(&buff[i], len - i, " CHGPROT=%x",
+		FIELD2VALUE(MAX77759_CHG_CNFG_06_CHGPROT, val));
+	i += SCNPRINTF(&buff[i], len - i, " SPR_1_0=%x",
+		FIELD2VALUE(MAX77759_CHG_CNFG_06_SPR_1_0, val));
+#else
+	buff[0] = 0;
+#endif
+	return buff;
+}
+
+/*
+ * CHG_CNFG_07,0xC0,0b00110000,0x30
+ * WD_QBATOFF,REGTEMP[3:0],,,,SPR_2,FGSRC
+ */
+#define MAX77759_CHG_CNFG_07	0xC0
+#define MAX77759_CHG_CNFG_07_WD_QBATOFF	(0x1 << 7)
+#define MAX77759_CHG_CNFG_07_SPR_2	(0x1 << 2)
+#define MAX77759_CHG_CNFG_07_FGSRC	(0x1 << 1)
+#define MAX77759_CHG_CNFG_07_FSHIP_MODE	(0x1 << 0)
+
+#define MAX77759_CHG_CNFG_07_WD_QBATOFF_SHIFT	7
+#define MAX77759_CHG_CNFG_07_WD_QBATOFF_MASK	(0x1 << 7)
+#define MAX77759_CHG_CNFG_07_WD_QBATOFF_CLEAR	(~(0x1 << 7))
+#define MAX77759_CHG_CNFG_07_REGTEMP_SHIFT	3
+#define MAX77759_CHG_CNFG_07_REGTEMP_MASK	(0xf << 3)
+#define MAX77759_CHG_CNFG_07_REGTEMP_CLEAR	(~(0xf << 3))
+#define MAX77759_CHG_CNFG_07_SPR_2_SHIFT	2
+#define MAX77759_CHG_CNFG_07_SPR_2_MASK	(0x1 << 2)
+#define MAX77759_CHG_CNFG_07_SPR_2_CLEAR	(~(0x1 << 2))
+#define MAX77759_CHG_CNFG_07_FGSRC_SHIFT	1
+#define MAX77759_CHG_CNFG_07_FGSRC_MASK	(0x1 << 1)
+#define MAX77759_CHG_CNFG_07_FGSRC_CLEAR	(~(0x1 << 1))
+#define MAX77759_CHG_CNFG_07_FSHIP_MODE_SHIFT	0
+#define MAX77759_CHG_CNFG_07_FSHIP_MODE_MASK	(0x1 << 0)
+#define MAX77759_CHG_CNFG_07_FSHIP_MODE_CLEAR	(~(0x1 << 0))
+
+MAX77759_BFF(chg_cnfg_07_wd_qbatoff,7,7)
+MAX77759_BFF(chg_cnfg_07_regtemp,6,3)
+MAX77759_BFF(chg_cnfg_07_spr_2,2,2)
+MAX77759_BFF(chg_cnfg_07_fgsrc,1,1)
+MAX77759_BFF(chg_cnfg_07_fship_mode,0,0)
+static inline const char *
+max77759_chg_cnfg_07_cstr(char *buff, size_t len, int val)
+{
+#ifdef SCNPRINTF
+	int i = 0;
+
+	i += SCNPRINTF(&buff[i], len - i, " WD_QBATOFF=%x",
+		FIELD2VALUE(MAX77759_CHG_CNFG_07_WD_QBATOFF, val));
+	i += SCNPRINTF(&buff[i], len - i, " REGTEMP=%x",
+		FIELD2VALUE(MAX77759_CHG_CNFG_07_REGTEMP, val));
+	i += SCNPRINTF(&buff[i], len - i, " SPR_2=%x",
+		FIELD2VALUE(MAX77759_CHG_CNFG_07_SPR_2, val));
+	i += SCNPRINTF(&buff[i], len - i, " FGSRC=%x",
+		FIELD2VALUE(MAX77759_CHG_CNFG_07_FGSRC, val));
+	i += SCNPRINTF(&buff[i], len - i, " FSHIP_MODE=%x",
+		FIELD2VALUE(MAX77759_CHG_CNFG_07_FSHIP_MODE, val));
+#else
+	buff[0] = 0;
+#endif
+	return buff;
+}
+
+/*
+ * CHG_CNFG_08,0xC1,0b00000101,0x05
+ * SPR_7,VCHGCV_WARM,ICHGCC_WARM,VCHGCV_COOL,ICHGCC_COOL,JEITA_EN,FSW[1:0]
+ */
+#define MAX77759_CHG_CNFG_08	0xC1
+#define MAX77759_CHG_CNFG_08_SPR_7	(0x1 << 7)
+#define MAX77759_CHG_CNFG_08_VCHGCV_WARM	(0x1 << 6)
+#define MAX77759_CHG_CNFG_08_ICHGCC_WARM	(0x1 << 5)
+#define MAX77759_CHG_CNFG_08_VCHGCV_COOL	(0x1 << 4)
+#define MAX77759_CHG_CNFG_08_ICHGCC_COOL	(0x1 << 3)
+#define MAX77759_CHG_CNFG_08_JEITA_EN	(0x1 << 2)
+
+#define MAX77759_CHG_CNFG_08_SPR_7_SHIFT	7
+#define MAX77759_CHG_CNFG_08_SPR_7_MASK	(0x1 << 7)
+#define MAX77759_CHG_CNFG_08_SPR_7_CLEAR	(~(0x1 << 7))
+#define MAX77759_CHG_CNFG_08_VCHGCV_WARM_SHIFT	6
+#define MAX77759_CHG_CNFG_08_VCHGCV_WARM_MASK	(0x1 << 6)
+#define MAX77759_CHG_CNFG_08_VCHGCV_WARM_CLEAR	(~(0x1 << 6))
+#define MAX77759_CHG_CNFG_08_ICHGCC_WARM_SHIFT	5
+#define MAX77759_CHG_CNFG_08_ICHGCC_WARM_MASK	(0x1 << 5)
+#define MAX77759_CHG_CNFG_08_ICHGCC_WARM_CLEAR	(~(0x1 << 5))
+#define MAX77759_CHG_CNFG_08_VCHGCV_COOL_SHIFT	4
+#define MAX77759_CHG_CNFG_08_VCHGCV_COOL_MASK	(0x1 << 4)
+#define MAX77759_CHG_CNFG_08_VCHGCV_COOL_CLEAR	(~(0x1 << 4))
+#define MAX77759_CHG_CNFG_08_ICHGCC_COOL_SHIFT	3
+#define MAX77759_CHG_CNFG_08_ICHGCC_COOL_MASK	(0x1 << 3)
+#define MAX77759_CHG_CNFG_08_ICHGCC_COOL_CLEAR	(~(0x1 << 3))
+#define MAX77759_CHG_CNFG_08_JEITA_EN_SHIFT	2
+#define MAX77759_CHG_CNFG_08_JEITA_EN_MASK	(0x1 << 2)
+#define MAX77759_CHG_CNFG_08_JEITA_EN_CLEAR	(~(0x1 << 2))
+#define MAX77759_CHG_CNFG_08_FSW_SHIFT	0
+#define MAX77759_CHG_CNFG_08_FSW_MASK	(0x3 << 0)
+#define MAX77759_CHG_CNFG_08_FSW_CLEAR	(~(0x3 << 0))
+
+MAX77759_BFF(chg_cnfg_08_spr_7,7,7)
+MAX77759_BFF(chg_cnfg_08_vchgcv_warm,6,6)
+MAX77759_BFF(chg_cnfg_08_ichgcc_warm,5,5)
+MAX77759_BFF(chg_cnfg_08_vchgcv_cool,4,4)
+MAX77759_BFF(chg_cnfg_08_ichgcc_cool,3,3)
+MAX77759_BFF(chg_cnfg_08_jeita_en,2,2)
+MAX77759_BFF(chg_cnfg_08_fsw,1,0)
+static inline const char *
+max77759_chg_cnfg_08_cstr(char *buff, size_t len, int val)
+{
+#ifdef SCNPRINTF
+	int i = 0;
+
+	i += SCNPRINTF(&buff[i], len - i, " SPR_7=%x",
+		FIELD2VALUE(MAX77759_CHG_CNFG_08_SPR_7, val));
+	i += SCNPRINTF(&buff[i], len - i, " VCHGCV_WARM=%x",
+		FIELD2VALUE(MAX77759_CHG_CNFG_08_VCHGCV_WARM, val));
+	i += SCNPRINTF(&buff[i], len - i, " ICHGCC_WARM=%x",
+		FIELD2VALUE(MAX77759_CHG_CNFG_08_ICHGCC_WARM, val));
+	i += SCNPRINTF(&buff[i], len - i, " VCHGCV_COOL=%x",
+		FIELD2VALUE(MAX77759_CHG_CNFG_08_VCHGCV_COOL, val));
+	i += SCNPRINTF(&buff[i], len - i, " ICHGCC_COOL=%x",
+		FIELD2VALUE(MAX77759_CHG_CNFG_08_ICHGCC_COOL, val));
+	i += SCNPRINTF(&buff[i], len - i, " JEITA_EN=%x",
+		FIELD2VALUE(MAX77759_CHG_CNFG_08_JEITA_EN, val));
+	i += SCNPRINTF(&buff[i], len - i, " FSW=%x",
+		FIELD2VALUE(MAX77759_CHG_CNFG_08_FSW, val));
+#else
+	buff[0] = 0;
+#endif
+	return buff;
+}
+
+/*
+ * CHG_CNFG_09,0xC2,0b00010011,0x13
+ * NO_AUTOIBUS,CHGIN_ILIM[6:0],,,,,
+ */
+#define MAX77759_CHG_CNFG_09	0xC2
+#define MAX77759_CHG_CNFG_09_NO_AUTOIBUS	(0x1 << 7)
+
+#define MAX77759_CHG_CNFG_09_NO_AUTOIBUS_SHIFT	7
+#define MAX77759_CHG_CNFG_09_NO_AUTOIBUS_MASK	(0x1 << 7)
+#define MAX77759_CHG_CNFG_09_NO_AUTOIBUS_CLEAR	(~(0x1 << 7))
+#define MAX77759_CHG_CNFG_09_CHGIN_ILIM_SHIFT	0
+#define MAX77759_CHG_CNFG_09_CHGIN_ILIM_MASK	(0x7f << 0)
+#define MAX77759_CHG_CNFG_09_CHGIN_ILIM_CLEAR	(~(0x7f << 0))
+
+MAX77759_BFF(chg_cnfg_09_no_autoibus,7,7)
+MAX77759_BFF(chg_cnfg_09_chgin_ilim,6,0)
+static inline const char *
+max77759_chg_cnfg_09_cstr(char *buff, size_t len, int val)
+{
+#ifdef SCNPRINTF
+	int i = 0;
+
+	i += SCNPRINTF(&buff[i], len - i, " NO_AUTOIBUS=%x",
+		FIELD2VALUE(MAX77759_CHG_CNFG_09_NO_AUTOIBUS, val));
+	i += SCNPRINTF(&buff[i], len - i, " CHGIN_ILIM=%x",
+		FIELD2VALUE(MAX77759_CHG_CNFG_09_CHGIN_ILIM, val));
+#else
+	buff[0] = 0;
+#endif
+	return buff;
+}
+
+/*
+ * CHG_CNFG_10,0xC3,0b00001111,0x0f
+ * INPUT_MASK_CLR,SPR_6,WCIN_ILIM[5:0],,,,
+ */
+#define MAX77759_CHG_CNFG_10	0xC3
+#define MAX77759_CHG_CNFG_10_INPUT_MASK_CLR	(0x1 << 7)
+#define MAX77759_CHG_CNFG_10_SPR_6	(0x1 << 6)
+
+#define MAX77759_CHG_CNFG_10_INPUT_MASK_CLR_SHIFT	7
+#define MAX77759_CHG_CNFG_10_INPUT_MASK_CLR_MASK	(0x1 << 7)
+#define MAX77759_CHG_CNFG_10_INPUT_MASK_CLR_CLEAR	(~(0x1 << 7))
+#define MAX77759_CHG_CNFG_10_SPR_6_SHIFT	6
+#define MAX77759_CHG_CNFG_10_SPR_6_MASK	(0x1 << 6)
+#define MAX77759_CHG_CNFG_10_SPR_6_CLEAR	(~(0x1 << 6))
+#define MAX77759_CHG_CNFG_10_WCIN_ILIM_SHIFT	0
+#define MAX77759_CHG_CNFG_10_WCIN_ILIM_MASK	(0x3f << 0)
+#define MAX77759_CHG_CNFG_10_WCIN_ILIM_CLEAR	(~(0x3f << 0))
+
+MAX77759_BFF(chg_cnfg_10_input_mask_clr,7,7)
+MAX77759_BFF(chg_cnfg_10_spr_6,6,6)
+MAX77759_BFF(chg_cnfg_10_wcin_ilim,5,0)
+static inline const char *
+max77759_chg_cnfg_10_cstr(char *buff, size_t len, int val)
+{
+#ifdef SCNPRINTF
+	int i = 0;
+
+	i += SCNPRINTF(&buff[i], len - i, " INPUT_MASK_CLR=%x",
+		FIELD2VALUE(MAX77759_CHG_CNFG_10_INPUT_MASK_CLR, val));
+	i += SCNPRINTF(&buff[i], len - i, " SPR_6=%x",
+		FIELD2VALUE(MAX77759_CHG_CNFG_10_SPR_6, val));
+	i += SCNPRINTF(&buff[i], len - i, " WCIN_ILIM=%x",
+		FIELD2VALUE(MAX77759_CHG_CNFG_10_WCIN_ILIM, val));
+#else
+	buff[0] = 0;
+#endif
+	return buff;
+}
+
+/*
+ * CHG_CNFG_11,0xC4,0b00000000,0x00
+ * VBYPSET[7:0],,,,,,
+ */
+#define MAX77759_CHG_CNFG_11	0xC4
+
+/*
+ * CHG_CNFG_12,0xC5,0b01101010,0x6a
+ * CHG_EN,WCINSEL,CHGINSEL,VCHGIN_REG[1:0],,WCIN_REG[1:0],
+ */
+#define MAX77759_CHG_CNFG_12	0xC5
+#define MAX77759_CHG_CNFG_12_CHG_EN	(0x1 << 7)
+#define MAX77759_CHG_CNFG_12_WCINSEL	(0x1 << 6)
+#define MAX77759_CHG_CNFG_12_CHGINSEL	(0x1 << 5)
+#define MAX77759_CHG_CNFG_12_DISKIP	(0x1 << 0)
+
+#define MAX77759_CHG_CNFG_12_CHG_EN_SHIFT	7
+#define MAX77759_CHG_CNFG_12_CHG_EN_MASK	(0x1 << 7)
+#define MAX77759_CHG_CNFG_12_CHG_EN_CLEAR	(~(0x1 << 7))
+#define MAX77759_CHG_CNFG_12_WCINSEL_SHIFT	6
+#define MAX77759_CHG_CNFG_12_WCINSEL_MASK	(0x1 << 6)
+#define MAX77759_CHG_CNFG_12_WCINSEL_CLEAR	(~(0x1 << 6))
+#define MAX77759_CHG_CNFG_12_CHGINSEL_SHIFT	5
+#define MAX77759_CHG_CNFG_12_CHGINSEL_MASK	(0x1 << 5)
+#define MAX77759_CHG_CNFG_12_CHGINSEL_CLEAR	(~(0x1 << 5))
+#define MAX77759_CHG_CNFG_12_VCHGIN_REG_SHIFT	3
+#define MAX77759_CHG_CNFG_12_VCHGIN_REG_MASK	(0x3 << 3)
+#define MAX77759_CHG_CNFG_12_VCHGIN_REG_CLEAR	(~(0x3 << 3))
+#define MAX77759_CHG_CNFG_12_WCIN_REG_SHIFT	1
+#define MAX77759_CHG_CNFG_12_WCIN_REG_MASK	(0x3 << 1)
+#define MAX77759_CHG_CNFG_12_WCIN_REG_CLEAR	(~(0x3 << 1))
+#define MAX77759_CHG_CNFG_12_DISKIP_SHIFT	0
+#define MAX77759_CHG_CNFG_12_DISKIP_MASK	(0x1 << 0)
+#define MAX77759_CHG_CNFG_12_DISKIP_CLEAR	(~(0x1 << 0))
+
+MAX77759_BFF(chg_cnfg_12_chg_en,7,7)
+MAX77759_BFF(chg_cnfg_12_wcinsel,6,6)
+MAX77759_BFF(chg_cnfg_12_chginsel,5,5)
+MAX77759_BFF(chg_cnfg_12_vchgin_reg,4,3)
+MAX77759_BFF(chg_cnfg_12_wcin_reg,2,1)
+MAX77759_BFF(chg_cnfg_12_diskip,0,0)
+static inline const char *
+max77759_chg_cnfg_12_cstr(char *buff, size_t len, int val)
+{
+#ifdef SCNPRINTF
+	int i = 0;
+
+	i += SCNPRINTF(&buff[i], len - i, " CHG_EN=%x",
+		FIELD2VALUE(MAX77759_CHG_CNFG_12_CHG_EN, val));
+	i += SCNPRINTF(&buff[i], len - i, " WCINSEL=%x",
+		FIELD2VALUE(MAX77759_CHG_CNFG_12_WCINSEL, val));
+	i += SCNPRINTF(&buff[i], len - i, " CHGINSEL=%x",
+		FIELD2VALUE(MAX77759_CHG_CNFG_12_CHGINSEL, val));
+	i += SCNPRINTF(&buff[i], len - i, " VCHGIN_REG=%x",
+		FIELD2VALUE(MAX77759_CHG_CNFG_12_VCHGIN_REG, val));
+	i += SCNPRINTF(&buff[i], len - i, " WCIN_REG=%x",
+		FIELD2VALUE(MAX77759_CHG_CNFG_12_WCIN_REG, val));
+	i += SCNPRINTF(&buff[i], len - i, " DISKIP=%x",
+		FIELD2VALUE(MAX77759_CHG_CNFG_12_DISKIP, val));
+#else
+	buff[0] = 0;
+#endif
+	return buff;
+}
+
+/*
+ * CHG_CNFG_13,0xC6,0b00000011,0x03
+ * EN_FG_ILIM_CTRL,THM_CHR_RSTART,THM_CC_HZ,THM_BUCK_DIS,THM2_HW_CTRL,USB_TEMP[2:0],
+ */
+#define MAX77759_CHG_CNFG_13	0xC6
+#define MAX77759_CHG_CNFG_13_EN_FG_ILIM_CTRL	(0x1 << 7)
+#define MAX77759_CHG_CNFG_13_THM_CHR_RSTART	(0x1 << 6)
+#define MAX77759_CHG_CNFG_13_THM_CC_HZ	(0x1 << 5)
+#define MAX77759_CHG_CNFG_13_THM_BUCK_DIS	(0x1 << 4)
+#define MAX77759_CHG_CNFG_13_THM2_HW_CTRL	(0x1 << 3)
+
+#define MAX77759_CHG_CNFG_13_EN_FG_ILIM_CTRL_SHIFT	7
+#define MAX77759_CHG_CNFG_13_EN_FG_ILIM_CTRL_MASK	(0x1 << 7)
+#define MAX77759_CHG_CNFG_13_EN_FG_ILIM_CTRL_CLEAR	(~(0x1 << 7))
+#define MAX77759_CHG_CNFG_13_THM_CHR_RSTART_SHIFT	6
+#define MAX77759_CHG_CNFG_13_THM_CHR_RSTART_MASK	(0x1 << 6)
+#define MAX77759_CHG_CNFG_13_THM_CHR_RSTART_CLEAR	(~(0x1 << 6))
+#define MAX77759_CHG_CNFG_13_THM_CC_HZ_SHIFT	5
+#define MAX77759_CHG_CNFG_13_THM_CC_HZ_MASK	(0x1 << 5)
+#define MAX77759_CHG_CNFG_13_THM_CC_HZ_CLEAR	(~(0x1 << 5))
+#define MAX77759_CHG_CNFG_13_THM_BUCK_DIS_SHIFT	4
+#define MAX77759_CHG_CNFG_13_THM_BUCK_DIS_MASK	(0x1 << 4)
+#define MAX77759_CHG_CNFG_13_THM_BUCK_DIS_CLEAR	(~(0x1 << 4))
+#define MAX77759_CHG_CNFG_13_THM2_HW_CTRL_SHIFT	3
+#define MAX77759_CHG_CNFG_13_THM2_HW_CTRL_MASK	(0x1 << 3)
+#define MAX77759_CHG_CNFG_13_THM2_HW_CTRL_CLEAR	(~(0x1 << 3))
+#define MAX77759_CHG_CNFG_13_USB_TEMP_SHIFT	0
+#define MAX77759_CHG_CNFG_13_USB_TEMP_MASK	(0x7 << 0)
+#define MAX77759_CHG_CNFG_13_USB_TEMP_CLEAR	(~(0x7 << 0))
+
+MAX77759_BFF(chg_cnfg_13_en_fg_ilim_ctrl,7,7)
+MAX77759_BFF(chg_cnfg_13_thm_chr_rstart,6,6)
+MAX77759_BFF(chg_cnfg_13_thm_cc_hz,5,5)
+MAX77759_BFF(chg_cnfg_13_thm_buck_dis,4,4)
+MAX77759_BFF(chg_cnfg_13_thm2_hw_ctrl,3,3)
+MAX77759_BFF(chg_cnfg_13_usb_temp,2,0)
+static inline const char *
+max77759_chg_cnfg_13_cstr(char *buff, size_t len, int val)
+{
+#ifdef SCNPRINTF
+	int i = 0;
+
+	i += SCNPRINTF(&buff[i], len - i, " EN_FG_ILIM_CTRL=%x",
+		FIELD2VALUE(MAX77759_CHG_CNFG_13_EN_FG_ILIM_CTRL, val));
+	i += SCNPRINTF(&buff[i], len - i, " THM_CHR_RSTART=%x",
+		FIELD2VALUE(MAX77759_CHG_CNFG_13_THM_CHR_RSTART, val));
+	i += SCNPRINTF(&buff[i], len - i, " THM_CC_HZ=%x",
+		FIELD2VALUE(MAX77759_CHG_CNFG_13_THM_CC_HZ, val));
+	i += SCNPRINTF(&buff[i], len - i, " THM_BUCK_DIS=%x",
+		FIELD2VALUE(MAX77759_CHG_CNFG_13_THM_BUCK_DIS, val));
+	i += SCNPRINTF(&buff[i], len - i, " THM2_HW_CTRL=%x",
+		FIELD2VALUE(MAX77759_CHG_CNFG_13_THM2_HW_CTRL, val));
+	i += SCNPRINTF(&buff[i], len - i, " USB_TEMP=%x",
+		FIELD2VALUE(MAX77759_CHG_CNFG_13_USB_TEMP, val));
+#else
+	buff[0] = 0;
+#endif
+	return buff;
+}
+
+/*
+ * CHG_CNFG_14,0xC7,0b00000110,0x06
+ * BAT_OILO_REL[1:0],,BAT_OPEN_TO[1:0],,BAT_OILO[3:0],,
+ */
+#define MAX77759_CHG_CNFG_14	0xC7
+
+#define MAX77759_CHG_CNFG_14_BAT_OILO_REL_SHIFT	6
+#define MAX77759_CHG_CNFG_14_BAT_OILO_REL_MASK	(0x3 << 6)
+#define MAX77759_CHG_CNFG_14_BAT_OILO_REL_CLEAR	(~(0x3 << 6))
+#define MAX77759_CHG_CNFG_14_BAT_OPEN_TO_SHIFT	4
+#define MAX77759_CHG_CNFG_14_BAT_OPEN_TO_MASK	(0x3 << 4)
+#define MAX77759_CHG_CNFG_14_BAT_OPEN_TO_CLEAR	(~(0x3 << 4))
+#define MAX77759_CHG_CNFG_14_BAT_OILO_SHIFT	0
+#define MAX77759_CHG_CNFG_14_BAT_OILO_MASK	(0xf << 0)
+#define MAX77759_CHG_CNFG_14_BAT_OILO_CLEAR	(~(0xf << 0))
+
+MAX77759_BFF(chg_cnfg_14_bat_oilo_rel,7,6)
+MAX77759_BFF(chg_cnfg_14_bat_open_to,5,4)
+MAX77759_BFF(chg_cnfg_14_bat_oilo,3,0)
+static inline const char *
+max77759_chg_cnfg_14_cstr(char *buff, size_t len, int val)
+{
+#ifdef SCNPRINTF
+	int i = 0;
+
+	i += SCNPRINTF(&buff[i], len - i, " BAT_OILO_REL=%x",
+		FIELD2VALUE(MAX77759_CHG_CNFG_14_BAT_OILO_REL, val));
+	i += SCNPRINTF(&buff[i], len - i, " BAT_OPEN_TO=%x",
+		FIELD2VALUE(MAX77759_CHG_CNFG_14_BAT_OPEN_TO, val));
+	i += SCNPRINTF(&buff[i], len - i, " BAT_OILO=%x",
+		FIELD2VALUE(MAX77759_CHG_CNFG_14_BAT_OILO, val));
+#else
+	buff[0] = 0;
+#endif
+	return buff;
+}
+
+/*
+ * CHG_CNFG_15,0xC8,0b00001000,0x08
+ * SYS_UVLO1_REL[1:0],,SYS_UVLO1_HYST[1:0],,SYS_UVLO1[3:0],,
+ */
+#define MAX77759_CHG_CNFG_15	0xC8
+
+#define MAX77759_CHG_CNFG_15_SYS_UVLO1_REL_SHIFT	6
+#define MAX77759_CHG_CNFG_15_SYS_UVLO1_REL_MASK	(0x3 << 6)
+#define MAX77759_CHG_CNFG_15_SYS_UVLO1_REL_CLEAR	(~(0x3 << 6))
+#define MAX77759_CHG_CNFG_15_SYS_UVLO1_HYST_SHIFT	4
+#define MAX77759_CHG_CNFG_15_SYS_UVLO1_HYST_MASK	(0x3 << 4)
+#define MAX77759_CHG_CNFG_15_SYS_UVLO1_HYST_CLEAR	(~(0x3 << 4))
+#define MAX77759_CHG_CNFG_15_SYS_UVLO1_SHIFT	0
+#define MAX77759_CHG_CNFG_15_SYS_UVLO1_MASK	(0xf << 0)
+#define MAX77759_CHG_CNFG_15_SYS_UVLO1_CLEAR	(~(0xf << 0))
+
+MAX77759_BFF(chg_cnfg_15_sys_uvlo1_rel,7,6)
+MAX77759_BFF(chg_cnfg_15_sys_uvlo1_hyst,5,4)
+MAX77759_BFF(chg_cnfg_15_sys_uvlo1,3,0)
+static inline const char *
+max77759_chg_cnfg_15_cstr(char *buff, size_t len, int val)
+{
+#ifdef SCNPRINTF
+	int i = 0;
+
+	i += SCNPRINTF(&buff[i], len - i, " SYS_UVLO1_REL=%x",
+		FIELD2VALUE(MAX77759_CHG_CNFG_15_SYS_UVLO1_REL, val));
+	i += SCNPRINTF(&buff[i], len - i, " SYS_UVLO1_HYST=%x",
+		FIELD2VALUE(MAX77759_CHG_CNFG_15_SYS_UVLO1_HYST, val));
+	i += SCNPRINTF(&buff[i], len - i, " SYS_UVLO1=%x",
+		FIELD2VALUE(MAX77759_CHG_CNFG_15_SYS_UVLO1, val));
+#else
+	buff[0] = 0;
+#endif
+	return buff;
+}
+
+/*
+ * CHG_CNFG_16,0xC9,0b00000100,0x04
+ * SYS_UVLO2_REL[1:0],,SYS_UVLO2_HYST[1:0],,SYS_UVLO2[3:0],,
+ */
+#define MAX77759_CHG_CNFG_16	0xC9
+
+#define MAX77759_CHG_CNFG_16_SYS_UVLO2_REL_SHIFT	6
+#define MAX77759_CHG_CNFG_16_SYS_UVLO2_REL_MASK	(0x3 << 6)
+#define MAX77759_CHG_CNFG_16_SYS_UVLO2_REL_CLEAR	(~(0x3 << 6))
+#define MAX77759_CHG_CNFG_16_SYS_UVLO2_HYST_SHIFT	4
+#define MAX77759_CHG_CNFG_16_SYS_UVLO2_HYST_MASK	(0x3 << 4)
+#define MAX77759_CHG_CNFG_16_SYS_UVLO2_HYST_CLEAR	(~(0x3 << 4))
+#define MAX77759_CHG_CNFG_16_SYS_UVLO2_SHIFT	0
+#define MAX77759_CHG_CNFG_16_SYS_UVLO2_MASK	(0xf << 0)
+#define MAX77759_CHG_CNFG_16_SYS_UVLO2_CLEAR	(~(0xf << 0))
+
+MAX77759_BFF(chg_cnfg_16_sys_uvlo2_rel,7,6)
+MAX77759_BFF(chg_cnfg_16_sys_uvlo2_hyst,5,4)
+MAX77759_BFF(chg_cnfg_16_sys_uvlo2,3,0)
+static inline const char *
+max77759_chg_cnfg_16_cstr(char *buff, size_t len, int val)
+{
+#ifdef SCNPRINTF
+	int i = 0;
+
+	i += SCNPRINTF(&buff[i], len - i, " SYS_UVLO2_REL=%x",
+		FIELD2VALUE(MAX77759_CHG_CNFG_16_SYS_UVLO2_REL, val));
+	i += SCNPRINTF(&buff[i], len - i, " SYS_UVLO2_HYST=%x",
+		FIELD2VALUE(MAX77759_CHG_CNFG_16_SYS_UVLO2_HYST, val));
+	i += SCNPRINTF(&buff[i], len - i, " SYS_UVLO2=%x",
+		FIELD2VALUE(MAX77759_CHG_CNFG_16_SYS_UVLO2, val));
+#else
+	buff[0] = 0;
+#endif
+	return buff;
+}
+
+/*
+ * CHG_CNFG_17,0xCA,0b01000000,0x40
+ * AICL[1:0],,SPR_5_3[2:0],,,BAT_OILO_DET,SYS_UVLO2_DET
+ */
+#define MAX77759_CHG_CNFG_17	0xCA
+#define MAX77759_CHG_CNFG_17_BAT_OILO_DET	(0x1 << 2)
+#define MAX77759_CHG_CNFG_17_SYS_UVLO2_DET	(0x1 << 1)
+#define MAX77759_CHG_CNFG_17_SYS_UVLO1_DET	(0x1 << 0)
+
+#define MAX77759_CHG_CNFG_17_AICL_SHIFT	6
+#define MAX77759_CHG_CNFG_17_AICL_MASK	(0x3 << 6)
+#define MAX77759_CHG_CNFG_17_AICL_CLEAR	(~(0x3 << 6))
+#define MAX77759_CHG_CNFG_17_SPR_5_3_SHIFT	3
+#define MAX77759_CHG_CNFG_17_SPR_5_3_MASK	(0x7 << 3)
+#define MAX77759_CHG_CNFG_17_SPR_5_3_CLEAR	(~(0x7 << 3))
+#define MAX77759_CHG_CNFG_17_BAT_OILO_DET_SHIFT	2
+#define MAX77759_CHG_CNFG_17_BAT_OILO_DET_MASK	(0x1 << 2)
+#define MAX77759_CHG_CNFG_17_BAT_OILO_DET_CLEAR	(~(0x1 << 2))
+#define MAX77759_CHG_CNFG_17_SYS_UVLO2_DET_SHIFT	1
+#define MAX77759_CHG_CNFG_17_SYS_UVLO2_DET_MASK	(0x1 << 1)
+#define MAX77759_CHG_CNFG_17_SYS_UVLO2_DET_CLEAR	(~(0x1 << 1))
+#define MAX77759_CHG_CNFG_17_SYS_UVLO1_DET_SHIFT	0
+#define MAX77759_CHG_CNFG_17_SYS_UVLO1_DET_MASK	(0x1 << 0)
+#define MAX77759_CHG_CNFG_17_SYS_UVLO1_DET_CLEAR	(~(0x1 << 0))
+
+MAX77759_BFF(chg_cnfg_17_aicl,7,6)
+MAX77759_BFF(chg_cnfg_17_spr_5_3,5,3)
+MAX77759_BFF(chg_cnfg_17_bat_oilo_det,2,2)
+MAX77759_BFF(chg_cnfg_17_sys_uvlo2_det,1,1)
+MAX77759_BFF(chg_cnfg_17_sys_uvlo1_det,0,0)
+static inline const char *
+max77759_chg_cnfg_17_cstr(char *buff, size_t len, int val)
+{
+#ifdef SCNPRINTF
+	int i = 0;
+
+	i += SCNPRINTF(&buff[i], len - i, " AICL=%x",
+		FIELD2VALUE(MAX77759_CHG_CNFG_17_AICL, val));
+	i += SCNPRINTF(&buff[i], len - i, " SPR_5_3=%x",
+		FIELD2VALUE(MAX77759_CHG_CNFG_17_SPR_5_3, val));
+	i += SCNPRINTF(&buff[i], len - i, " BAT_OILO_DET=%x",
+		FIELD2VALUE(MAX77759_CHG_CNFG_17_BAT_OILO_DET, val));
+	i += SCNPRINTF(&buff[i], len - i, " SYS_UVLO2_DET=%x",
+		FIELD2VALUE(MAX77759_CHG_CNFG_17_SYS_UVLO2_DET, val));
+	i += SCNPRINTF(&buff[i], len - i, " SYS_UVLO1_DET=%x",
+		FIELD2VALUE(MAX77759_CHG_CNFG_17_SYS_UVLO1_DET, val));
+#else
+	buff[0] = 0;
+#endif
+	return buff;
+}
+
+/*
+ * CHG_CNFG_18,0xCB,0b11000000,0xc0
+ * VDP1_STP_BST,VDP2_STP_BST,MINVSYS[1:0],,OTG_V_PGM,SPSN_DET_EN,MASTER_DC
+ */
+#define MAX77759_CHG_CNFG_18	0xCB
+#define MAX77759_CHG_CNFG_18_VDP1_STP_BST	(0x1 << 7)
+#define MAX77759_CHG_CNFG_18_VDP2_STP_BST	(0x1 << 6)
+#define MAX77759_CHG_CNFG_18_OTG_V_PGM	(0x1 << 3)
+#define MAX77759_CHG_CNFG_18_SPSN_DET_EN	(0x1 << 2)
+#define MAX77759_CHG_CNFG_18_MASTER_DC	(0x1 << 1)
+#define MAX77759_CHG_CNFG_18_WDTEN	(0x1 << 0)
+
+#define MAX77759_CHG_CNFG_18_VDP1_STP_BST_SHIFT	7
+#define MAX77759_CHG_CNFG_18_VDP1_STP_BST_MASK	(0x1 << 7)
+#define MAX77759_CHG_CNFG_18_VDP1_STP_BST_CLEAR	(~(0x1 << 7))
+#define MAX77759_CHG_CNFG_18_VDP2_STP_BST_SHIFT	6
+#define MAX77759_CHG_CNFG_18_VDP2_STP_BST_MASK	(0x1 << 6)
+#define MAX77759_CHG_CNFG_18_VDP2_STP_BST_CLEAR	(~(0x1 << 6))
+#define MAX77759_CHG_CNFG_18_MINVSYS_SHIFT	4
+#define MAX77759_CHG_CNFG_18_MINVSYS_MASK	(0x3 << 4)
+#define MAX77759_CHG_CNFG_18_MINVSYS_CLEAR	(~(0x3 << 4))
+#define MAX77759_CHG_CNFG_18_OTG_V_PGM_SHIFT	3
+#define MAX77759_CHG_CNFG_18_OTG_V_PGM_MASK	(0x1 << 3)
+#define MAX77759_CHG_CNFG_18_OTG_V_PGM_CLEAR	(~(0x1 << 3))
+#define MAX77759_CHG_CNFG_18_SPSN_DET_EN_SHIFT	2
+#define MAX77759_CHG_CNFG_18_SPSN_DET_EN_MASK	(0x1 << 2)
+#define MAX77759_CHG_CNFG_18_SPSN_DET_EN_CLEAR	(~(0x1 << 2))
+#define MAX77759_CHG_CNFG_18_MASTER_DC_SHIFT	1
+#define MAX77759_CHG_CNFG_18_MASTER_DC_MASK	(0x1 << 1)
+#define MAX77759_CHG_CNFG_18_MASTER_DC_CLEAR	(~(0x1 << 1))
+#define MAX77759_CHG_CNFG_18_WDTEN_SHIFT	0
+#define MAX77759_CHG_CNFG_18_WDTEN_MASK	(0x1 << 0)
+#define MAX77759_CHG_CNFG_18_WDTEN_CLEAR	(~(0x1 << 0))
+
+MAX77759_BFF(chg_cnfg_18_vdp1_stp_bst,7,7)
+MAX77759_BFF(chg_cnfg_18_vdp2_stp_bst,6,6)
+MAX77759_BFF(chg_cnfg_18_minvsys,5,4)
+MAX77759_BFF(chg_cnfg_18_otg_v_pgm,3,3)
+MAX77759_BFF(chg_cnfg_18_spsn_det_en,2,2)
+MAX77759_BFF(chg_cnfg_18_master_dc,1,1)
+MAX77759_BFF(chg_cnfg_18_wdten,0,0)
+static inline const char *
+max77759_chg_cnfg_18_cstr(char *buff, size_t len, int val)
+{
+#ifdef SCNPRINTF
+	int i = 0;
+
+	i += SCNPRINTF(&buff[i], len - i, " VDP1_STP_BST=%x",
+		FIELD2VALUE(MAX77759_CHG_CNFG_18_VDP1_STP_BST, val));
+	i += SCNPRINTF(&buff[i], len - i, " VDP2_STP_BST=%x",
+		FIELD2VALUE(MAX77759_CHG_CNFG_18_VDP2_STP_BST, val));
+	i += SCNPRINTF(&buff[i], len - i, " MINVSYS=%x",
+		FIELD2VALUE(MAX77759_CHG_CNFG_18_MINVSYS, val));
+	i += SCNPRINTF(&buff[i], len - i, " OTG_V_PGM=%x",
+		FIELD2VALUE(MAX77759_CHG_CNFG_18_OTG_V_PGM, val));
+	i += SCNPRINTF(&buff[i], len - i, " SPSN_DET_EN=%x",
+		FIELD2VALUE(MAX77759_CHG_CNFG_18_SPSN_DET_EN, val));
+	i += SCNPRINTF(&buff[i], len - i, " MASTER_DC=%x",
+		FIELD2VALUE(MAX77759_CHG_CNFG_18_MASTER_DC, val));
+	i += SCNPRINTF(&buff[i], len - i, " WDTEN=%x",
+		FIELD2VALUE(MAX77759_CHG_CNFG_18_WDTEN, val));
+#else
+	buff[0] = 0;
+#endif
+	return buff;
+}
+
+/*
+ * CHG_CNFG_19,0xCC,0b00010000,0x10
+ * SPR_7_5[2:0],,,INLIM_CLK[1:0],,DIS_IR_CTRL,SLOWLX[1:0]
+ */
+#define MAX77759_CHG_CNFG_19	0xCC
+
+/* section:  FuelGauge  */
+#define MAX77759_CHG_CNFG_19_DIS_IR_CTRL	(0x1 << 2)
+
+#define MAX77759_CHG_CNFG_19_SPR_7_5_SHIFT	5
+#define MAX77759_CHG_CNFG_19_SPR_7_5_MASK	(0x7 << 5)
+#define MAX77759_CHG_CNFG_19_SPR_7_5_CLEAR	(~(0x7 << 5))
+#define MAX77759_CHG_CNFG_19_INLIM_CLK_SHIFT	3
+#define MAX77759_CHG_CNFG_19_INLIM_CLK_MASK	(0x3 << 3)
+#define MAX77759_CHG_CNFG_19_INLIM_CLK_CLEAR	(~(0x3 << 3))
+#define MAX77759_CHG_CNFG_19_DIS_IR_CTRL_SHIFT	2
+#define MAX77759_CHG_CNFG_19_DIS_IR_CTRL_MASK	(0x1 << 2)
+#define MAX77759_CHG_CNFG_19_DIS_IR_CTRL_CLEAR	(~(0x1 << 2))
+#define MAX77759_CHG_CNFG_19_SLOWLX_SHIFT	0
+#define MAX77759_CHG_CNFG_19_SLOWLX_MASK	(0x3 << 0)
+#define MAX77759_CHG_CNFG_19_SLOWLX_CLEAR	(~(0x3 << 0))
+
+MAX77759_BFF(chg_cnfg_19_spr_7_5,7,5)
+MAX77759_BFF(chg_cnfg_19_inlim_clk,4,3)
+MAX77759_BFF(chg_cnfg_19_dis_ir_ctrl,2,2)
+MAX77759_BFF(chg_cnfg_19_slowlx,1,0)
+static inline const char *
+max77759_chg_cnfg_19_cstr(char *buff, size_t len, int val)
+{
+#ifdef SCNPRINTF
+	int i = 0;
+
+	i += SCNPRINTF(&buff[i], len - i, " SPR_7_5=%x",
+		FIELD2VALUE(MAX77759_CHG_CNFG_19_SPR_7_5, val));
+	i += SCNPRINTF(&buff[i], len - i, " INLIM_CLK=%x",
+		FIELD2VALUE(MAX77759_CHG_CNFG_19_INLIM_CLK, val));
+	i += SCNPRINTF(&buff[i], len - i, " DIS_IR_CTRL=%x",
+		FIELD2VALUE(MAX77759_CHG_CNFG_19_DIS_IR_CTRL, val));
+	i += SCNPRINTF(&buff[i], len - i, " SLOWLX=%x",
+		FIELD2VALUE(MAX77759_CHG_CNFG_19_SLOWLX, val));
+#else
+	buff[0] = 0;
+#endif
+	return buff;
+}
+
+/*
+ * Status,0x0,0b00000010,0x02
+ * Br,Smx,Tmx,Vmx,Bi,Smn,Tmn
+ */
+#define MAX77759_FG_STATUS	0x0
+#define MAX77759_FG_STATUS_BR	(0x1 << 15)
+#define MAX77759_FG_STATUS_SMX	(0x1 << 14)
+#define MAX77759_FG_STATUS_TMX	(0x1 << 13)
+#define MAX77759_FG_STATUS_VMX	(0x1 << 12)
+#define MAX77759_FG_STATUS_BI	(0x1 << 11)
+#define MAX77759_FG_STATUS_SMN	(0x1 << 10)
+#define MAX77759_FG_STATUS_TMN	(0x1 << 9)
+#define MAX77759_FG_STATUS_VMN	(0x1 << 8)
+#define MAX77759_FG_STATUS_DSOCI	(0x1 << 7)
+#define MAX77759_FG_STATUS_THMHOT	(0x1 << 6)
+#define MAX77759_FG_STATUS_SPR_5	(0x1 << 5)
+#define MAX77759_FG_STATUS_ISYSMX	(0x1 << 4)
+#define MAX77759_FG_STATUS_BST	(0x1 << 3)
+#define MAX77759_FG_STATUS_SPR_2	(0x1 << 2)
+#define MAX77759_FG_STATUS_POR	(0x1 << 1)
+#define MAX77759_FG_STATUS_IMN	(0x1 << 0)
+
+#define MAX77759_FG_STATUS_BR_SHIFT	15
+#define MAX77759_FG_STATUS_BR_MASK	(0x1 << 15)
+#define MAX77759_FG_STATUS_BR_CLEAR	(~(0x1 << 15))
+#define MAX77759_FG_STATUS_SMX_SHIFT	14
+#define MAX77759_FG_STATUS_SMX_MASK	(0x1 << 14)
+#define MAX77759_FG_STATUS_SMX_CLEAR	(~(0x1 << 14))
+#define MAX77759_FG_STATUS_TMX_SHIFT	13
+#define MAX77759_FG_STATUS_TMX_MASK	(0x1 << 13)
+#define MAX77759_FG_STATUS_TMX_CLEAR	(~(0x1 << 13))
+#define MAX77759_FG_STATUS_VMX_SHIFT	12
+#define MAX77759_FG_STATUS_VMX_MASK	(0x1 << 12)
+#define MAX77759_FG_STATUS_VMX_CLEAR	(~(0x1 << 12))
+#define MAX77759_FG_STATUS_BI_SHIFT	11
+#define MAX77759_FG_STATUS_BI_MASK	(0x1 << 11)
+#define MAX77759_FG_STATUS_BI_CLEAR	(~(0x1 << 11))
+#define MAX77759_FG_STATUS_SMN_SHIFT	10
+#define MAX77759_FG_STATUS_SMN_MASK	(0x1 << 10)
+#define MAX77759_FG_STATUS_SMN_CLEAR	(~(0x1 << 10))
+#define MAX77759_FG_STATUS_TMN_SHIFT	9
+#define MAX77759_FG_STATUS_TMN_MASK	(0x1 << 9)
+#define MAX77759_FG_STATUS_TMN_CLEAR	(~(0x1 << 9))
+#define MAX77759_FG_STATUS_VMN_SHIFT	8
+#define MAX77759_FG_STATUS_VMN_MASK	(0x1 << 8)
+#define MAX77759_FG_STATUS_VMN_CLEAR	(~(0x1 << 8))
+#define MAX77759_FG_STATUS_DSOCI_SHIFT	7
+#define MAX77759_FG_STATUS_DSOCI_MASK	(0x1 << 7)
+#define MAX77759_FG_STATUS_DSOCI_CLEAR	(~(0x1 << 7))
+#define MAX77759_FG_STATUS_THMHOT_SHIFT	6
+#define MAX77759_FG_STATUS_THMHOT_MASK	(0x1 << 6)
+#define MAX77759_FG_STATUS_THMHOT_CLEAR	(~(0x1 << 6))
+#define MAX77759_FG_STATUS_SPR_5_SHIFT	5
+#define MAX77759_FG_STATUS_SPR_5_MASK	(0x1 << 5)
+#define MAX77759_FG_STATUS_SPR_5_CLEAR	(~(0x1 << 5))
+#define MAX77759_FG_STATUS_ISYSMX_SHIFT	4
+#define MAX77759_FG_STATUS_ISYSMX_MASK	(0x1 << 4)
+#define MAX77759_FG_STATUS_ISYSMX_CLEAR	(~(0x1 << 4))
+#define MAX77759_FG_STATUS_BST_SHIFT	3
+#define MAX77759_FG_STATUS_BST_MASK	(0x1 << 3)
+#define MAX77759_FG_STATUS_BST_CLEAR	(~(0x1 << 3))
+#define MAX77759_FG_STATUS_SPR_2_SHIFT	2
+#define MAX77759_FG_STATUS_SPR_2_MASK	(0x1 << 2)
+#define MAX77759_FG_STATUS_SPR_2_CLEAR	(~(0x1 << 2))
+#define MAX77759_FG_STATUS_POR_SHIFT	1
+#define MAX77759_FG_STATUS_POR_MASK	(0x1 << 1)
+#define MAX77759_FG_STATUS_POR_CLEAR	(~(0x1 << 1))
+#define MAX77759_FG_STATUS_IMN_SHIFT	0
+#define MAX77759_FG_STATUS_IMN_MASK	(0x1 << 0)
+#define MAX77759_FG_STATUS_IMN_CLEAR	(~(0x1 << 0))
+
+MAX77759_BFF(fg_status_br,15,15)
+MAX77759_BFF(fg_status_smx,14,14)
+MAX77759_BFF(fg_status_tmx,13,13)
+MAX77759_BFF(fg_status_vmx,12,12)
+MAX77759_BFF(fg_status_bi,11,11)
+MAX77759_BFF(fg_status_smn,10,10)
+MAX77759_BFF(fg_status_tmn,9,9)
+MAX77759_BFF(fg_status_vmn,8,8)
+MAX77759_BFF(fg_status_dsoci,7,7)
+MAX77759_BFF(fg_status_thmhot,6,6)
+MAX77759_BFF(fg_status_spr_5,5,5)
+MAX77759_BFF(fg_status_isysmx,4,4)
+MAX77759_BFF(fg_status_bst,3,3)
+MAX77759_BFF(fg_status_spr_2,2,2)
+MAX77759_BFF(fg_status_por,1,1)
+MAX77759_BFF(fg_status_imn,0,0)
+static inline const char *
+max77759_fg_status_cstr(char *buff, size_t len, int val)
+{
+#ifdef SCNPRINTF
+	int i = 0;
+
+	i += SCNPRINTF(&buff[i], len - i, " BR=%x",
+		FIELD2VALUE(MAX77759_FG_STATUS_BR, val));
+	i += SCNPRINTF(&buff[i], len - i, " SMX=%x",
+		FIELD2VALUE(MAX77759_FG_STATUS_SMX, val));
+	i += SCNPRINTF(&buff[i], len - i, " TMX=%x",
+		FIELD2VALUE(MAX77759_FG_STATUS_TMX, val));
+	i += SCNPRINTF(&buff[i], len - i, " VMX=%x",
+		FIELD2VALUE(MAX77759_FG_STATUS_VMX, val));
+	i += SCNPRINTF(&buff[i], len - i, " BI=%x",
+		FIELD2VALUE(MAX77759_FG_STATUS_BI, val));
+	i += SCNPRINTF(&buff[i], len - i, " SMN=%x",
+		FIELD2VALUE(MAX77759_FG_STATUS_SMN, val));
+	i += SCNPRINTF(&buff[i], len - i, " TMN=%x",
+		FIELD2VALUE(MAX77759_FG_STATUS_TMN, val));
+	i += SCNPRINTF(&buff[i], len - i, " VMN=%x",
+		FIELD2VALUE(MAX77759_FG_STATUS_VMN, val));
+	i += SCNPRINTF(&buff[i], len - i, " DSOCI=%x",
+		FIELD2VALUE(MAX77759_FG_STATUS_DSOCI, val));
+	i += SCNPRINTF(&buff[i], len - i, " THMHOT=%x",
+		FIELD2VALUE(MAX77759_FG_STATUS_THMHOT, val));
+	i += SCNPRINTF(&buff[i], len - i, " SPR_5=%x",
+		FIELD2VALUE(MAX77759_FG_STATUS_SPR_5, val));
+	i += SCNPRINTF(&buff[i], len - i, " ISYSMX=%x",
+		FIELD2VALUE(MAX77759_FG_STATUS_ISYSMX, val));
+	i += SCNPRINTF(&buff[i], len - i, " BST=%x",
+		FIELD2VALUE(MAX77759_FG_STATUS_BST, val));
+	i += SCNPRINTF(&buff[i], len - i, " SPR_2=%x",
+		FIELD2VALUE(MAX77759_FG_STATUS_SPR_2, val));
+	i += SCNPRINTF(&buff[i], len - i, " POR=%x",
+		FIELD2VALUE(MAX77759_FG_STATUS_POR, val));
+	i += SCNPRINTF(&buff[i], len - i, " IMN=%x",
+		FIELD2VALUE(MAX77759_FG_STATUS_IMN, val));
+#else
+	buff[0] = 0;
+#endif
+	return buff;
+}
+
+/*
+ * VAlrtTh,0x1,0b1111111100000000,0xff00
+ * MaxVoltageAlrt[7:0],,,,,,
+ */
+#define MAX77759_FG_VALRTTH	0x1
+
+#define MAX77759_FG_VALRTTH_MAXVOLTAGEALRT_SHIFT	8
+#define MAX77759_FG_VALRTTH_MAXVOLTAGEALRT_MASK	(0xff << 8)
+#define MAX77759_FG_VALRTTH_MAXVOLTAGEALRT_CLEAR	(~(0xff << 8))
+#define MAX77759_FG_VALRTTH_MINVOLTAGEALRT_SHIFT	0
+#define MAX77759_FG_VALRTTH_MINVOLTAGEALRT_MASK	(0xff << 0)
+#define MAX77759_FG_VALRTTH_MINVOLTAGEALRT_CLEAR	(~(0xff << 0))
+
+MAX77759_BFF(fg_valrtth_maxvoltagealrt,15,8)
+MAX77759_BFF(fg_valrtth_minvoltagealrt,7,0)
+static inline const char *
+max77759_fg_valrtth_cstr(char *buff, size_t len, int val)
+{
+#ifdef SCNPRINTF
+	int i = 0;
+
+	i += SCNPRINTF(&buff[i], len - i, " MAXVOLTAGEALRT=%x",
+		FIELD2VALUE(MAX77759_FG_VALRTTH_MAXVOLTAGEALRT, val));
+	i += SCNPRINTF(&buff[i], len - i, " MINVOLTAGEALRT=%x",
+		FIELD2VALUE(MAX77759_FG_VALRTTH_MINVOLTAGEALRT, val));
+#else
+	buff[0] = 0;
+#endif
+	return buff;
+}
+
+/*
+ * TAlrtTh,0x2,0b111111110000000,0x7f80
+ * MaxTempAlrt[7:0],,,,,,
+ */
+#define MAX77759_FG_TALRTTH	0x2
+
+#define MAX77759_FG_TALRTTH_MAXTEMPALRT_SHIFT	8
+#define MAX77759_FG_TALRTTH_MAXTEMPALRT_MASK	(0xff << 8)
+#define MAX77759_FG_TALRTTH_MAXTEMPALRT_CLEAR	(~(0xff << 8))
+#define MAX77759_FG_TALRTTH_MINTEMPALRT_SHIFT	0
+#define MAX77759_FG_TALRTTH_MINTEMPALRT_MASK	(0xff << 0)
+#define MAX77759_FG_TALRTTH_MINTEMPALRT_CLEAR	(~(0xff << 0))
+
+MAX77759_BFF(fg_talrtth_maxtempalrt,15,8)
+MAX77759_BFF(fg_talrtth_mintempalrt,7,0)
+static inline const char *
+max77759_fg_talrtth_cstr(char *buff, size_t len, int val)
+{
+#ifdef SCNPRINTF
+	int i = 0;
+
+	i += SCNPRINTF(&buff[i], len - i, " MAXTEMPALRT=%x",
+		FIELD2VALUE(MAX77759_FG_TALRTTH_MAXTEMPALRT, val));
+	i += SCNPRINTF(&buff[i], len - i, " MINTEMPALRT=%x",
+		FIELD2VALUE(MAX77759_FG_TALRTTH_MINTEMPALRT, val));
+#else
+	buff[0] = 0;
+#endif
+	return buff;
+}
+
+/*
+ * SAlrtTh,0x3,0b1111111100000000,0xff00
+ * MaxSocAlrt[7:0],,,,,,
+ */
+#define MAX77759_FG_SALRTTH	0x3
+
+#define MAX77759_FG_SALRTTH_MAXSOCALRT_SHIFT	8
+#define MAX77759_FG_SALRTTH_MAXSOCALRT_MASK	(0xff << 8)
+#define MAX77759_FG_SALRTTH_MAXSOCALRT_CLEAR	(~(0xff << 8))
+#define MAX77759_FG_SALRTTH_MINSOCALRT_SHIFT	0
+#define MAX77759_FG_SALRTTH_MINSOCALRT_MASK	(0xff << 0)
+#define MAX77759_FG_SALRTTH_MINSOCALRT_CLEAR	(~(0xff << 0))
+
+MAX77759_BFF(fg_salrtth_maxsocalrt,15,8)
+MAX77759_BFF(fg_salrtth_minsocalrt,7,0)
+static inline const char *
+max77759_fg_salrtth_cstr(char *buff, size_t len, int val)
+{
+#ifdef SCNPRINTF
+	int i = 0;
+
+	i += SCNPRINTF(&buff[i], len - i, " MAXSOCALRT=%x",
+		FIELD2VALUE(MAX77759_FG_SALRTTH_MAXSOCALRT, val));
+	i += SCNPRINTF(&buff[i], len - i, " MINSOCALRT=%x",
+		FIELD2VALUE(MAX77759_FG_SALRTTH_MINSOCALRT, val));
+#else
+	buff[0] = 0;
+#endif
+	return buff;
+}
+
+/*
+ * AtRate,0x4,0b00000000,0x00
+ * AtRate[15:8],,,,,,
+ */
+#define MAX77759_FG_ATRATE	0x4
+
+/*
+ * RepCap,0x5,0b10111011100,0x5dc
+ * RepCap[15:8],,,,,,
+ */
+#define MAX77759_FG_REPCAP	0x5
+
+/*
+ * RepSOC,0x6,0b11001000000000,0x3200
+ * RepSOC[15:8],,,,,,
+ */
+#define MAX77759_FG_REPSOC	0x6
+
+/*
+ * Age,0x7,0b110010000000000,0x6400
+ * Age[15:8],,,,,,
+ */
+#define MAX77759_FG_AGE	0x7
+
+/*
+ * Temp,0x8,0b1011000000000,0x1600
+ * TEMP[15:8],,,,,,
+ */
+#define MAX77759_FG_TEMP	0x8
+
+/*
+ * Vcell,0x9,0b1011010000000000,0xb400
+ * VCELL[15:8],,,,,,
+ */
+#define MAX77759_FG_VCELL	0x9
+
+/*
+ * Current,0xA,0b00000000,0x00
+ * Current[15:8],,,,,,
+ */
+#define MAX77759_FG_CURRENT	0xA
+
+/*
+ * AvgCurrent,0xB,0b00000000,0x00
+ * AvgCurrent[15:8],,,,,,
+ */
+#define MAX77759_FG_AVGCURRENT	0xB
+
+/*
+ * QResidual,0xC,0b00000000,0x00
+ * Qresidual[15:8],,,,,,
+ */
+#define MAX77759_FG_QRESIDUAL	0xC
+
+/*
+ * MixSOC,0xD,0b11001000000000,0x3200
+ * MixSOC[15:8],,,,,,
+ */
+#define MAX77759_FG_MIXSOC	0xD
+
+/*
+ * AvSOC,0xE,0b11001000000000,0x3200
+ * AvSOC[15:8],,,,,,
+ */
+#define MAX77759_FG_AVSOC	0xE
+
+/*
+ * MixCap,0xF,0b10111011100,0x5dc
+ * MixCapH[15:8],,,,,,
+ */
+#define MAX77759_FG_MIXCAP	0xF
+
+/*
+ * FullCap,0x10,0b101110111000,0xbb8
+ * FullCAP[15:8],,,,,,
+ */
+#define MAX77759_FG_FULLCAP	0x10
+
+/*
+ * TTE,0x11,0b00000000,0x00
+ * hr[5:0],,,,,,mn[5:4]
+ */
+#define MAX77759_FG_TTE	0x11
+
+#define MAX77759_FG_TTE_HR_SHIFT	10
+#define MAX77759_FG_TTE_HR_MASK	(0x3f << 10)
+#define MAX77759_FG_TTE_HR_CLEAR	(~(0x3f << 10))
+#define MAX77759_FG_TTE_MN_SHIFT	4
+#define MAX77759_FG_TTE_MN_MASK	(0x3f << 4)
+#define MAX77759_FG_TTE_MN_CLEAR	(~(0x3f << 4))
+#define MAX77759_FG_TTE_SEC_SHIFT	0
+#define MAX77759_FG_TTE_SEC_MASK	(0xf << 0)
+#define MAX77759_FG_TTE_SEC_CLEAR	(~(0xf << 0))
+
+MAX77759_BFF(fg_tte_hr,15,10)
+MAX77759_BFF(fg_tte_mn,9,4)
+MAX77759_BFF(fg_tte_sec,3,0)
+static inline const char *
+max77759_fg_tte_cstr(char *buff, size_t len, int val)
+{
+#ifdef SCNPRINTF
+	int i = 0;
+
+	i += SCNPRINTF(&buff[i], len - i, " HR=%x",
+		FIELD2VALUE(MAX77759_FG_TTE_HR, val));
+	i += SCNPRINTF(&buff[i], len - i, " MN=%x",
+		FIELD2VALUE(MAX77759_FG_TTE_MN, val));
+	i += SCNPRINTF(&buff[i], len - i, " SEC=%x",
+		FIELD2VALUE(MAX77759_FG_TTE_SEC, val));
+#else
+	buff[0] = 0;
+#endif
+	return buff;
+}
+
+/*
+ * QRTable00,0x12,0b11110000000000,0x3c00
+ * QRTable00[15:8],,,,,,
+ */
+#define MAX77759_FG_QRTABLE00	0x12
+
+/*
+ * FullSocThr,0x13,0b101000000000000,0x5000
+ * FullSOCThr[15:8],,,,,,
+ */
+#define MAX77759_FG_FULLSOCTHR	0x13
+
+/*
+ * Rslow,0x14,0b1010010000,0x290
+ * RSLOW[15:8],,,,,,
+ */
+#define MAX77759_FG_RSLOW	0x14
+
+/*
+ * RFast,0x15,0b101001000,0x148
+ * RFAST[15:8],,,,,,
+ */
+#define MAX77759_FG_RFAST	0x15
+
+/*
+ * AvgTA,0x16,0b1011000000000,0x1600
+ * AvgTA[15:8],,,,,,
+ */
+#define MAX77759_FG_AVGTA	0x16
+
+/*
+ * Cycles,0x17,0b00000000,0x00
+ * Cycles[15:8],,,,,,
+ */
+#define MAX77759_FG_CYCLES	0x17
+
+/*
+ * DesignCap,0x18,0b101110111000,0xbb8
+ * DesignCap[15:8],,,,,,
+ */
+#define MAX77759_FG_DESIGNCAP	0x18
+
+/*
+ * AvgVCell,0x19,0b1011010000000000,0xb400
+ * AvgVCELL[15:8],,,,,,
+ */
+#define MAX77759_FG_AVGVCELL	0x19
+
+/*
+ * MaxMinTemp,0x1A,0b1000000001111111,0x807f
+ * MaxTemperature[7:0],,,,,,
+ */
+#define MAX77759_FG_MAXMINTEMP	0x1A
+
+#define MAX77759_FG_MAXMINTEMP_MAXTEMPERATURE_SHIFT	8
+#define MAX77759_FG_MAXMINTEMP_MAXTEMPERATURE_MASK	(0xff << 8)
+#define MAX77759_FG_MAXMINTEMP_MAXTEMPERATURE_CLEAR	(~(0xff << 8))
+#define MAX77759_FG_MAXMINTEMP_MINTEMPERATURE_SHIFT	0
+#define MAX77759_FG_MAXMINTEMP_MINTEMPERATURE_MASK	(0xff << 0)
+#define MAX77759_FG_MAXMINTEMP_MINTEMPERATURE_CLEAR	(~(0xff << 0))
+
+MAX77759_BFF(fg_maxmintemp_maxtemperature,15,8)
+MAX77759_BFF(fg_maxmintemp_mintemperature,7,0)
+static inline const char *
+max77759_fg_maxmintemp_cstr(char *buff, size_t len, int val)
+{
+#ifdef SCNPRINTF
+	int i = 0;
+
+	i += SCNPRINTF(&buff[i], len - i, " MAXTEMPERATURE=%x",
+		FIELD2VALUE(MAX77759_FG_MAXMINTEMP_MAXTEMPERATURE, val));
+	i += SCNPRINTF(&buff[i], len - i, " MINTEMPERATURE=%x",
+		FIELD2VALUE(MAX77759_FG_MAXMINTEMP_MINTEMPERATURE, val));
+#else
+	buff[0] = 0;
+#endif
+	return buff;
+}
+
+/*
+ * MaxMinVolt,0x1B,0b11111111,0xff
+ * MaxVoltage[7:0],,,,,,
+ */
+#define MAX77759_FG_MAXMINVOLT	0x1B
+
+#define MAX77759_FG_MAXMINVOLT_MAXVOLTAGE_SHIFT	8
+#define MAX77759_FG_MAXMINVOLT_MAXVOLTAGE_MASK	(0xff << 8)
+#define MAX77759_FG_MAXMINVOLT_MAXVOLTAGE_CLEAR	(~(0xff << 8))
+#define MAX77759_FG_MAXMINVOLT_MINVOLTAGE_SHIFT	0
+#define MAX77759_FG_MAXMINVOLT_MINVOLTAGE_MASK	(0xff << 0)
+#define MAX77759_FG_MAXMINVOLT_MINVOLTAGE_CLEAR	(~(0xff << 0))
+
+MAX77759_BFF(fg_maxminvolt_maxvoltage,15,8)
+MAX77759_BFF(fg_maxminvolt_minvoltage,7,0)
+static inline const char *
+max77759_fg_maxminvolt_cstr(char *buff, size_t len, int val)
+{
+#ifdef SCNPRINTF
+	int i = 0;
+
+	i += SCNPRINTF(&buff[i], len - i, " MAXVOLTAGE=%x",
+		FIELD2VALUE(MAX77759_FG_MAXMINVOLT_MAXVOLTAGE, val));
+	i += SCNPRINTF(&buff[i], len - i, " MINVOLTAGE=%x",
+		FIELD2VALUE(MAX77759_FG_MAXMINVOLT_MINVOLTAGE, val));
+#else
+	buff[0] = 0;
+#endif
+	return buff;
+}
+
+/*
+ * MaxMinCurr,0x1C,0b1000000001111111,0x807f
+ * MaxChargeCurrent[7:0],,,,,,
+ */
+#define MAX77759_FG_MAXMINCURR	0x1C
+
+#define MAX77759_FG_MAXMINCURR_MAXCHARGECURRENT_SHIFT	8
+#define MAX77759_FG_MAXMINCURR_MAXCHARGECURRENT_MASK	(0xff << 8)
+#define MAX77759_FG_MAXMINCURR_MAXCHARGECURRENT_CLEAR	(~(0xff << 8))
+#define MAX77759_FG_MAXMINCURR_MAXDISCURRENT_SHIFT	0
+#define MAX77759_FG_MAXMINCURR_MAXDISCURRENT_MASK	(0xff << 0)
+#define MAX77759_FG_MAXMINCURR_MAXDISCURRENT_CLEAR	(~(0xff << 0))
+
+MAX77759_BFF(fg_maxmincurr_maxchargecurrent,15,8)
+MAX77759_BFF(fg_maxmincurr_maxdiscurrent,7,0)
+static inline const char *
+max77759_fg_maxmincurr_cstr(char *buff, size_t len, int val)
+{
+#ifdef SCNPRINTF
+	int i = 0;
+
+	i += SCNPRINTF(&buff[i], len - i, " MAXCHARGECURRENT=%x",
+		FIELD2VALUE(MAX77759_FG_MAXMINCURR_MAXCHARGECURRENT, val));
+	i += SCNPRINTF(&buff[i], len - i, " MAXDISCURRENT=%x",
+		FIELD2VALUE(MAX77759_FG_MAXMINCURR_MAXDISCURRENT, val));
+#else
+	buff[0] = 0;
+#endif
+	return buff;
+}
+
+/*
+ * Config,0x1D,0b10001101010000,0x2350
+ * SPR_15,Ss,Ts,Vs,SPR_11,AINSH,Ten
+ */
+#define MAX77759_FG_CONFIG	0x1D
+#define MAX77759_FG_CONFIG_SPR_15	(0x1 << 15)
+#define MAX77759_FG_CONFIG_SS	(0x1 << 14)
+#define MAX77759_FG_CONFIG_TS	(0x1 << 13)
+#define MAX77759_FG_CONFIG_VS	(0x1 << 12)
+#define MAX77759_FG_CONFIG_SPR_11	(0x1 << 11)
+#define MAX77759_FG_CONFIG_AINSH	(0x1 << 10)
+#define MAX77759_FG_CONFIG_TEN	(0x1 << 9)
+#define MAX77759_FG_CONFIG_TEX	(0x1 << 8)
+#define MAX77759_FG_CONFIG_SHDN	(0x1 << 7)
+#define MAX77759_FG_CONFIG_I2CSH	(0x1 << 6)
+#define MAX77759_FG_CONFIG_SPR_5	(0x1 << 5)
+#define MAX77759_FG_CONFIG_ETHRM	(0x1 << 4)
+#define MAX77759_FG_CONFIG_FTHRM	(0x1 << 3)
+#define MAX77759_FG_CONFIG_AEN	(0x1 << 2)
+#define MAX77759_FG_CONFIG_BEI	(0x1 << 1)
+#define MAX77759_FG_CONFIG_BER	(0x1 << 0)
+
+#define MAX77759_FG_CONFIG_SPR_15_SHIFT	15
+#define MAX77759_FG_CONFIG_SPR_15_MASK	(0x1 << 15)
+#define MAX77759_FG_CONFIG_SPR_15_CLEAR	(~(0x1 << 15))
+#define MAX77759_FG_CONFIG_SS_SHIFT	14
+#define MAX77759_FG_CONFIG_SS_MASK	(0x1 << 14)
+#define MAX77759_FG_CONFIG_SS_CLEAR	(~(0x1 << 14))
+#define MAX77759_FG_CONFIG_TS_SHIFT	13
+#define MAX77759_FG_CONFIG_TS_MASK	(0x1 << 13)
+#define MAX77759_FG_CONFIG_TS_CLEAR	(~(0x1 << 13))
+#define MAX77759_FG_CONFIG_VS_SHIFT	12
+#define MAX77759_FG_CONFIG_VS_MASK	(0x1 << 12)
+#define MAX77759_FG_CONFIG_VS_CLEAR	(~(0x1 << 12))
+#define MAX77759_FG_CONFIG_SPR_11_SHIFT	11
+#define MAX77759_FG_CONFIG_SPR_11_MASK	(0x1 << 11)
+#define MAX77759_FG_CONFIG_SPR_11_CLEAR	(~(0x1 << 11))
+#define MAX77759_FG_CONFIG_AINSH_SHIFT	10
+#define MAX77759_FG_CONFIG_AINSH_MASK	(0x1 << 10)
+#define MAX77759_FG_CONFIG_AINSH_CLEAR	(~(0x1 << 10))
+#define MAX77759_FG_CONFIG_TEN_SHIFT	9
+#define MAX77759_FG_CONFIG_TEN_MASK	(0x1 << 9)
+#define MAX77759_FG_CONFIG_TEN_CLEAR	(~(0x1 << 9))
+#define MAX77759_FG_CONFIG_TEX_SHIFT	8
+#define MAX77759_FG_CONFIG_TEX_MASK	(0x1 << 8)
+#define MAX77759_FG_CONFIG_TEX_CLEAR	(~(0x1 << 8))
+#define MAX77759_FG_CONFIG_SHDN_SHIFT	7
+#define MAX77759_FG_CONFIG_SHDN_MASK	(0x1 << 7)
+#define MAX77759_FG_CONFIG_SHDN_CLEAR	(~(0x1 << 7))
+#define MAX77759_FG_CONFIG_I2CSH_SHIFT	6
+#define MAX77759_FG_CONFIG_I2CSH_MASK	(0x1 << 6)
+#define MAX77759_FG_CONFIG_I2CSH_CLEAR	(~(0x1 << 6))
+#define MAX77759_FG_CONFIG_SPR_5_SHIFT	5
+#define MAX77759_FG_CONFIG_SPR_5_MASK	(0x1 << 5)
+#define MAX77759_FG_CONFIG_SPR_5_CLEAR	(~(0x1 << 5))
+#define MAX77759_FG_CONFIG_ETHRM_SHIFT	4
+#define MAX77759_FG_CONFIG_ETHRM_MASK	(0x1 << 4)
+#define MAX77759_FG_CONFIG_ETHRM_CLEAR	(~(0x1 << 4))
+#define MAX77759_FG_CONFIG_FTHRM_SHIFT	3
+#define MAX77759_FG_CONFIG_FTHRM_MASK	(0x1 << 3)
+#define MAX77759_FG_CONFIG_FTHRM_CLEAR	(~(0x1 << 3))
+#define MAX77759_FG_CONFIG_AEN_SHIFT	2
+#define MAX77759_FG_CONFIG_AEN_MASK	(0x1 << 2)
+#define MAX77759_FG_CONFIG_AEN_CLEAR	(~(0x1 << 2))
+#define MAX77759_FG_CONFIG_BEI_SHIFT	1
+#define MAX77759_FG_CONFIG_BEI_MASK	(0x1 << 1)
+#define MAX77759_FG_CONFIG_BEI_CLEAR	(~(0x1 << 1))
+#define MAX77759_FG_CONFIG_BER_SHIFT	0
+#define MAX77759_FG_CONFIG_BER_MASK	(0x1 << 0)
+#define MAX77759_FG_CONFIG_BER_CLEAR	(~(0x1 << 0))
+
+MAX77759_BFF(fg_config_spr_15,15,15)
+MAX77759_BFF(fg_config_ss,14,14)
+MAX77759_BFF(fg_config_ts,13,13)
+MAX77759_BFF(fg_config_vs,12,12)
+MAX77759_BFF(fg_config_spr_11,11,11)
+MAX77759_BFF(fg_config_ainsh,10,10)
+MAX77759_BFF(fg_config_ten,9,9)
+MAX77759_BFF(fg_config_tex,8,8)
+MAX77759_BFF(fg_config_shdn,7,7)
+MAX77759_BFF(fg_config_i2csh,6,6)
+MAX77759_BFF(fg_config_spr_5,5,5)
+MAX77759_BFF(fg_config_ethrm,4,4)
+MAX77759_BFF(fg_config_fthrm,3,3)
+MAX77759_BFF(fg_config_aen,2,2)
+MAX77759_BFF(fg_config_bei,1,1)
+MAX77759_BFF(fg_config_ber,0,0)
+static inline const char *
+max77759_fg_config_cstr(char *buff, size_t len, int val)
+{
+#ifdef SCNPRINTF
+	int i = 0;
+
+	i += SCNPRINTF(&buff[i], len - i, " SPR_15=%x",
+		FIELD2VALUE(MAX77759_FG_CONFIG_SPR_15, val));
+	i += SCNPRINTF(&buff[i], len - i, " SS=%x",
+		FIELD2VALUE(MAX77759_FG_CONFIG_SS, val));
+	i += SCNPRINTF(&buff[i], len - i, " TS=%x",
+		FIELD2VALUE(MAX77759_FG_CONFIG_TS, val));
+	i += SCNPRINTF(&buff[i], len - i, " VS=%x",
+		FIELD2VALUE(MAX77759_FG_CONFIG_VS, val));
+	i += SCNPRINTF(&buff[i], len - i, " SPR_11=%x",
+		FIELD2VALUE(MAX77759_FG_CONFIG_SPR_11, val));
+	i += SCNPRINTF(&buff[i], len - i, " AINSH=%x",
+		FIELD2VALUE(MAX77759_FG_CONFIG_AINSH, val));
+	i += SCNPRINTF(&buff[i], len - i, " TEN=%x",
+		FIELD2VALUE(MAX77759_FG_CONFIG_TEN, val));
+	i += SCNPRINTF(&buff[i], len - i, " TEX=%x",
+		FIELD2VALUE(MAX77759_FG_CONFIG_TEX, val));
+	i += SCNPRINTF(&buff[i], len - i, " SHDN=%x",
+		FIELD2VALUE(MAX77759_FG_CONFIG_SHDN, val));
+	i += SCNPRINTF(&buff[i], len - i, " I2CSH=%x",
+		FIELD2VALUE(MAX77759_FG_CONFIG_I2CSH, val));
+	i += SCNPRINTF(&buff[i], len - i, " SPR_5=%x",
+		FIELD2VALUE(MAX77759_FG_CONFIG_SPR_5, val));
+	i += SCNPRINTF(&buff[i], len - i, " ETHRM=%x",
+		FIELD2VALUE(MAX77759_FG_CONFIG_ETHRM, val));
+	i += SCNPRINTF(&buff[i], len - i, " FTHRM=%x",
+		FIELD2VALUE(MAX77759_FG_CONFIG_FTHRM, val));
+	i += SCNPRINTF(&buff[i], len - i, " AEN=%x",
+		FIELD2VALUE(MAX77759_FG_CONFIG_AEN, val));
+	i += SCNPRINTF(&buff[i], len - i, " BEI=%x",
+		FIELD2VALUE(MAX77759_FG_CONFIG_BEI, val));
+	i += SCNPRINTF(&buff[i], len - i, " BER=%x",
+		FIELD2VALUE(MAX77759_FG_CONFIG_BER, val));
+#else
+	buff[0] = 0;
+#endif
+	return buff;
+}
+
+/*
+ * IChgTerm,0x1E,0b1111000000,0x3c0
+ * ICHGTerm[15:8],,,,,,
+ */
+#define MAX77759_FG_ICHGTERM	0x1E
+
+/*
+ * AvCap,0x1F,0b10111011100,0x5dc
+ * AvCap[15:8],,,,,,
+ */
+#define MAX77759_FG_AVCAP	0x1F
+
+/*
+ * TTF,0x20,0b1111111111111111,0xffff
+ * hr[5:0],,,,,,mn[5:4]
+ */
+#define MAX77759_FG_TTF	0x20
+
+#define MAX77759_FG_TTF_HR_SHIFT	10
+#define MAX77759_FG_TTF_HR_MASK	(0x3f << 10)
+#define MAX77759_FG_TTF_HR_CLEAR	(~(0x3f << 10))
+#define MAX77759_FG_TTF_MN_SHIFT	4
+#define MAX77759_FG_TTF_MN_MASK	(0x3f << 4)
+#define MAX77759_FG_TTF_MN_CLEAR	(~(0x3f << 4))
+#define MAX77759_FG_TTF_SEC_SHIFT	0
+#define MAX77759_FG_TTF_SEC_MASK	(0xf << 0)
+#define MAX77759_FG_TTF_SEC_CLEAR	(~(0xf << 0))
+
+MAX77759_BFF(fg_ttf_hr,15,10)
+MAX77759_BFF(fg_ttf_mn,9,4)
+MAX77759_BFF(fg_ttf_sec,3,0)
+static inline const char *
+max77759_fg_ttf_cstr(char *buff, size_t len, int val)
+{
+#ifdef SCNPRINTF
+	int i = 0;
+
+	i += SCNPRINTF(&buff[i], len - i, " HR=%x",
+		FIELD2VALUE(MAX77759_FG_TTF_HR, val));
+	i += SCNPRINTF(&buff[i], len - i, " MN=%x",
+		FIELD2VALUE(MAX77759_FG_TTF_MN, val));
+	i += SCNPRINTF(&buff[i], len - i, " SEC=%x",
+		FIELD2VALUE(MAX77759_FG_TTF_SEC, val));
+#else
+	buff[0] = 0;
+#endif
+	return buff;
+}
+
+/*
+ * DevName,0x21,0b110001000000000,0x6200
+ * DevName[15:8],,,,,,
+ */
+#define MAX77759_FG_DEVNAME	0x21
+
+/*
+ * QRTable10,0x22,0b1101110000000,0x1b80
+ * QRTable10[15:8],,,,,,
+ */
+#define MAX77759_FG_QRTABLE10	0x22
+
+/*
+ * FullCapNom,0x23,0b101110111000,0xbb8
+ * FullCapNom[15:8],,,,,,
+ */
+#define MAX77759_FG_FULLCAPNOM	0x23
+
+/*
+ * TempNom,0x24,0b1010000000000,0x1400
+ * TempNom[9:2],,,,,,
+ */
+#define MAX77759_FG_TEMPNOM	0x24
+
+#define MAX77759_FG_TEMPNOM_TEMPNOM_SHIFT	6
+#define MAX77759_FG_TEMPNOM_TEMPNOM_MASK	(0x3ff << 6)
+#define MAX77759_FG_TEMPNOM_TEMPNOM_CLEAR	(~(0x3ff << 6))
+#define MAX77759_FG_TEMPNOM_SPR_5_0_SHIFT	0
+#define MAX77759_FG_TEMPNOM_SPR_5_0_MASK	(0x3f << 0)
+#define MAX77759_FG_TEMPNOM_SPR_5_0_CLEAR	(~(0x3f << 0))
+
+MAX77759_BFF(fg_tempnom_tempnom,15,6)
+MAX77759_BFF(fg_tempnom_spr_5_0,5,0)
+static inline const char *
+max77759_fg_tempnom_cstr(char *buff, size_t len, int val)
+{
+#ifdef SCNPRINTF
+	int i = 0;
+
+	i += SCNPRINTF(&buff[i], len - i, " TEMPNOM=%x",
+		FIELD2VALUE(MAX77759_FG_TEMPNOM_TEMPNOM, val));
+	i += SCNPRINTF(&buff[i], len - i, " SPR_5_0=%x",
+		FIELD2VALUE(MAX77759_FG_TEMPNOM_SPR_5_0, val));
+#else
+	buff[0] = 0;
+#endif
+	return buff;
+}
+
+/*
+ * TempLim,0x25,0b10001100000101,0x2305
+ * TempHot[7:0],,,,,,
+ */
+#define MAX77759_FG_TEMPLIM	0x25
+
+#define MAX77759_FG_TEMPLIM_TEMPHOT_SHIFT	8
+#define MAX77759_FG_TEMPLIM_TEMPHOT_MASK	(0xff << 8)
+#define MAX77759_FG_TEMPLIM_TEMPHOT_CLEAR	(~(0xff << 8))
+#define MAX77759_FG_TEMPLIM_TEMPCOLD_SHIFT	0
+#define MAX77759_FG_TEMPLIM_TEMPCOLD_MASK	(0xff << 0)
+#define MAX77759_FG_TEMPLIM_TEMPCOLD_CLEAR	(~(0xff << 0))
+
+MAX77759_BFF(fg_templim_temphot,15,8)
+MAX77759_BFF(fg_templim_tempcold,7,0)
+static inline const char *
+max77759_fg_templim_cstr(char *buff, size_t len, int val)
+{
+#ifdef SCNPRINTF
+	int i = 0;
+
+	i += SCNPRINTF(&buff[i], len - i, " TEMPHOT=%x",
+		FIELD2VALUE(MAX77759_FG_TEMPLIM_TEMPHOT, val));
+	i += SCNPRINTF(&buff[i], len - i, " TEMPCOLD=%x",
+		FIELD2VALUE(MAX77759_FG_TEMPLIM_TEMPCOLD, val));
+#else
+	buff[0] = 0;
+#endif
+	return buff;
+}
+
+/*
+ * AvgTA0,0x26,0b1011000000000,0x1600
+ * AvgTA0[15:8],,,,,,
+ */
+#define MAX77759_FG_AVGTA0	0x26
+
+/*
+ * AIN0,0x27,0b1000100011010000,0x88d0
+ * AIN0[15:8],,,,,,
+ */
+#define MAX77759_FG_AIN0	0x27
+
+/*
+ * LearnCfg,0x28,0b10011000000011,0x2603
+ * LearnRCOMP[2:0],,,LearnTCO[2:0],,,FCLrn[1:0]
+ */
+#define MAX77759_FG_LEARNCFG	0x28
+#define MAX77759_FG_LEARNCFG_SPR_7	(0x1 << 7)
+#define MAX77759_FG_LEARNCFG_SPR_3	(0x1 << 3)
+#define MAX77759_FG_LEARNCFG_FILLEMPTY	(0x1 << 2)
+#define MAX77759_FG_LEARNCFG_RESERVED_1	(0x1 << 1)
+#define MAX77759_FG_LEARNCFG_SPR_0	(0x1 << 0)
+
+#define MAX77759_FG_LEARNCFG_LEARNRCOMP_SHIFT	13
+#define MAX77759_FG_LEARNCFG_LEARNRCOMP_MASK	(0x7 << 13)
+#define MAX77759_FG_LEARNCFG_LEARNRCOMP_CLEAR	(~(0x7 << 13))
+#define MAX77759_FG_LEARNCFG_LEARNTCO_SHIFT	10
+#define MAX77759_FG_LEARNCFG_LEARNTCO_MASK	(0x7 << 10)
+#define MAX77759_FG_LEARNCFG_LEARNTCO_CLEAR	(~(0x7 << 10))
+#define MAX77759_FG_LEARNCFG_FCLRN_SHIFT	8
+#define MAX77759_FG_LEARNCFG_FCLRN_MASK	(0x3 << 8)
+#define MAX77759_FG_LEARNCFG_FCLRN_CLEAR	(~(0x3 << 8))
+#define MAX77759_FG_LEARNCFG_SPR_7_SHIFT	7
+#define MAX77759_FG_LEARNCFG_SPR_7_MASK	(0x1 << 7)
+#define MAX77759_FG_LEARNCFG_SPR_7_CLEAR	(~(0x1 << 7))
+#define MAX77759_FG_LEARNCFG_FCLRNSTAGE_SHIFT	4
+#define MAX77759_FG_LEARNCFG_FCLRNSTAGE_MASK	(0x7 << 4)
+#define MAX77759_FG_LEARNCFG_FCLRNSTAGE_CLEAR	(~(0x7 << 4))
+#define MAX77759_FG_LEARNCFG_SPR_3_SHIFT	3
+#define MAX77759_FG_LEARNCFG_SPR_3_MASK	(0x1 << 3)
+#define MAX77759_FG_LEARNCFG_SPR_3_CLEAR	(~(0x1 << 3))
+#define MAX77759_FG_LEARNCFG_FILLEMPTY_SHIFT	2
+#define MAX77759_FG_LEARNCFG_FILLEMPTY_MASK	(0x1 << 2)
+#define MAX77759_FG_LEARNCFG_FILLEMPTY_CLEAR	(~(0x1 << 2))
+#define MAX77759_FG_LEARNCFG_RESERVED_1_SHIFT	1
+#define MAX77759_FG_LEARNCFG_RESERVED_1_MASK	(0x1 << 1)
+#define MAX77759_FG_LEARNCFG_RESERVED_1_CLEAR	(~(0x1 << 1))
+#define MAX77759_FG_LEARNCFG_SPR_0_SHIFT	0
+#define MAX77759_FG_LEARNCFG_SPR_0_MASK	(0x1 << 0)
+#define MAX77759_FG_LEARNCFG_SPR_0_CLEAR	(~(0x1 << 0))
+
+MAX77759_BFF(fg_learncfg_learnrcomp,15,13)
+MAX77759_BFF(fg_learncfg_learntco,12,10)
+MAX77759_BFF(fg_learncfg_fclrn,9,8)
+MAX77759_BFF(fg_learncfg_spr_7,7,7)
+MAX77759_BFF(fg_learncfg_fclrnstage,6,4)
+MAX77759_BFF(fg_learncfg_spr_3,3,3)
+MAX77759_BFF(fg_learncfg_fillempty,2,2)
+MAX77759_BFF(fg_learncfg_reserved_1,1,1)
+MAX77759_BFF(fg_learncfg_spr_0,0,0)
+static inline const char *
+max77759_fg_learncfg_cstr(char *buff, size_t len, int val)
+{
+#ifdef SCNPRINTF
+	int i = 0;
+
+	i += SCNPRINTF(&buff[i], len - i, " LEARNRCOMP=%x",
+		FIELD2VALUE(MAX77759_FG_LEARNCFG_LEARNRCOMP, val));
+	i += SCNPRINTF(&buff[i], len - i, " LEARNTCO=%x",
+		FIELD2VALUE(MAX77759_FG_LEARNCFG_LEARNTCO, val));
+	i += SCNPRINTF(&buff[i], len - i, " FCLRN=%x",
+		FIELD2VALUE(MAX77759_FG_LEARNCFG_FCLRN, val));
+	i += SCNPRINTF(&buff[i], len - i, " SPR_7=%x",
+		FIELD2VALUE(MAX77759_FG_LEARNCFG_SPR_7, val));
+	i += SCNPRINTF(&buff[i], len - i, " FCLRNSTAGE=%x",
+		FIELD2VALUE(MAX77759_FG_LEARNCFG_FCLRNSTAGE, val));
+	i += SCNPRINTF(&buff[i], len - i, " SPR_3=%x",
+		FIELD2VALUE(MAX77759_FG_LEARNCFG_SPR_3, val));
+	i += SCNPRINTF(&buff[i], len - i, " FILLEMPTY=%x",
+		FIELD2VALUE(MAX77759_FG_LEARNCFG_FILLEMPTY, val));
+	i += SCNPRINTF(&buff[i], len - i, " RESERVED_1=%x",
+		FIELD2VALUE(MAX77759_FG_LEARNCFG_RESERVED_1, val));
+	i += SCNPRINTF(&buff[i], len - i, " SPR_0=%x",
+		FIELD2VALUE(MAX77759_FG_LEARNCFG_SPR_0, val));
+#else
+	buff[0] = 0;
+#endif
+	return buff;
+}
+
+/*
+ * FilterCfg,0x29,0b1100111010100100,0xcea4
+ * SPR_15_14[1:0],,NTEMP[2:0],,,NMIX[3:1],
+ */
+#define MAX77759_FG_FILTERCFG	0x29
+
+#define MAX77759_FG_FILTERCFG_SPR_15_14_SHIFT	14
+#define MAX77759_FG_FILTERCFG_SPR_15_14_MASK	(0x3 << 14)
+#define MAX77759_FG_FILTERCFG_SPR_15_14_CLEAR	(~(0x3 << 14))
+#define MAX77759_FG_FILTERCFG_NTEMP_SHIFT	11
+#define MAX77759_FG_FILTERCFG_NTEMP_MASK	(0x7 << 11)
+#define MAX77759_FG_FILTERCFG_NTEMP_CLEAR	(~(0x7 << 11))
+#define MAX77759_FG_FILTERCFG_NMIX_SHIFT	8
+#define MAX77759_FG_FILTERCFG_NMIX_MASK	(0x7 << 8)
+#define MAX77759_FG_FILTERCFG_NMIX_CLEAR	(~(0x7 << 8))
+#define MAX77759_FG_FILTERCFG_NAVGCELL_SHIFT	5
+#define MAX77759_FG_FILTERCFG_NAVGCELL_MASK	(0x7 << 5)
+#define MAX77759_FG_FILTERCFG_NAVGCELL_CLEAR	(~(0x7 << 5))
+#define MAX77759_FG_FILTERCFG_NCURR_SHIFT	1
+#define MAX77759_FG_FILTERCFG_NCURR_MASK	(0xf << 1)
+#define MAX77759_FG_FILTERCFG_NCURR_CLEAR	(~(0xf << 1))
+
+MAX77759_BFF(fg_filtercfg_spr_15_14,15,14)
+MAX77759_BFF(fg_filtercfg_ntemp,13,11)
+MAX77759_BFF(fg_filtercfg_nmix,10,8)
+MAX77759_BFF(fg_filtercfg_navgcell,7,5)
+MAX77759_BFF(fg_filtercfg_ncurr,4,1)
+static inline const char *
+max77759_fg_filtercfg_cstr(char *buff, size_t len, int val)
+{
+#ifdef SCNPRINTF
+	int i = 0;
+
+	i += SCNPRINTF(&buff[i], len - i, " SPR_15_14=%x",
+		FIELD2VALUE(MAX77759_FG_FILTERCFG_SPR_15_14, val));
+	i += SCNPRINTF(&buff[i], len - i, " NTEMP=%x",
+		FIELD2VALUE(MAX77759_FG_FILTERCFG_NTEMP, val));
+	i += SCNPRINTF(&buff[i], len - i, " NMIX=%x",
+		FIELD2VALUE(MAX77759_FG_FILTERCFG_NMIX, val));
+	i += SCNPRINTF(&buff[i], len - i, " NAVGCELL=%x",
+		FIELD2VALUE(MAX77759_FG_FILTERCFG_NAVGCELL, val));
+	i += SCNPRINTF(&buff[i], len - i, " NCURR=%x",
+		FIELD2VALUE(MAX77759_FG_FILTERCFG_NCURR, val));
+#else
+	buff[0] = 0;
+#endif
+	return buff;
+}
+
+/*
+ * RelaxCfg,0x2A,0b10000011001001,0x20c9
+ * LoadThr[6:0],,,,,,
+ */
+#define MAX77759_FG_RELAXCFG	0x2A
+
+#define MAX77759_FG_RELAXCFG_LOADTHR_SHIFT	9
+#define MAX77759_FG_RELAXCFG_LOADTHR_MASK	(0x7f << 9)
+#define MAX77759_FG_RELAXCFG_LOADTHR_CLEAR	(~(0x7f << 9))
+#define MAX77759_FG_RELAXCFG_DVTHR_SHIFT	4
+#define MAX77759_FG_RELAXCFG_DVTHR_MASK	(0xf << 4)
+#define MAX77759_FG_RELAXCFG_DVTHR_CLEAR	(~(0xf << 4))
+#define MAX77759_FG_RELAXCFG_DTTHR_SHIFT	0
+#define MAX77759_FG_RELAXCFG_DTTHR_MASK	(0xf << 0)
+#define MAX77759_FG_RELAXCFG_DTTHR_CLEAR	(~(0xf << 0))
+
+MAX77759_BFF(fg_relaxcfg_loadthr,15,9)
+MAX77759_BFF(fg_relaxcfg_dvthr,7,4)
+MAX77759_BFF(fg_relaxcfg_dtthr,3,0)
+static inline const char *
+max77759_fg_relaxcfg_cstr(char *buff, size_t len, int val)
+{
+#ifdef SCNPRINTF
+	int i = 0;
+
+	i += SCNPRINTF(&buff[i], len - i, " LOADTHR=%x",
+		FIELD2VALUE(MAX77759_FG_RELAXCFG_LOADTHR, val));
+	i += SCNPRINTF(&buff[i], len - i, " DVTHR=%x",
+		FIELD2VALUE(MAX77759_FG_RELAXCFG_DVTHR, val));
+	i += SCNPRINTF(&buff[i], len - i, " DTTHR=%x",
+		FIELD2VALUE(MAX77759_FG_RELAXCFG_DTTHR, val));
+#else
+	buff[0] = 0;
+#endif
+	return buff;
+}
+
+/*
+ * MiscCfg,0x2B,0b100111010000,0x9d0
+ * FUS[3:0],,,,EnBi1,InitVFG,MixRate[4:3]
+ */
+#define MAX77759_FG_MISCCFG	0x2B
+#define MAX77759_FG_MISCCFG_ENBI1	(0x1 << 11)
+#define MAX77759_FG_MISCCFG_INITVFG	(0x1 << 10)
+#define MAX77759_FG_MISCCFG_RDFCLRN	(0x1 << 4)
+#define MAX77759_FG_MISCCFG_VTTL	(0x1 << 3)
+#define MAX77759_FG_MISCCFG_VEX	(0x1 << 2)
+
+#define MAX77759_FG_MISCCFG_FUS_SHIFT	12
+#define MAX77759_FG_MISCCFG_FUS_MASK	(0xf << 12)
+#define MAX77759_FG_MISCCFG_FUS_CLEAR	(~(0xf << 12))
+#define MAX77759_FG_MISCCFG_ENBI1_SHIFT	11
+#define MAX77759_FG_MISCCFG_ENBI1_MASK	(0x1 << 11)
+#define MAX77759_FG_MISCCFG_ENBI1_CLEAR	(~(0x1 << 11))
+#define MAX77759_FG_MISCCFG_INITVFG_SHIFT	10
+#define MAX77759_FG_MISCCFG_INITVFG_MASK	(0x1 << 10)
+#define MAX77759_FG_MISCCFG_INITVFG_CLEAR	(~(0x1 << 10))
+#define MAX77759_FG_MISCCFG_MIXRATE_SHIFT	5
+#define MAX77759_FG_MISCCFG_MIXRATE_MASK	(0x1f << 5)
+#define MAX77759_FG_MISCCFG_MIXRATE_CLEAR	(~(0x1f << 5))
+#define MAX77759_FG_MISCCFG_RDFCLRN_SHIFT	4
+#define MAX77759_FG_MISCCFG_RDFCLRN_MASK	(0x1 << 4)
+#define MAX77759_FG_MISCCFG_RDFCLRN_CLEAR	(~(0x1 << 4))
+#define MAX77759_FG_MISCCFG_VTTL_SHIFT	3
+#define MAX77759_FG_MISCCFG_VTTL_MASK	(0x1 << 3)
+#define MAX77759_FG_MISCCFG_VTTL_CLEAR	(~(0x1 << 3))
+#define MAX77759_FG_MISCCFG_VEX_SHIFT	2
+#define MAX77759_FG_MISCCFG_VEX_MASK	(0x1 << 2)
+#define MAX77759_FG_MISCCFG_VEX_CLEAR	(~(0x1 << 2))
+#define MAX77759_FG_MISCCFG_SACFG_SHIFT	0
+#define MAX77759_FG_MISCCFG_SACFG_MASK	(0x3 << 0)
+#define MAX77759_FG_MISCCFG_SACFG_CLEAR	(~(0x3 << 0))
+
+MAX77759_BFF(fg_misccfg_fus,15,12)
+MAX77759_BFF(fg_misccfg_enbi1,11,11)
+MAX77759_BFF(fg_misccfg_initvfg,10,10)
+MAX77759_BFF(fg_misccfg_mixrate,9,5)
+MAX77759_BFF(fg_misccfg_rdfclrn,4,4)
+MAX77759_BFF(fg_misccfg_vttl,3,3)
+MAX77759_BFF(fg_misccfg_vex,2,2)
+MAX77759_BFF(fg_misccfg_sacfg,1,0)
+static inline const char *
+max77759_fg_misccfg_cstr(char *buff, size_t len, int val)
+{
+#ifdef SCNPRINTF
+	int i = 0;
+
+	i += SCNPRINTF(&buff[i], len - i, " FUS=%x",
+		FIELD2VALUE(MAX77759_FG_MISCCFG_FUS, val));
+	i += SCNPRINTF(&buff[i], len - i, " ENBI1=%x",
+		FIELD2VALUE(MAX77759_FG_MISCCFG_ENBI1, val));
+	i += SCNPRINTF(&buff[i], len - i, " INITVFG=%x",
+		FIELD2VALUE(MAX77759_FG_MISCCFG_INITVFG, val));
+	i += SCNPRINTF(&buff[i], len - i, " MIXRATE=%x",
+		FIELD2VALUE(MAX77759_FG_MISCCFG_MIXRATE, val));
+	i += SCNPRINTF(&buff[i], len - i, " RDFCLRN=%x",
+		FIELD2VALUE(MAX77759_FG_MISCCFG_RDFCLRN, val));
+	i += SCNPRINTF(&buff[i], len - i, " VTTL=%x",
+		FIELD2VALUE(MAX77759_FG_MISCCFG_VTTL, val));
+	i += SCNPRINTF(&buff[i], len - i, " VEX=%x",
+		FIELD2VALUE(MAX77759_FG_MISCCFG_VEX, val));
+	i += SCNPRINTF(&buff[i], len - i, " SACFG=%x",
+		FIELD2VALUE(MAX77759_FG_MISCCFG_SACFG, val));
+#else
+	buff[0] = 0;
+#endif
+	return buff;
+}
+
+/*
+ * TGain,0x2C,0b1110101110001101,0xeb8d
+ * TGAIN[15:8],,,,,,
+ */
+#define MAX77759_FG_TGAIN	0x2C
+
+/*
+ * TOff,0x2D,0b10000010101010,0x20aa
+ * TOFF[15:8],,,,,,
+ */
+#define MAX77759_FG_TOFF	0x2D
+
+/*
+ * CGain,0x2E,0b10000000000,0x400
+ * CGAIN[15:8],,,,,,
+ */
+#define MAX77759_FG_CGAIN	0x2E
+
+/*
+ * COff,0x2F,0b00000000,0x00
+ * COFF[15:8],,,,,,
+ */
+#define MAX77759_FG_COFF	0x2F
+
+/*
+ * dV_acc,0x30,0b10000000000,0x400
+ * dV_acc[15:8],,,,,,
+ */
+#define MAX77759_FG_DV_ACC	0x30
+
+/*
+ * dI_acc,0x31,0b11001000000,0x640
+ * dI_acc[15:8],,,,,,
+ */
+#define MAX77759_FG_DI_ACC	0x31
+
+/*
+ * QRTable20,0x32,0b101100000100,0xb04
+ * QRTable20[15:8],,,,,,
+ */
+#define MAX77759_FG_QRTABLE20	0x32
+
+/*
+ * AtTTF,0x33,0b1111111111111111,0xffff
+ * AtTTF[15:8],,,,,,
+ */
+#define MAX77759_FG_ATTTF	0x33
+
+/*
+ * TConvert,0x34,0b1011000000000,0x1600
+ * TConvert[15:8],,,,,,
+ */
+#define MAX77759_FG_TCONVERT	0x34
+
+/*
+ * FullCapRep,0x35,0b101110111000,0xbb8
+ * FullCapRep[15:8],,,,,,
+ */
+#define MAX77759_FG_FULLCAPREP	0x35
+
+/*
+ * IAvgEmpty,0x36,0b1111010001001000,0xf448
+ * Iavg_empty[15:8],,,,,,
+ */
+#define MAX77759_FG_IAVGEMPTY	0x36
+
+/*
+ * FCTC,0x37,0b10111100000,0x5e0
+ * RSRVD[15:8],,,,,,
+ */
+#define MAX77759_FG_FCTC	0x37
+
+/*
+ * RComp0,0x38,0b01110000,0x70
+ * SPR_15_8[7:0],,,,,,
+ */
+#define MAX77759_FG_RCOMP0	0x38
+
+#define MAX77759_FG_RCOMP0_SPR_15_8_SHIFT	8
+#define MAX77759_FG_RCOMP0_SPR_15_8_MASK	(0xff << 8)
+#define MAX77759_FG_RCOMP0_SPR_15_8_CLEAR	(~(0xff << 8))
+#define MAX77759_FG_RCOMP0_RCOMP0_SHIFT	0
+#define MAX77759_FG_RCOMP0_RCOMP0_MASK	(0xff << 0)
+#define MAX77759_FG_RCOMP0_RCOMP0_CLEAR	(~(0xff << 0))
+
+MAX77759_BFF(fg_rcomp0_spr_15_8,15,8)
+MAX77759_BFF(fg_rcomp0_rcomp0,7,0)
+static inline const char *
+max77759_fg_rcomp0_cstr(char *buff, size_t len, int val)
+{
+#ifdef SCNPRINTF
+	int i = 0;
+
+	i += SCNPRINTF(&buff[i], len - i, " SPR_15_8=%x",
+		FIELD2VALUE(MAX77759_FG_RCOMP0_SPR_15_8, val));
+	i += SCNPRINTF(&buff[i], len - i, " RCOMP0=%x",
+		FIELD2VALUE(MAX77759_FG_RCOMP0_RCOMP0, val));
+#else
+	buff[0] = 0;
+#endif
+	return buff;
+}
+
+/*
+ * TempCo,0x39,0b10011000111101,0x263d
+ * TempCoHot[7:0],,,,,,
+ */
+#define MAX77759_FG_TEMPCO	0x39
+
+#define MAX77759_FG_TEMPCO_TEMPCOHOT_SHIFT	8
+#define MAX77759_FG_TEMPCO_TEMPCOHOT_MASK	(0xff << 8)
+#define MAX77759_FG_TEMPCO_TEMPCOHOT_CLEAR	(~(0xff << 8))
+#define MAX77759_FG_TEMPCO_TEMPCOCOLD_SHIFT	0
+#define MAX77759_FG_TEMPCO_TEMPCOCOLD_MASK	(0xff << 0)
+#define MAX77759_FG_TEMPCO_TEMPCOCOLD_CLEAR	(~(0xff << 0))
+
+MAX77759_BFF(fg_tempco_tempcohot,15,8)
+MAX77759_BFF(fg_tempco_tempcocold,7,0)
+static inline const char *
+max77759_fg_tempco_cstr(char *buff, size_t len, int val)
+{
+#ifdef SCNPRINTF
+	int i = 0;
+
+	i += SCNPRINTF(&buff[i], len - i, " TEMPCOHOT=%x",
+		FIELD2VALUE(MAX77759_FG_TEMPCO_TEMPCOHOT, val));
+	i += SCNPRINTF(&buff[i], len - i, " TEMPCOCOLD=%x",
+		FIELD2VALUE(MAX77759_FG_TEMPCO_TEMPCOCOLD, val));
+#else
+	buff[0] = 0;
+#endif
+	return buff;
+}
+
+/*
+ * VEmpty,0x3A,0b1010010101100001,0xa561
+ * V_Empty[8:1],,,,,,
+ */
+#define MAX77759_FG_VEMPTY	0x3A
+
+#define MAX77759_FG_VEMPTY_V_EMPTY_SHIFT	8
+#define MAX77759_FG_VEMPTY_V_EMPTY_MASK	(0xff << 8)
+#define MAX77759_FG_VEMPTY_V_EMPTY_CLEAR	(~(0xff << 8))
+#define MAX77759_FG_VEMPTY_V_RECOVER_SHIFT	1
+#define MAX77759_FG_VEMPTY_V_RECOVER_MASK	(0x7f << 1)
+#define MAX77759_FG_VEMPTY_V_RECOVER_CLEAR	(~(0x7f << 1))
+
+MAX77759_BFF(fg_vempty_v_empty,15,8)
+MAX77759_BFF(fg_vempty_v_recover,7,1)
+static inline const char *
+max77759_fg_vempty_cstr(char *buff, size_t len, int val)
+{
+#ifdef SCNPRINTF
+	int i = 0;
+
+	i += SCNPRINTF(&buff[i], len - i, " V_EMPTY=%x",
+		FIELD2VALUE(MAX77759_FG_VEMPTY_V_EMPTY, val));
+	i += SCNPRINTF(&buff[i], len - i, " V_RECOVER=%x",
+		FIELD2VALUE(MAX77759_FG_VEMPTY_V_RECOVER, val));
+#else
+	buff[0] = 0;
+#endif
+	return buff;
+}
+
+/*
+ * AvgCurrent0,0x3B,0b111111111111111,0x7fff
+ * AvgCurrent0[15:8],,,,,,
+ */
+#define MAX77759_FG_AVGCURRENT0	0x3B
+
+/*
+ * TaskPeriod,0x3C,0b1011010000000,0x1680
+ * TaskPeriod[15:8],,,,,,
+ */
+#define MAX77759_FG_TASKPERIOD	0x3C
+
+/*
+ * FStat,0x3D,0b00000001,0x01
+ * SPR_15,RDF,SPR_13,DeBn,SRP_11,Relck,RelDt
+ */
+#define MAX77759_FG_FSTAT	0x3D
+#define MAX77759_FG_FSTAT_SPR_15	(0x1 << 15)
+#define MAX77759_FG_FSTAT_RDF	(0x1 << 14)
+#define MAX77759_FG_FSTAT_SPR_13	(0x1 << 13)
+#define MAX77759_FG_FSTAT_DEBN	(0x1 << 12)
+#define MAX77759_FG_FSTAT_SRP_11	(0x1 << 11)
+#define MAX77759_FG_FSTAT_RELCK	(0x1 << 10)
+#define MAX77759_FG_FSTAT_RELDT	(0x1 << 9)
+#define MAX77759_FG_FSTAT_EDET	(0x1 << 8)
+#define MAX77759_FG_FSTAT_FQ	(0x1 << 7)
+#define MAX77759_FG_FSTAT_RELDT2	(0x1 << 6)
+#define MAX77759_FG_FSTAT_TIMER_START	(0x1 << 5)
+#define MAX77759_FG_FSTAT_SPR_4	(0x1 << 4)
+#define MAX77759_FG_FSTAT_ACCEN	(0x1 << 3)
+#define MAX77759_FG_FSTAT_WK	(0x1 << 2)
+#define MAX77759_FG_FSTAT_LDMDL	(0x1 << 1)
+#define MAX77759_FG_FSTAT_DNR	(0x1 << 0)
+
+#define MAX77759_FG_FSTAT_SPR_15_SHIFT	15
+#define MAX77759_FG_FSTAT_SPR_15_MASK	(0x1 << 15)
+#define MAX77759_FG_FSTAT_SPR_15_CLEAR	(~(0x1 << 15))
+#define MAX77759_FG_FSTAT_RDF_SHIFT	14
+#define MAX77759_FG_FSTAT_RDF_MASK	(0x1 << 14)
+#define MAX77759_FG_FSTAT_RDF_CLEAR	(~(0x1 << 14))
+#define MAX77759_FG_FSTAT_SPR_13_SHIFT	13
+#define MAX77759_FG_FSTAT_SPR_13_MASK	(0x1 << 13)
+#define MAX77759_FG_FSTAT_SPR_13_CLEAR	(~(0x1 << 13))
+#define MAX77759_FG_FSTAT_DEBN_SHIFT	12
+#define MAX77759_FG_FSTAT_DEBN_MASK	(0x1 << 12)
+#define MAX77759_FG_FSTAT_DEBN_CLEAR	(~(0x1 << 12))
+#define MAX77759_FG_FSTAT_SRP_11_SHIFT	11
+#define MAX77759_FG_FSTAT_SRP_11_MASK	(0x1 << 11)
+#define MAX77759_FG_FSTAT_SRP_11_CLEAR	(~(0x1 << 11))
+#define MAX77759_FG_FSTAT_RELCK_SHIFT	10
+#define MAX77759_FG_FSTAT_RELCK_MASK	(0x1 << 10)
+#define MAX77759_FG_FSTAT_RELCK_CLEAR	(~(0x1 << 10))
+#define MAX77759_FG_FSTAT_RELDT_SHIFT	9
+#define MAX77759_FG_FSTAT_RELDT_MASK	(0x1 << 9)
+#define MAX77759_FG_FSTAT_RELDT_CLEAR	(~(0x1 << 9))
+#define MAX77759_FG_FSTAT_EDET_SHIFT	8
+#define MAX77759_FG_FSTAT_EDET_MASK	(0x1 << 8)
+#define MAX77759_FG_FSTAT_EDET_CLEAR	(~(0x1 << 8))
+#define MAX77759_FG_FSTAT_FQ_SHIFT	7
+#define MAX77759_FG_FSTAT_FQ_MASK	(0x1 << 7)
+#define MAX77759_FG_FSTAT_FQ_CLEAR	(~(0x1 << 7))
+#define MAX77759_FG_FSTAT_RELDT2_SHIFT	6
+#define MAX77759_FG_FSTAT_RELDT2_MASK	(0x1 << 6)
+#define MAX77759_FG_FSTAT_RELDT2_CLEAR	(~(0x1 << 6))
+#define MAX77759_FG_FSTAT_TIMER_START_SHIFT	5
+#define MAX77759_FG_FSTAT_TIMER_START_MASK	(0x1 << 5)
+#define MAX77759_FG_FSTAT_TIMER_START_CLEAR	(~(0x1 << 5))
+#define MAX77759_FG_FSTAT_SPR_4_SHIFT	4
+#define MAX77759_FG_FSTAT_SPR_4_MASK	(0x1 << 4)
+#define MAX77759_FG_FSTAT_SPR_4_CLEAR	(~(0x1 << 4))
+#define MAX77759_FG_FSTAT_ACCEN_SHIFT	3
+#define MAX77759_FG_FSTAT_ACCEN_MASK	(0x1 << 3)
+#define MAX77759_FG_FSTAT_ACCEN_CLEAR	(~(0x1 << 3))
+#define MAX77759_FG_FSTAT_WK_SHIFT	2
+#define MAX77759_FG_FSTAT_WK_MASK	(0x1 << 2)
+#define MAX77759_FG_FSTAT_WK_CLEAR	(~(0x1 << 2))
+#define MAX77759_FG_FSTAT_LDMDL_SHIFT	1
+#define MAX77759_FG_FSTAT_LDMDL_MASK	(0x1 << 1)
+#define MAX77759_FG_FSTAT_LDMDL_CLEAR	(~(0x1 << 1))
+#define MAX77759_FG_FSTAT_DNR_SHIFT	0
+#define MAX77759_FG_FSTAT_DNR_MASK	(0x1 << 0)
+#define MAX77759_FG_FSTAT_DNR_CLEAR	(~(0x1 << 0))
+
+MAX77759_BFF(fg_fstat_spr_15,15,15)
+MAX77759_BFF(fg_fstat_rdf,14,14)
+MAX77759_BFF(fg_fstat_spr_13,13,13)
+MAX77759_BFF(fg_fstat_debn,12,12)
+MAX77759_BFF(fg_fstat_srp_11,11,11)
+MAX77759_BFF(fg_fstat_relck,10,10)
+MAX77759_BFF(fg_fstat_reldt,9,9)
+MAX77759_BFF(fg_fstat_edet,8,8)
+MAX77759_BFF(fg_fstat_fq,7,7)
+MAX77759_BFF(fg_fstat_reldt2,6,6)
+MAX77759_BFF(fg_fstat_timer_start,5,5)
+MAX77759_BFF(fg_fstat_spr_4,4,4)
+MAX77759_BFF(fg_fstat_accen,3,3)
+MAX77759_BFF(fg_fstat_wk,2,2)
+MAX77759_BFF(fg_fstat_ldmdl,1,1)
+MAX77759_BFF(fg_fstat_dnr,0,0)
+static inline const char *
+max77759_fg_fstat_cstr(char *buff, size_t len, int val)
+{
+#ifdef SCNPRINTF
+	int i = 0;
+
+	i += SCNPRINTF(&buff[i], len - i, " SPR_15=%x",
+		FIELD2VALUE(MAX77759_FG_FSTAT_SPR_15, val));
+	i += SCNPRINTF(&buff[i], len - i, " RDF=%x",
+		FIELD2VALUE(MAX77759_FG_FSTAT_RDF, val));
+	i += SCNPRINTF(&buff[i], len - i, " SPR_13=%x",
+		FIELD2VALUE(MAX77759_FG_FSTAT_SPR_13, val));
+	i += SCNPRINTF(&buff[i], len - i, " DEBN=%x",
+		FIELD2VALUE(MAX77759_FG_FSTAT_DEBN, val));
+	i += SCNPRINTF(&buff[i], len - i, " SRP_11=%x",
+		FIELD2VALUE(MAX77759_FG_FSTAT_SRP_11, val));
+	i += SCNPRINTF(&buff[i], len - i, " RELCK=%x",
+		FIELD2VALUE(MAX77759_FG_FSTAT_RELCK, val));
+	i += SCNPRINTF(&buff[i], len - i, " RELDT=%x",
+		FIELD2VALUE(MAX77759_FG_FSTAT_RELDT, val));
+	i += SCNPRINTF(&buff[i], len - i, " EDET=%x",
+		FIELD2VALUE(MAX77759_FG_FSTAT_EDET, val));
+	i += SCNPRINTF(&buff[i], len - i, " FQ=%x",
+		FIELD2VALUE(MAX77759_FG_FSTAT_FQ, val));
+	i += SCNPRINTF(&buff[i], len - i, " RELDT2=%x",
+		FIELD2VALUE(MAX77759_FG_FSTAT_RELDT2, val));
+	i += SCNPRINTF(&buff[i], len - i, " TIMER_START=%x",
+		FIELD2VALUE(MAX77759_FG_FSTAT_TIMER_START, val));
+	i += SCNPRINTF(&buff[i], len - i, " SPR_4=%x",
+		FIELD2VALUE(MAX77759_FG_FSTAT_SPR_4, val));
+	i += SCNPRINTF(&buff[i], len - i, " ACCEN=%x",
+		FIELD2VALUE(MAX77759_FG_FSTAT_ACCEN, val));
+	i += SCNPRINTF(&buff[i], len - i, " WK=%x",
+		FIELD2VALUE(MAX77759_FG_FSTAT_WK, val));
+	i += SCNPRINTF(&buff[i], len - i, " LDMDL=%x",
+		FIELD2VALUE(MAX77759_FG_FSTAT_LDMDL, val));
+	i += SCNPRINTF(&buff[i], len - i, " DNR=%x",
+		FIELD2VALUE(MAX77759_FG_FSTAT_DNR, val));
+#else
+	buff[0] = 0;
+#endif
+	return buff;
+}
+
+/*
+ * Timer,0x3E,0b00000000,0x00
+ * TIMER[15:8],,,,,,
+ */
+#define MAX77759_FG_TIMER	0x3E
+
+/*
+ * ShdnTimer,0x3F,0b1110000000000000,0xe000
+ * SHDN_THR[2:0],,,SHDNCTR[12:8],,,
+ */
+#define MAX77759_FG_SHDNTIMER	0x3F
+
+#define MAX77759_FG_SHDNTIMER_SHDN_THR_SHIFT	13
+#define MAX77759_FG_SHDNTIMER_SHDN_THR_MASK	(0x7 << 13)
+#define MAX77759_FG_SHDNTIMER_SHDN_THR_CLEAR	(~(0x7 << 13))
+#define MAX77759_FG_SHDNTIMER_SHDNCTR_SHIFT	0
+#define MAX77759_FG_SHDNTIMER_SHDNCTR_MASK	(0x1fff << 0)
+#define MAX77759_FG_SHDNTIMER_SHDNCTR_CLEAR	(~(0x1fff << 0))
+
+MAX77759_BFF(fg_shdntimer_shdn_thr,15,13)
+MAX77759_BFF(fg_shdntimer_shdnctr,12,0)
+static inline const char *
+max77759_fg_shdntimer_cstr(char *buff, size_t len, int val)
+{
+#ifdef SCNPRINTF
+	int i = 0;
+
+	i += SCNPRINTF(&buff[i], len - i, " SHDN_THR=%x",
+		FIELD2VALUE(MAX77759_FG_SHDNTIMER_SHDN_THR, val));
+	i += SCNPRINTF(&buff[i], len - i, " SHDNCTR=%x",
+		FIELD2VALUE(MAX77759_FG_SHDNTIMER_SHDNCTR, val));
+#else
+	buff[0] = 0;
+#endif
+	return buff;
+}
+
+/*
+ * THMHOT,0x40,0b11111111100,0x7fc
+ * VR[4:0],,,,,Vhys[2:0],
+ */
+#define MAX77759_FG_THMHOT	0x40
+
+#define MAX77759_FG_THMHOT_VR_SHIFT	11
+#define MAX77759_FG_THMHOT_VR_MASK	(0x1f << 11)
+#define MAX77759_FG_THMHOT_VR_CLEAR	(~(0x1f << 11))
+#define MAX77759_FG_THMHOT_VHYS_SHIFT	8
+#define MAX77759_FG_THMHOT_VHYS_MASK	(0x7 << 8)
+#define MAX77759_FG_THMHOT_VHYS_CLEAR	(~(0x7 << 8))
+#define MAX77759_FG_THMHOT_TR_SHIFT	3
+#define MAX77759_FG_THMHOT_TR_MASK	(0x1f << 3)
+#define MAX77759_FG_THMHOT_TR_CLEAR	(~(0x1f << 3))
+#define MAX77759_FG_THMHOT_THYS_SHIFT	0
+#define MAX77759_FG_THMHOT_THYS_MASK	(0x7 << 0)
+#define MAX77759_FG_THMHOT_THYS_CLEAR	(~(0x7 << 0))
+
+MAX77759_BFF(fg_thmhot_vr,15,11)
+MAX77759_BFF(fg_thmhot_vhys,10,8)
+MAX77759_BFF(fg_thmhot_tr,7,3)
+MAX77759_BFF(fg_thmhot_thys,2,0)
+static inline const char *
+max77759_fg_thmhot_cstr(char *buff, size_t len, int val)
+{
+#ifdef SCNPRINTF
+	int i = 0;
+
+	i += SCNPRINTF(&buff[i], len - i, " VR=%x",
+		FIELD2VALUE(MAX77759_FG_THMHOT_VR, val));
+	i += SCNPRINTF(&buff[i], len - i, " VHYS=%x",
+		FIELD2VALUE(MAX77759_FG_THMHOT_VHYS, val));
+	i += SCNPRINTF(&buff[i], len - i, " TR=%x",
+		FIELD2VALUE(MAX77759_FG_THMHOT_TR, val));
+	i += SCNPRINTF(&buff[i], len - i, " THYS=%x",
+		FIELD2VALUE(MAX77759_FG_THMHOT_THYS, val));
+#else
+	buff[0] = 0;
+#endif
+	return buff;
+}
+
+/*
+ * CTESample,0x41,0b00000000,0x00
+ * CTESample[15:8],,,,,,
+ */
+#define MAX77759_FG_CTESAMPLE	0x41
+
+/*
+ * QRTable30,0x42,0b100010000101,0x885
+ * QRTable30[15:8],,,,,,
+ */
+#define MAX77759_FG_QRTABLE30	0x42
+
+/*
+ * ISys,0x43,0b00000000,0x00
+ * ISYS[15:8],,,,,,
+ */
+#define MAX77759_FG_ISYS	0x43
+
+/*
+ * AvgVCell0,0x44,0b1000000000000000,0x8000
+ * AvgVCELL0[15:8],,,,,,
+ */
+#define MAX77759_FG_AVGVCELL0	0x44
+
+/*
+ * dQAcc,0x45,0b00010111,0x17
+ * dQacc[15:8],,,,,,
+ */
+#define MAX77759_FG_DQACC	0x45
+
+/*
+ * dPAcc,0x46,0b110010000,0x190
+ * dPacc[15:8],,,,,,
+ */
+#define MAX77759_FG_DPACC	0x46
+
+/*
+ * RlxSOC,0x47,0b00000000,0x00
+ * RlxSOC[15:8],,,,,,
+ */
+#define MAX77759_FG_RLXSOC	0x47
+
+/*
+ * VFSOC0,0x48,0b11001000000000,0x3200
+ * VFSOC0[15:8],,,,,,
+ */
+#define MAX77759_FG_VFSOC0	0x48
+
+/*
+ * ConvgCfg,0x49,0b10001001000001,0x2241
+ * RepLow[3:0],,,,VoltLowOff[4:1],,
+ */
+#define MAX77759_FG_CONVGCFG	0x49
+
+#define MAX77759_FG_CONVGCFG_REPLOW_SHIFT	12
+#define MAX77759_FG_CONVGCFG_REPLOW_MASK	(0xf << 12)
+#define MAX77759_FG_CONVGCFG_REPLOW_CLEAR	(~(0xf << 12))
+#define MAX77759_FG_CONVGCFG_VOLTLOWOFF_SHIFT	8
+#define MAX77759_FG_CONVGCFG_VOLTLOWOFF_MASK	(0xf << 8)
+#define MAX77759_FG_CONVGCFG_VOLTLOWOFF_CLEAR	(~(0xf << 8))
+#define MAX77759_FG_CONVGCFG_MINSLOPEX_SHIFT	4
+#define MAX77759_FG_CONVGCFG_MINSLOPEX_MASK	(0xf << 4)
+#define MAX77759_FG_CONVGCFG_MINSLOPEX_CLEAR	(~(0xf << 4))
+#define MAX77759_FG_CONVGCFG_REPL_PER_STAGE_SHIFT	1
+#define MAX77759_FG_CONVGCFG_REPL_PER_STAGE_MASK	(0x7 << 1)
+#define MAX77759_FG_CONVGCFG_REPL_PER_STAGE_CLEAR	(~(0x7 << 1))
+
+MAX77759_BFF(fg_convgcfg_replow,15,12)
+MAX77759_BFF(fg_convgcfg_voltlowoff,11,8)
+MAX77759_BFF(fg_convgcfg_minslopex,7,4)
+MAX77759_BFF(fg_convgcfg_repl_per_stage,3,1)
+static inline const char *
+max77759_fg_convgcfg_cstr(char *buff, size_t len, int val)
+{
+#ifdef SCNPRINTF
+	int i = 0;
+
+	i += SCNPRINTF(&buff[i], len - i, " REPLOW=%x",
+		FIELD2VALUE(MAX77759_FG_CONVGCFG_REPLOW, val));
+	i += SCNPRINTF(&buff[i], len - i, " VOLTLOWOFF=%x",
+		FIELD2VALUE(MAX77759_FG_CONVGCFG_VOLTLOWOFF, val));
+	i += SCNPRINTF(&buff[i], len - i, " MINSLOPEX=%x",
+		FIELD2VALUE(MAX77759_FG_CONVGCFG_MINSLOPEX, val));
+	i += SCNPRINTF(&buff[i], len - i, " REPL_PER_STAGE=%x",
+		FIELD2VALUE(MAX77759_FG_CONVGCFG_REPL_PER_STAGE, val));
+#else
+	buff[0] = 0;
+#endif
+	return buff;
+}
+
+/*
+ * VFRemCap,0x4A,0b10111011100,0x5dc
+ * VFRemCap[15:8],,,,,,
+ */
+#define MAX77759_FG_VFREMCAP	0x4A
+
+/*
+ * AvgISys,0x4B,0b00000000,0x00
+ * AVGISYS[15:8],,,,,,
+ */
+#define MAX77759_FG_AVGISYS	0x4B
+
+/*
+ * QH0,0x4C,0b00000000,0x00
+ * QH0[15:8],,,,,,
+ */
+#define MAX77759_FG_QH0	0x4C
+
+/*
+ * QH,0x4D,0b00000000,0x00
+ * QH[15:8],,,,,,
+ */
+#define MAX77759_FG_QH	0x4D
+
+/*
+ * QL,0x4E,0b00000000,0x00
+ * QL[15:8],,,,,,
+ */
+#define MAX77759_FG_QL	0x4E
+
+/*
+ * MixAtFull,0x4F,0b101110111000,0xbb8
+ * Reserved[15:8],,,,,,
+ */
+#define MAX77759_FG_MIXATFULL	0x4F
+
+/*
+ * Status2,0xB0,0b00000000,0x00
+ * SPR_15_6[9:2],,,,,,
+ */
+#define MAX77759_FG_STATUS2	0xB0
+#define MAX77759_FG_STATUS2_FULLDET	(0x1 << 5)
+#define MAX77759_FG_STATUS2_HIB	(0x1 << 1)
+#define MAX77759_FG_STATUS2_SPR_0	(0x1 << 0)
+
+#define MAX77759_FG_STATUS2_SPR_15_6_SHIFT	6
+#define MAX77759_FG_STATUS2_SPR_15_6_MASK	(0x3ff << 6)
+#define MAX77759_FG_STATUS2_SPR_15_6_CLEAR	(~(0x3ff << 6))
+#define MAX77759_FG_STATUS2_FULLDET_SHIFT	5
+#define MAX77759_FG_STATUS2_FULLDET_MASK	(0x1 << 5)
+#define MAX77759_FG_STATUS2_FULLDET_CLEAR	(~(0x1 << 5))
+#define MAX77759_FG_STATUS2_SPR_4_2_SHIFT	2
+#define MAX77759_FG_STATUS2_SPR_4_2_MASK	(0x7 << 2)
+#define MAX77759_FG_STATUS2_SPR_4_2_CLEAR	(~(0x7 << 2))
+#define MAX77759_FG_STATUS2_HIB_SHIFT	1
+#define MAX77759_FG_STATUS2_HIB_MASK	(0x1 << 1)
+#define MAX77759_FG_STATUS2_HIB_CLEAR	(~(0x1 << 1))
+#define MAX77759_FG_STATUS2_SPR_0_SHIFT	0
+#define MAX77759_FG_STATUS2_SPR_0_MASK	(0x1 << 0)
+#define MAX77759_FG_STATUS2_SPR_0_CLEAR	(~(0x1 << 0))
+
+MAX77759_BFF(fg_status2_spr_15_6,15,6)
+MAX77759_BFF(fg_status2_fulldet,5,5)
+MAX77759_BFF(fg_status2_spr_4_2,4,2)
+MAX77759_BFF(fg_status2_hib,1,1)
+MAX77759_BFF(fg_status2_spr_0,0,0)
+static inline const char *
+max77759_fg_status2_cstr(char *buff, size_t len, int val)
+{
+#ifdef SCNPRINTF
+	int i = 0;
+
+	i += SCNPRINTF(&buff[i], len - i, " SPR_15_6=%x",
+		FIELD2VALUE(MAX77759_FG_STATUS2_SPR_15_6, val));
+	i += SCNPRINTF(&buff[i], len - i, " FULLDET=%x",
+		FIELD2VALUE(MAX77759_FG_STATUS2_FULLDET, val));
+	i += SCNPRINTF(&buff[i], len - i, " SPR_4_2=%x",
+		FIELD2VALUE(MAX77759_FG_STATUS2_SPR_4_2, val));
+	i += SCNPRINTF(&buff[i], len - i, " HIB=%x",
+		FIELD2VALUE(MAX77759_FG_STATUS2_HIB, val));
+	i += SCNPRINTF(&buff[i], len - i, " SPR_0=%x",
+		FIELD2VALUE(MAX77759_FG_STATUS2_SPR_0, val));
+#else
+	buff[0] = 0;
+#endif
+	return buff;
+}
+
+/*
+ * VSys,0xB1,0b00000000,0x00
+ * VSys[15:8],,,,,,
+ */
+#define MAX77759_FG_VSYS	0xB1
+
+/*
+ * TAlrtTh2,0xB2,0b111111110000000,0x7f80
+ * Reserved[15:8],,,,,,
+ */
+#define MAX77759_FG_TALRTTH2	0xB2
+
+/*
+ * VByp,0xB3,0b00000000,0x00
+ * VByp[15:8],,,,,,
+ */
+#define MAX77759_FG_VBYP	0xB3
+
+/*
+ * IAlrtTh,0xB4,0b111111110000000,0x7f80
+ * ISYSOCP_TH[7:0],,,,,,
+ */
+#define MAX77759_FG_IALRTTH	0xB4
+
+#define MAX77759_FG_IALRTTH_ISYSOCP_TH_SHIFT	8
+#define MAX77759_FG_IALRTTH_ISYSOCP_TH_MASK	(0xff << 8)
+#define MAX77759_FG_IALRTTH_ISYSOCP_TH_CLEAR	(~(0xff << 8))
+#define MAX77759_FG_IALRTTH_IBATTMIN_TH_SHIFT	0
+#define MAX77759_FG_IALRTTH_IBATTMIN_TH_MASK	(0xff << 0)
+#define MAX77759_FG_IALRTTH_IBATTMIN_TH_CLEAR	(~(0xff << 0))
+
+MAX77759_BFF(fg_ialrtth_isysocp_th,15,8)
+MAX77759_BFF(fg_ialrtth_ibattmin_th,7,0)
+static inline const char *
+max77759_fg_ialrtth_cstr(char *buff, size_t len, int val)
+{
+#ifdef SCNPRINTF
+	int i = 0;
+
+	i += SCNPRINTF(&buff[i], len - i, " ISYSOCP_TH=%x",
+		FIELD2VALUE(MAX77759_FG_IALRTTH_ISYSOCP_TH, val));
+	i += SCNPRINTF(&buff[i], len - i, " IBATTMIN_TH=%x",
+		FIELD2VALUE(MAX77759_FG_IALRTTH_IBATTMIN_TH, val));
+#else
+	buff[0] = 0;
+#endif
+	return buff;
+}
+
+/*
+ * TTF_CFG,0xB5,0b00000101,0x05
+ * SPR_15_3[12:5],,,,,,
+ */
+#define MAX77759_FG_TTF_CFG	0xB5
+
+#define MAX77759_FG_TTF_CFG_SPR_15_3_SHIFT	3
+#define MAX77759_FG_TTF_CFG_SPR_15_3_MASK	(0x1fff << 3)
+#define MAX77759_FG_TTF_CFG_SPR_15_3_CLEAR	(~(0x1fff << 3))
+#define MAX77759_FG_TTF_CFG_TTF_CFG_SHIFT	0
+#define MAX77759_FG_TTF_CFG_TTF_CFG_MASK	(0x7 << 0)
+#define MAX77759_FG_TTF_CFG_TTF_CFG_CLEAR	(~(0x7 << 0))
+
+MAX77759_BFF(fg_ttf_cfg_spr_15_3,15,3)
+MAX77759_BFF(fg_ttf_cfg_ttf_cfg,2,0)
+static inline const char *
+max77759_fg_ttf_cfg_cstr(char *buff, size_t len, int val)
+{
+#ifdef SCNPRINTF
+	int i = 0;
+
+	i += SCNPRINTF(&buff[i], len - i, " SPR_15_3=%x",
+		FIELD2VALUE(MAX77759_FG_TTF_CFG_SPR_15_3, val));
+	i += SCNPRINTF(&buff[i], len - i, " TTF_CFG=%x",
+		FIELD2VALUE(MAX77759_FG_TTF_CFG_TTF_CFG, val));
+#else
+	buff[0] = 0;
+#endif
+	return buff;
+}
+
+/*
+ * CV_MixCap,0xB6,0b100011001010,0x8ca
+ * CV_MixCap[15:8],,,,,,
+ */
+#define MAX77759_FG_CV_MIXCAP	0xB6
+
+/*
+ * CV_HalfTime,0xB7,0b101000000000,0xa00
+ * CV_Halftime[15:8],,,,,,
+ */
+#define MAX77759_FG_CV_HALFTIME	0xB7
+
+/*
+ * CGTempCo,0xB8,0b00000000,0x00
+ * Reserved[15:8],,,,,,
+ */
+#define MAX77759_FG_CGTEMPCO	0xB8
+
+/*
+ * Curve,0xB9,0b01101011,0x6b
+ * Reserved[7:0],,,,,,
+ */
+#define MAX77759_FG_CURVE	0xB9
+
+#define MAX77759_FG_CURVE_RESERVED_SHIFT	8
+#define MAX77759_FG_CURVE_RESERVED_MASK	(0xff << 8)
+#define MAX77759_FG_CURVE_RESERVED_CLEAR	(~(0xff << 8))
+#define MAX77759_FG_CURVE_TCURVE_SHIFT	0
+#define MAX77759_FG_CURVE_TCURVE_MASK	(0xff << 0)
+#define MAX77759_FG_CURVE_TCURVE_CLEAR	(~(0xff << 0))
+
+MAX77759_BFF(fg_curve_reserved,15,8)
+MAX77759_BFF(fg_curve_tcurve,7,0)
+static inline const char *
+max77759_fg_curve_cstr(char *buff, size_t len, int val)
+{
+#ifdef SCNPRINTF
+	int i = 0;
+
+	i += SCNPRINTF(&buff[i], len - i, " RESERVED=%x",
+		FIELD2VALUE(MAX77759_FG_CURVE_RESERVED, val));
+	i += SCNPRINTF(&buff[i], len - i, " TCURVE=%x",
+		FIELD2VALUE(MAX77759_FG_CURVE_TCURVE, val));
+#else
+	buff[0] = 0;
+#endif
+	return buff;
+}
+
+/*
+ * HibCfg,0xBA,0b100100001100,0x90c
+ * EnHib,HibEnterTime[2:0],,,HibThreshold[3:0],,
+ */
+#define MAX77759_FG_HIBCFG	0xBA
+#define MAX77759_FG_HIBCFG_ENHIB	(0x1 << 15)
+
+#define MAX77759_FG_HIBCFG_ENHIB_SHIFT	15
+#define MAX77759_FG_HIBCFG_ENHIB_MASK	(0x1 << 15)
+#define MAX77759_FG_HIBCFG_ENHIB_CLEAR	(~(0x1 << 15))
+#define MAX77759_FG_HIBCFG_HIBENTERTIME_SHIFT	12
+#define MAX77759_FG_HIBCFG_HIBENTERTIME_MASK	(0x7 << 12)
+#define MAX77759_FG_HIBCFG_HIBENTERTIME_CLEAR	(~(0x7 << 12))
+#define MAX77759_FG_HIBCFG_HIBTHRESHOLD_SHIFT	8
+#define MAX77759_FG_HIBCFG_HIBTHRESHOLD_MASK	(0xf << 8)
+#define MAX77759_FG_HIBCFG_HIBTHRESHOLD_CLEAR	(~(0xf << 8))
+#define MAX77759_FG_HIBCFG_SPR_7_5_SHIFT	5
+#define MAX77759_FG_HIBCFG_SPR_7_5_MASK	(0x7 << 5)
+#define MAX77759_FG_HIBCFG_SPR_7_5_CLEAR	(~(0x7 << 5))
+#define MAX77759_FG_HIBCFG_HIBEXITTIME_SHIFT	3
+#define MAX77759_FG_HIBCFG_HIBEXITTIME_MASK	(0x3 << 3)
+#define MAX77759_FG_HIBCFG_HIBEXITTIME_CLEAR	(~(0x3 << 3))
+#define MAX77759_FG_HIBCFG_HIBSCALAR_SHIFT	0
+#define MAX77759_FG_HIBCFG_HIBSCALAR_MASK	(0x7 << 0)
+#define MAX77759_FG_HIBCFG_HIBSCALAR_CLEAR	(~(0x7 << 0))
+
+MAX77759_BFF(fg_hibcfg_enhib,15,15)
+MAX77759_BFF(fg_hibcfg_hibentertime,14,12)
+MAX77759_BFF(fg_hibcfg_hibthreshold,11,8)
+MAX77759_BFF(fg_hibcfg_spr_7_5,7,5)
+MAX77759_BFF(fg_hibcfg_hibexittime,4,3)
+MAX77759_BFF(fg_hibcfg_hibscalar,2,0)
+static inline const char *
+max77759_fg_hibcfg_cstr(char *buff, size_t len, int val)
+{
+#ifdef SCNPRINTF
+	int i = 0;
+
+	i += SCNPRINTF(&buff[i], len - i, " ENHIB=%x",
+		FIELD2VALUE(MAX77759_FG_HIBCFG_ENHIB, val));
+	i += SCNPRINTF(&buff[i], len - i, " HIBENTERTIME=%x",
+		FIELD2VALUE(MAX77759_FG_HIBCFG_HIBENTERTIME, val));
+	i += SCNPRINTF(&buff[i], len - i, " HIBTHRESHOLD=%x",
+		FIELD2VALUE(MAX77759_FG_HIBCFG_HIBTHRESHOLD, val));
+	i += SCNPRINTF(&buff[i], len - i, " SPR_7_5=%x",
+		FIELD2VALUE(MAX77759_FG_HIBCFG_SPR_7_5, val));
+	i += SCNPRINTF(&buff[i], len - i, " HIBEXITTIME=%x",
+		FIELD2VALUE(MAX77759_FG_HIBCFG_HIBEXITTIME, val));
+	i += SCNPRINTF(&buff[i], len - i, " HIBSCALAR=%x",
+		FIELD2VALUE(MAX77759_FG_HIBCFG_HIBSCALAR, val));
+#else
+	buff[0] = 0;
+#endif
+	return buff;
+}
+
+/*
+ * Config2,0xBB,0b01010000,0x50
+ * SPR_15_11[4:0],,,,,FCThmHot,ThmHotEn
+ */
+#define MAX77759_FG_CONFIG2	0xBB
+#define MAX77759_FG_CONFIG2_FCTHMHOT	(0x1 << 10)
+#define MAX77759_FG_CONFIG2_THMHOTEN	(0x1 << 9)
+#define MAX77759_FG_CONFIG2_THMHOTALRTEN	(0x1 << 8)
+#define MAX77759_FG_CONFIG2_DSOCEN	(0x1 << 7)
+#define MAX77759_FG_CONFIG2_TALRTEN	(0x1 << 6)
+#define MAX77759_FG_CONFIG2_LDMDL	(0x1 << 5)
+#define MAX77759_FG_CONFIG2_OCVQEN	(0x1 << 4)
+
+#define MAX77759_FG_CONFIG2_SPR_15_11_SHIFT	11
+#define MAX77759_FG_CONFIG2_SPR_15_11_MASK	(0x1f << 11)
+#define MAX77759_FG_CONFIG2_SPR_15_11_CLEAR	(~(0x1f << 11))
+#define MAX77759_FG_CONFIG2_FCTHMHOT_SHIFT	10
+#define MAX77759_FG_CONFIG2_FCTHMHOT_MASK	(0x1 << 10)
+#define MAX77759_FG_CONFIG2_FCTHMHOT_CLEAR	(~(0x1 << 10))
+#define MAX77759_FG_CONFIG2_THMHOTEN_SHIFT	9
+#define MAX77759_FG_CONFIG2_THMHOTEN_MASK	(0x1 << 9)
+#define MAX77759_FG_CONFIG2_THMHOTEN_CLEAR	(~(0x1 << 9))
+#define MAX77759_FG_CONFIG2_THMHOTALRTEN_SHIFT	8
+#define MAX77759_FG_CONFIG2_THMHOTALRTEN_MASK	(0x1 << 8)
+#define MAX77759_FG_CONFIG2_THMHOTALRTEN_CLEAR	(~(0x1 << 8))
+#define MAX77759_FG_CONFIG2_DSOCEN_SHIFT	7
+#define MAX77759_FG_CONFIG2_DSOCEN_MASK	(0x1 << 7)
+#define MAX77759_FG_CONFIG2_DSOCEN_CLEAR	(~(0x1 << 7))
+#define MAX77759_FG_CONFIG2_TALRTEN_SHIFT	6
+#define MAX77759_FG_CONFIG2_TALRTEN_MASK	(0x1 << 6)
+#define MAX77759_FG_CONFIG2_TALRTEN_CLEAR	(~(0x1 << 6))
+#define MAX77759_FG_CONFIG2_LDMDL_SHIFT	5
+#define MAX77759_FG_CONFIG2_LDMDL_MASK	(0x1 << 5)
+#define MAX77759_FG_CONFIG2_LDMDL_CLEAR	(~(0x1 << 5))
+#define MAX77759_FG_CONFIG2_OCVQEN_SHIFT	4
+#define MAX77759_FG_CONFIG2_OCVQEN_MASK	(0x1 << 4)
+#define MAX77759_FG_CONFIG2_OCVQEN_CLEAR	(~(0x1 << 4))
+#define MAX77759_FG_CONFIG2_ISYSNCURR_SHIFT	0
+#define MAX77759_FG_CONFIG2_ISYSNCURR_MASK	(0xf << 0)
+#define MAX77759_FG_CONFIG2_ISYSNCURR_CLEAR	(~(0xf << 0))
+
+MAX77759_BFF(fg_config2_spr_15_11,15,11)
+MAX77759_BFF(fg_config2_fcthmhot,10,10)
+MAX77759_BFF(fg_config2_thmhoten,9,9)
+MAX77759_BFF(fg_config2_thmhotalrten,8,8)
+MAX77759_BFF(fg_config2_dsocen,7,7)
+MAX77759_BFF(fg_config2_talrten,6,6)
+MAX77759_BFF(fg_config2_ldmdl,5,5)
+MAX77759_BFF(fg_config2_ocvqen,4,4)
+MAX77759_BFF(fg_config2_isysncurr,3,0)
+static inline const char *
+max77759_fg_config2_cstr(char *buff, size_t len, int val)
+{
+#ifdef SCNPRINTF
+	int i = 0;
+
+	i += SCNPRINTF(&buff[i], len - i, " SPR_15_11=%x",
+		FIELD2VALUE(MAX77759_FG_CONFIG2_SPR_15_11, val));
+	i += SCNPRINTF(&buff[i], len - i, " FCTHMHOT=%x",
+		FIELD2VALUE(MAX77759_FG_CONFIG2_FCTHMHOT, val));
+	i += SCNPRINTF(&buff[i], len - i, " THMHOTEN=%x",
+		FIELD2VALUE(MAX77759_FG_CONFIG2_THMHOTEN, val));
+	i += SCNPRINTF(&buff[i], len - i, " THMHOTALRTEN=%x",
+		FIELD2VALUE(MAX77759_FG_CONFIG2_THMHOTALRTEN, val));
+	i += SCNPRINTF(&buff[i], len - i, " DSOCEN=%x",
+		FIELD2VALUE(MAX77759_FG_CONFIG2_DSOCEN, val));
+	i += SCNPRINTF(&buff[i], len - i, " TALRTEN=%x",
+		FIELD2VALUE(MAX77759_FG_CONFIG2_TALRTEN, val));
+	i += SCNPRINTF(&buff[i], len - i, " LDMDL=%x",
+		FIELD2VALUE(MAX77759_FG_CONFIG2_LDMDL, val));
+	i += SCNPRINTF(&buff[i], len - i, " OCVQEN=%x",
+		FIELD2VALUE(MAX77759_FG_CONFIG2_OCVQEN, val));
+	i += SCNPRINTF(&buff[i], len - i, " ISYSNCURR=%x",
+		FIELD2VALUE(MAX77759_FG_CONFIG2_ISYSNCURR, val));
+#else
+	buff[0] = 0;
+#endif
+	return buff;
+}
+
+/*
+ * VRipple,0xBC,0b00000000,0x00
+ * Vripple[15:8],,,,,,
+ */
+#define MAX77759_FG_VRIPPLE	0xBC
+
+/*
+ * RippleCfg,0xBD,0b1000000100,0x204
+ * kDV[12:5],,,,,,
+ */
+#define MAX77759_FG_RIPPLECFG	0xBD
+
+#define MAX77759_FG_RIPPLECFG_KDV_SHIFT	3
+#define MAX77759_FG_RIPPLECFG_KDV_MASK	(0x1fff << 3)
+#define MAX77759_FG_RIPPLECFG_KDV_CLEAR	(~(0x1fff << 3))
+#define MAX77759_FG_RIPPLECFG_NR_SHIFT	0
+#define MAX77759_FG_RIPPLECFG_NR_MASK	(0x7 << 0)
+#define MAX77759_FG_RIPPLECFG_NR_CLEAR	(~(0x7 << 0))
+
+MAX77759_BFF(fg_ripplecfg_kdv,15,3)
+MAX77759_BFF(fg_ripplecfg_nr,2,0)
+static inline const char *
+max77759_fg_ripplecfg_cstr(char *buff, size_t len, int val)
+{
+#ifdef SCNPRINTF
+	int i = 0;
+
+	i += SCNPRINTF(&buff[i], len - i, " KDV=%x",
+		FIELD2VALUE(MAX77759_FG_RIPPLECFG_KDV, val));
+	i += SCNPRINTF(&buff[i], len - i, " NR=%x",
+		FIELD2VALUE(MAX77759_FG_RIPPLECFG_NR, val));
+#else
+	buff[0] = 0;
+#endif
+	return buff;
+}
+
+/*
+ * TimerH,0xBE,0b00000000,0x00
+ * TIMERH[15:8],,,,,,
+ */
+#define MAX77759_FG_TIMERH	0xBE
+
+/*
+ * IIn,0xD0,0b00000000,0x00
+ * ,,,,,,
+ */
+#define MAX77759_FG_IIN	0xD0
+
+/*
+ * AtQresidual,0xDC,0b00000000,0x00
+ * AtQresidual[15:8],,,,,,
+ */
+#define MAX77759_FG_ATQRESIDUAL	0xDC
+
+/*
+ * AtTTE,0xDD,0b00000000,0x00
+ * AtTTE[15:8],,,,,,
+ */
+#define MAX77759_FG_ATTTE	0xDD
+
+/*
+ * AtAvSOC,0xDE,0b00000000,0x00
+ * AtAvSOC[15:8],,,,,,
+ */
+#define MAX77759_FG_ATAVSOC	0xDE
+
+/*
+ * AtAvCap,0xDF,0b00000000,0x00
+ * AtAvCap[15:8],,,,,,
+ */
+#define MAX77759_FG_ATAVCAP	0xDF
+
+/*
+ * VFOCV,0xFB,0b00000000,0x00
+ * VFOCV[15:8],,,,,,
+ */
+#define MAX77759_FG_VFOCV	0xFB
+
+/*
+ * VFSOC,0xFF,0b00000000,0x00
+ * VFSOC[15:8],,,,,,
+ */
+#define MAX77759_FG_VFSOC	0xFF
+
+/* section:  USB  */
+
+/*
+ * VENDOR_ID_L,0x0,0b01101010,0x6a
+ * VENDOR_ID_L[7:0],,,,,,
+ */
+#define MAX77759_USB_VENDOR_ID_L	0x0
+
+/*
+ * VENDOR_ID_H,0x1,0b00001011,0x0b
+ * VENDOR_ID_H[7:0],,,,,,
+ */
+#define MAX77759_USB_VENDOR_ID_H	0x1
+
+/*
+ * PRODUCT_ID_L,0x2,0b01011001,0x59
+ * PRODUCT_ID_L[7:0],,,,,,
+ */
+#define MAX77759_USB_PRODUCT_ID_L	0x2
+
+/*
+ * PRODUCT_ID_H,0x3,0b01110111,0x77
+ * PRODUCT_ID_H[7:0],,,,,,
+ */
+#define MAX77759_USB_PRODUCT_ID_H	0x3
+
+/*
+ * DEVICE_ID_L,0x4,0b00000010,0x02
+ * DEVICE_ID_L[7:0],,,,,,
+ */
+#define MAX77759_USB_DEVICE_ID_L	0x4
+
+/*
+ * DEVICE_ID_H,0x5,0b00000000,0x00
+ * DEVICE_ID_H[7:0],,,,,,
+ */
+#define MAX77759_USB_DEVICE_ID_H	0x5
+
+/*
+ * USBTYPEC_REV_L,0x6,0b00010011,0x13
+ * TYPEC_REV_L[7:0],,,,,,
+ */
+#define MAX77759_USB_USBTYPEC_REV_L	0x6
+
+/*
+ * USBTYPEC_REV_H,0x7,0b00000000,0x00
+ * TYPEC_REV_H[7:0],,,,,,
+ */
+#define MAX77759_USB_USBTYPEC_REV_H	0x7
+
+/*
+ * USBPD_REV_VER_L,0x8,0b00010010,0x12
+ * PD_VER[7:0],,,,,,
+ */
+#define MAX77759_USB_USBPD_REV_VER_L	0x8
+
+/*
+ * USBPD_REV_VER_H,0x9,0b00110000,0x30
+ * PD_REV[7:0],,,,,,
+ */
+#define MAX77759_USB_USBPD_REV_VER_H	0x9
+
+/*
+ * PD_INTERFACE_REV_L,0xA,0b00010001,0x11
+ * PD_IF_REV_L[7:0],,,,,,
+ */
+#define MAX77759_USB_PD_INTERFACE_REV_L	0xA
+
+/*
+ * PD_INTERFACE_REV_H,0xB,0b00100000,0x20
+ * PD_IF_REV_H[7:0],,,,,,
+ */
+#define MAX77759_USB_PD_INTERFACE_REV_H	0xB
+
+/*
+ * ALERT_L,0x10,0b00000000,0x00
+ * VBUS_ALARM_HI,TX_SOP_MSG_SUCC,TX_SOP_MSG_DISCRD,TX_SOP_MSG_FAIL,RX_HARD_RST,RX_SOP_MSG_STAT,PWR_STAT
+ */
+#define MAX77759_USB_ALERT_L	0x10
+#define MAX77759_USB_ALERT_L_VBUS_ALARM_HI	(0x1 << 7)
+#define MAX77759_USB_ALERT_L_TX_SOP_MSG_SUCC	(0x1 << 6)
+#define MAX77759_USB_ALERT_L_TX_SOP_MSG_DISCRD	(0x1 << 5)
+#define MAX77759_USB_ALERT_L_TX_SOP_MSG_FAIL	(0x1 << 4)
+#define MAX77759_USB_ALERT_L_RX_HARD_RST	(0x1 << 3)
+#define MAX77759_USB_ALERT_L_RX_SOP_MSG_STAT	(0x1 << 2)
+#define MAX77759_USB_ALERT_L_PWR_STAT	(0x1 << 1)
+#define MAX77759_USB_ALERT_L_CC_STAT	(0x1 << 0)
+
+#define MAX77759_USB_ALERT_L_VBUS_ALARM_HI_SHIFT	7
+#define MAX77759_USB_ALERT_L_VBUS_ALARM_HI_MASK	(0x1 << 7)
+#define MAX77759_USB_ALERT_L_VBUS_ALARM_HI_CLEAR	(~(0x1 << 7))
+#define MAX77759_USB_ALERT_L_TX_SOP_MSG_SUCC_SHIFT	6
+#define MAX77759_USB_ALERT_L_TX_SOP_MSG_SUCC_MASK	(0x1 << 6)
+#define MAX77759_USB_ALERT_L_TX_SOP_MSG_SUCC_CLEAR	(~(0x1 << 6))
+#define MAX77759_USB_ALERT_L_TX_SOP_MSG_DISCRD_SHIFT	5
+#define MAX77759_USB_ALERT_L_TX_SOP_MSG_DISCRD_MASK	(0x1 << 5)
+#define MAX77759_USB_ALERT_L_TX_SOP_MSG_DISCRD_CLEAR	(~(0x1 << 5))
+#define MAX77759_USB_ALERT_L_TX_SOP_MSG_FAIL_SHIFT	4
+#define MAX77759_USB_ALERT_L_TX_SOP_MSG_FAIL_MASK	(0x1 << 4)
+#define MAX77759_USB_ALERT_L_TX_SOP_MSG_FAIL_CLEAR	(~(0x1 << 4))
+#define MAX77759_USB_ALERT_L_RX_HARD_RST_SHIFT	3
+#define MAX77759_USB_ALERT_L_RX_HARD_RST_MASK	(0x1 << 3)
+#define MAX77759_USB_ALERT_L_RX_HARD_RST_CLEAR	(~(0x1 << 3))
+#define MAX77759_USB_ALERT_L_RX_SOP_MSG_STAT_SHIFT	2
+#define MAX77759_USB_ALERT_L_RX_SOP_MSG_STAT_MASK	(0x1 << 2)
+#define MAX77759_USB_ALERT_L_RX_SOP_MSG_STAT_CLEAR	(~(0x1 << 2))
+#define MAX77759_USB_ALERT_L_PWR_STAT_SHIFT	1
+#define MAX77759_USB_ALERT_L_PWR_STAT_MASK	(0x1 << 1)
+#define MAX77759_USB_ALERT_L_PWR_STAT_CLEAR	(~(0x1 << 1))
+#define MAX77759_USB_ALERT_L_CC_STAT_SHIFT	0
+#define MAX77759_USB_ALERT_L_CC_STAT_MASK	(0x1 << 0)
+#define MAX77759_USB_ALERT_L_CC_STAT_CLEAR	(~(0x1 << 0))
+
+MAX77759_BFF(usb_alert_l_vbus_alarm_hi,7,7)
+MAX77759_BFF(usb_alert_l_tx_sop_msg_succ,6,6)
+MAX77759_BFF(usb_alert_l_tx_sop_msg_discrd,5,5)
+MAX77759_BFF(usb_alert_l_tx_sop_msg_fail,4,4)
+MAX77759_BFF(usb_alert_l_rx_hard_rst,3,3)
+MAX77759_BFF(usb_alert_l_rx_sop_msg_stat,2,2)
+MAX77759_BFF(usb_alert_l_pwr_stat,1,1)
+MAX77759_BFF(usb_alert_l_cc_stat,0,0)
+static inline const char *
+max77759_usb_alert_l_cstr(char *buff, size_t len, int val)
+{
+#ifdef SCNPRINTF
+	int i = 0;
+
+	i += SCNPRINTF(&buff[i], len - i, " VBUS_ALARM_HI=%x",
+		FIELD2VALUE(MAX77759_USB_ALERT_L_VBUS_ALARM_HI, val));
+	i += SCNPRINTF(&buff[i], len - i, " TX_SOP_MSG_SUCC=%x",
+		FIELD2VALUE(MAX77759_USB_ALERT_L_TX_SOP_MSG_SUCC, val));
+	i += SCNPRINTF(&buff[i], len - i, " TX_SOP_MSG_DISCRD=%x",
+		FIELD2VALUE(MAX77759_USB_ALERT_L_TX_SOP_MSG_DISCRD, val));
+	i += SCNPRINTF(&buff[i], len - i, " TX_SOP_MSG_FAIL=%x",
+		FIELD2VALUE(MAX77759_USB_ALERT_L_TX_SOP_MSG_FAIL, val));
+	i += SCNPRINTF(&buff[i], len - i, " RX_HARD_RST=%x",
+		FIELD2VALUE(MAX77759_USB_ALERT_L_RX_HARD_RST, val));
+	i += SCNPRINTF(&buff[i], len - i, " RX_SOP_MSG_STAT=%x",
+		FIELD2VALUE(MAX77759_USB_ALERT_L_RX_SOP_MSG_STAT, val));
+	i += SCNPRINTF(&buff[i], len - i, " PWR_STAT=%x",
+		FIELD2VALUE(MAX77759_USB_ALERT_L_PWR_STAT, val));
+	i += SCNPRINTF(&buff[i], len - i, " CC_STAT=%x",
+		FIELD2VALUE(MAX77759_USB_ALERT_L_CC_STAT, val));
+#else
+	buff[0] = 0;
+#endif
+	return buff;
+}
+
+/*
+ * ALERT_H,0x11,0b00000000,0x00
+ * VNDR_ALRT,ALERT_EXTND,EXTND_STAT,RSVD_4,VBUS_SNK_DISC_DET,RX_BUFF_OVRFL,FAULT_STAT
+ */
+#define MAX77759_USB_ALERT_H	0x11
+#define MAX77759_USB_ALERT_H_VNDR_ALRT	(0x1 << 7)
+#define MAX77759_USB_ALERT_H_ALERT_EXTND	(0x1 << 6)
+#define MAX77759_USB_ALERT_H_EXTND_STAT	(0x1 << 5)
+#define MAX77759_USB_ALERT_H_RSVD_4	(0x1 << 4)
+#define MAX77759_USB_ALERT_H_VBUS_SNK_DISC_DET	(0x1 << 3)
+#define MAX77759_USB_ALERT_H_RX_BUFF_OVRFL	(0x1 << 2)
+#define MAX77759_USB_ALERT_H_FAULT_STAT	(0x1 << 1)
+#define MAX77759_USB_ALERT_H_VBUS_ALARM_LO	(0x1 << 0)
+
+#define MAX77759_USB_ALERT_H_VNDR_ALRT_SHIFT	7
+#define MAX77759_USB_ALERT_H_VNDR_ALRT_MASK	(0x1 << 7)
+#define MAX77759_USB_ALERT_H_VNDR_ALRT_CLEAR	(~(0x1 << 7))
+#define MAX77759_USB_ALERT_H_ALERT_EXTND_SHIFT	6
+#define MAX77759_USB_ALERT_H_ALERT_EXTND_MASK	(0x1 << 6)
+#define MAX77759_USB_ALERT_H_ALERT_EXTND_CLEAR	(~(0x1 << 6))
+#define MAX77759_USB_ALERT_H_EXTND_STAT_SHIFT	5
+#define MAX77759_USB_ALERT_H_EXTND_STAT_MASK	(0x1 << 5)
+#define MAX77759_USB_ALERT_H_EXTND_STAT_CLEAR	(~(0x1 << 5))
+#define MAX77759_USB_ALERT_H_RSVD_4_SHIFT	4
+#define MAX77759_USB_ALERT_H_RSVD_4_MASK	(0x1 << 4)
+#define MAX77759_USB_ALERT_H_RSVD_4_CLEAR	(~(0x1 << 4))
+#define MAX77759_USB_ALERT_H_VBUS_SNK_DISC_DET_SHIFT	3
+#define MAX77759_USB_ALERT_H_VBUS_SNK_DISC_DET_MASK	(0x1 << 3)
+#define MAX77759_USB_ALERT_H_VBUS_SNK_DISC_DET_CLEAR	(~(0x1 << 3))
+#define MAX77759_USB_ALERT_H_RX_BUFF_OVRFL_SHIFT	2
+#define MAX77759_USB_ALERT_H_RX_BUFF_OVRFL_MASK	(0x1 << 2)
+#define MAX77759_USB_ALERT_H_RX_BUFF_OVRFL_CLEAR	(~(0x1 << 2))
+#define MAX77759_USB_ALERT_H_FAULT_STAT_SHIFT	1
+#define MAX77759_USB_ALERT_H_FAULT_STAT_MASK	(0x1 << 1)
+#define MAX77759_USB_ALERT_H_FAULT_STAT_CLEAR	(~(0x1 << 1))
+#define MAX77759_USB_ALERT_H_VBUS_ALARM_LO_SHIFT	0
+#define MAX77759_USB_ALERT_H_VBUS_ALARM_LO_MASK	(0x1 << 0)
+#define MAX77759_USB_ALERT_H_VBUS_ALARM_LO_CLEAR	(~(0x1 << 0))
+
+MAX77759_BFF(usb_alert_h_vndr_alrt,7,7)
+MAX77759_BFF(usb_alert_h_alert_extnd,6,6)
+MAX77759_BFF(usb_alert_h_extnd_stat,5,5)
+MAX77759_BFF(usb_alert_h_rsvd_4,4,4)
+MAX77759_BFF(usb_alert_h_vbus_snk_disc_det,3,3)
+MAX77759_BFF(usb_alert_h_rx_buff_ovrfl,2,2)
+MAX77759_BFF(usb_alert_h_fault_stat,1,1)
+MAX77759_BFF(usb_alert_h_vbus_alarm_lo,0,0)
+static inline const char *
+max77759_usb_alert_h_cstr(char *buff, size_t len, int val)
+{
+#ifdef SCNPRINTF
+	int i = 0;
+
+	i += SCNPRINTF(&buff[i], len - i, " VNDR_ALRT=%x",
+		FIELD2VALUE(MAX77759_USB_ALERT_H_VNDR_ALRT, val));
+	i += SCNPRINTF(&buff[i], len - i, " ALERT_EXTND=%x",
+		FIELD2VALUE(MAX77759_USB_ALERT_H_ALERT_EXTND, val));
+	i += SCNPRINTF(&buff[i], len - i, " EXTND_STAT=%x",
+		FIELD2VALUE(MAX77759_USB_ALERT_H_EXTND_STAT, val));
+	i += SCNPRINTF(&buff[i], len - i, " RSVD_4=%x",
+		FIELD2VALUE(MAX77759_USB_ALERT_H_RSVD_4, val));
+	i += SCNPRINTF(&buff[i], len - i, " VBUS_SNK_DISC_DET=%x",
+		FIELD2VALUE(MAX77759_USB_ALERT_H_VBUS_SNK_DISC_DET, val));
+	i += SCNPRINTF(&buff[i], len - i, " RX_BUFF_OVRFL=%x",
+		FIELD2VALUE(MAX77759_USB_ALERT_H_RX_BUFF_OVRFL, val));
+	i += SCNPRINTF(&buff[i], len - i, " FAULT_STAT=%x",
+		FIELD2VALUE(MAX77759_USB_ALERT_H_FAULT_STAT, val));
+	i += SCNPRINTF(&buff[i], len - i, " VBUS_ALARM_LO=%x",
+		FIELD2VALUE(MAX77759_USB_ALERT_H_VBUS_ALARM_LO, val));
+#else
+	buff[0] = 0;
+#endif
+	return buff;
+}
+
+/*
+ * ALERT_MASK_L,0x12,0b11111111,0xff
+ * MSK_VBUS_V_ALRM_HI,MSK_TX_SOP_MSG_SUCC,MSK_TX_SOP_MSG_DISCRD,MSK_TX_SOP_MSG_FAIL,MSK_RX_HARD_RST,MSK_RX_SOP_MSG_STAT,MSK_PWR_STAT
+ */
+#define MAX77759_USB_ALERT_MASK_L	0x12
+#define MAX77759_USB_ALERT_MASK_L_MSK_VBUS_V_ALRM_HI	(0x1 << 7)
+#define MAX77759_USB_ALERT_MASK_L_MSK_TX_SOP_MSG_SUCC	(0x1 << 6)
+#define MAX77759_USB_ALERT_MASK_L_MSK_TX_SOP_MSG_DISCRD	(0x1 << 5)
+#define MAX77759_USB_ALERT_MASK_L_MSK_TX_SOP_MSG_FAIL	(0x1 << 4)
+#define MAX77759_USB_ALERT_MASK_L_MSK_RX_HARD_RST	(0x1 << 3)
+#define MAX77759_USB_ALERT_MASK_L_MSK_RX_SOP_MSG_STAT	(0x1 << 2)
+#define MAX77759_USB_ALERT_MASK_L_MSK_PWR_STAT	(0x1 << 1)
+#define MAX77759_USB_ALERT_MASK_L_MSK_CC_STAT	(0x1 << 0)
+
+#define MAX77759_USB_ALERT_MASK_L_MSK_VBUS_V_ALRM_HI_SHIFT	7
+#define MAX77759_USB_ALERT_MASK_L_MSK_VBUS_V_ALRM_HI_MASK	(0x1 << 7)
+#define MAX77759_USB_ALERT_MASK_L_MSK_VBUS_V_ALRM_HI_CLEAR	(~(0x1 << 7))
+#define MAX77759_USB_ALERT_MASK_L_MSK_TX_SOP_MSG_SUCC_SHIFT	6
+#define MAX77759_USB_ALERT_MASK_L_MSK_TX_SOP_MSG_SUCC_MASK	(0x1 << 6)
+#define MAX77759_USB_ALERT_MASK_L_MSK_TX_SOP_MSG_SUCC_CLEAR	(~(0x1 << 6))
+#define MAX77759_USB_ALERT_MASK_L_MSK_TX_SOP_MSG_DISCRD_SHIFT	5
+#define MAX77759_USB_ALERT_MASK_L_MSK_TX_SOP_MSG_DISCRD_MASK	(0x1 << 5)
+#define MAX77759_USB_ALERT_MASK_L_MSK_TX_SOP_MSG_DISCRD_CLEAR	(~(0x1 << 5))
+#define MAX77759_USB_ALERT_MASK_L_MSK_TX_SOP_MSG_FAIL_SHIFT	4
+#define MAX77759_USB_ALERT_MASK_L_MSK_TX_SOP_MSG_FAIL_MASK	(0x1 << 4)
+#define MAX77759_USB_ALERT_MASK_L_MSK_TX_SOP_MSG_FAIL_CLEAR	(~(0x1 << 4))
+#define MAX77759_USB_ALERT_MASK_L_MSK_RX_HARD_RST_SHIFT	3
+#define MAX77759_USB_ALERT_MASK_L_MSK_RX_HARD_RST_MASK	(0x1 << 3)
+#define MAX77759_USB_ALERT_MASK_L_MSK_RX_HARD_RST_CLEAR	(~(0x1 << 3))
+#define MAX77759_USB_ALERT_MASK_L_MSK_RX_SOP_MSG_STAT_SHIFT	2
+#define MAX77759_USB_ALERT_MASK_L_MSK_RX_SOP_MSG_STAT_MASK	(0x1 << 2)
+#define MAX77759_USB_ALERT_MASK_L_MSK_RX_SOP_MSG_STAT_CLEAR	(~(0x1 << 2))
+#define MAX77759_USB_ALERT_MASK_L_MSK_PWR_STAT_SHIFT	1
+#define MAX77759_USB_ALERT_MASK_L_MSK_PWR_STAT_MASK	(0x1 << 1)
+#define MAX77759_USB_ALERT_MASK_L_MSK_PWR_STAT_CLEAR	(~(0x1 << 1))
+#define MAX77759_USB_ALERT_MASK_L_MSK_CC_STAT_SHIFT	0
+#define MAX77759_USB_ALERT_MASK_L_MSK_CC_STAT_MASK	(0x1 << 0)
+#define MAX77759_USB_ALERT_MASK_L_MSK_CC_STAT_CLEAR	(~(0x1 << 0))
+
+MAX77759_BFF(usb_alert_mask_l_msk_vbus_v_alrm_hi,7,7)
+MAX77759_BFF(usb_alert_mask_l_msk_tx_sop_msg_succ,6,6)
+MAX77759_BFF(usb_alert_mask_l_msk_tx_sop_msg_discrd,5,5)
+MAX77759_BFF(usb_alert_mask_l_msk_tx_sop_msg_fail,4,4)
+MAX77759_BFF(usb_alert_mask_l_msk_rx_hard_rst,3,3)
+MAX77759_BFF(usb_alert_mask_l_msk_rx_sop_msg_stat,2,2)
+MAX77759_BFF(usb_alert_mask_l_msk_pwr_stat,1,1)
+MAX77759_BFF(usb_alert_mask_l_msk_cc_stat,0,0)
+static inline const char *
+max77759_usb_alert_mask_l_cstr(char *buff, size_t len, int val)
+{
+#ifdef SCNPRINTF
+	int i = 0;
+
+	i += SCNPRINTF(&buff[i], len - i, " MSK_VBUS_V_ALRM_HI=%x",
+		FIELD2VALUE(MAX77759_USB_ALERT_MASK_L_MSK_VBUS_V_ALRM_HI, val));
+	i += SCNPRINTF(&buff[i], len - i, " MSK_TX_SOP_MSG_SUCC=%x",
+		FIELD2VALUE(MAX77759_USB_ALERT_MASK_L_MSK_TX_SOP_MSG_SUCC, val));
+	i += SCNPRINTF(&buff[i], len - i, " MSK_TX_SOP_MSG_DISCRD=%x",
+		FIELD2VALUE(MAX77759_USB_ALERT_MASK_L_MSK_TX_SOP_MSG_DISCRD, val));
+	i += SCNPRINTF(&buff[i], len - i, " MSK_TX_SOP_MSG_FAIL=%x",
+		FIELD2VALUE(MAX77759_USB_ALERT_MASK_L_MSK_TX_SOP_MSG_FAIL, val));
+	i += SCNPRINTF(&buff[i], len - i, " MSK_RX_HARD_RST=%x",
+		FIELD2VALUE(MAX77759_USB_ALERT_MASK_L_MSK_RX_HARD_RST, val));
+	i += SCNPRINTF(&buff[i], len - i, " MSK_RX_SOP_MSG_STAT=%x",
+		FIELD2VALUE(MAX77759_USB_ALERT_MASK_L_MSK_RX_SOP_MSG_STAT, val));
+	i += SCNPRINTF(&buff[i], len - i, " MSK_PWR_STAT=%x",
+		FIELD2VALUE(MAX77759_USB_ALERT_MASK_L_MSK_PWR_STAT, val));
+	i += SCNPRINTF(&buff[i], len - i, " MSK_CC_STAT=%x",
+		FIELD2VALUE(MAX77759_USB_ALERT_MASK_L_MSK_CC_STAT, val));
+#else
+	buff[0] = 0;
+#endif
+	return buff;
+}
+
+/*
+ * ALERT_MASK_H,0x13,0b01101111,0x6f
+ * MSK_VNDR_ALRT,MSK_ALRT_EXTND,MSK_EXTND_STAT,RSVD_4,MSK_VBUS_SNK_DISC_DET,MSK_RX_BUFF_OVRFL,MSK_FAULT_STAT
+ */
+#define MAX77759_USB_ALERT_MASK_H	0x13
+#define MAX77759_USB_ALERT_MASK_H_MSK_VNDR_ALRT	(0x1 << 7)
+#define MAX77759_USB_ALERT_MASK_H_MSK_ALRT_EXTND	(0x1 << 6)
+#define MAX77759_USB_ALERT_MASK_H_MSK_EXTND_STAT	(0x1 << 5)
+#define MAX77759_USB_ALERT_MASK_H_RSVD_4	(0x1 << 4)
+#define MAX77759_USB_ALERT_MASK_H_MSK_VBUS_SNK_DISC_DET	(0x1 << 3)
+#define MAX77759_USB_ALERT_MASK_H_MSK_RX_BUFF_OVRFL	(0x1 << 2)
+#define MAX77759_USB_ALERT_MASK_H_MSK_FAULT_STAT	(0x1 << 1)
+#define MAX77759_USB_ALERT_MASK_H_MSK_VBUS_V_ALRM_LO	(0x1 << 0)
+
+#define MAX77759_USB_ALERT_MASK_H_MSK_VNDR_ALRT_SHIFT	7
+#define MAX77759_USB_ALERT_MASK_H_MSK_VNDR_ALRT_MASK	(0x1 << 7)
+#define MAX77759_USB_ALERT_MASK_H_MSK_VNDR_ALRT_CLEAR	(~(0x1 << 7))
+#define MAX77759_USB_ALERT_MASK_H_MSK_ALRT_EXTND_SHIFT	6
+#define MAX77759_USB_ALERT_MASK_H_MSK_ALRT_EXTND_MASK	(0x1 << 6)
+#define MAX77759_USB_ALERT_MASK_H_MSK_ALRT_EXTND_CLEAR	(~(0x1 << 6))
+#define MAX77759_USB_ALERT_MASK_H_MSK_EXTND_STAT_SHIFT	5
+#define MAX77759_USB_ALERT_MASK_H_MSK_EXTND_STAT_MASK	(0x1 << 5)
+#define MAX77759_USB_ALERT_MASK_H_MSK_EXTND_STAT_CLEAR	(~(0x1 << 5))
+#define MAX77759_USB_ALERT_MASK_H_RSVD_4_SHIFT	4
+#define MAX77759_USB_ALERT_MASK_H_RSVD_4_MASK	(0x1 << 4)
+#define MAX77759_USB_ALERT_MASK_H_RSVD_4_CLEAR	(~(0x1 << 4))
+#define MAX77759_USB_ALERT_MASK_H_MSK_VBUS_SNK_DISC_DET_SHIFT	3
+#define MAX77759_USB_ALERT_MASK_H_MSK_VBUS_SNK_DISC_DET_MASK	(0x1 << 3)
+#define MAX77759_USB_ALERT_MASK_H_MSK_VBUS_SNK_DISC_DET_CLEAR	(~(0x1 << 3))
+#define MAX77759_USB_ALERT_MASK_H_MSK_RX_BUFF_OVRFL_SHIFT	2
+#define MAX77759_USB_ALERT_MASK_H_MSK_RX_BUFF_OVRFL_MASK	(0x1 << 2)
+#define MAX77759_USB_ALERT_MASK_H_MSK_RX_BUFF_OVRFL_CLEAR	(~(0x1 << 2))
+#define MAX77759_USB_ALERT_MASK_H_MSK_FAULT_STAT_SHIFT	1
+#define MAX77759_USB_ALERT_MASK_H_MSK_FAULT_STAT_MASK	(0x1 << 1)
+#define MAX77759_USB_ALERT_MASK_H_MSK_FAULT_STAT_CLEAR	(~(0x1 << 1))
+#define MAX77759_USB_ALERT_MASK_H_MSK_VBUS_V_ALRM_LO_SHIFT	0
+#define MAX77759_USB_ALERT_MASK_H_MSK_VBUS_V_ALRM_LO_MASK	(0x1 << 0)
+#define MAX77759_USB_ALERT_MASK_H_MSK_VBUS_V_ALRM_LO_CLEAR	(~(0x1 << 0))
+
+MAX77759_BFF(usb_alert_mask_h_msk_vndr_alrt,7,7)
+MAX77759_BFF(usb_alert_mask_h_msk_alrt_extnd,6,6)
+MAX77759_BFF(usb_alert_mask_h_msk_extnd_stat,5,5)
+MAX77759_BFF(usb_alert_mask_h_rsvd_4,4,4)
+MAX77759_BFF(usb_alert_mask_h_msk_vbus_snk_disc_det,3,3)
+MAX77759_BFF(usb_alert_mask_h_msk_rx_buff_ovrfl,2,2)
+MAX77759_BFF(usb_alert_mask_h_msk_fault_stat,1,1)
+MAX77759_BFF(usb_alert_mask_h_msk_vbus_v_alrm_lo,0,0)
+static inline const char *
+max77759_usb_alert_mask_h_cstr(char *buff, size_t len, int val)
+{
+#ifdef SCNPRINTF
+	int i = 0;
+
+	i += SCNPRINTF(&buff[i], len - i, " MSK_VNDR_ALRT=%x",
+		FIELD2VALUE(MAX77759_USB_ALERT_MASK_H_MSK_VNDR_ALRT, val));
+	i += SCNPRINTF(&buff[i], len - i, " MSK_ALRT_EXTND=%x",
+		FIELD2VALUE(MAX77759_USB_ALERT_MASK_H_MSK_ALRT_EXTND, val));
+	i += SCNPRINTF(&buff[i], len - i, " MSK_EXTND_STAT=%x",
+		FIELD2VALUE(MAX77759_USB_ALERT_MASK_H_MSK_EXTND_STAT, val));
+	i += SCNPRINTF(&buff[i], len - i, " RSVD_4=%x",
+		FIELD2VALUE(MAX77759_USB_ALERT_MASK_H_RSVD_4, val));
+	i += SCNPRINTF(&buff[i], len - i, " MSK_VBUS_SNK_DISC_DET=%x",
+		FIELD2VALUE(MAX77759_USB_ALERT_MASK_H_MSK_VBUS_SNK_DISC_DET, val));
+	i += SCNPRINTF(&buff[i], len - i, " MSK_RX_BUFF_OVRFL=%x",
+		FIELD2VALUE(MAX77759_USB_ALERT_MASK_H_MSK_RX_BUFF_OVRFL, val));
+	i += SCNPRINTF(&buff[i], len - i, " MSK_FAULT_STAT=%x",
+		FIELD2VALUE(MAX77759_USB_ALERT_MASK_H_MSK_FAULT_STAT, val));
+	i += SCNPRINTF(&buff[i], len - i, " MSK_VBUS_V_ALRM_LO=%x",
+		FIELD2VALUE(MAX77759_USB_ALERT_MASK_H_MSK_VBUS_V_ALRM_LO, val));
+#else
+	buff[0] = 0;
+#endif
+	return buff;
+}
+
+/*
+ * POWER_STATUS_MASK_REG,0x14,0b11111111,0xff
+ * MSK_DEBG_ACC_CONN_STAT,MSK_TCPC_INIT_STAT,MSK_SRC_HI_V_STAT,MSK_SRC_VBUS_STAT,MSK_VBUS_DET_STAT,MSK_VBUS_PRSN_STAT,MSK_VCONN_PRSN_STAT
+ */
+#define MAX77759_USB_POWER_STATUS_MASK_REG	0x14
+#define MAX77759_USB_POWER_STATUS_MASK_REG_MSK_DEBG_ACC_CONN_STAT	(0x1 << 7)
+#define MAX77759_USB_POWER_STATUS_MASK_REG_MSK_TCPC_INIT_STAT	(0x1 << 6)
+#define MAX77759_USB_POWER_STATUS_MASK_REG_MSK_SRC_HI_V_STAT	(0x1 << 5)
+#define MAX77759_USB_POWER_STATUS_MASK_REG_MSK_SRC_VBUS_STAT	(0x1 << 4)
+#define MAX77759_USB_POWER_STATUS_MASK_REG_MSK_VBUS_DET_STAT	(0x1 << 3)
+#define MAX77759_USB_POWER_STATUS_MASK_REG_MSK_VBUS_PRSN_STAT	(0x1 << 2)
+#define MAX77759_USB_POWER_STATUS_MASK_REG_MSK_VCONN_PRSN_STAT	(0x1 << 1)
+#define MAX77759_USB_POWER_STATUS_MASK_REG_MSK_SNK_VBUS_STAT	(0x1 << 0)
+
+#define MAX77759_USB_POWER_STATUS_MASK_REG_MSK_DEBG_ACC_CONN_STAT_SHIFT	7
+#define MAX77759_USB_POWER_STATUS_MASK_REG_MSK_DEBG_ACC_CONN_STAT_MASK	(0x1 << 7)
+#define MAX77759_USB_POWER_STATUS_MASK_REG_MSK_DEBG_ACC_CONN_STAT_CLEAR	(~(0x1 << 7))
+#define MAX77759_USB_POWER_STATUS_MASK_REG_MSK_TCPC_INIT_STAT_SHIFT	6
+#define MAX77759_USB_POWER_STATUS_MASK_REG_MSK_TCPC_INIT_STAT_MASK	(0x1 << 6)
+#define MAX77759_USB_POWER_STATUS_MASK_REG_MSK_TCPC_INIT_STAT_CLEAR	(~(0x1 << 6))
+#define MAX77759_USB_POWER_STATUS_MASK_REG_MSK_SRC_HI_V_STAT_SHIFT	5
+#define MAX77759_USB_POWER_STATUS_MASK_REG_MSK_SRC_HI_V_STAT_MASK	(0x1 << 5)
+#define MAX77759_USB_POWER_STATUS_MASK_REG_MSK_SRC_HI_V_STAT_CLEAR	(~(0x1 << 5))
+#define MAX77759_USB_POWER_STATUS_MASK_REG_MSK_SRC_VBUS_STAT_SHIFT	4
+#define MAX77759_USB_POWER_STATUS_MASK_REG_MSK_SRC_VBUS_STAT_MASK	(0x1 << 4)
+#define MAX77759_USB_POWER_STATUS_MASK_REG_MSK_SRC_VBUS_STAT_CLEAR	(~(0x1 << 4))
+#define MAX77759_USB_POWER_STATUS_MASK_REG_MSK_VBUS_DET_STAT_SHIFT	3
+#define MAX77759_USB_POWER_STATUS_MASK_REG_MSK_VBUS_DET_STAT_MASK	(0x1 << 3)
+#define MAX77759_USB_POWER_STATUS_MASK_REG_MSK_VBUS_DET_STAT_CLEAR	(~(0x1 << 3))
+#define MAX77759_USB_POWER_STATUS_MASK_REG_MSK_VBUS_PRSN_STAT_SHIFT	2
+#define MAX77759_USB_POWER_STATUS_MASK_REG_MSK_VBUS_PRSN_STAT_MASK	(0x1 << 2)
+#define MAX77759_USB_POWER_STATUS_MASK_REG_MSK_VBUS_PRSN_STAT_CLEAR	(~(0x1 << 2))
+#define MAX77759_USB_POWER_STATUS_MASK_REG_MSK_VCONN_PRSN_STAT_SHIFT	1
+#define MAX77759_USB_POWER_STATUS_MASK_REG_MSK_VCONN_PRSN_STAT_MASK	(0x1 << 1)
+#define MAX77759_USB_POWER_STATUS_MASK_REG_MSK_VCONN_PRSN_STAT_CLEAR	(~(0x1 << 1))
+#define MAX77759_USB_POWER_STATUS_MASK_REG_MSK_SNK_VBUS_STAT_SHIFT	0
+#define MAX77759_USB_POWER_STATUS_MASK_REG_MSK_SNK_VBUS_STAT_MASK	(0x1 << 0)
+#define MAX77759_USB_POWER_STATUS_MASK_REG_MSK_SNK_VBUS_STAT_CLEAR	(~(0x1 << 0))
+
+MAX77759_BFF(usb_power_status_mask_reg_msk_debg_acc_conn_stat,7,7)
+MAX77759_BFF(usb_power_status_mask_reg_msk_tcpc_init_stat,6,6)
+MAX77759_BFF(usb_power_status_mask_reg_msk_src_hi_v_stat,5,5)
+MAX77759_BFF(usb_power_status_mask_reg_msk_src_vbus_stat,4,4)
+MAX77759_BFF(usb_power_status_mask_reg_msk_vbus_det_stat,3,3)
+MAX77759_BFF(usb_power_status_mask_reg_msk_vbus_prsn_stat,2,2)
+MAX77759_BFF(usb_power_status_mask_reg_msk_vconn_prsn_stat,1,1)
+MAX77759_BFF(usb_power_status_mask_reg_msk_snk_vbus_stat,0,0)
+static inline const char *
+max77759_usb_power_status_mask_reg_cstr(char *buff, size_t len, int val)
+{
+#ifdef SCNPRINTF
+	int i = 0;
+
+	i += SCNPRINTF(&buff[i], len - i, " MSK_DEBG_ACC_CONN_STAT=%x",
+		FIELD2VALUE(MAX77759_USB_POWER_STATUS_MASK_REG_MSK_DEBG_ACC_CONN_STAT, val));
+	i += SCNPRINTF(&buff[i], len - i, " MSK_TCPC_INIT_STAT=%x",
+		FIELD2VALUE(MAX77759_USB_POWER_STATUS_MASK_REG_MSK_TCPC_INIT_STAT, val));
+	i += SCNPRINTF(&buff[i], len - i, " MSK_SRC_HI_V_STAT=%x",
+		FIELD2VALUE(MAX77759_USB_POWER_STATUS_MASK_REG_MSK_SRC_HI_V_STAT, val));
+	i += SCNPRINTF(&buff[i], len - i, " MSK_SRC_VBUS_STAT=%x",
+		FIELD2VALUE(MAX77759_USB_POWER_STATUS_MASK_REG_MSK_SRC_VBUS_STAT, val));
+	i += SCNPRINTF(&buff[i], len - i, " MSK_VBUS_DET_STAT=%x",
+		FIELD2VALUE(MAX77759_USB_POWER_STATUS_MASK_REG_MSK_VBUS_DET_STAT, val));
+	i += SCNPRINTF(&buff[i], len - i, " MSK_VBUS_PRSN_STAT=%x",
+		FIELD2VALUE(MAX77759_USB_POWER_STATUS_MASK_REG_MSK_VBUS_PRSN_STAT, val));
+	i += SCNPRINTF(&buff[i], len - i, " MSK_VCONN_PRSN_STAT=%x",
+		FIELD2VALUE(MAX77759_USB_POWER_STATUS_MASK_REG_MSK_VCONN_PRSN_STAT, val));
+	i += SCNPRINTF(&buff[i], len - i, " MSK_SNK_VBUS_STAT=%x",
+		FIELD2VALUE(MAX77759_USB_POWER_STATUS_MASK_REG_MSK_SNK_VBUS_STAT, val));
+#else
+	buff[0] = 0;
+#endif
+	return buff;
+}
+
+/*
+ * FAULT_STATUS_MASK_REG,0x15,0b11111111,0xff
+ * MSK_All_REG_RST,MSK_FORC_VBUS,MSK_AUTO_DISCH_FAIL,MSK_FORC_DISCH_FAIL,MSK_VBUS_OCP,MSK_VBUS_OVP,MSK_VCONN_OCP
+ */
+#define MAX77759_USB_FAULT_STATUS_MASK_REG	0x15
+#define MAX77759_USB_FAULT_STATUS_MASK_REG_MSK_ALL_REG_RST	(0x1 << 7)
+#define MAX77759_USB_FAULT_STATUS_MASK_REG_MSK_FORC_VBUS	(0x1 << 6)
+#define MAX77759_USB_FAULT_STATUS_MASK_REG_MSK_AUTO_DISCH_FAIL	(0x1 << 5)
+#define MAX77759_USB_FAULT_STATUS_MASK_REG_MSK_FORC_DISCH_FAIL	(0x1 << 4)
+#define MAX77759_USB_FAULT_STATUS_MASK_REG_MSK_VBUS_OCP	(0x1 << 3)
+#define MAX77759_USB_FAULT_STATUS_MASK_REG_MSK_VBUS_OVP	(0x1 << 2)
+#define MAX77759_USB_FAULT_STATUS_MASK_REG_MSK_VCONN_OCP	(0x1 << 1)
+#define MAX77759_USB_FAULT_STATUS_MASK_REG_MSK_I2C_ERR	(0x1 << 0)
+
+#define MAX77759_USB_FAULT_STATUS_MASK_REG_MSK_ALL_REG_RST_SHIFT	7
+#define MAX77759_USB_FAULT_STATUS_MASK_REG_MSK_ALL_REG_RST_MASK	(0x1 << 7)
+#define MAX77759_USB_FAULT_STATUS_MASK_REG_MSK_ALL_REG_RST_CLEAR	(~(0x1 << 7))
+#define MAX77759_USB_FAULT_STATUS_MASK_REG_MSK_FORC_VBUS_SHIFT	6
+#define MAX77759_USB_FAULT_STATUS_MASK_REG_MSK_FORC_VBUS_MASK	(0x1 << 6)
+#define MAX77759_USB_FAULT_STATUS_MASK_REG_MSK_FORC_VBUS_CLEAR	(~(0x1 << 6))
+#define MAX77759_USB_FAULT_STATUS_MASK_REG_MSK_AUTO_DISCH_FAIL_SHIFT	5
+#define MAX77759_USB_FAULT_STATUS_MASK_REG_MSK_AUTO_DISCH_FAIL_MASK	(0x1 << 5)
+#define MAX77759_USB_FAULT_STATUS_MASK_REG_MSK_AUTO_DISCH_FAIL_CLEAR	(~(0x1 << 5))
+#define MAX77759_USB_FAULT_STATUS_MASK_REG_MSK_FORC_DISCH_FAIL_SHIFT	4
+#define MAX77759_USB_FAULT_STATUS_MASK_REG_MSK_FORC_DISCH_FAIL_MASK	(0x1 << 4)
+#define MAX77759_USB_FAULT_STATUS_MASK_REG_MSK_FORC_DISCH_FAIL_CLEAR	(~(0x1 << 4))
+#define MAX77759_USB_FAULT_STATUS_MASK_REG_MSK_VBUS_OCP_SHIFT	3
+#define MAX77759_USB_FAULT_STATUS_MASK_REG_MSK_VBUS_OCP_MASK	(0x1 << 3)
+#define MAX77759_USB_FAULT_STATUS_MASK_REG_MSK_VBUS_OCP_CLEAR	(~(0x1 << 3))
+#define MAX77759_USB_FAULT_STATUS_MASK_REG_MSK_VBUS_OVP_SHIFT	2
+#define MAX77759_USB_FAULT_STATUS_MASK_REG_MSK_VBUS_OVP_MASK	(0x1 << 2)
+#define MAX77759_USB_FAULT_STATUS_MASK_REG_MSK_VBUS_OVP_CLEAR	(~(0x1 << 2))
+#define MAX77759_USB_FAULT_STATUS_MASK_REG_MSK_VCONN_OCP_SHIFT	1
+#define MAX77759_USB_FAULT_STATUS_MASK_REG_MSK_VCONN_OCP_MASK	(0x1 << 1)
+#define MAX77759_USB_FAULT_STATUS_MASK_REG_MSK_VCONN_OCP_CLEAR	(~(0x1 << 1))
+#define MAX77759_USB_FAULT_STATUS_MASK_REG_MSK_I2C_ERR_SHIFT	0
+#define MAX77759_USB_FAULT_STATUS_MASK_REG_MSK_I2C_ERR_MASK	(0x1 << 0)
+#define MAX77759_USB_FAULT_STATUS_MASK_REG_MSK_I2C_ERR_CLEAR	(~(0x1 << 0))
+
+MAX77759_BFF(usb_fault_status_mask_reg_msk_all_reg_rst,7,7)
+MAX77759_BFF(usb_fault_status_mask_reg_msk_forc_vbus,6,6)
+MAX77759_BFF(usb_fault_status_mask_reg_msk_auto_disch_fail,5,5)
+MAX77759_BFF(usb_fault_status_mask_reg_msk_forc_disch_fail,4,4)
+MAX77759_BFF(usb_fault_status_mask_reg_msk_vbus_ocp,3,3)
+MAX77759_BFF(usb_fault_status_mask_reg_msk_vbus_ovp,2,2)
+MAX77759_BFF(usb_fault_status_mask_reg_msk_vconn_ocp,1,1)
+MAX77759_BFF(usb_fault_status_mask_reg_msk_i2c_err,0,0)
+static inline const char *
+max77759_usb_fault_status_mask_reg_cstr(char *buff, size_t len, int val)
+{
+#ifdef SCNPRINTF
+	int i = 0;
+
+	i += SCNPRINTF(&buff[i], len - i, " MSK_ALL_REG_RST=%x",
+		FIELD2VALUE(MAX77759_USB_FAULT_STATUS_MASK_REG_MSK_ALL_REG_RST, val));
+	i += SCNPRINTF(&buff[i], len - i, " MSK_FORC_VBUS=%x",
+		FIELD2VALUE(MAX77759_USB_FAULT_STATUS_MASK_REG_MSK_FORC_VBUS, val));
+	i += SCNPRINTF(&buff[i], len - i, " MSK_AUTO_DISCH_FAIL=%x",
+		FIELD2VALUE(MAX77759_USB_FAULT_STATUS_MASK_REG_MSK_AUTO_DISCH_FAIL, val));
+	i += SCNPRINTF(&buff[i], len - i, " MSK_FORC_DISCH_FAIL=%x",
+		FIELD2VALUE(MAX77759_USB_FAULT_STATUS_MASK_REG_MSK_FORC_DISCH_FAIL, val));
+	i += SCNPRINTF(&buff[i], len - i, " MSK_VBUS_OCP=%x",
+		FIELD2VALUE(MAX77759_USB_FAULT_STATUS_MASK_REG_MSK_VBUS_OCP, val));
+	i += SCNPRINTF(&buff[i], len - i, " MSK_VBUS_OVP=%x",
+		FIELD2VALUE(MAX77759_USB_FAULT_STATUS_MASK_REG_MSK_VBUS_OVP, val));
+	i += SCNPRINTF(&buff[i], len - i, " MSK_VCONN_OCP=%x",
+		FIELD2VALUE(MAX77759_USB_FAULT_STATUS_MASK_REG_MSK_VCONN_OCP, val));
+	i += SCNPRINTF(&buff[i], len - i, " MSK_I2C_ERR=%x",
+		FIELD2VALUE(MAX77759_USB_FAULT_STATUS_MASK_REG_MSK_I2C_ERR, val));
+#else
+	buff[0] = 0;
+#endif
+	return buff;
+}
+
+/*
+ * EXTENDED_STATUS_MASK_REG,0x16,0b00000001,0x01
+ * RSVD_7_1[6:0],,,,,,
+ */
+#define MAX77759_USB_EXTENDED_STATUS_MASK_REG	0x16
+#define MAX77759_USB_EXTENDED_STATUS_MASK_REG_MSK_VSAFE0V	(0x1 << 0)
+
+#define MAX77759_USB_EXTENDED_STATUS_MASK_REG_RSVD_7_1_SHIFT	1
+#define MAX77759_USB_EXTENDED_STATUS_MASK_REG_RSVD_7_1_MASK	(0x7f << 1)
+#define MAX77759_USB_EXTENDED_STATUS_MASK_REG_RSVD_7_1_CLEAR	(~(0x7f << 1))
+#define MAX77759_USB_EXTENDED_STATUS_MASK_REG_MSK_VSAFE0V_SHIFT	0
+#define MAX77759_USB_EXTENDED_STATUS_MASK_REG_MSK_VSAFE0V_MASK	(0x1 << 0)
+#define MAX77759_USB_EXTENDED_STATUS_MASK_REG_MSK_VSAFE0V_CLEAR	(~(0x1 << 0))
+
+MAX77759_BFF(usb_extended_status_mask_reg_rsvd_7_1,7,1)
+MAX77759_BFF(usb_extended_status_mask_reg_msk_vsafe0v,0,0)
+static inline const char *
+max77759_usb_extended_status_mask_reg_cstr(char *buff, size_t len, int val)
+{
+#ifdef SCNPRINTF
+	int i = 0;
+
+	i += SCNPRINTF(&buff[i], len - i, " RSVD_7_1=%x",
+		FIELD2VALUE(MAX77759_USB_EXTENDED_STATUS_MASK_REG_RSVD_7_1, val));
+	i += SCNPRINTF(&buff[i], len - i, " MSK_VSAFE0V=%x",
+		FIELD2VALUE(MAX77759_USB_EXTENDED_STATUS_MASK_REG_MSK_VSAFE0V, val));
+#else
+	buff[0] = 0;
+#endif
+	return buff;
+}
+
+/*
+ * ALERT_EXTENDED_MASK,0x17,0b00000001,0x01
+ * RSVD_7_1[6:0],,,,,,
+ */
+#define MAX77759_USB_ALERT_EXTENDED_MASK	0x17
+#define MAX77759_USB_ALERT_EXTENDED_MASK_MSK_SNK_FRS	(0x1 << 0)
+
+#define MAX77759_USB_ALERT_EXTENDED_MASK_RSVD_7_1_SHIFT	1
+#define MAX77759_USB_ALERT_EXTENDED_MASK_RSVD_7_1_MASK	(0x7f << 1)
+#define MAX77759_USB_ALERT_EXTENDED_MASK_RSVD_7_1_CLEAR	(~(0x7f << 1))
+#define MAX77759_USB_ALERT_EXTENDED_MASK_MSK_SNK_FRS_SHIFT	0
+#define MAX77759_USB_ALERT_EXTENDED_MASK_MSK_SNK_FRS_MASK	(0x1 << 0)
+#define MAX77759_USB_ALERT_EXTENDED_MASK_MSK_SNK_FRS_CLEAR	(~(0x1 << 0))
+
+MAX77759_BFF(usb_alert_extended_mask_rsvd_7_1,7,1)
+MAX77759_BFF(usb_alert_extended_mask_msk_snk_frs,0,0)
+static inline const char *
+max77759_usb_alert_extended_mask_cstr(char *buff, size_t len, int val)
+{
+#ifdef SCNPRINTF
+	int i = 0;
+
+	i += SCNPRINTF(&buff[i], len - i, " RSVD_7_1=%x",
+		FIELD2VALUE(MAX77759_USB_ALERT_EXTENDED_MASK_RSVD_7_1, val));
+	i += SCNPRINTF(&buff[i], len - i, " MSK_SNK_FRS=%x",
+		FIELD2VALUE(MAX77759_USB_ALERT_EXTENDED_MASK_MSK_SNK_FRS, val));
+#else
+	buff[0] = 0;
+#endif
+	return buff;
+}
+
+/*
+ * CONFIG_STANDARD_OUTPUT,0x18,0b01000000,0x40
+ * RSVD_7,DbgAccConn,RSVD_5,RSVD_4_3[1:0],,RSVD_2,RSVD_1
+ */
+#define MAX77759_USB_CONFIG_STANDARD_OUTPUT	0x18
+#define MAX77759_USB_CONFIG_STANDARD_OUTPUT_RSVD_7	(0x1 << 7)
+#define MAX77759_USB_CONFIG_STANDARD_OUTPUT_DBGACCCONN	(0x1 << 6)
+#define MAX77759_USB_CONFIG_STANDARD_OUTPUT_RSVD_5	(0x1 << 5)
+#define MAX77759_USB_CONFIG_STANDARD_OUTPUT_RSVD_2	(0x1 << 2)
+#define MAX77759_USB_CONFIG_STANDARD_OUTPUT_RSVD_1	(0x1 << 1)
+#define MAX77759_USB_CONFIG_STANDARD_OUTPUT_RSVD_0	(0x1 << 0)
+
+#define MAX77759_USB_CONFIG_STANDARD_OUTPUT_RSVD_7_SHIFT	7
+#define MAX77759_USB_CONFIG_STANDARD_OUTPUT_RSVD_7_MASK	(0x1 << 7)
+#define MAX77759_USB_CONFIG_STANDARD_OUTPUT_RSVD_7_CLEAR	(~(0x1 << 7))
+#define MAX77759_USB_CONFIG_STANDARD_OUTPUT_DBGACCCONN_SHIFT	6
+#define MAX77759_USB_CONFIG_STANDARD_OUTPUT_DBGACCCONN_MASK	(0x1 << 6)
+#define MAX77759_USB_CONFIG_STANDARD_OUTPUT_DBGACCCONN_CLEAR	(~(0x1 << 6))
+#define MAX77759_USB_CONFIG_STANDARD_OUTPUT_RSVD_5_SHIFT	5
+#define MAX77759_USB_CONFIG_STANDARD_OUTPUT_RSVD_5_MASK	(0x1 << 5)
+#define MAX77759_USB_CONFIG_STANDARD_OUTPUT_RSVD_5_CLEAR	(~(0x1 << 5))
+#define MAX77759_USB_CONFIG_STANDARD_OUTPUT_RSVD_4_3_SHIFT	3
+#define MAX77759_USB_CONFIG_STANDARD_OUTPUT_RSVD_4_3_MASK	(0x3 << 3)
+#define MAX77759_USB_CONFIG_STANDARD_OUTPUT_RSVD_4_3_CLEAR	(~(0x3 << 3))
+#define MAX77759_USB_CONFIG_STANDARD_OUTPUT_RSVD_2_SHIFT	2
+#define MAX77759_USB_CONFIG_STANDARD_OUTPUT_RSVD_2_MASK	(0x1 << 2)
+#define MAX77759_USB_CONFIG_STANDARD_OUTPUT_RSVD_2_CLEAR	(~(0x1 << 2))
+#define MAX77759_USB_CONFIG_STANDARD_OUTPUT_RSVD_1_SHIFT	1
+#define MAX77759_USB_CONFIG_STANDARD_OUTPUT_RSVD_1_MASK	(0x1 << 1)
+#define MAX77759_USB_CONFIG_STANDARD_OUTPUT_RSVD_1_CLEAR	(~(0x1 << 1))
+#define MAX77759_USB_CONFIG_STANDARD_OUTPUT_RSVD_0_SHIFT	0
+#define MAX77759_USB_CONFIG_STANDARD_OUTPUT_RSVD_0_MASK	(0x1 << 0)
+#define MAX77759_USB_CONFIG_STANDARD_OUTPUT_RSVD_0_CLEAR	(~(0x1 << 0))
+
+MAX77759_BFF(usb_config_standard_output_rsvd_7,7,7)
+MAX77759_BFF(usb_config_standard_output_dbgaccconn,6,6)
+MAX77759_BFF(usb_config_standard_output_rsvd_5,5,5)
+MAX77759_BFF(usb_config_standard_output_rsvd_4_3,4,3)
+MAX77759_BFF(usb_config_standard_output_rsvd_2,2,2)
+MAX77759_BFF(usb_config_standard_output_rsvd_1,1,1)
+MAX77759_BFF(usb_config_standard_output_rsvd_0,0,0)
+static inline const char *
+max77759_usb_config_standard_output_cstr(char *buff, size_t len, int val)
+{
+#ifdef SCNPRINTF
+	int i = 0;
+
+	i += SCNPRINTF(&buff[i], len - i, " RSVD_7=%x",
+		FIELD2VALUE(MAX77759_USB_CONFIG_STANDARD_OUTPUT_RSVD_7, val));
+	i += SCNPRINTF(&buff[i], len - i, " DBGACCCONN=%x",
+		FIELD2VALUE(MAX77759_USB_CONFIG_STANDARD_OUTPUT_DBGACCCONN, val));
+	i += SCNPRINTF(&buff[i], len - i, " RSVD_5=%x",
+		FIELD2VALUE(MAX77759_USB_CONFIG_STANDARD_OUTPUT_RSVD_5, val));
+	i += SCNPRINTF(&buff[i], len - i, " RSVD_4_3=%x",
+		FIELD2VALUE(MAX77759_USB_CONFIG_STANDARD_OUTPUT_RSVD_4_3, val));
+	i += SCNPRINTF(&buff[i], len - i, " RSVD_2=%x",
+		FIELD2VALUE(MAX77759_USB_CONFIG_STANDARD_OUTPUT_RSVD_2, val));
+	i += SCNPRINTF(&buff[i], len - i, " RSVD_1=%x",
+		FIELD2VALUE(MAX77759_USB_CONFIG_STANDARD_OUTPUT_RSVD_1, val));
+	i += SCNPRINTF(&buff[i], len - i, " RSVD_0=%x",
+		FIELD2VALUE(MAX77759_USB_CONFIG_STANDARD_OUTPUT_RSVD_0, val));
+#else
+	buff[0] = 0;
+#endif
+	return buff;
+}
+
+/*
+ * TCPC_CONTROL_REG,0x19,0b00000000,0x00
+ * RSVD_7,EN_LK4CONN_ALRT,EN_WD_TMR,DBG_ACC_CNTRL,RSVD_3_2[1:0],,BIST_TM
+ */
+#define MAX77759_USB_TCPC_CONTROL_REG	0x19
+#define MAX77759_USB_TCPC_CONTROL_REG_RSVD_7	(0x1 << 7)
+#define MAX77759_USB_TCPC_CONTROL_REG_EN_LK4CONN_ALRT	(0x1 << 6)
+#define MAX77759_USB_TCPC_CONTROL_REG_EN_WD_TMR	(0x1 << 5)
+#define MAX77759_USB_TCPC_CONTROL_REG_DBG_ACC_CNTRL	(0x1 << 4)
+#define MAX77759_USB_TCPC_CONTROL_REG_BIST_TM	(0x1 << 1)
+#define MAX77759_USB_TCPC_CONTROL_REG_PLUG_ORNT	(0x1 << 0)
+
+#define MAX77759_USB_TCPC_CONTROL_REG_RSVD_7_SHIFT	7
+#define MAX77759_USB_TCPC_CONTROL_REG_RSVD_7_MASK	(0x1 << 7)
+#define MAX77759_USB_TCPC_CONTROL_REG_RSVD_7_CLEAR	(~(0x1 << 7))
+#define MAX77759_USB_TCPC_CONTROL_REG_EN_LK4CONN_ALRT_SHIFT	6
+#define MAX77759_USB_TCPC_CONTROL_REG_EN_LK4CONN_ALRT_MASK	(0x1 << 6)
+#define MAX77759_USB_TCPC_CONTROL_REG_EN_LK4CONN_ALRT_CLEAR	(~(0x1 << 6))
+#define MAX77759_USB_TCPC_CONTROL_REG_EN_WD_TMR_SHIFT	5
+#define MAX77759_USB_TCPC_CONTROL_REG_EN_WD_TMR_MASK	(0x1 << 5)
+#define MAX77759_USB_TCPC_CONTROL_REG_EN_WD_TMR_CLEAR	(~(0x1 << 5))
+#define MAX77759_USB_TCPC_CONTROL_REG_DBG_ACC_CNTRL_SHIFT	4
+#define MAX77759_USB_TCPC_CONTROL_REG_DBG_ACC_CNTRL_MASK	(0x1 << 4)
+#define MAX77759_USB_TCPC_CONTROL_REG_DBG_ACC_CNTRL_CLEAR	(~(0x1 << 4))
+#define MAX77759_USB_TCPC_CONTROL_REG_RSVD_3_2_SHIFT	2
+#define MAX77759_USB_TCPC_CONTROL_REG_RSVD_3_2_MASK	(0x3 << 2)
+#define MAX77759_USB_TCPC_CONTROL_REG_RSVD_3_2_CLEAR	(~(0x3 << 2))
+#define MAX77759_USB_TCPC_CONTROL_REG_BIST_TM_SHIFT	1
+#define MAX77759_USB_TCPC_CONTROL_REG_BIST_TM_MASK	(0x1 << 1)
+#define MAX77759_USB_TCPC_CONTROL_REG_BIST_TM_CLEAR	(~(0x1 << 1))
+#define MAX77759_USB_TCPC_CONTROL_REG_PLUG_ORNT_SHIFT	0
+#define MAX77759_USB_TCPC_CONTROL_REG_PLUG_ORNT_MASK	(0x1 << 0)
+#define MAX77759_USB_TCPC_CONTROL_REG_PLUG_ORNT_CLEAR	(~(0x1 << 0))
+
+MAX77759_BFF(usb_tcpc_control_reg_rsvd_7,7,7)
+MAX77759_BFF(usb_tcpc_control_reg_en_lk4conn_alrt,6,6)
+MAX77759_BFF(usb_tcpc_control_reg_en_wd_tmr,5,5)
+MAX77759_BFF(usb_tcpc_control_reg_dbg_acc_cntrl,4,4)
+MAX77759_BFF(usb_tcpc_control_reg_rsvd_3_2,3,2)
+MAX77759_BFF(usb_tcpc_control_reg_bist_tm,1,1)
+MAX77759_BFF(usb_tcpc_control_reg_plug_ornt,0,0)
+static inline const char *
+max77759_usb_tcpc_control_reg_cstr(char *buff, size_t len, int val)
+{
+#ifdef SCNPRINTF
+	int i = 0;
+
+	i += SCNPRINTF(&buff[i], len - i, " RSVD_7=%x",
+		FIELD2VALUE(MAX77759_USB_TCPC_CONTROL_REG_RSVD_7, val));
+	i += SCNPRINTF(&buff[i], len - i, " EN_LK4CONN_ALRT=%x",
+		FIELD2VALUE(MAX77759_USB_TCPC_CONTROL_REG_EN_LK4CONN_ALRT, val));
+	i += SCNPRINTF(&buff[i], len - i, " EN_WD_TMR=%x",
+		FIELD2VALUE(MAX77759_USB_TCPC_CONTROL_REG_EN_WD_TMR, val));
+	i += SCNPRINTF(&buff[i], len - i, " DBG_ACC_CNTRL=%x",
+		FIELD2VALUE(MAX77759_USB_TCPC_CONTROL_REG_DBG_ACC_CNTRL, val));
+	i += SCNPRINTF(&buff[i], len - i, " RSVD_3_2=%x",
+		FIELD2VALUE(MAX77759_USB_TCPC_CONTROL_REG_RSVD_3_2, val));
+	i += SCNPRINTF(&buff[i], len - i, " BIST_TM=%x",
+		FIELD2VALUE(MAX77759_USB_TCPC_CONTROL_REG_BIST_TM, val));
+	i += SCNPRINTF(&buff[i], len - i, " PLUG_ORNT=%x",
+		FIELD2VALUE(MAX77759_USB_TCPC_CONTROL_REG_PLUG_ORNT, val));
+#else
+	buff[0] = 0;
+#endif
+	return buff;
+}
+
+/*
+ * ROLE_CONTROL_REG,0x1A,0b00001010,0x0a
+ * RSVD_7,DRP,RP_VAL[1:0],,CC2[1:0],,CC1[1:0]
+ */
+#define MAX77759_USB_ROLE_CONTROL_REG	0x1A
+#define MAX77759_USB_ROLE_CONTROL_REG_RSVD_7	(0x1 << 7)
+#define MAX77759_USB_ROLE_CONTROL_REG_DRP	(0x1 << 6)
+
+#define MAX77759_USB_ROLE_CONTROL_REG_RSVD_7_SHIFT	7
+#define MAX77759_USB_ROLE_CONTROL_REG_RSVD_7_MASK	(0x1 << 7)
+#define MAX77759_USB_ROLE_CONTROL_REG_RSVD_7_CLEAR	(~(0x1 << 7))
+#define MAX77759_USB_ROLE_CONTROL_REG_DRP_SHIFT	6
+#define MAX77759_USB_ROLE_CONTROL_REG_DRP_MASK	(0x1 << 6)
+#define MAX77759_USB_ROLE_CONTROL_REG_DRP_CLEAR	(~(0x1 << 6))
+#define MAX77759_USB_ROLE_CONTROL_REG_RP_VAL_SHIFT	4
+#define MAX77759_USB_ROLE_CONTROL_REG_RP_VAL_MASK	(0x3 << 4)
+#define MAX77759_USB_ROLE_CONTROL_REG_RP_VAL_CLEAR	(~(0x3 << 4))
+#define MAX77759_USB_ROLE_CONTROL_REG_CC2_SHIFT	2
+#define MAX77759_USB_ROLE_CONTROL_REG_CC2_MASK	(0x3 << 2)
+#define MAX77759_USB_ROLE_CONTROL_REG_CC2_CLEAR	(~(0x3 << 2))
+#define MAX77759_USB_ROLE_CONTROL_REG_CC1_SHIFT	0
+#define MAX77759_USB_ROLE_CONTROL_REG_CC1_MASK	(0x3 << 0)
+#define MAX77759_USB_ROLE_CONTROL_REG_CC1_CLEAR	(~(0x3 << 0))
+
+MAX77759_BFF(usb_role_control_reg_rsvd_7,7,7)
+MAX77759_BFF(usb_role_control_reg_drp,6,6)
+MAX77759_BFF(usb_role_control_reg_rp_val,5,4)
+MAX77759_BFF(usb_role_control_reg_cc2,3,2)
+MAX77759_BFF(usb_role_control_reg_cc1,1,0)
+static inline const char *
+max77759_usb_role_control_reg_cstr(char *buff, size_t len, int val)
+{
+#ifdef SCNPRINTF
+	int i = 0;
+
+	i += SCNPRINTF(&buff[i], len - i, " RSVD_7=%x",
+		FIELD2VALUE(MAX77759_USB_ROLE_CONTROL_REG_RSVD_7, val));
+	i += SCNPRINTF(&buff[i], len - i, " DRP=%x",
+		FIELD2VALUE(MAX77759_USB_ROLE_CONTROL_REG_DRP, val));
+	i += SCNPRINTF(&buff[i], len - i, " RP_VAL=%x",
+		FIELD2VALUE(MAX77759_USB_ROLE_CONTROL_REG_RP_VAL, val));
+	i += SCNPRINTF(&buff[i], len - i, " CC2=%x",
+		FIELD2VALUE(MAX77759_USB_ROLE_CONTROL_REG_CC2, val));
+	i += SCNPRINTF(&buff[i], len - i, " CC1=%x",
+		FIELD2VALUE(MAX77759_USB_ROLE_CONTROL_REG_CC1, val));
+#else
+	buff[0] = 0;
+#endif
+	return buff;
+}
+
+/*
+ * FAULT_CONTROL_REG,0x1B,0b00000000,0x00
+ * RSVD_7_5[2:0],,,RSVD_4,VBUS_DISCH_FAIL_DIS,RSVD_2,RSVD_1
+ */
+#define MAX77759_USB_FAULT_CONTROL_REG	0x1B
+#define MAX77759_USB_FAULT_CONTROL_REG_RSVD_4	(0x1 << 4)
+#define MAX77759_USB_FAULT_CONTROL_REG_VBUS_DISCH_FAIL_DIS	(0x1 << 3)
+#define MAX77759_USB_FAULT_CONTROL_REG_RSVD_2	(0x1 << 2)
+#define MAX77759_USB_FAULT_CONTROL_REG_RSVD_1	(0x1 << 1)
+#define MAX77759_USB_FAULT_CONTROL_REG_VCONN_OCP_FAULT_DIS	(0x1 << 0)
+
+#define MAX77759_USB_FAULT_CONTROL_REG_RSVD_7_5_SHIFT	5
+#define MAX77759_USB_FAULT_CONTROL_REG_RSVD_7_5_MASK	(0x7 << 5)
+#define MAX77759_USB_FAULT_CONTROL_REG_RSVD_7_5_CLEAR	(~(0x7 << 5))
+#define MAX77759_USB_FAULT_CONTROL_REG_RSVD_4_SHIFT	4
+#define MAX77759_USB_FAULT_CONTROL_REG_RSVD_4_MASK	(0x1 << 4)
+#define MAX77759_USB_FAULT_CONTROL_REG_RSVD_4_CLEAR	(~(0x1 << 4))
+#define MAX77759_USB_FAULT_CONTROL_REG_VBUS_DISCH_FAIL_DIS_SHIFT	3
+#define MAX77759_USB_FAULT_CONTROL_REG_VBUS_DISCH_FAIL_DIS_MASK	(0x1 << 3)
+#define MAX77759_USB_FAULT_CONTROL_REG_VBUS_DISCH_FAIL_DIS_CLEAR	(~(0x1 << 3))
+#define MAX77759_USB_FAULT_CONTROL_REG_RSVD_2_SHIFT	2
+#define MAX77759_USB_FAULT_CONTROL_REG_RSVD_2_MASK	(0x1 << 2)
+#define MAX77759_USB_FAULT_CONTROL_REG_RSVD_2_CLEAR	(~(0x1 << 2))
+#define MAX77759_USB_FAULT_CONTROL_REG_RSVD_1_SHIFT	1
+#define MAX77759_USB_FAULT_CONTROL_REG_RSVD_1_MASK	(0x1 << 1)
+#define MAX77759_USB_FAULT_CONTROL_REG_RSVD_1_CLEAR	(~(0x1 << 1))
+#define MAX77759_USB_FAULT_CONTROL_REG_VCONN_OCP_FAULT_DIS_SHIFT	0
+#define MAX77759_USB_FAULT_CONTROL_REG_VCONN_OCP_FAULT_DIS_MASK	(0x1 << 0)
+#define MAX77759_USB_FAULT_CONTROL_REG_VCONN_OCP_FAULT_DIS_CLEAR	(~(0x1 << 0))
+
+MAX77759_BFF(usb_fault_control_reg_rsvd_7_5,7,5)
+MAX77759_BFF(usb_fault_control_reg_rsvd_4,4,4)
+MAX77759_BFF(usb_fault_control_reg_vbus_disch_fail_dis,3,3)
+MAX77759_BFF(usb_fault_control_reg_rsvd_2,2,2)
+MAX77759_BFF(usb_fault_control_reg_rsvd_1,1,1)
+MAX77759_BFF(usb_fault_control_reg_vconn_ocp_fault_dis,0,0)
+static inline const char *
+max77759_usb_fault_control_reg_cstr(char *buff, size_t len, int val)
+{
+#ifdef SCNPRINTF
+	int i = 0;
+
+	i += SCNPRINTF(&buff[i], len - i, " RSVD_7_5=%x",
+		FIELD2VALUE(MAX77759_USB_FAULT_CONTROL_REG_RSVD_7_5, val));
+	i += SCNPRINTF(&buff[i], len - i, " RSVD_4=%x",
+		FIELD2VALUE(MAX77759_USB_FAULT_CONTROL_REG_RSVD_4, val));
+	i += SCNPRINTF(&buff[i], len - i, " VBUS_DISCH_FAIL_DIS=%x",
+		FIELD2VALUE(MAX77759_USB_FAULT_CONTROL_REG_VBUS_DISCH_FAIL_DIS, val));
+	i += SCNPRINTF(&buff[i], len - i, " RSVD_2=%x",
+		FIELD2VALUE(MAX77759_USB_FAULT_CONTROL_REG_RSVD_2, val));
+	i += SCNPRINTF(&buff[i], len - i, " RSVD_1=%x",
+		FIELD2VALUE(MAX77759_USB_FAULT_CONTROL_REG_RSVD_1, val));
+	i += SCNPRINTF(&buff[i], len - i, " VCONN_OCP_FAULT_DIS=%x",
+		FIELD2VALUE(MAX77759_USB_FAULT_CONTROL_REG_VCONN_OCP_FAULT_DIS, val));
+#else
+	buff[0] = 0;
+#endif
+	return buff;
+}
+
+/*
+ * POWER_CONTROL_REG,0x1C,0b01100000,0x60
+ * FAST_RSWP_EN,VBUS_VOLT_MON,DIS_VOLT_ALRM,AUTO_DISCH_DISC,EN_BLEED_DISCH,FORC_DISCH,RSVD_1
+ */
+#define MAX77759_USB_POWER_CONTROL_REG	0x1C
+#define MAX77759_USB_POWER_CONTROL_REG_FAST_RSWP_EN	(0x1 << 7)
+#define MAX77759_USB_POWER_CONTROL_REG_VBUS_VOLT_MON	(0x1 << 6)
+#define MAX77759_USB_POWER_CONTROL_REG_DIS_VOLT_ALRM	(0x1 << 5)
+#define MAX77759_USB_POWER_CONTROL_REG_AUTO_DISCH_DISC	(0x1 << 4)
+#define MAX77759_USB_POWER_CONTROL_REG_EN_BLEED_DISCH	(0x1 << 3)
+#define MAX77759_USB_POWER_CONTROL_REG_FORC_DISCH	(0x1 << 2)
+#define MAX77759_USB_POWER_CONTROL_REG_RSVD_1	(0x1 << 1)
+#define MAX77759_USB_POWER_CONTROL_REG_EN_VCONN	(0x1 << 0)
+
+#define MAX77759_USB_POWER_CONTROL_REG_FAST_RSWP_EN_SHIFT	7
+#define MAX77759_USB_POWER_CONTROL_REG_FAST_RSWP_EN_MASK	(0x1 << 7)
+#define MAX77759_USB_POWER_CONTROL_REG_FAST_RSWP_EN_CLEAR	(~(0x1 << 7))
+#define MAX77759_USB_POWER_CONTROL_REG_VBUS_VOLT_MON_SHIFT	6
+#define MAX77759_USB_POWER_CONTROL_REG_VBUS_VOLT_MON_MASK	(0x1 << 6)
+#define MAX77759_USB_POWER_CONTROL_REG_VBUS_VOLT_MON_CLEAR	(~(0x1 << 6))
+#define MAX77759_USB_POWER_CONTROL_REG_DIS_VOLT_ALRM_SHIFT	5
+#define MAX77759_USB_POWER_CONTROL_REG_DIS_VOLT_ALRM_MASK	(0x1 << 5)
+#define MAX77759_USB_POWER_CONTROL_REG_DIS_VOLT_ALRM_CLEAR	(~(0x1 << 5))
+#define MAX77759_USB_POWER_CONTROL_REG_AUTO_DISCH_DISC_SHIFT	4
+#define MAX77759_USB_POWER_CONTROL_REG_AUTO_DISCH_DISC_MASK	(0x1 << 4)
+#define MAX77759_USB_POWER_CONTROL_REG_AUTO_DISCH_DISC_CLEAR	(~(0x1 << 4))
+#define MAX77759_USB_POWER_CONTROL_REG_EN_BLEED_DISCH_SHIFT	3
+#define MAX77759_USB_POWER_CONTROL_REG_EN_BLEED_DISCH_MASK	(0x1 << 3)
+#define MAX77759_USB_POWER_CONTROL_REG_EN_BLEED_DISCH_CLEAR	(~(0x1 << 3))
+#define MAX77759_USB_POWER_CONTROL_REG_FORC_DISCH_SHIFT	2
+#define MAX77759_USB_POWER_CONTROL_REG_FORC_DISCH_MASK	(0x1 << 2)
+#define MAX77759_USB_POWER_CONTROL_REG_FORC_DISCH_CLEAR	(~(0x1 << 2))
+#define MAX77759_USB_POWER_CONTROL_REG_RSVD_1_SHIFT	1
+#define MAX77759_USB_POWER_CONTROL_REG_RSVD_1_MASK	(0x1 << 1)
+#define MAX77759_USB_POWER_CONTROL_REG_RSVD_1_CLEAR	(~(0x1 << 1))
+#define MAX77759_USB_POWER_CONTROL_REG_EN_VCONN_SHIFT	0
+#define MAX77759_USB_POWER_CONTROL_REG_EN_VCONN_MASK	(0x1 << 0)
+#define MAX77759_USB_POWER_CONTROL_REG_EN_VCONN_CLEAR	(~(0x1 << 0))
+
+MAX77759_BFF(usb_power_control_reg_fast_rswp_en,7,7)
+MAX77759_BFF(usb_power_control_reg_vbus_volt_mon,6,6)
+MAX77759_BFF(usb_power_control_reg_dis_volt_alrm,5,5)
+MAX77759_BFF(usb_power_control_reg_auto_disch_disc,4,4)
+MAX77759_BFF(usb_power_control_reg_en_bleed_disch,3,3)
+MAX77759_BFF(usb_power_control_reg_forc_disch,2,2)
+MAX77759_BFF(usb_power_control_reg_rsvd_1,1,1)
+MAX77759_BFF(usb_power_control_reg_en_vconn,0,0)
+static inline const char *
+max77759_usb_power_control_reg_cstr(char *buff, size_t len, int val)
+{
+#ifdef SCNPRINTF
+	int i = 0;
+
+	i += SCNPRINTF(&buff[i], len - i, " FAST_RSWP_EN=%x",
+		FIELD2VALUE(MAX77759_USB_POWER_CONTROL_REG_FAST_RSWP_EN, val));
+	i += SCNPRINTF(&buff[i], len - i, " VBUS_VOLT_MON=%x",
+		FIELD2VALUE(MAX77759_USB_POWER_CONTROL_REG_VBUS_VOLT_MON, val));
+	i += SCNPRINTF(&buff[i], len - i, " DIS_VOLT_ALRM=%x",
+		FIELD2VALUE(MAX77759_USB_POWER_CONTROL_REG_DIS_VOLT_ALRM, val));
+	i += SCNPRINTF(&buff[i], len - i, " AUTO_DISCH_DISC=%x",
+		FIELD2VALUE(MAX77759_USB_POWER_CONTROL_REG_AUTO_DISCH_DISC, val));
+	i += SCNPRINTF(&buff[i], len - i, " EN_BLEED_DISCH=%x",
+		FIELD2VALUE(MAX77759_USB_POWER_CONTROL_REG_EN_BLEED_DISCH, val));
+	i += SCNPRINTF(&buff[i], len - i, " FORC_DISCH=%x",
+		FIELD2VALUE(MAX77759_USB_POWER_CONTROL_REG_FORC_DISCH, val));
+	i += SCNPRINTF(&buff[i], len - i, " RSVD_1=%x",
+		FIELD2VALUE(MAX77759_USB_POWER_CONTROL_REG_RSVD_1, val));
+	i += SCNPRINTF(&buff[i], len - i, " EN_VCONN=%x",
+		FIELD2VALUE(MAX77759_USB_POWER_CONTROL_REG_EN_VCONN, val));
+#else
+	buff[0] = 0;
+#endif
+	return buff;
+}
+
+/*
+ * CC_STATUS_REG,0x1D,0b00000000,0x00
+ * RSVD_7_6[1:0],,LOOKING4CONN,CONN_RSLT,CC2_STATE[1:0],,CC1_STATE[1:0]
+ */
+#define MAX77759_USB_CC_STATUS_REG	0x1D
+#define MAX77759_USB_CC_STATUS_REG_LOOKING4CONN	(0x1 << 5)
+#define MAX77759_USB_CC_STATUS_REG_CONN_RSLT	(0x1 << 4)
+
+#define MAX77759_USB_CC_STATUS_REG_RSVD_7_6_SHIFT	6
+#define MAX77759_USB_CC_STATUS_REG_RSVD_7_6_MASK	(0x3 << 6)
+#define MAX77759_USB_CC_STATUS_REG_RSVD_7_6_CLEAR	(~(0x3 << 6))
+#define MAX77759_USB_CC_STATUS_REG_LOOKING4CONN_SHIFT	5
+#define MAX77759_USB_CC_STATUS_REG_LOOKING4CONN_MASK	(0x1 << 5)
+#define MAX77759_USB_CC_STATUS_REG_LOOKING4CONN_CLEAR	(~(0x1 << 5))
+#define MAX77759_USB_CC_STATUS_REG_CONN_RSLT_SHIFT	4
+#define MAX77759_USB_CC_STATUS_REG_CONN_RSLT_MASK	(0x1 << 4)
+#define MAX77759_USB_CC_STATUS_REG_CONN_RSLT_CLEAR	(~(0x1 << 4))
+#define MAX77759_USB_CC_STATUS_REG_CC2_STATE_SHIFT	2
+#define MAX77759_USB_CC_STATUS_REG_CC2_STATE_MASK	(0x3 << 2)
+#define MAX77759_USB_CC_STATUS_REG_CC2_STATE_CLEAR	(~(0x3 << 2))
+#define MAX77759_USB_CC_STATUS_REG_CC1_STATE_SHIFT	0
+#define MAX77759_USB_CC_STATUS_REG_CC1_STATE_MASK	(0x3 << 0)
+#define MAX77759_USB_CC_STATUS_REG_CC1_STATE_CLEAR	(~(0x3 << 0))
+
+MAX77759_BFF(usb_cc_status_reg_rsvd_7_6,7,6)
+MAX77759_BFF(usb_cc_status_reg_looking4conn,5,5)
+MAX77759_BFF(usb_cc_status_reg_conn_rslt,4,4)
+MAX77759_BFF(usb_cc_status_reg_cc2_state,3,2)
+MAX77759_BFF(usb_cc_status_reg_cc1_state,1,0)
+static inline const char *
+max77759_usb_cc_status_reg_cstr(char *buff, size_t len, int val)
+{
+#ifdef SCNPRINTF
+	int i = 0;
+
+	i += SCNPRINTF(&buff[i], len - i, " RSVD_7_6=%x",
+		FIELD2VALUE(MAX77759_USB_CC_STATUS_REG_RSVD_7_6, val));
+	i += SCNPRINTF(&buff[i], len - i, " LOOKING4CONN=%x",
+		FIELD2VALUE(MAX77759_USB_CC_STATUS_REG_LOOKING4CONN, val));
+	i += SCNPRINTF(&buff[i], len - i, " CONN_RSLT=%x",
+		FIELD2VALUE(MAX77759_USB_CC_STATUS_REG_CONN_RSLT, val));
+	i += SCNPRINTF(&buff[i], len - i, " CC2_STATE=%x",
+		FIELD2VALUE(MAX77759_USB_CC_STATUS_REG_CC2_STATE, val));
+	i += SCNPRINTF(&buff[i], len - i, " CC1_STATE=%x",
+		FIELD2VALUE(MAX77759_USB_CC_STATUS_REG_CC1_STATE, val));
+#else
+	buff[0] = 0;
+#endif
+	return buff;
+}
+
+/*
+ * POWER_STATUS_REG,0x1E,0b00001000,0x08
+ * DBG_ACC_CONN,TCPC_INIT_STAT,SRC_HI_VOLT,SRC_VBUS,VBUS_DET_EN,VBUS_PRESENT,VCONN_PRESENT
+ */
+#define MAX77759_USB_POWER_STATUS_REG	0x1E
+#define MAX77759_USB_POWER_STATUS_REG_DBG_ACC_CONN	(0x1 << 7)
+#define MAX77759_USB_POWER_STATUS_REG_TCPC_INIT_STAT	(0x1 << 6)
+#define MAX77759_USB_POWER_STATUS_REG_SRC_HI_VOLT	(0x1 << 5)
+#define MAX77759_USB_POWER_STATUS_REG_SRC_VBUS	(0x1 << 4)
+#define MAX77759_USB_POWER_STATUS_REG_VBUS_DET_EN	(0x1 << 3)
+#define MAX77759_USB_POWER_STATUS_REG_VBUS_PRESENT	(0x1 << 2)
+#define MAX77759_USB_POWER_STATUS_REG_VCONN_PRESENT	(0x1 << 1)
+#define MAX77759_USB_POWER_STATUS_REG_SNK_VBUS	(0x1 << 0)
+
+#define MAX77759_USB_POWER_STATUS_REG_DBG_ACC_CONN_SHIFT	7
+#define MAX77759_USB_POWER_STATUS_REG_DBG_ACC_CONN_MASK	(0x1 << 7)
+#define MAX77759_USB_POWER_STATUS_REG_DBG_ACC_CONN_CLEAR	(~(0x1 << 7))
+#define MAX77759_USB_POWER_STATUS_REG_TCPC_INIT_STAT_SHIFT	6
+#define MAX77759_USB_POWER_STATUS_REG_TCPC_INIT_STAT_MASK	(0x1 << 6)
+#define MAX77759_USB_POWER_STATUS_REG_TCPC_INIT_STAT_CLEAR	(~(0x1 << 6))
+#define MAX77759_USB_POWER_STATUS_REG_SRC_HI_VOLT_SHIFT	5
+#define MAX77759_USB_POWER_STATUS_REG_SRC_HI_VOLT_MASK	(0x1 << 5)
+#define MAX77759_USB_POWER_STATUS_REG_SRC_HI_VOLT_CLEAR	(~(0x1 << 5))
+#define MAX77759_USB_POWER_STATUS_REG_SRC_VBUS_SHIFT	4
+#define MAX77759_USB_POWER_STATUS_REG_SRC_VBUS_MASK	(0x1 << 4)
+#define MAX77759_USB_POWER_STATUS_REG_SRC_VBUS_CLEAR	(~(0x1 << 4))
+#define MAX77759_USB_POWER_STATUS_REG_VBUS_DET_EN_SHIFT	3
+#define MAX77759_USB_POWER_STATUS_REG_VBUS_DET_EN_MASK	(0x1 << 3)
+#define MAX77759_USB_POWER_STATUS_REG_VBUS_DET_EN_CLEAR	(~(0x1 << 3))
+#define MAX77759_USB_POWER_STATUS_REG_VBUS_PRESENT_SHIFT	2
+#define MAX77759_USB_POWER_STATUS_REG_VBUS_PRESENT_MASK	(0x1 << 2)
+#define MAX77759_USB_POWER_STATUS_REG_VBUS_PRESENT_CLEAR	(~(0x1 << 2))
+#define MAX77759_USB_POWER_STATUS_REG_VCONN_PRESENT_SHIFT	1
+#define MAX77759_USB_POWER_STATUS_REG_VCONN_PRESENT_MASK	(0x1 << 1)
+#define MAX77759_USB_POWER_STATUS_REG_VCONN_PRESENT_CLEAR	(~(0x1 << 1))
+#define MAX77759_USB_POWER_STATUS_REG_SNK_VBUS_SHIFT	0
+#define MAX77759_USB_POWER_STATUS_REG_SNK_VBUS_MASK	(0x1 << 0)
+#define MAX77759_USB_POWER_STATUS_REG_SNK_VBUS_CLEAR	(~(0x1 << 0))
+
+MAX77759_BFF(usb_power_status_reg_dbg_acc_conn,7,7)
+MAX77759_BFF(usb_power_status_reg_tcpc_init_stat,6,6)
+MAX77759_BFF(usb_power_status_reg_src_hi_volt,5,5)
+MAX77759_BFF(usb_power_status_reg_src_vbus,4,4)
+MAX77759_BFF(usb_power_status_reg_vbus_det_en,3,3)
+MAX77759_BFF(usb_power_status_reg_vbus_present,2,2)
+MAX77759_BFF(usb_power_status_reg_vconn_present,1,1)
+MAX77759_BFF(usb_power_status_reg_snk_vbus,0,0)
+static inline const char *
+max77759_usb_power_status_reg_cstr(char *buff, size_t len, int val)
+{
+#ifdef SCNPRINTF
+	int i = 0;
+
+	i += SCNPRINTF(&buff[i], len - i, " DBG_ACC_CONN=%x",
+		FIELD2VALUE(MAX77759_USB_POWER_STATUS_REG_DBG_ACC_CONN, val));
+	i += SCNPRINTF(&buff[i], len - i, " TCPC_INIT_STAT=%x",
+		FIELD2VALUE(MAX77759_USB_POWER_STATUS_REG_TCPC_INIT_STAT, val));
+	i += SCNPRINTF(&buff[i], len - i, " SRC_HI_VOLT=%x",
+		FIELD2VALUE(MAX77759_USB_POWER_STATUS_REG_SRC_HI_VOLT, val));
+	i += SCNPRINTF(&buff[i], len - i, " SRC_VBUS=%x",
+		FIELD2VALUE(MAX77759_USB_POWER_STATUS_REG_SRC_VBUS, val));
+	i += SCNPRINTF(&buff[i], len - i, " VBUS_DET_EN=%x",
+		FIELD2VALUE(MAX77759_USB_POWER_STATUS_REG_VBUS_DET_EN, val));
+	i += SCNPRINTF(&buff[i], len - i, " VBUS_PRESENT=%x",
+		FIELD2VALUE(MAX77759_USB_POWER_STATUS_REG_VBUS_PRESENT, val));
+	i += SCNPRINTF(&buff[i], len - i, " VCONN_PRESENT=%x",
+		FIELD2VALUE(MAX77759_USB_POWER_STATUS_REG_VCONN_PRESENT, val));
+	i += SCNPRINTF(&buff[i], len - i, " SNK_VBUS=%x",
+		FIELD2VALUE(MAX77759_USB_POWER_STATUS_REG_SNK_VBUS, val));
+#else
+	buff[0] = 0;
+#endif
+	return buff;
+}
+
+/*
+ * FAULT_STATUS_REG,0x1F,0b10000000,0x80
+ * ALL_REG_RST,RSVD_6,AUTO_DISCH_FAIL,FORCE_DISCH_FAIL,RSVD_3,RSVD_2,VCONN_OCP_FAULT
+ */
+#define MAX77759_USB_FAULT_STATUS_REG	0x1F
+#define MAX77759_USB_FAULT_STATUS_REG_ALL_REG_RST	(0x1 << 7)
+#define MAX77759_USB_FAULT_STATUS_REG_RSVD_6	(0x1 << 6)
+#define MAX77759_USB_FAULT_STATUS_REG_AUTO_DISCH_FAIL	(0x1 << 5)
+#define MAX77759_USB_FAULT_STATUS_REG_FORCE_DISCH_FAIL	(0x1 << 4)
+#define MAX77759_USB_FAULT_STATUS_REG_RSVD_3	(0x1 << 3)
+#define MAX77759_USB_FAULT_STATUS_REG_RSVD_2	(0x1 << 2)
+#define MAX77759_USB_FAULT_STATUS_REG_VCONN_OCP_FAULT	(0x1 << 1)
+#define MAX77759_USB_FAULT_STATUS_REG_I2C_ERR	(0x1 << 0)
+
+#define MAX77759_USB_FAULT_STATUS_REG_ALL_REG_RST_SHIFT	7
+#define MAX77759_USB_FAULT_STATUS_REG_ALL_REG_RST_MASK	(0x1 << 7)
+#define MAX77759_USB_FAULT_STATUS_REG_ALL_REG_RST_CLEAR	(~(0x1 << 7))
+#define MAX77759_USB_FAULT_STATUS_REG_RSVD_6_SHIFT	6
+#define MAX77759_USB_FAULT_STATUS_REG_RSVD_6_MASK	(0x1 << 6)
+#define MAX77759_USB_FAULT_STATUS_REG_RSVD_6_CLEAR	(~(0x1 << 6))
+#define MAX77759_USB_FAULT_STATUS_REG_AUTO_DISCH_FAIL_SHIFT	5
+#define MAX77759_USB_FAULT_STATUS_REG_AUTO_DISCH_FAIL_MASK	(0x1 << 5)
+#define MAX77759_USB_FAULT_STATUS_REG_AUTO_DISCH_FAIL_CLEAR	(~(0x1 << 5))
+#define MAX77759_USB_FAULT_STATUS_REG_FORCE_DISCH_FAIL_SHIFT	4
+#define MAX77759_USB_FAULT_STATUS_REG_FORCE_DISCH_FAIL_MASK	(0x1 << 4)
+#define MAX77759_USB_FAULT_STATUS_REG_FORCE_DISCH_FAIL_CLEAR	(~(0x1 << 4))
+#define MAX77759_USB_FAULT_STATUS_REG_RSVD_3_SHIFT	3
+#define MAX77759_USB_FAULT_STATUS_REG_RSVD_3_MASK	(0x1 << 3)
+#define MAX77759_USB_FAULT_STATUS_REG_RSVD_3_CLEAR	(~(0x1 << 3))
+#define MAX77759_USB_FAULT_STATUS_REG_RSVD_2_SHIFT	2
+#define MAX77759_USB_FAULT_STATUS_REG_RSVD_2_MASK	(0x1 << 2)
+#define MAX77759_USB_FAULT_STATUS_REG_RSVD_2_CLEAR	(~(0x1 << 2))
+#define MAX77759_USB_FAULT_STATUS_REG_VCONN_OCP_FAULT_SHIFT	1
+#define MAX77759_USB_FAULT_STATUS_REG_VCONN_OCP_FAULT_MASK	(0x1 << 1)
+#define MAX77759_USB_FAULT_STATUS_REG_VCONN_OCP_FAULT_CLEAR	(~(0x1 << 1))
+#define MAX77759_USB_FAULT_STATUS_REG_I2C_ERR_SHIFT	0
+#define MAX77759_USB_FAULT_STATUS_REG_I2C_ERR_MASK	(0x1 << 0)
+#define MAX77759_USB_FAULT_STATUS_REG_I2C_ERR_CLEAR	(~(0x1 << 0))
+
+MAX77759_BFF(usb_fault_status_reg_all_reg_rst,7,7)
+MAX77759_BFF(usb_fault_status_reg_rsvd_6,6,6)
+MAX77759_BFF(usb_fault_status_reg_auto_disch_fail,5,5)
+MAX77759_BFF(usb_fault_status_reg_force_disch_fail,4,4)
+MAX77759_BFF(usb_fault_status_reg_rsvd_3,3,3)
+MAX77759_BFF(usb_fault_status_reg_rsvd_2,2,2)
+MAX77759_BFF(usb_fault_status_reg_vconn_ocp_fault,1,1)
+MAX77759_BFF(usb_fault_status_reg_i2c_err,0,0)
+static inline const char *
+max77759_usb_fault_status_reg_cstr(char *buff, size_t len, int val)
+{
+#ifdef SCNPRINTF
+	int i = 0;
+
+	i += SCNPRINTF(&buff[i], len - i, " ALL_REG_RST=%x",
+		FIELD2VALUE(MAX77759_USB_FAULT_STATUS_REG_ALL_REG_RST, val));
+	i += SCNPRINTF(&buff[i], len - i, " RSVD_6=%x",
+		FIELD2VALUE(MAX77759_USB_FAULT_STATUS_REG_RSVD_6, val));
+	i += SCNPRINTF(&buff[i], len - i, " AUTO_DISCH_FAIL=%x",
+		FIELD2VALUE(MAX77759_USB_FAULT_STATUS_REG_AUTO_DISCH_FAIL, val));
+	i += SCNPRINTF(&buff[i], len - i, " FORCE_DISCH_FAIL=%x",
+		FIELD2VALUE(MAX77759_USB_FAULT_STATUS_REG_FORCE_DISCH_FAIL, val));
+	i += SCNPRINTF(&buff[i], len - i, " RSVD_3=%x",
+		FIELD2VALUE(MAX77759_USB_FAULT_STATUS_REG_RSVD_3, val));
+	i += SCNPRINTF(&buff[i], len - i, " RSVD_2=%x",
+		FIELD2VALUE(MAX77759_USB_FAULT_STATUS_REG_RSVD_2, val));
+	i += SCNPRINTF(&buff[i], len - i, " VCONN_OCP_FAULT=%x",
+		FIELD2VALUE(MAX77759_USB_FAULT_STATUS_REG_VCONN_OCP_FAULT, val));
+	i += SCNPRINTF(&buff[i], len - i, " I2C_ERR=%x",
+		FIELD2VALUE(MAX77759_USB_FAULT_STATUS_REG_I2C_ERR, val));
+#else
+	buff[0] = 0;
+#endif
+	return buff;
+}
+
+/*
+ * EXTENDED_STATUS_REG,0x20,0b00000000,0x00
+ * RSVD_7_1[6:0],,,,,,
+ */
+#define MAX77759_USB_EXTENDED_STATUS_REG	0x20
+#define MAX77759_USB_EXTENDED_STATUS_REG_VSAFE0V	(0x1 << 0)
+
+#define MAX77759_USB_EXTENDED_STATUS_REG_RSVD_7_1_SHIFT	1
+#define MAX77759_USB_EXTENDED_STATUS_REG_RSVD_7_1_MASK	(0x7f << 1)
+#define MAX77759_USB_EXTENDED_STATUS_REG_RSVD_7_1_CLEAR	(~(0x7f << 1))
+#define MAX77759_USB_EXTENDED_STATUS_REG_VSAFE0V_SHIFT	0
+#define MAX77759_USB_EXTENDED_STATUS_REG_VSAFE0V_MASK	(0x1 << 0)
+#define MAX77759_USB_EXTENDED_STATUS_REG_VSAFE0V_CLEAR	(~(0x1 << 0))
+
+MAX77759_BFF(usb_extended_status_reg_rsvd_7_1,7,1)
+MAX77759_BFF(usb_extended_status_reg_vsafe0v,0,0)
+static inline const char *
+max77759_usb_extended_status_reg_cstr(char *buff, size_t len, int val)
+{
+#ifdef SCNPRINTF
+	int i = 0;
+
+	i += SCNPRINTF(&buff[i], len - i, " RSVD_7_1=%x",
+		FIELD2VALUE(MAX77759_USB_EXTENDED_STATUS_REG_RSVD_7_1, val));
+	i += SCNPRINTF(&buff[i], len - i, " VSAFE0V=%x",
+		FIELD2VALUE(MAX77759_USB_EXTENDED_STATUS_REG_VSAFE0V, val));
+#else
+	buff[0] = 0;
+#endif
+	return buff;
+}
+
+/*
+ * ALERT_EXTENDED,0x21,0b00000000,0x00
+ * RSVD_7_3[4:0],,,,,RSVD_2,RSVD_1
+ */
+#define MAX77759_USB_ALERT_EXTENDED	0x21
+#define MAX77759_USB_ALERT_EXTENDED_RSVD_2	(0x1 << 2)
+#define MAX77759_USB_ALERT_EXTENDED_RSVD_1	(0x1 << 1)
+#define MAX77759_USB_ALERT_EXTENDED_SNK_FRS	(0x1 << 0)
+
+#define MAX77759_USB_ALERT_EXTENDED_RSVD_7_3_SHIFT	3
+#define MAX77759_USB_ALERT_EXTENDED_RSVD_7_3_MASK	(0x1f << 3)
+#define MAX77759_USB_ALERT_EXTENDED_RSVD_7_3_CLEAR	(~(0x1f << 3))
+#define MAX77759_USB_ALERT_EXTENDED_RSVD_2_SHIFT	2
+#define MAX77759_USB_ALERT_EXTENDED_RSVD_2_MASK	(0x1 << 2)
+#define MAX77759_USB_ALERT_EXTENDED_RSVD_2_CLEAR	(~(0x1 << 2))
+#define MAX77759_USB_ALERT_EXTENDED_RSVD_1_SHIFT	1
+#define MAX77759_USB_ALERT_EXTENDED_RSVD_1_MASK	(0x1 << 1)
+#define MAX77759_USB_ALERT_EXTENDED_RSVD_1_CLEAR	(~(0x1 << 1))
+#define MAX77759_USB_ALERT_EXTENDED_SNK_FRS_SHIFT	0
+#define MAX77759_USB_ALERT_EXTENDED_SNK_FRS_MASK	(0x1 << 0)
+#define MAX77759_USB_ALERT_EXTENDED_SNK_FRS_CLEAR	(~(0x1 << 0))
+
+MAX77759_BFF(usb_alert_extended_rsvd_7_3,7,3)
+MAX77759_BFF(usb_alert_extended_rsvd_2,2,2)
+MAX77759_BFF(usb_alert_extended_rsvd_1,1,1)
+MAX77759_BFF(usb_alert_extended_snk_frs,0,0)
+static inline const char *
+max77759_usb_alert_extended_cstr(char *buff, size_t len, int val)
+{
+#ifdef SCNPRINTF
+	int i = 0;
+
+	i += SCNPRINTF(&buff[i], len - i, " RSVD_7_3=%x",
+		FIELD2VALUE(MAX77759_USB_ALERT_EXTENDED_RSVD_7_3, val));
+	i += SCNPRINTF(&buff[i], len - i, " RSVD_2=%x",
+		FIELD2VALUE(MAX77759_USB_ALERT_EXTENDED_RSVD_2, val));
+	i += SCNPRINTF(&buff[i], len - i, " RSVD_1=%x",
+		FIELD2VALUE(MAX77759_USB_ALERT_EXTENDED_RSVD_1, val));
+	i += SCNPRINTF(&buff[i], len - i, " SNK_FRS=%x",
+		FIELD2VALUE(MAX77759_USB_ALERT_EXTENDED_SNK_FRS, val));
+#else
+	buff[0] = 0;
+#endif
+	return buff;
+}
+
+/*
+ * COMMAND_REG,0x23,0b00000000,0x00
+ * COMMAND[7:0],,,,,,
+ */
+#define MAX77759_USB_COMMAND_REG	0x23
+
+/*
+ * DEVICE_CAPABILITIES_1_L,0x24,0b11011000,0xd8
+ * PWR_ROLE_CAP[2:0],,,SOP_DBG_CAP,SRC_VCONN_CAP,SNK_VBUS_CAP,SRC_HI_VBUS_CAP
+ */
+#define MAX77759_USB_DEVICE_CAPABILITIES_1_L	0x24
+#define MAX77759_USB_DEVICE_CAPABILITIES_1_L_SOP_DBG_CAP	(0x1 << 4)
+#define MAX77759_USB_DEVICE_CAPABILITIES_1_L_SRC_VCONN_CAP	(0x1 << 3)
+#define MAX77759_USB_DEVICE_CAPABILITIES_1_L_SNK_VBUS_CAP	(0x1 << 2)
+#define MAX77759_USB_DEVICE_CAPABILITIES_1_L_SRC_HI_VBUS_CAP	(0x1 << 1)
+#define MAX77759_USB_DEVICE_CAPABILITIES_1_L_SRC_VBUS_CAP	(0x1 << 0)
+
+#define MAX77759_USB_DEVICE_CAPABILITIES_1_L_PWR_ROLE_CAP_SHIFT	5
+#define MAX77759_USB_DEVICE_CAPABILITIES_1_L_PWR_ROLE_CAP_MASK	(0x7 << 5)
+#define MAX77759_USB_DEVICE_CAPABILITIES_1_L_PWR_ROLE_CAP_CLEAR	(~(0x7 << 5))
+#define MAX77759_USB_DEVICE_CAPABILITIES_1_L_SOP_DBG_CAP_SHIFT	4
+#define MAX77759_USB_DEVICE_CAPABILITIES_1_L_SOP_DBG_CAP_MASK	(0x1 << 4)
+#define MAX77759_USB_DEVICE_CAPABILITIES_1_L_SOP_DBG_CAP_CLEAR	(~(0x1 << 4))
+#define MAX77759_USB_DEVICE_CAPABILITIES_1_L_SRC_VCONN_CAP_SHIFT	3
+#define MAX77759_USB_DEVICE_CAPABILITIES_1_L_SRC_VCONN_CAP_MASK	(0x1 << 3)
+#define MAX77759_USB_DEVICE_CAPABILITIES_1_L_SRC_VCONN_CAP_CLEAR	(~(0x1 << 3))
+#define MAX77759_USB_DEVICE_CAPABILITIES_1_L_SNK_VBUS_CAP_SHIFT	2
+#define MAX77759_USB_DEVICE_CAPABILITIES_1_L_SNK_VBUS_CAP_MASK	(0x1 << 2)
+#define MAX77759_USB_DEVICE_CAPABILITIES_1_L_SNK_VBUS_CAP_CLEAR	(~(0x1 << 2))
+#define MAX77759_USB_DEVICE_CAPABILITIES_1_L_SRC_HI_VBUS_CAP_SHIFT	1
+#define MAX77759_USB_DEVICE_CAPABILITIES_1_L_SRC_HI_VBUS_CAP_MASK	(0x1 << 1)
+#define MAX77759_USB_DEVICE_CAPABILITIES_1_L_SRC_HI_VBUS_CAP_CLEAR	(~(0x1 << 1))
+#define MAX77759_USB_DEVICE_CAPABILITIES_1_L_SRC_VBUS_CAP_SHIFT	0
+#define MAX77759_USB_DEVICE_CAPABILITIES_1_L_SRC_VBUS_CAP_MASK	(0x1 << 0)
+#define MAX77759_USB_DEVICE_CAPABILITIES_1_L_SRC_VBUS_CAP_CLEAR	(~(0x1 << 0))
+
+MAX77759_BFF(usb_device_capabilities_1_l_pwr_role_cap,7,5)
+MAX77759_BFF(usb_device_capabilities_1_l_sop_dbg_cap,4,4)
+MAX77759_BFF(usb_device_capabilities_1_l_src_vconn_cap,3,3)
+MAX77759_BFF(usb_device_capabilities_1_l_snk_vbus_cap,2,2)
+MAX77759_BFF(usb_device_capabilities_1_l_src_hi_vbus_cap,1,1)
+MAX77759_BFF(usb_device_capabilities_1_l_src_vbus_cap,0,0)
+static inline const char *
+max77759_usb_device_capabilities_1_l_cstr(char *buff, size_t len, int val)
+{
+#ifdef SCNPRINTF
+	int i = 0;
+
+	i += SCNPRINTF(&buff[i], len - i, " PWR_ROLE_CAP=%x",
+		FIELD2VALUE(MAX77759_USB_DEVICE_CAPABILITIES_1_L_PWR_ROLE_CAP, val));
+	i += SCNPRINTF(&buff[i], len - i, " SOP_DBG_CAP=%x",
+		FIELD2VALUE(MAX77759_USB_DEVICE_CAPABILITIES_1_L_SOP_DBG_CAP, val));
+	i += SCNPRINTF(&buff[i], len - i, " SRC_VCONN_CAP=%x",
+		FIELD2VALUE(MAX77759_USB_DEVICE_CAPABILITIES_1_L_SRC_VCONN_CAP, val));
+	i += SCNPRINTF(&buff[i], len - i, " SNK_VBUS_CAP=%x",
+		FIELD2VALUE(MAX77759_USB_DEVICE_CAPABILITIES_1_L_SNK_VBUS_CAP, val));
+	i += SCNPRINTF(&buff[i], len - i, " SRC_HI_VBUS_CAP=%x",
+		FIELD2VALUE(MAX77759_USB_DEVICE_CAPABILITIES_1_L_SRC_HI_VBUS_CAP, val));
+	i += SCNPRINTF(&buff[i], len - i, " SRC_VBUS_CAP=%x",
+		FIELD2VALUE(MAX77759_USB_DEVICE_CAPABILITIES_1_L_SRC_VBUS_CAP, val));
+#else
+	buff[0] = 0;
+#endif
+	return buff;
+}
+
+/*
+ * DEVICE_CAPABILITIES_1_H,0x25,0b00011110,0x1e
+ * VBUS_HI_VOLT_TRGT_CAP,VBUS_OCP_RPT_CAP,VBUS_OVP_RPT_CAP,BLEED_DISCH_CAP,FORCE_DISCH_CAP,VBUS_MEAS_ALRM_CAP,SRC_RES_SUP_CAP[1:0]
+ */
+#define MAX77759_USB_DEVICE_CAPABILITIES_1_H	0x25
+#define MAX77759_USB_DEVICE_CAPABILITIES_1_H_VBUS_HI_VOLT_TRGT_CAP	(0x1 << 7)
+#define MAX77759_USB_DEVICE_CAPABILITIES_1_H_VBUS_OCP_RPT_CAP	(0x1 << 6)
+#define MAX77759_USB_DEVICE_CAPABILITIES_1_H_VBUS_OVP_RPT_CAP	(0x1 << 5)
+#define MAX77759_USB_DEVICE_CAPABILITIES_1_H_BLEED_DISCH_CAP	(0x1 << 4)
+#define MAX77759_USB_DEVICE_CAPABILITIES_1_H_FORCE_DISCH_CAP	(0x1 << 3)
+#define MAX77759_USB_DEVICE_CAPABILITIES_1_H_VBUS_MEAS_ALRM_CAP	(0x1 << 2)
+
+#define MAX77759_USB_DEVICE_CAPABILITIES_1_H_VBUS_HI_VOLT_TRGT_CAP_SHIFT	7
+#define MAX77759_USB_DEVICE_CAPABILITIES_1_H_VBUS_HI_VOLT_TRGT_CAP_MASK	(0x1 << 7)
+#define MAX77759_USB_DEVICE_CAPABILITIES_1_H_VBUS_HI_VOLT_TRGT_CAP_CLEAR	(~(0x1 << 7))
+#define MAX77759_USB_DEVICE_CAPABILITIES_1_H_VBUS_OCP_RPT_CAP_SHIFT	6
+#define MAX77759_USB_DEVICE_CAPABILITIES_1_H_VBUS_OCP_RPT_CAP_MASK	(0x1 << 6)
+#define MAX77759_USB_DEVICE_CAPABILITIES_1_H_VBUS_OCP_RPT_CAP_CLEAR	(~(0x1 << 6))
+#define MAX77759_USB_DEVICE_CAPABILITIES_1_H_VBUS_OVP_RPT_CAP_SHIFT	5
+#define MAX77759_USB_DEVICE_CAPABILITIES_1_H_VBUS_OVP_RPT_CAP_MASK	(0x1 << 5)
+#define MAX77759_USB_DEVICE_CAPABILITIES_1_H_VBUS_OVP_RPT_CAP_CLEAR	(~(0x1 << 5))
+#define MAX77759_USB_DEVICE_CAPABILITIES_1_H_BLEED_DISCH_CAP_SHIFT	4
+#define MAX77759_USB_DEVICE_CAPABILITIES_1_H_BLEED_DISCH_CAP_MASK	(0x1 << 4)
+#define MAX77759_USB_DEVICE_CAPABILITIES_1_H_BLEED_DISCH_CAP_CLEAR	(~(0x1 << 4))
+#define MAX77759_USB_DEVICE_CAPABILITIES_1_H_FORCE_DISCH_CAP_SHIFT	3
+#define MAX77759_USB_DEVICE_CAPABILITIES_1_H_FORCE_DISCH_CAP_MASK	(0x1 << 3)
+#define MAX77759_USB_DEVICE_CAPABILITIES_1_H_FORCE_DISCH_CAP_CLEAR	(~(0x1 << 3))
+#define MAX77759_USB_DEVICE_CAPABILITIES_1_H_VBUS_MEAS_ALRM_CAP_SHIFT	2
+#define MAX77759_USB_DEVICE_CAPABILITIES_1_H_VBUS_MEAS_ALRM_CAP_MASK	(0x1 << 2)
+#define MAX77759_USB_DEVICE_CAPABILITIES_1_H_VBUS_MEAS_ALRM_CAP_CLEAR	(~(0x1 << 2))
+#define MAX77759_USB_DEVICE_CAPABILITIES_1_H_SRC_RES_SUP_CAP_SHIFT	0
+#define MAX77759_USB_DEVICE_CAPABILITIES_1_H_SRC_RES_SUP_CAP_MASK	(0x3 << 0)
+#define MAX77759_USB_DEVICE_CAPABILITIES_1_H_SRC_RES_SUP_CAP_CLEAR	(~(0x3 << 0))
+
+MAX77759_BFF(usb_device_capabilities_1_h_vbus_hi_volt_trgt_cap,7,7)
+MAX77759_BFF(usb_device_capabilities_1_h_vbus_ocp_rpt_cap,6,6)
+MAX77759_BFF(usb_device_capabilities_1_h_vbus_ovp_rpt_cap,5,5)
+MAX77759_BFF(usb_device_capabilities_1_h_bleed_disch_cap,4,4)
+MAX77759_BFF(usb_device_capabilities_1_h_force_disch_cap,3,3)
+MAX77759_BFF(usb_device_capabilities_1_h_vbus_meas_alrm_cap,2,2)
+MAX77759_BFF(usb_device_capabilities_1_h_src_res_sup_cap,1,0)
+static inline const char *
+max77759_usb_device_capabilities_1_h_cstr(char *buff, size_t len, int val)
+{
+#ifdef SCNPRINTF
+	int i = 0;
+
+	i += SCNPRINTF(&buff[i], len - i, " VBUS_HI_VOLT_TRGT_CAP=%x",
+		FIELD2VALUE(MAX77759_USB_DEVICE_CAPABILITIES_1_H_VBUS_HI_VOLT_TRGT_CAP, val));
+	i += SCNPRINTF(&buff[i], len - i, " VBUS_OCP_RPT_CAP=%x",
+		FIELD2VALUE(MAX77759_USB_DEVICE_CAPABILITIES_1_H_VBUS_OCP_RPT_CAP, val));
+	i += SCNPRINTF(&buff[i], len - i, " VBUS_OVP_RPT_CAP=%x",
+		FIELD2VALUE(MAX77759_USB_DEVICE_CAPABILITIES_1_H_VBUS_OVP_RPT_CAP, val));
+	i += SCNPRINTF(&buff[i], len - i, " BLEED_DISCH_CAP=%x",
+		FIELD2VALUE(MAX77759_USB_DEVICE_CAPABILITIES_1_H_BLEED_DISCH_CAP, val));
+	i += SCNPRINTF(&buff[i], len - i, " FORCE_DISCH_CAP=%x",
+		FIELD2VALUE(MAX77759_USB_DEVICE_CAPABILITIES_1_H_FORCE_DISCH_CAP, val));
+	i += SCNPRINTF(&buff[i], len - i, " VBUS_MEAS_ALRM_CAP=%x",
+		FIELD2VALUE(MAX77759_USB_DEVICE_CAPABILITIES_1_H_VBUS_MEAS_ALRM_CAP, val));
+	i += SCNPRINTF(&buff[i], len - i, " SRC_RES_SUP_CAP=%x",
+		FIELD2VALUE(MAX77759_USB_DEVICE_CAPABILITIES_1_H_SRC_RES_SUP_CAP, val));
+#else
+	buff[0] = 0;
+#endif
+	return buff;
+}
+
+/*
+ * DEVICE_CAPABILITIES_2_L,0x26,0b11000001,0xc1
+ * SNK_DISC_DET_CAP,STP_DISCH_THR_CAP,VBUS_VOLT_ALRM_LSB_CAP[1:0],,VCONN_PWR_CAP[2:0],,
+ */
+#define MAX77759_USB_DEVICE_CAPABILITIES_2_L	0x26
+#define MAX77759_USB_DEVICE_CAPABILITIES_2_L_SNK_DISC_DET_CAP	(0x1 << 7)
+#define MAX77759_USB_DEVICE_CAPABILITIES_2_L_STP_DISCH_THR_CAP	(0x1 << 6)
+#define MAX77759_USB_DEVICE_CAPABILITIES_2_L_VCONN_OCP_CAP	(0x1 << 0)
+
+#define MAX77759_USB_DEVICE_CAPABILITIES_2_L_SNK_DISC_DET_CAP_SHIFT	7
+#define MAX77759_USB_DEVICE_CAPABILITIES_2_L_SNK_DISC_DET_CAP_MASK	(0x1 << 7)
+#define MAX77759_USB_DEVICE_CAPABILITIES_2_L_SNK_DISC_DET_CAP_CLEAR	(~(0x1 << 7))
+#define MAX77759_USB_DEVICE_CAPABILITIES_2_L_STP_DISCH_THR_CAP_SHIFT	6
+#define MAX77759_USB_DEVICE_CAPABILITIES_2_L_STP_DISCH_THR_CAP_MASK	(0x1 << 6)
+#define MAX77759_USB_DEVICE_CAPABILITIES_2_L_STP_DISCH_THR_CAP_CLEAR	(~(0x1 << 6))
+#define MAX77759_USB_DEVICE_CAPABILITIES_2_L_VBUS_VOLT_ALRM_LSB_CAP_SHIFT	4
+#define MAX77759_USB_DEVICE_CAPABILITIES_2_L_VBUS_VOLT_ALRM_LSB_CAP_MASK	(0x3 << 4)
+#define MAX77759_USB_DEVICE_CAPABILITIES_2_L_VBUS_VOLT_ALRM_LSB_CAP_CLEAR	(~(0x3 << 4))
+#define MAX77759_USB_DEVICE_CAPABILITIES_2_L_VCONN_PWR_CAP_SHIFT	1
+#define MAX77759_USB_DEVICE_CAPABILITIES_2_L_VCONN_PWR_CAP_MASK	(0x7 << 1)
+#define MAX77759_USB_DEVICE_CAPABILITIES_2_L_VCONN_PWR_CAP_CLEAR	(~(0x7 << 1))
+#define MAX77759_USB_DEVICE_CAPABILITIES_2_L_VCONN_OCP_CAP_SHIFT	0
+#define MAX77759_USB_DEVICE_CAPABILITIES_2_L_VCONN_OCP_CAP_MASK	(0x1 << 0)
+#define MAX77759_USB_DEVICE_CAPABILITIES_2_L_VCONN_OCP_CAP_CLEAR	(~(0x1 << 0))
+
+MAX77759_BFF(usb_device_capabilities_2_l_snk_disc_det_cap,7,7)
+MAX77759_BFF(usb_device_capabilities_2_l_stp_disch_thr_cap,6,6)
+MAX77759_BFF(usb_device_capabilities_2_l_vbus_volt_alrm_lsb_cap,5,4)
+MAX77759_BFF(usb_device_capabilities_2_l_vconn_pwr_cap,3,1)
+MAX77759_BFF(usb_device_capabilities_2_l_vconn_ocp_cap,0,0)
+static inline const char *
+max77759_usb_device_capabilities_2_l_cstr(char *buff, size_t len, int val)
+{
+#ifdef SCNPRINTF
+	int i = 0;
+
+	i += SCNPRINTF(&buff[i], len - i, " SNK_DISC_DET_CAP=%x",
+		FIELD2VALUE(MAX77759_USB_DEVICE_CAPABILITIES_2_L_SNK_DISC_DET_CAP, val));
+	i += SCNPRINTF(&buff[i], len - i, " STP_DISCH_THR_CAP=%x",
+		FIELD2VALUE(MAX77759_USB_DEVICE_CAPABILITIES_2_L_STP_DISCH_THR_CAP, val));
+	i += SCNPRINTF(&buff[i], len - i, " VBUS_VOLT_ALRM_LSB_CAP=%x",
+		FIELD2VALUE(MAX77759_USB_DEVICE_CAPABILITIES_2_L_VBUS_VOLT_ALRM_LSB_CAP, val));
+	i += SCNPRINTF(&buff[i], len - i, " VCONN_PWR_CAP=%x",
+		FIELD2VALUE(MAX77759_USB_DEVICE_CAPABILITIES_2_L_VCONN_PWR_CAP, val));
+	i += SCNPRINTF(&buff[i], len - i, " VCONN_OCP_CAP=%x",
+		FIELD2VALUE(MAX77759_USB_DEVICE_CAPABILITIES_2_L_VCONN_OCP_CAP, val));
+#else
+	buff[0] = 0;
+#endif
+	return buff;
+}
+
+/*
+ * DEVICE_CAPABILITIES_2_H,0x27,0b00000011,0x03
+ * RSVD_7,MSGDisDisc,GENERIC_TMR_CAP,LONG_MSG_CAP,SMB_PEC_CAP,SRC_FRS_CAP,SNK_FRS_CAP
+ */
+#define MAX77759_USB_DEVICE_CAPABILITIES_2_H	0x27
+#define MAX77759_USB_DEVICE_CAPABILITIES_2_H_RSVD_7	(0x1 << 7)
+#define MAX77759_USB_DEVICE_CAPABILITIES_2_H_MSGDISDISC	(0x1 << 6)
+#define MAX77759_USB_DEVICE_CAPABILITIES_2_H_GENERIC_TMR_CAP	(0x1 << 5)
+#define MAX77759_USB_DEVICE_CAPABILITIES_2_H_LONG_MSG_CAP	(0x1 << 4)
+#define MAX77759_USB_DEVICE_CAPABILITIES_2_H_SMB_PEC_CAP	(0x1 << 3)
+#define MAX77759_USB_DEVICE_CAPABILITIES_2_H_SRC_FRS_CAP	(0x1 << 2)
+#define MAX77759_USB_DEVICE_CAPABILITIES_2_H_SNK_FRS_CAP	(0x1 << 1)
+#define MAX77759_USB_DEVICE_CAPABILITIES_2_H_WDOG_TMR_CAP	(0x1 << 0)
+
+#define MAX77759_USB_DEVICE_CAPABILITIES_2_H_RSVD_7_SHIFT	7
+#define MAX77759_USB_DEVICE_CAPABILITIES_2_H_RSVD_7_MASK	(0x1 << 7)
+#define MAX77759_USB_DEVICE_CAPABILITIES_2_H_RSVD_7_CLEAR	(~(0x1 << 7))
+#define MAX77759_USB_DEVICE_CAPABILITIES_2_H_MSGDISDISC_SHIFT	6
+#define MAX77759_USB_DEVICE_CAPABILITIES_2_H_MSGDISDISC_MASK	(0x1 << 6)
+#define MAX77759_USB_DEVICE_CAPABILITIES_2_H_MSGDISDISC_CLEAR	(~(0x1 << 6))
+#define MAX77759_USB_DEVICE_CAPABILITIES_2_H_GENERIC_TMR_CAP_SHIFT	5
+#define MAX77759_USB_DEVICE_CAPABILITIES_2_H_GENERIC_TMR_CAP_MASK	(0x1 << 5)
+#define MAX77759_USB_DEVICE_CAPABILITIES_2_H_GENERIC_TMR_CAP_CLEAR	(~(0x1 << 5))
+#define MAX77759_USB_DEVICE_CAPABILITIES_2_H_LONG_MSG_CAP_SHIFT	4
+#define MAX77759_USB_DEVICE_CAPABILITIES_2_H_LONG_MSG_CAP_MASK	(0x1 << 4)
+#define MAX77759_USB_DEVICE_CAPABILITIES_2_H_LONG_MSG_CAP_CLEAR	(~(0x1 << 4))
+#define MAX77759_USB_DEVICE_CAPABILITIES_2_H_SMB_PEC_CAP_SHIFT	3
+#define MAX77759_USB_DEVICE_CAPABILITIES_2_H_SMB_PEC_CAP_MASK	(0x1 << 3)
+#define MAX77759_USB_DEVICE_CAPABILITIES_2_H_SMB_PEC_CAP_CLEAR	(~(0x1 << 3))
+#define MAX77759_USB_DEVICE_CAPABILITIES_2_H_SRC_FRS_CAP_SHIFT	2
+#define MAX77759_USB_DEVICE_CAPABILITIES_2_H_SRC_FRS_CAP_MASK	(0x1 << 2)
+#define MAX77759_USB_DEVICE_CAPABILITIES_2_H_SRC_FRS_CAP_CLEAR	(~(0x1 << 2))
+#define MAX77759_USB_DEVICE_CAPABILITIES_2_H_SNK_FRS_CAP_SHIFT	1
+#define MAX77759_USB_DEVICE_CAPABILITIES_2_H_SNK_FRS_CAP_MASK	(0x1 << 1)
+#define MAX77759_USB_DEVICE_CAPABILITIES_2_H_SNK_FRS_CAP_CLEAR	(~(0x1 << 1))
+#define MAX77759_USB_DEVICE_CAPABILITIES_2_H_WDOG_TMR_CAP_SHIFT	0
+#define MAX77759_USB_DEVICE_CAPABILITIES_2_H_WDOG_TMR_CAP_MASK	(0x1 << 0)
+#define MAX77759_USB_DEVICE_CAPABILITIES_2_H_WDOG_TMR_CAP_CLEAR	(~(0x1 << 0))
+
+MAX77759_BFF(usb_device_capabilities_2_h_rsvd_7,7,7)
+MAX77759_BFF(usb_device_capabilities_2_h_msgdisdisc,6,6)
+MAX77759_BFF(usb_device_capabilities_2_h_generic_tmr_cap,5,5)
+MAX77759_BFF(usb_device_capabilities_2_h_long_msg_cap,4,4)
+MAX77759_BFF(usb_device_capabilities_2_h_smb_pec_cap,3,3)
+MAX77759_BFF(usb_device_capabilities_2_h_src_frs_cap,2,2)
+MAX77759_BFF(usb_device_capabilities_2_h_snk_frs_cap,1,1)
+MAX77759_BFF(usb_device_capabilities_2_h_wdog_tmr_cap,0,0)
+static inline const char *
+max77759_usb_device_capabilities_2_h_cstr(char *buff, size_t len, int val)
+{
+#ifdef SCNPRINTF
+	int i = 0;
+
+	i += SCNPRINTF(&buff[i], len - i, " RSVD_7=%x",
+		FIELD2VALUE(MAX77759_USB_DEVICE_CAPABILITIES_2_H_RSVD_7, val));
+	i += SCNPRINTF(&buff[i], len - i, " MSGDISDISC=%x",
+		FIELD2VALUE(MAX77759_USB_DEVICE_CAPABILITIES_2_H_MSGDISDISC, val));
+	i += SCNPRINTF(&buff[i], len - i, " GENERIC_TMR_CAP=%x",
+		FIELD2VALUE(MAX77759_USB_DEVICE_CAPABILITIES_2_H_GENERIC_TMR_CAP, val));
+	i += SCNPRINTF(&buff[i], len - i, " LONG_MSG_CAP=%x",
+		FIELD2VALUE(MAX77759_USB_DEVICE_CAPABILITIES_2_H_LONG_MSG_CAP, val));
+	i += SCNPRINTF(&buff[i], len - i, " SMB_PEC_CAP=%x",
+		FIELD2VALUE(MAX77759_USB_DEVICE_CAPABILITIES_2_H_SMB_PEC_CAP, val));
+	i += SCNPRINTF(&buff[i], len - i, " SRC_FRS_CAP=%x",
+		FIELD2VALUE(MAX77759_USB_DEVICE_CAPABILITIES_2_H_SRC_FRS_CAP, val));
+	i += SCNPRINTF(&buff[i], len - i, " SNK_FRS_CAP=%x",
+		FIELD2VALUE(MAX77759_USB_DEVICE_CAPABILITIES_2_H_SNK_FRS_CAP, val));
+	i += SCNPRINTF(&buff[i], len - i, " WDOG_TMR_CAP=%x",
+		FIELD2VALUE(MAX77759_USB_DEVICE_CAPABILITIES_2_H_WDOG_TMR_CAP, val));
+#else
+	buff[0] = 0;
+#endif
+	return buff;
+}
+
+/*
+ * STANDARD_INPUT_CAPABILITIES_REG,0x28,0b00000000,0x00
+ * RSVD_7_5[2:0],,,SRC_FRS_INP_CAP[1:0],,VBUS_EXT_OVP_CAP,VBUS_EXT_OCP_CAP
+ */
+#define MAX77759_USB_STANDARD_INPUT_CAPABILITIES_REG	0x28
+#define MAX77759_USB_STANDARD_INPUT_CAPABILITIES_REG_VBUS_EXT_OVP_CAP	(0x1 << 2)
+#define MAX77759_USB_STANDARD_INPUT_CAPABILITIES_REG_VBUS_EXT_OCP_CAP	(0x1 << 1)
+#define MAX77759_USB_STANDARD_INPUT_CAPABILITIES_REG_FRC_OFF_VBUS_CAP	(0x1 << 0)
+
+#define MAX77759_USB_STANDARD_INPUT_CAPABILITIES_REG_RSVD_7_5_SHIFT	5
+#define MAX77759_USB_STANDARD_INPUT_CAPABILITIES_REG_RSVD_7_5_MASK	(0x7 << 5)
+#define MAX77759_USB_STANDARD_INPUT_CAPABILITIES_REG_RSVD_7_5_CLEAR	(~(0x7 << 5))
+#define MAX77759_USB_STANDARD_INPUT_CAPABILITIES_REG_SRC_FRS_INP_CAP_SHIFT	3
+#define MAX77759_USB_STANDARD_INPUT_CAPABILITIES_REG_SRC_FRS_INP_CAP_MASK	(0x3 << 3)
+#define MAX77759_USB_STANDARD_INPUT_CAPABILITIES_REG_SRC_FRS_INP_CAP_CLEAR	(~(0x3 << 3))
+#define MAX77759_USB_STANDARD_INPUT_CAPABILITIES_REG_VBUS_EXT_OVP_CAP_SHIFT	2
+#define MAX77759_USB_STANDARD_INPUT_CAPABILITIES_REG_VBUS_EXT_OVP_CAP_MASK	(0x1 << 2)
+#define MAX77759_USB_STANDARD_INPUT_CAPABILITIES_REG_VBUS_EXT_OVP_CAP_CLEAR	(~(0x1 << 2))
+#define MAX77759_USB_STANDARD_INPUT_CAPABILITIES_REG_VBUS_EXT_OCP_CAP_SHIFT	1
+#define MAX77759_USB_STANDARD_INPUT_CAPABILITIES_REG_VBUS_EXT_OCP_CAP_MASK	(0x1 << 1)
+#define MAX77759_USB_STANDARD_INPUT_CAPABILITIES_REG_VBUS_EXT_OCP_CAP_CLEAR	(~(0x1 << 1))
+#define MAX77759_USB_STANDARD_INPUT_CAPABILITIES_REG_FRC_OFF_VBUS_CAP_SHIFT	0
+#define MAX77759_USB_STANDARD_INPUT_CAPABILITIES_REG_FRC_OFF_VBUS_CAP_MASK	(0x1 << 0)
+#define MAX77759_USB_STANDARD_INPUT_CAPABILITIES_REG_FRC_OFF_VBUS_CAP_CLEAR	(~(0x1 << 0))
+
+MAX77759_BFF(usb_standard_input_capabilities_reg_rsvd_7_5,7,5)
+MAX77759_BFF(usb_standard_input_capabilities_reg_src_frs_inp_cap,4,3)
+MAX77759_BFF(usb_standard_input_capabilities_reg_vbus_ext_ovp_cap,2,2)
+MAX77759_BFF(usb_standard_input_capabilities_reg_vbus_ext_ocp_cap,1,1)
+MAX77759_BFF(usb_standard_input_capabilities_reg_frc_off_vbus_cap,0,0)
+static inline const char *
+max77759_usb_standard_input_capabilities_reg_cstr(char *buff, size_t len, int val)
+{
+#ifdef SCNPRINTF
+	int i = 0;
+
+	i += SCNPRINTF(&buff[i], len - i, " RSVD_7_5=%x",
+		FIELD2VALUE(MAX77759_USB_STANDARD_INPUT_CAPABILITIES_REG_RSVD_7_5, val));
+	i += SCNPRINTF(&buff[i], len - i, " SRC_FRS_INP_CAP=%x",
+		FIELD2VALUE(MAX77759_USB_STANDARD_INPUT_CAPABILITIES_REG_SRC_FRS_INP_CAP, val));
+	i += SCNPRINTF(&buff[i], len - i, " VBUS_EXT_OVP_CAP=%x",
+		FIELD2VALUE(MAX77759_USB_STANDARD_INPUT_CAPABILITIES_REG_VBUS_EXT_OVP_CAP, val));
+	i += SCNPRINTF(&buff[i], len - i, " VBUS_EXT_OCP_CAP=%x",
+		FIELD2VALUE(MAX77759_USB_STANDARD_INPUT_CAPABILITIES_REG_VBUS_EXT_OCP_CAP, val));
+	i += SCNPRINTF(&buff[i], len - i, " FRC_OFF_VBUS_CAP=%x",
+		FIELD2VALUE(MAX77759_USB_STANDARD_INPUT_CAPABILITIES_REG_FRC_OFF_VBUS_CAP, val));
+#else
+	buff[0] = 0;
+#endif
+	return buff;
+}
+
+/*
+ * STANDARD_OUTPUT_CAPABILITIES_REG,0x29,0b01000000,0x40
+ * VBUS_SNK_DIS_DET_CAP,DBG_ACC_CAP,VBUS_PRESENT_CAP,AUD_ACC_CAP,ACT_CBL_CAP,MUX_CONFG_CAP,CONN_PRESENT_CAP
+ */
+#define MAX77759_USB_STANDARD_OUTPUT_CAPABILITIES_REG	0x29
+#define MAX77759_USB_STANDARD_OUTPUT_CAPABILITIES_REG_VBUS_SNK_DIS_DET_CAP	(0x1 << 7)
+#define MAX77759_USB_STANDARD_OUTPUT_CAPABILITIES_REG_DBG_ACC_CAP	(0x1 << 6)
+#define MAX77759_USB_STANDARD_OUTPUT_CAPABILITIES_REG_VBUS_PRESENT_CAP	(0x1 << 5)
+#define MAX77759_USB_STANDARD_OUTPUT_CAPABILITIES_REG_AUD_ACC_CAP	(0x1 << 4)
+#define MAX77759_USB_STANDARD_OUTPUT_CAPABILITIES_REG_ACT_CBL_CAP	(0x1 << 3)
+#define MAX77759_USB_STANDARD_OUTPUT_CAPABILITIES_REG_MUX_CONFG_CAP	(0x1 << 2)
+#define MAX77759_USB_STANDARD_OUTPUT_CAPABILITIES_REG_CONN_PRESENT_CAP	(0x1 << 1)
+#define MAX77759_USB_STANDARD_OUTPUT_CAPABILITIES_REG_CONN_ORIENT_CAP	(0x1 << 0)
+
+#define MAX77759_USB_STANDARD_OUTPUT_CAPABILITIES_REG_VBUS_SNK_DIS_DET_CAP_SHIFT	7
+#define MAX77759_USB_STANDARD_OUTPUT_CAPABILITIES_REG_VBUS_SNK_DIS_DET_CAP_MASK	(0x1 << 7)
+#define MAX77759_USB_STANDARD_OUTPUT_CAPABILITIES_REG_VBUS_SNK_DIS_DET_CAP_CLEAR	(~(0x1 << 7))
+#define MAX77759_USB_STANDARD_OUTPUT_CAPABILITIES_REG_DBG_ACC_CAP_SHIFT	6
+#define MAX77759_USB_STANDARD_OUTPUT_CAPABILITIES_REG_DBG_ACC_CAP_MASK	(0x1 << 6)
+#define MAX77759_USB_STANDARD_OUTPUT_CAPABILITIES_REG_DBG_ACC_CAP_CLEAR	(~(0x1 << 6))
+#define MAX77759_USB_STANDARD_OUTPUT_CAPABILITIES_REG_VBUS_PRESENT_CAP_SHIFT	5
+#define MAX77759_USB_STANDARD_OUTPUT_CAPABILITIES_REG_VBUS_PRESENT_CAP_MASK	(0x1 << 5)
+#define MAX77759_USB_STANDARD_OUTPUT_CAPABILITIES_REG_VBUS_PRESENT_CAP_CLEAR	(~(0x1 << 5))
+#define MAX77759_USB_STANDARD_OUTPUT_CAPABILITIES_REG_AUD_ACC_CAP_SHIFT	4
+#define MAX77759_USB_STANDARD_OUTPUT_CAPABILITIES_REG_AUD_ACC_CAP_MASK	(0x1 << 4)
+#define MAX77759_USB_STANDARD_OUTPUT_CAPABILITIES_REG_AUD_ACC_CAP_CLEAR	(~(0x1 << 4))
+#define MAX77759_USB_STANDARD_OUTPUT_CAPABILITIES_REG_ACT_CBL_CAP_SHIFT	3
+#define MAX77759_USB_STANDARD_OUTPUT_CAPABILITIES_REG_ACT_CBL_CAP_MASK	(0x1 << 3)
+#define MAX77759_USB_STANDARD_OUTPUT_CAPABILITIES_REG_ACT_CBL_CAP_CLEAR	(~(0x1 << 3))
+#define MAX77759_USB_STANDARD_OUTPUT_CAPABILITIES_REG_MUX_CONFG_CAP_SHIFT	2
+#define MAX77759_USB_STANDARD_OUTPUT_CAPABILITIES_REG_MUX_CONFG_CAP_MASK	(0x1 << 2)
+#define MAX77759_USB_STANDARD_OUTPUT_CAPABILITIES_REG_MUX_CONFG_CAP_CLEAR	(~(0x1 << 2))
+#define MAX77759_USB_STANDARD_OUTPUT_CAPABILITIES_REG_CONN_PRESENT_CAP_SHIFT	1
+#define MAX77759_USB_STANDARD_OUTPUT_CAPABILITIES_REG_CONN_PRESENT_CAP_MASK	(0x1 << 1)
+#define MAX77759_USB_STANDARD_OUTPUT_CAPABILITIES_REG_CONN_PRESENT_CAP_CLEAR	(~(0x1 << 1))
+#define MAX77759_USB_STANDARD_OUTPUT_CAPABILITIES_REG_CONN_ORIENT_CAP_SHIFT	0
+#define MAX77759_USB_STANDARD_OUTPUT_CAPABILITIES_REG_CONN_ORIENT_CAP_MASK	(0x1 << 0)
+#define MAX77759_USB_STANDARD_OUTPUT_CAPABILITIES_REG_CONN_ORIENT_CAP_CLEAR	(~(0x1 << 0))
+
+MAX77759_BFF(usb_standard_output_capabilities_reg_vbus_snk_dis_det_cap,7,7)
+MAX77759_BFF(usb_standard_output_capabilities_reg_dbg_acc_cap,6,6)
+MAX77759_BFF(usb_standard_output_capabilities_reg_vbus_present_cap,5,5)
+MAX77759_BFF(usb_standard_output_capabilities_reg_aud_acc_cap,4,4)
+MAX77759_BFF(usb_standard_output_capabilities_reg_act_cbl_cap,3,3)
+MAX77759_BFF(usb_standard_output_capabilities_reg_mux_confg_cap,2,2)
+MAX77759_BFF(usb_standard_output_capabilities_reg_conn_present_cap,1,1)
+MAX77759_BFF(usb_standard_output_capabilities_reg_conn_orient_cap,0,0)
+static inline const char *
+max77759_usb_standard_output_capabilities_reg_cstr(char *buff, size_t len, int val)
+{
+#ifdef SCNPRINTF
+	int i = 0;
+
+	i += SCNPRINTF(&buff[i], len - i, " VBUS_SNK_DIS_DET_CAP=%x",
+		FIELD2VALUE(MAX77759_USB_STANDARD_OUTPUT_CAPABILITIES_REG_VBUS_SNK_DIS_DET_CAP, val));
+	i += SCNPRINTF(&buff[i], len - i, " DBG_ACC_CAP=%x",
+		FIELD2VALUE(MAX77759_USB_STANDARD_OUTPUT_CAPABILITIES_REG_DBG_ACC_CAP, val));
+	i += SCNPRINTF(&buff[i], len - i, " VBUS_PRESENT_CAP=%x",
+		FIELD2VALUE(MAX77759_USB_STANDARD_OUTPUT_CAPABILITIES_REG_VBUS_PRESENT_CAP, val));
+	i += SCNPRINTF(&buff[i], len - i, " AUD_ACC_CAP=%x",
+		FIELD2VALUE(MAX77759_USB_STANDARD_OUTPUT_CAPABILITIES_REG_AUD_ACC_CAP, val));
+	i += SCNPRINTF(&buff[i], len - i, " ACT_CBL_CAP=%x",
+		FIELD2VALUE(MAX77759_USB_STANDARD_OUTPUT_CAPABILITIES_REG_ACT_CBL_CAP, val));
+	i += SCNPRINTF(&buff[i], len - i, " MUX_CONFG_CAP=%x",
+		FIELD2VALUE(MAX77759_USB_STANDARD_OUTPUT_CAPABILITIES_REG_MUX_CONFG_CAP, val));
+	i += SCNPRINTF(&buff[i], len - i, " CONN_PRESENT_CAP=%x",
+		FIELD2VALUE(MAX77759_USB_STANDARD_OUTPUT_CAPABILITIES_REG_CONN_PRESENT_CAP, val));
+	i += SCNPRINTF(&buff[i], len - i, " CONN_ORIENT_CAP=%x",
+		FIELD2VALUE(MAX77759_USB_STANDARD_OUTPUT_CAPABILITIES_REG_CONN_ORIENT_CAP, val));
+#else
+	buff[0] = 0;
+#endif
+	return buff;
+}
+
+/*
+ * CONFIG_EXTENDED1_REG,0x2A,0b00000000,0x00
+ * RSVD_7_2[5:0],,,,,,RSVD_1
+ */
+#define MAX77759_USB_CONFIG_EXTENDED1_REG	0x2A
+#define MAX77759_USB_CONFIG_EXTENDED1_REG_RSVD_1	(0x1 << 1)
+#define MAX77759_USB_CONFIG_EXTENDED1_REG_RSVD_0	(0x1 << 0)
+
+#define MAX77759_USB_CONFIG_EXTENDED1_REG_RSVD_7_2_SHIFT	2
+#define MAX77759_USB_CONFIG_EXTENDED1_REG_RSVD_7_2_MASK	(0x3f << 2)
+#define MAX77759_USB_CONFIG_EXTENDED1_REG_RSVD_7_2_CLEAR	(~(0x3f << 2))
+#define MAX77759_USB_CONFIG_EXTENDED1_REG_RSVD_1_SHIFT	1
+#define MAX77759_USB_CONFIG_EXTENDED1_REG_RSVD_1_MASK	(0x1 << 1)
+#define MAX77759_USB_CONFIG_EXTENDED1_REG_RSVD_1_CLEAR	(~(0x1 << 1))
+#define MAX77759_USB_CONFIG_EXTENDED1_REG_RSVD_0_SHIFT	0
+#define MAX77759_USB_CONFIG_EXTENDED1_REG_RSVD_0_MASK	(0x1 << 0)
+#define MAX77759_USB_CONFIG_EXTENDED1_REG_RSVD_0_CLEAR	(~(0x1 << 0))
+
+MAX77759_BFF(usb_config_extended1_reg_rsvd_7_2,7,2)
+MAX77759_BFF(usb_config_extended1_reg_rsvd_1,1,1)
+MAX77759_BFF(usb_config_extended1_reg_rsvd_0,0,0)
+static inline const char *
+max77759_usb_config_extended1_reg_cstr(char *buff, size_t len, int val)
+{
+#ifdef SCNPRINTF
+	int i = 0;
+
+	i += SCNPRINTF(&buff[i], len - i, " RSVD_7_2=%x",
+		FIELD2VALUE(MAX77759_USB_CONFIG_EXTENDED1_REG_RSVD_7_2, val));
+	i += SCNPRINTF(&buff[i], len - i, " RSVD_1=%x",
+		FIELD2VALUE(MAX77759_USB_CONFIG_EXTENDED1_REG_RSVD_1, val));
+	i += SCNPRINTF(&buff[i], len - i, " RSVD_0=%x",
+		FIELD2VALUE(MAX77759_USB_CONFIG_EXTENDED1_REG_RSVD_0, val));
+#else
+	buff[0] = 0;
+#endif
+	return buff;
+}
+
+/*
+ * MESSAGE_HEADER_INFO_REG,0x2E,0b00000100,0x04
+ * RSVD_7_5[2:0],,,CBL_PLG,DATA_ROLE,USB_PD[1:0],
+ */
+#define MAX77759_USB_MESSAGE_HEADER_INFO_REG	0x2E
+#define MAX77759_USB_MESSAGE_HEADER_INFO_REG_CBL_PLG	(0x1 << 4)
+#define MAX77759_USB_MESSAGE_HEADER_INFO_REG_DATA_ROLE	(0x1 << 3)
+#define MAX77759_USB_MESSAGE_HEADER_INFO_REG_PWR_ROLE	(0x1 << 0)
+
+#define MAX77759_USB_MESSAGE_HEADER_INFO_REG_RSVD_7_5_SHIFT	5
+#define MAX77759_USB_MESSAGE_HEADER_INFO_REG_RSVD_7_5_MASK	(0x7 << 5)
+#define MAX77759_USB_MESSAGE_HEADER_INFO_REG_RSVD_7_5_CLEAR	(~(0x7 << 5))
+#define MAX77759_USB_MESSAGE_HEADER_INFO_REG_CBL_PLG_SHIFT	4
+#define MAX77759_USB_MESSAGE_HEADER_INFO_REG_CBL_PLG_MASK	(0x1 << 4)
+#define MAX77759_USB_MESSAGE_HEADER_INFO_REG_CBL_PLG_CLEAR	(~(0x1 << 4))
+#define MAX77759_USB_MESSAGE_HEADER_INFO_REG_DATA_ROLE_SHIFT	3
+#define MAX77759_USB_MESSAGE_HEADER_INFO_REG_DATA_ROLE_MASK	(0x1 << 3)
+#define MAX77759_USB_MESSAGE_HEADER_INFO_REG_DATA_ROLE_CLEAR	(~(0x1 << 3))
+#define MAX77759_USB_MESSAGE_HEADER_INFO_REG_USB_PD_SHIFT	1
+#define MAX77759_USB_MESSAGE_HEADER_INFO_REG_USB_PD_MASK	(0x3 << 1)
+#define MAX77759_USB_MESSAGE_HEADER_INFO_REG_USB_PD_CLEAR	(~(0x3 << 1))
+#define MAX77759_USB_MESSAGE_HEADER_INFO_REG_PWR_ROLE_SHIFT	0
+#define MAX77759_USB_MESSAGE_HEADER_INFO_REG_PWR_ROLE_MASK	(0x1 << 0)
+#define MAX77759_USB_MESSAGE_HEADER_INFO_REG_PWR_ROLE_CLEAR	(~(0x1 << 0))
+
+MAX77759_BFF(usb_message_header_info_reg_rsvd_7_5,7,5)
+MAX77759_BFF(usb_message_header_info_reg_cbl_plg,4,4)
+MAX77759_BFF(usb_message_header_info_reg_data_role,3,3)
+MAX77759_BFF(usb_message_header_info_reg_usb_pd,2,1)
+MAX77759_BFF(usb_message_header_info_reg_pwr_role,0,0)
+static inline const char *
+max77759_usb_message_header_info_reg_cstr(char *buff, size_t len, int val)
+{
+#ifdef SCNPRINTF
+	int i = 0;
+
+	i += SCNPRINTF(&buff[i], len - i, " RSVD_7_5=%x",
+		FIELD2VALUE(MAX77759_USB_MESSAGE_HEADER_INFO_REG_RSVD_7_5, val));
+	i += SCNPRINTF(&buff[i], len - i, " CBL_PLG=%x",
+		FIELD2VALUE(MAX77759_USB_MESSAGE_HEADER_INFO_REG_CBL_PLG, val));
+	i += SCNPRINTF(&buff[i], len - i, " DATA_ROLE=%x",
+		FIELD2VALUE(MAX77759_USB_MESSAGE_HEADER_INFO_REG_DATA_ROLE, val));
+	i += SCNPRINTF(&buff[i], len - i, " USB_PD=%x",
+		FIELD2VALUE(MAX77759_USB_MESSAGE_HEADER_INFO_REG_USB_PD, val));
+	i += SCNPRINTF(&buff[i], len - i, " PWR_ROLE=%x",
+		FIELD2VALUE(MAX77759_USB_MESSAGE_HEADER_INFO_REG_PWR_ROLE, val));
+#else
+	buff[0] = 0;
+#endif
+	return buff;
+}
+
+/*
+ * RECEIVE_DETECT_REG,0x2F,0b00000000,0x00
+ * RSVD_7,EN_CBL_RST,EN_HRD_RST,EN_SOP_DBG2,EN_SOP_DBG1,EN_SOP2,EN_SOP1
+ */
+#define MAX77759_USB_RECEIVE_DETECT_REG	0x2F
+#define MAX77759_USB_RECEIVE_DETECT_REG_RSVD_7	(0x1 << 7)
+#define MAX77759_USB_RECEIVE_DETECT_REG_EN_CBL_RST	(0x1 << 6)
+#define MAX77759_USB_RECEIVE_DETECT_REG_EN_HRD_RST	(0x1 << 5)
+#define MAX77759_USB_RECEIVE_DETECT_REG_EN_SOP_DBG2	(0x1 << 4)
+#define MAX77759_USB_RECEIVE_DETECT_REG_EN_SOP_DBG1	(0x1 << 3)
+#define MAX77759_USB_RECEIVE_DETECT_REG_EN_SOP2	(0x1 << 2)
+#define MAX77759_USB_RECEIVE_DETECT_REG_EN_SOP1	(0x1 << 1)
+#define MAX77759_USB_RECEIVE_DETECT_REG_EN_SOP	(0x1 << 0)
+
+#define MAX77759_USB_RECEIVE_DETECT_REG_RSVD_7_SHIFT	7
+#define MAX77759_USB_RECEIVE_DETECT_REG_RSVD_7_MASK	(0x1 << 7)
+#define MAX77759_USB_RECEIVE_DETECT_REG_RSVD_7_CLEAR	(~(0x1 << 7))
+#define MAX77759_USB_RECEIVE_DETECT_REG_EN_CBL_RST_SHIFT	6
+#define MAX77759_USB_RECEIVE_DETECT_REG_EN_CBL_RST_MASK	(0x1 << 6)
+#define MAX77759_USB_RECEIVE_DETECT_REG_EN_CBL_RST_CLEAR	(~(0x1 << 6))
+#define MAX77759_USB_RECEIVE_DETECT_REG_EN_HRD_RST_SHIFT	5
+#define MAX77759_USB_RECEIVE_DETECT_REG_EN_HRD_RST_MASK	(0x1 << 5)
+#define MAX77759_USB_RECEIVE_DETECT_REG_EN_HRD_RST_CLEAR	(~(0x1 << 5))
+#define MAX77759_USB_RECEIVE_DETECT_REG_EN_SOP_DBG2_SHIFT	4
+#define MAX77759_USB_RECEIVE_DETECT_REG_EN_SOP_DBG2_MASK	(0x1 << 4)
+#define MAX77759_USB_RECEIVE_DETECT_REG_EN_SOP_DBG2_CLEAR	(~(0x1 << 4))
+#define MAX77759_USB_RECEIVE_DETECT_REG_EN_SOP_DBG1_SHIFT	3
+#define MAX77759_USB_RECEIVE_DETECT_REG_EN_SOP_DBG1_MASK	(0x1 << 3)
+#define MAX77759_USB_RECEIVE_DETECT_REG_EN_SOP_DBG1_CLEAR	(~(0x1 << 3))
+#define MAX77759_USB_RECEIVE_DETECT_REG_EN_SOP2_SHIFT	2
+#define MAX77759_USB_RECEIVE_DETECT_REG_EN_SOP2_MASK	(0x1 << 2)
+#define MAX77759_USB_RECEIVE_DETECT_REG_EN_SOP2_CLEAR	(~(0x1 << 2))
+#define MAX77759_USB_RECEIVE_DETECT_REG_EN_SOP1_SHIFT	1
+#define MAX77759_USB_RECEIVE_DETECT_REG_EN_SOP1_MASK	(0x1 << 1)
+#define MAX77759_USB_RECEIVE_DETECT_REG_EN_SOP1_CLEAR	(~(0x1 << 1))
+#define MAX77759_USB_RECEIVE_DETECT_REG_EN_SOP_SHIFT	0
+#define MAX77759_USB_RECEIVE_DETECT_REG_EN_SOP_MASK	(0x1 << 0)
+#define MAX77759_USB_RECEIVE_DETECT_REG_EN_SOP_CLEAR	(~(0x1 << 0))
+
+MAX77759_BFF(usb_receive_detect_reg_rsvd_7,7,7)
+MAX77759_BFF(usb_receive_detect_reg_en_cbl_rst,6,6)
+MAX77759_BFF(usb_receive_detect_reg_en_hrd_rst,5,5)
+MAX77759_BFF(usb_receive_detect_reg_en_sop_dbg2,4,4)
+MAX77759_BFF(usb_receive_detect_reg_en_sop_dbg1,3,3)
+MAX77759_BFF(usb_receive_detect_reg_en_sop2,2,2)
+MAX77759_BFF(usb_receive_detect_reg_en_sop1,1,1)
+MAX77759_BFF(usb_receive_detect_reg_en_sop,0,0)
+static inline const char *
+max77759_usb_receive_detect_reg_cstr(char *buff, size_t len, int val)
+{
+#ifdef SCNPRINTF
+	int i = 0;
+
+	i += SCNPRINTF(&buff[i], len - i, " RSVD_7=%x",
+		FIELD2VALUE(MAX77759_USB_RECEIVE_DETECT_REG_RSVD_7, val));
+	i += SCNPRINTF(&buff[i], len - i, " EN_CBL_RST=%x",
+		FIELD2VALUE(MAX77759_USB_RECEIVE_DETECT_REG_EN_CBL_RST, val));
+	i += SCNPRINTF(&buff[i], len - i, " EN_HRD_RST=%x",
+		FIELD2VALUE(MAX77759_USB_RECEIVE_DETECT_REG_EN_HRD_RST, val));
+	i += SCNPRINTF(&buff[i], len - i, " EN_SOP_DBG2=%x",
+		FIELD2VALUE(MAX77759_USB_RECEIVE_DETECT_REG_EN_SOP_DBG2, val));
+	i += SCNPRINTF(&buff[i], len - i, " EN_SOP_DBG1=%x",
+		FIELD2VALUE(MAX77759_USB_RECEIVE_DETECT_REG_EN_SOP_DBG1, val));
+	i += SCNPRINTF(&buff[i], len - i, " EN_SOP2=%x",
+		FIELD2VALUE(MAX77759_USB_RECEIVE_DETECT_REG_EN_SOP2, val));
+	i += SCNPRINTF(&buff[i], len - i, " EN_SOP1=%x",
+		FIELD2VALUE(MAX77759_USB_RECEIVE_DETECT_REG_EN_SOP1, val));
+	i += SCNPRINTF(&buff[i], len - i, " EN_SOP=%x",
+		FIELD2VALUE(MAX77759_USB_RECEIVE_DETECT_REG_EN_SOP, val));
+#else
+	buff[0] = 0;
+#endif
+	return buff;
+}
+
+/*
+ * RECEIVE_BUFFER_REG,0x30,0b00000000,0x00
+ * RECEIVE_BUFFER[7:0],,,,,,
+ */
+#define MAX77759_USB_RECEIVE_BUFFER_REG	0x30
+
+/*
+ * TRANSMIT_REG,0x50,0b00000000,0x00
+ * RSVD_7_6[1:0],,RETRY_COUNTER[1:0],,RSVD_3,TX_SOP_MESSAGE[2:0],
+ */
+#define MAX77759_USB_TRANSMIT_REG	0x50
+#define MAX77759_USB_TRANSMIT_REG_RSVD_3	(0x1 << 3)
+
+#define MAX77759_USB_TRANSMIT_REG_RSVD_7_6_SHIFT	6
+#define MAX77759_USB_TRANSMIT_REG_RSVD_7_6_MASK	(0x3 << 6)
+#define MAX77759_USB_TRANSMIT_REG_RSVD_7_6_CLEAR	(~(0x3 << 6))
+#define MAX77759_USB_TRANSMIT_REG_RETRY_COUNTER_SHIFT	4
+#define MAX77759_USB_TRANSMIT_REG_RETRY_COUNTER_MASK	(0x3 << 4)
+#define MAX77759_USB_TRANSMIT_REG_RETRY_COUNTER_CLEAR	(~(0x3 << 4))
+#define MAX77759_USB_TRANSMIT_REG_RSVD_3_SHIFT	3
+#define MAX77759_USB_TRANSMIT_REG_RSVD_3_MASK	(0x1 << 3)
+#define MAX77759_USB_TRANSMIT_REG_RSVD_3_CLEAR	(~(0x1 << 3))
+#define MAX77759_USB_TRANSMIT_REG_TX_SOP_MESSAGE_SHIFT	0
+#define MAX77759_USB_TRANSMIT_REG_TX_SOP_MESSAGE_MASK	(0x7 << 0)
+#define MAX77759_USB_TRANSMIT_REG_TX_SOP_MESSAGE_CLEAR	(~(0x7 << 0))
+
+MAX77759_BFF(usb_transmit_reg_rsvd_7_6,7,6)
+MAX77759_BFF(usb_transmit_reg_retry_counter,5,4)
+MAX77759_BFF(usb_transmit_reg_rsvd_3,3,3)
+MAX77759_BFF(usb_transmit_reg_tx_sop_message,2,0)
+static inline const char *
+max77759_usb_transmit_reg_cstr(char *buff, size_t len, int val)
+{
+#ifdef SCNPRINTF
+	int i = 0;
+
+	i += SCNPRINTF(&buff[i], len - i, " RSVD_7_6=%x",
+		FIELD2VALUE(MAX77759_USB_TRANSMIT_REG_RSVD_7_6, val));
+	i += SCNPRINTF(&buff[i], len - i, " RETRY_COUNTER=%x",
+		FIELD2VALUE(MAX77759_USB_TRANSMIT_REG_RETRY_COUNTER, val));
+	i += SCNPRINTF(&buff[i], len - i, " RSVD_3=%x",
+		FIELD2VALUE(MAX77759_USB_TRANSMIT_REG_RSVD_3, val));
+	i += SCNPRINTF(&buff[i], len - i, " TX_SOP_MESSAGE=%x",
+		FIELD2VALUE(MAX77759_USB_TRANSMIT_REG_TX_SOP_MESSAGE, val));
+#else
+	buff[0] = 0;
+#endif
+	return buff;
+}
+
+/*
+ * TRANSMIT_BUFFER_REG,0x51,0b00000000,0x00
+ * TRANSMIT_BUFFER[7:0],,,,,,
+ */
+#define MAX77759_USB_TRANSMIT_BUFFER_REG	0x51
+
+/*
+ * VBUS_VOLTAGE_L,0x70,0b00000000,0x00
+ * VBUS_VOLTAGE7_0[7:0],,,,,,
+ */
+#define MAX77759_USB_VBUS_VOLTAGE_L	0x70
+
+/*
+ * VBUS_VOLTAGE_H,0x71,0b00000000,0x00
+ * RSVD_7_4[3:0],,,,SCALE_FACTOR[1:0],,VBUS_VOLTAGE9_8[1:0]
+ */
+#define MAX77759_USB_VBUS_VOLTAGE_H	0x71
+
+#define MAX77759_USB_VBUS_VOLTAGE_H_RSVD_7_4_SHIFT	4
+#define MAX77759_USB_VBUS_VOLTAGE_H_RSVD_7_4_MASK	(0xf << 4)
+#define MAX77759_USB_VBUS_VOLTAGE_H_RSVD_7_4_CLEAR	(~(0xf << 4))
+#define MAX77759_USB_VBUS_VOLTAGE_H_SCALE_FACTOR_SHIFT	2
+#define MAX77759_USB_VBUS_VOLTAGE_H_SCALE_FACTOR_MASK	(0x3 << 2)
+#define MAX77759_USB_VBUS_VOLTAGE_H_SCALE_FACTOR_CLEAR	(~(0x3 << 2))
+#define MAX77759_USB_VBUS_VOLTAGE_H_VBUS_VOLTAGE9_8_SHIFT	0
+#define MAX77759_USB_VBUS_VOLTAGE_H_VBUS_VOLTAGE9_8_MASK	(0x3 << 0)
+#define MAX77759_USB_VBUS_VOLTAGE_H_VBUS_VOLTAGE9_8_CLEAR	(~(0x3 << 0))
+
+MAX77759_BFF(usb_vbus_voltage_h_rsvd_7_4,7,4)
+MAX77759_BFF(usb_vbus_voltage_h_scale_factor,3,2)
+MAX77759_BFF(usb_vbus_voltage_h_vbus_voltage9_8,1,0)
+static inline const char *
+max77759_usb_vbus_voltage_h_cstr(char *buff, size_t len, int val)
+{
+#ifdef SCNPRINTF
+	int i = 0;
+
+	i += SCNPRINTF(&buff[i], len - i, " RSVD_7_4=%x",
+		FIELD2VALUE(MAX77759_USB_VBUS_VOLTAGE_H_RSVD_7_4, val));
+	i += SCNPRINTF(&buff[i], len - i, " SCALE_FACTOR=%x",
+		FIELD2VALUE(MAX77759_USB_VBUS_VOLTAGE_H_SCALE_FACTOR, val));
+	i += SCNPRINTF(&buff[i], len - i, " VBUS_VOLTAGE9_8=%x",
+		FIELD2VALUE(MAX77759_USB_VBUS_VOLTAGE_H_VBUS_VOLTAGE9_8, val));
+#else
+	buff[0] = 0;
+#endif
+	return buff;
+}
+
+/*
+ * VBUS_SNK_DISC_L,0x72,0b10001100,0x8c
+ * VBUS_SNK_DISC7_0[7:0],,,,,,
+ */
+#define MAX77759_USB_VBUS_SNK_DISC_L	0x72
+
+/*
+ * VBUS_SNK_DISC_H,0x73,0b00000000,0x00
+ * RSVD_7_2[5:0],,,,,,VBUS_SNK_DISC9_8[1:0]
+ */
+#define MAX77759_USB_VBUS_SNK_DISC_H	0x73
+
+#define MAX77759_USB_VBUS_SNK_DISC_H_RSVD_7_2_SHIFT	2
+#define MAX77759_USB_VBUS_SNK_DISC_H_RSVD_7_2_MASK	(0x3f << 2)
+#define MAX77759_USB_VBUS_SNK_DISC_H_RSVD_7_2_CLEAR	(~(0x3f << 2))
+#define MAX77759_USB_VBUS_SNK_DISC_H_VBUS_SNK_DISC9_8_SHIFT	0
+#define MAX77759_USB_VBUS_SNK_DISC_H_VBUS_SNK_DISC9_8_MASK	(0x3 << 0)
+#define MAX77759_USB_VBUS_SNK_DISC_H_VBUS_SNK_DISC9_8_CLEAR	(~(0x3 << 0))
+
+MAX77759_BFF(usb_vbus_snk_disc_h_rsvd_7_2,7,2)
+MAX77759_BFF(usb_vbus_snk_disc_h_vbus_snk_disc9_8,1,0)
+static inline const char *
+max77759_usb_vbus_snk_disc_h_cstr(char *buff, size_t len, int val)
+{
+#ifdef SCNPRINTF
+	int i = 0;
+
+	i += SCNPRINTF(&buff[i], len - i, " RSVD_7_2=%x",
+		FIELD2VALUE(MAX77759_USB_VBUS_SNK_DISC_H_RSVD_7_2, val));
+	i += SCNPRINTF(&buff[i], len - i, " VBUS_SNK_DISC9_8=%x",
+		FIELD2VALUE(MAX77759_USB_VBUS_SNK_DISC_H_VBUS_SNK_DISC9_8, val));
+#else
+	buff[0] = 0;
+#endif
+	return buff;
+}
+
+/*
+ * VBUS_STOP_DISCHARGE_THRESHOLD_L,0x74,0b00100000,0x20
+ * VBUS_STOP_DISCH_THRESHOLD7_0[7:0],,,,,,
+ */
+#define MAX77759_USB_VBUS_STOP_DISCHARGE_THRESHOLD_L	0x74
+
+/*
+ * VBUS_STOP_DISCHARGE_THRESHOLD_H,0x75,0b00000000,0x00
+ * RSVD_7_2[5:0],,,,,,VBUS_STOP_DISCH_THRESHOLD9_8[1:0]
+ */
+#define MAX77759_USB_VBUS_STOP_DISCHARGE_THRESHOLD_H	0x75
+
+#define MAX77759_USB_VBUS_STOP_DISCHARGE_THRESHOLD_H_RSVD_7_2_SHIFT	2
+#define MAX77759_USB_VBUS_STOP_DISCHARGE_THRESHOLD_H_RSVD_7_2_MASK	(0x3f << 2)
+#define MAX77759_USB_VBUS_STOP_DISCHARGE_THRESHOLD_H_RSVD_7_2_CLEAR	(~(0x3f << 2))
+#define MAX77759_USB_VBUS_STOP_DISCHARGE_THRESHOLD_H_VBUS_STOP_DISCH_THRESHOLD9_8_SHIFT	0
+#define MAX77759_USB_VBUS_STOP_DISCHARGE_THRESHOLD_H_VBUS_STOP_DISCH_THRESHOLD9_8_MASK	(0x3 << 0)
+#define MAX77759_USB_VBUS_STOP_DISCHARGE_THRESHOLD_H_VBUS_STOP_DISCH_THRESHOLD9_8_CLEAR	(~(0x3 << 0))
+
+MAX77759_BFF(usb_vbus_stop_discharge_threshold_h_rsvd_7_2,7,2)
+MAX77759_BFF(usb_vbus_stop_discharge_threshold_h_vbus_stop_disch_threshold9_8,1,0)
+static inline const char *
+max77759_usb_vbus_stop_discharge_threshold_h_cstr(char *buff, size_t len, int val)
+{
+#ifdef SCNPRINTF
+	int i = 0;
+
+	i += SCNPRINTF(&buff[i], len - i, " RSVD_7_2=%x",
+		FIELD2VALUE(MAX77759_USB_VBUS_STOP_DISCHARGE_THRESHOLD_H_RSVD_7_2, val));
+	i += SCNPRINTF(&buff[i], len - i, " VBUS_STOP_DISCH_THRESHOLD9_8=%x",
+		FIELD2VALUE(MAX77759_USB_VBUS_STOP_DISCHARGE_THRESHOLD_H_VBUS_STOP_DISCH_THRESHOLD9_8, val));
+#else
+	buff[0] = 0;
+#endif
+	return buff;
+}
+
+/*
+ * VBUS_VOLTAGE_ALARM_HI_CFG_L,0x76,0b00000000,0x00
+ * VBUS_ALARM_HI_CFG7_0[7:0],,,,,,
+ */
+#define MAX77759_USB_VBUS_VOLTAGE_ALARM_HI_CFG_L	0x76
+
+/*
+ * VBUS_VOLTAGE_ALARM_HI_CFG_H,0x77,0b00000000,0x00
+ * RSVD_7_2[5:0],,,,,,VBUS_ALARM_HI_CFG9_8[1:0]
+ */
+#define MAX77759_USB_VBUS_VOLTAGE_ALARM_HI_CFG_H	0x77
+
+#define MAX77759_USB_VBUS_VOLTAGE_ALARM_HI_CFG_H_RSVD_7_2_SHIFT	2
+#define MAX77759_USB_VBUS_VOLTAGE_ALARM_HI_CFG_H_RSVD_7_2_MASK	(0x3f << 2)
+#define MAX77759_USB_VBUS_VOLTAGE_ALARM_HI_CFG_H_RSVD_7_2_CLEAR	(~(0x3f << 2))
+#define MAX77759_USB_VBUS_VOLTAGE_ALARM_HI_CFG_H_VBUS_ALARM_HI_CFG9_8_SHIFT	0
+#define MAX77759_USB_VBUS_VOLTAGE_ALARM_HI_CFG_H_VBUS_ALARM_HI_CFG9_8_MASK	(0x3 << 0)
+#define MAX77759_USB_VBUS_VOLTAGE_ALARM_HI_CFG_H_VBUS_ALARM_HI_CFG9_8_CLEAR	(~(0x3 << 0))
+
+MAX77759_BFF(usb_vbus_voltage_alarm_hi_cfg_h_rsvd_7_2,7,2)
+MAX77759_BFF(usb_vbus_voltage_alarm_hi_cfg_h_vbus_alarm_hi_cfg9_8,1,0)
+static inline const char *
+max77759_usb_vbus_voltage_alarm_hi_cfg_h_cstr(char *buff, size_t len, int val)
+{
+#ifdef SCNPRINTF
+	int i = 0;
+
+	i += SCNPRINTF(&buff[i], len - i, " RSVD_7_2=%x",
+		FIELD2VALUE(MAX77759_USB_VBUS_VOLTAGE_ALARM_HI_CFG_H_RSVD_7_2, val));
+	i += SCNPRINTF(&buff[i], len - i, " VBUS_ALARM_HI_CFG9_8=%x",
+		FIELD2VALUE(MAX77759_USB_VBUS_VOLTAGE_ALARM_HI_CFG_H_VBUS_ALARM_HI_CFG9_8, val));
+#else
+	buff[0] = 0;
+#endif
+	return buff;
+}
+
+/*
+ * VBUS_VOLTAGE_ALARM_LO_CFG_L,0x78,0b00000000,0x00
+ * VBUS_ALARM_LO_CFG_7_0[7:0],,,,,,
+ */
+#define MAX77759_USB_VBUS_VOLTAGE_ALARM_LO_CFG_L	0x78
+
+/*
+ * VBUS_VOLTAGE_ALARM_LO_CFG_H,0x79,0b00000000,0x00
+ * RSVD_7_2[5:0],,,,,,VBUS_ALARM_LO_CFG9_8[1:0]
+ */
+#define MAX77759_USB_VBUS_VOLTAGE_ALARM_LO_CFG_H	0x79
+
+#define MAX77759_USB_VBUS_VOLTAGE_ALARM_LO_CFG_H_RSVD_7_2_SHIFT	2
+#define MAX77759_USB_VBUS_VOLTAGE_ALARM_LO_CFG_H_RSVD_7_2_MASK	(0x3f << 2)
+#define MAX77759_USB_VBUS_VOLTAGE_ALARM_LO_CFG_H_RSVD_7_2_CLEAR	(~(0x3f << 2))
+#define MAX77759_USB_VBUS_VOLTAGE_ALARM_LO_CFG_H_VBUS_ALARM_LO_CFG9_8_SHIFT	0
+#define MAX77759_USB_VBUS_VOLTAGE_ALARM_LO_CFG_H_VBUS_ALARM_LO_CFG9_8_MASK	(0x3 << 0)
+#define MAX77759_USB_VBUS_VOLTAGE_ALARM_LO_CFG_H_VBUS_ALARM_LO_CFG9_8_CLEAR	(~(0x3 << 0))
+
+MAX77759_BFF(usb_vbus_voltage_alarm_lo_cfg_h_rsvd_7_2,7,2)
+MAX77759_BFF(usb_vbus_voltage_alarm_lo_cfg_h_vbus_alarm_lo_cfg9_8,1,0)
+static inline const char *
+max77759_usb_vbus_voltage_alarm_lo_cfg_h_cstr(char *buff, size_t len, int val)
+{
+#ifdef SCNPRINTF
+	int i = 0;
+
+	i += SCNPRINTF(&buff[i], len - i, " RSVD_7_2=%x",
+		FIELD2VALUE(MAX77759_USB_VBUS_VOLTAGE_ALARM_LO_CFG_H_RSVD_7_2, val));
+	i += SCNPRINTF(&buff[i], len - i, " VBUS_ALARM_LO_CFG9_8=%x",
+		FIELD2VALUE(MAX77759_USB_VBUS_VOLTAGE_ALARM_LO_CFG_H_VBUS_ALARM_LO_CFG9_8, val));
+#else
+	buff[0] = 0;
+#endif
+	return buff;
+}
+
+/*
+ * VENDOR_ALERT1,0x80,0b00000000,0x00
+ * SPR_7_6[1:0],,dnVdatRefInt,chgTypRunFInt,chgTypRunRInt,prChgTypInt,dcdTmoInt
+ */
+#define MAX77759_USB_VENDOR_ALERT1	0x80
+#define MAX77759_USB_VENDOR_ALERT1_DNVDATREFINT	(0x1 << 5)
+#define MAX77759_USB_VENDOR_ALERT1_CHGTYPRUNFINT	(0x1 << 4)
+#define MAX77759_USB_VENDOR_ALERT1_CHGTYPRUNRINT	(0x1 << 3)
+#define MAX77759_USB_VENDOR_ALERT1_PRCHGTYPINT	(0x1 << 2)
+#define MAX77759_USB_VENDOR_ALERT1_DCDTMOINT	(0x1 << 1)
+#define MAX77759_USB_VENDOR_ALERT1_CHGTYPINT	(0x1 << 0)
+
+#define MAX77759_USB_VENDOR_ALERT1_SPR_7_6_SHIFT	6
+#define MAX77759_USB_VENDOR_ALERT1_SPR_7_6_MASK	(0x3 << 6)
+#define MAX77759_USB_VENDOR_ALERT1_SPR_7_6_CLEAR	(~(0x3 << 6))
+#define MAX77759_USB_VENDOR_ALERT1_DNVDATREFINT_SHIFT	5
+#define MAX77759_USB_VENDOR_ALERT1_DNVDATREFINT_MASK	(0x1 << 5)
+#define MAX77759_USB_VENDOR_ALERT1_DNVDATREFINT_CLEAR	(~(0x1 << 5))
+#define MAX77759_USB_VENDOR_ALERT1_CHGTYPRUNFINT_SHIFT	4
+#define MAX77759_USB_VENDOR_ALERT1_CHGTYPRUNFINT_MASK	(0x1 << 4)
+#define MAX77759_USB_VENDOR_ALERT1_CHGTYPRUNFINT_CLEAR	(~(0x1 << 4))
+#define MAX77759_USB_VENDOR_ALERT1_CHGTYPRUNRINT_SHIFT	3
+#define MAX77759_USB_VENDOR_ALERT1_CHGTYPRUNRINT_MASK	(0x1 << 3)
+#define MAX77759_USB_VENDOR_ALERT1_CHGTYPRUNRINT_CLEAR	(~(0x1 << 3))
+#define MAX77759_USB_VENDOR_ALERT1_PRCHGTYPINT_SHIFT	2
+#define MAX77759_USB_VENDOR_ALERT1_PRCHGTYPINT_MASK	(0x1 << 2)
+#define MAX77759_USB_VENDOR_ALERT1_PRCHGTYPINT_CLEAR	(~(0x1 << 2))
+#define MAX77759_USB_VENDOR_ALERT1_DCDTMOINT_SHIFT	1
+#define MAX77759_USB_VENDOR_ALERT1_DCDTMOINT_MASK	(0x1 << 1)
+#define MAX77759_USB_VENDOR_ALERT1_DCDTMOINT_CLEAR	(~(0x1 << 1))
+#define MAX77759_USB_VENDOR_ALERT1_CHGTYPINT_SHIFT	0
+#define MAX77759_USB_VENDOR_ALERT1_CHGTYPINT_MASK	(0x1 << 0)
+#define MAX77759_USB_VENDOR_ALERT1_CHGTYPINT_CLEAR	(~(0x1 << 0))
+
+MAX77759_BFF(usb_vendor_alert1_spr_7_6,7,6)
+MAX77759_BFF(usb_vendor_alert1_dnvdatrefint,5,5)
+MAX77759_BFF(usb_vendor_alert1_chgtyprunfint,4,4)
+MAX77759_BFF(usb_vendor_alert1_chgtyprunrint,3,3)
+MAX77759_BFF(usb_vendor_alert1_prchgtypint,2,2)
+MAX77759_BFF(usb_vendor_alert1_dcdtmoint,1,1)
+MAX77759_BFF(usb_vendor_alert1_chgtypint,0,0)
+static inline const char *
+max77759_usb_vendor_alert1_cstr(char *buff, size_t len, int val)
+{
+#ifdef SCNPRINTF
+	int i = 0;
+
+	i += SCNPRINTF(&buff[i], len - i, " SPR_7_6=%x",
+		FIELD2VALUE(MAX77759_USB_VENDOR_ALERT1_SPR_7_6, val));
+	i += SCNPRINTF(&buff[i], len - i, " DNVDATREFINT=%x",
+		FIELD2VALUE(MAX77759_USB_VENDOR_ALERT1_DNVDATREFINT, val));
+	i += SCNPRINTF(&buff[i], len - i, " CHGTYPRUNFINT=%x",
+		FIELD2VALUE(MAX77759_USB_VENDOR_ALERT1_CHGTYPRUNFINT, val));
+	i += SCNPRINTF(&buff[i], len - i, " CHGTYPRUNRINT=%x",
+		FIELD2VALUE(MAX77759_USB_VENDOR_ALERT1_CHGTYPRUNRINT, val));
+	i += SCNPRINTF(&buff[i], len - i, " PRCHGTYPINT=%x",
+		FIELD2VALUE(MAX77759_USB_VENDOR_ALERT1_PRCHGTYPINT, val));
+	i += SCNPRINTF(&buff[i], len - i, " DCDTMOINT=%x",
+		FIELD2VALUE(MAX77759_USB_VENDOR_ALERT1_DCDTMOINT, val));
+	i += SCNPRINTF(&buff[i], len - i, " CHGTYPINT=%x",
+		FIELD2VALUE(MAX77759_USB_VENDOR_ALERT1_CHGTYPINT, val));
+#else
+	buff[0] = 0;
+#endif
+	return buff;
+}
+
+/*
+ * VENDOR_ALERT2,0x81,0b00000000,0x00
+ * SBU_OVPint,USB_OVPint,CC_OVPint,SPR_4_3[1:0],,CCVCNSCInt,FLASH_ADCInt
+ */
+#define MAX77759_USB_VENDOR_ALERT2	0x81
+#define MAX77759_USB_VENDOR_ALERT2_SBU_OVPINT	(0x1 << 7)
+#define MAX77759_USB_VENDOR_ALERT2_USB_OVPINT	(0x1 << 6)
+#define MAX77759_USB_VENDOR_ALERT2_CC_OVPINT	(0x1 << 5)
+#define MAX77759_USB_VENDOR_ALERT2_CCVCNSCINT	(0x1 << 2)
+#define MAX77759_USB_VENDOR_ALERT2_FLASH_ADCINT	(0x1 << 1)
+#define MAX77759_USB_VENDOR_ALERT2_RX_MSG_DISC	(0x1 << 0)
+
+#define MAX77759_USB_VENDOR_ALERT2_SBU_OVPINT_SHIFT	7
+#define MAX77759_USB_VENDOR_ALERT2_SBU_OVPINT_MASK	(0x1 << 7)
+#define MAX77759_USB_VENDOR_ALERT2_SBU_OVPINT_CLEAR	(~(0x1 << 7))
+#define MAX77759_USB_VENDOR_ALERT2_USB_OVPINT_SHIFT	6
+#define MAX77759_USB_VENDOR_ALERT2_USB_OVPINT_MASK	(0x1 << 6)
+#define MAX77759_USB_VENDOR_ALERT2_USB_OVPINT_CLEAR	(~(0x1 << 6))
+#define MAX77759_USB_VENDOR_ALERT2_CC_OVPINT_SHIFT	5
+#define MAX77759_USB_VENDOR_ALERT2_CC_OVPINT_MASK	(0x1 << 5)
+#define MAX77759_USB_VENDOR_ALERT2_CC_OVPINT_CLEAR	(~(0x1 << 5))
+#define MAX77759_USB_VENDOR_ALERT2_SPR_4_3_SHIFT	3
+#define MAX77759_USB_VENDOR_ALERT2_SPR_4_3_MASK	(0x3 << 3)
+#define MAX77759_USB_VENDOR_ALERT2_SPR_4_3_CLEAR	(~(0x3 << 3))
+#define MAX77759_USB_VENDOR_ALERT2_CCVCNSCINT_SHIFT	2
+#define MAX77759_USB_VENDOR_ALERT2_CCVCNSCINT_MASK	(0x1 << 2)
+#define MAX77759_USB_VENDOR_ALERT2_CCVCNSCINT_CLEAR	(~(0x1 << 2))
+#define MAX77759_USB_VENDOR_ALERT2_FLASH_ADCINT_SHIFT	1
+#define MAX77759_USB_VENDOR_ALERT2_FLASH_ADCINT_MASK	(0x1 << 1)
+#define MAX77759_USB_VENDOR_ALERT2_FLASH_ADCINT_CLEAR	(~(0x1 << 1))
+#define MAX77759_USB_VENDOR_ALERT2_RX_MSG_DISC_SHIFT	0
+#define MAX77759_USB_VENDOR_ALERT2_RX_MSG_DISC_MASK	(0x1 << 0)
+#define MAX77759_USB_VENDOR_ALERT2_RX_MSG_DISC_CLEAR	(~(0x1 << 0))
+
+MAX77759_BFF(usb_vendor_alert2_sbu_ovpint,7,7)
+MAX77759_BFF(usb_vendor_alert2_usb_ovpint,6,6)
+MAX77759_BFF(usb_vendor_alert2_cc_ovpint,5,5)
+MAX77759_BFF(usb_vendor_alert2_spr_4_3,4,3)
+MAX77759_BFF(usb_vendor_alert2_ccvcnscint,2,2)
+MAX77759_BFF(usb_vendor_alert2_flash_adcint,1,1)
+MAX77759_BFF(usb_vendor_alert2_rx_msg_disc,0,0)
+static inline const char *
+max77759_usb_vendor_alert2_cstr(char *buff, size_t len, int val)
+{
+#ifdef SCNPRINTF
+	int i = 0;
+
+	i += SCNPRINTF(&buff[i], len - i, " SBU_OVPINT=%x",
+		FIELD2VALUE(MAX77759_USB_VENDOR_ALERT2_SBU_OVPINT, val));
+	i += SCNPRINTF(&buff[i], len - i, " USB_OVPINT=%x",
+		FIELD2VALUE(MAX77759_USB_VENDOR_ALERT2_USB_OVPINT, val));
+	i += SCNPRINTF(&buff[i], len - i, " CC_OVPINT=%x",
+		FIELD2VALUE(MAX77759_USB_VENDOR_ALERT2_CC_OVPINT, val));
+	i += SCNPRINTF(&buff[i], len - i, " SPR_4_3=%x",
+		FIELD2VALUE(MAX77759_USB_VENDOR_ALERT2_SPR_4_3, val));
+	i += SCNPRINTF(&buff[i], len - i, " CCVCNSCINT=%x",
+		FIELD2VALUE(MAX77759_USB_VENDOR_ALERT2_CCVCNSCINT, val));
+	i += SCNPRINTF(&buff[i], len - i, " FLASH_ADCINT=%x",
+		FIELD2VALUE(MAX77759_USB_VENDOR_ALERT2_FLASH_ADCINT, val));
+	i += SCNPRINTF(&buff[i], len - i, " RX_MSG_DISC=%x",
+		FIELD2VALUE(MAX77759_USB_VENDOR_ALERT2_RX_MSG_DISC, val));
+#else
+	buff[0] = 0;
+#endif
+	return buff;
+}
+
+/*
+ * VENDOR_ALERT_MASK1,0x82,0b11111111,0xff
+ * SPR_7_6[1:0],,MSK_dnVDatRef,MSK_chgTypRunF,MSK_chgTypRunR,MSK_PrchgTyp,MSK_dcdTmo
+ */
+#define MAX77759_USB_VENDOR_ALERT_MASK1	0x82
+#define MAX77759_USB_VENDOR_ALERT_MASK1_MSK_DNVDATREF	(0x1 << 5)
+#define MAX77759_USB_VENDOR_ALERT_MASK1_MSK_CHGTYPRUNF	(0x1 << 4)
+#define MAX77759_USB_VENDOR_ALERT_MASK1_MSK_CHGTYPRUNR	(0x1 << 3)
+#define MAX77759_USB_VENDOR_ALERT_MASK1_MSK_PRCHGTYP	(0x1 << 2)
+#define MAX77759_USB_VENDOR_ALERT_MASK1_MSK_DCDTMO	(0x1 << 1)
+#define MAX77759_USB_VENDOR_ALERT_MASK1_MSK_CHGTYP	(0x1 << 0)
+
+#define MAX77759_USB_VENDOR_ALERT_MASK1_SPR_7_6_SHIFT	6
+#define MAX77759_USB_VENDOR_ALERT_MASK1_SPR_7_6_MASK	(0x3 << 6)
+#define MAX77759_USB_VENDOR_ALERT_MASK1_SPR_7_6_CLEAR	(~(0x3 << 6))
+#define MAX77759_USB_VENDOR_ALERT_MASK1_MSK_DNVDATREF_SHIFT	5
+#define MAX77759_USB_VENDOR_ALERT_MASK1_MSK_DNVDATREF_MASK	(0x1 << 5)
+#define MAX77759_USB_VENDOR_ALERT_MASK1_MSK_DNVDATREF_CLEAR	(~(0x1 << 5))
+#define MAX77759_USB_VENDOR_ALERT_MASK1_MSK_CHGTYPRUNF_SHIFT	4
+#define MAX77759_USB_VENDOR_ALERT_MASK1_MSK_CHGTYPRUNF_MASK	(0x1 << 4)
+#define MAX77759_USB_VENDOR_ALERT_MASK1_MSK_CHGTYPRUNF_CLEAR	(~(0x1 << 4))
+#define MAX77759_USB_VENDOR_ALERT_MASK1_MSK_CHGTYPRUNR_SHIFT	3
+#define MAX77759_USB_VENDOR_ALERT_MASK1_MSK_CHGTYPRUNR_MASK	(0x1 << 3)
+#define MAX77759_USB_VENDOR_ALERT_MASK1_MSK_CHGTYPRUNR_CLEAR	(~(0x1 << 3))
+#define MAX77759_USB_VENDOR_ALERT_MASK1_MSK_PRCHGTYP_SHIFT	2
+#define MAX77759_USB_VENDOR_ALERT_MASK1_MSK_PRCHGTYP_MASK	(0x1 << 2)
+#define MAX77759_USB_VENDOR_ALERT_MASK1_MSK_PRCHGTYP_CLEAR	(~(0x1 << 2))
+#define MAX77759_USB_VENDOR_ALERT_MASK1_MSK_DCDTMO_SHIFT	1
+#define MAX77759_USB_VENDOR_ALERT_MASK1_MSK_DCDTMO_MASK	(0x1 << 1)
+#define MAX77759_USB_VENDOR_ALERT_MASK1_MSK_DCDTMO_CLEAR	(~(0x1 << 1))
+#define MAX77759_USB_VENDOR_ALERT_MASK1_MSK_CHGTYP_SHIFT	0
+#define MAX77759_USB_VENDOR_ALERT_MASK1_MSK_CHGTYP_MASK	(0x1 << 0)
+#define MAX77759_USB_VENDOR_ALERT_MASK1_MSK_CHGTYP_CLEAR	(~(0x1 << 0))
+
+MAX77759_BFF(usb_vendor_alert_mask1_spr_7_6,7,6)
+MAX77759_BFF(usb_vendor_alert_mask1_msk_dnvdatref,5,5)
+MAX77759_BFF(usb_vendor_alert_mask1_msk_chgtyprunf,4,4)
+MAX77759_BFF(usb_vendor_alert_mask1_msk_chgtyprunr,3,3)
+MAX77759_BFF(usb_vendor_alert_mask1_msk_prchgtyp,2,2)
+MAX77759_BFF(usb_vendor_alert_mask1_msk_dcdtmo,1,1)
+MAX77759_BFF(usb_vendor_alert_mask1_msk_chgtyp,0,0)
+static inline const char *
+max77759_usb_vendor_alert_mask1_cstr(char *buff, size_t len, int val)
+{
+#ifdef SCNPRINTF
+	int i = 0;
+
+	i += SCNPRINTF(&buff[i], len - i, " SPR_7_6=%x",
+		FIELD2VALUE(MAX77759_USB_VENDOR_ALERT_MASK1_SPR_7_6, val));
+	i += SCNPRINTF(&buff[i], len - i, " MSK_DNVDATREF=%x",
+		FIELD2VALUE(MAX77759_USB_VENDOR_ALERT_MASK1_MSK_DNVDATREF, val));
+	i += SCNPRINTF(&buff[i], len - i, " MSK_CHGTYPRUNF=%x",
+		FIELD2VALUE(MAX77759_USB_VENDOR_ALERT_MASK1_MSK_CHGTYPRUNF, val));
+	i += SCNPRINTF(&buff[i], len - i, " MSK_CHGTYPRUNR=%x",
+		FIELD2VALUE(MAX77759_USB_VENDOR_ALERT_MASK1_MSK_CHGTYPRUNR, val));
+	i += SCNPRINTF(&buff[i], len - i, " MSK_PRCHGTYP=%x",
+		FIELD2VALUE(MAX77759_USB_VENDOR_ALERT_MASK1_MSK_PRCHGTYP, val));
+	i += SCNPRINTF(&buff[i], len - i, " MSK_DCDTMO=%x",
+		FIELD2VALUE(MAX77759_USB_VENDOR_ALERT_MASK1_MSK_DCDTMO, val));
+	i += SCNPRINTF(&buff[i], len - i, " MSK_CHGTYP=%x",
+		FIELD2VALUE(MAX77759_USB_VENDOR_ALERT_MASK1_MSK_CHGTYP, val));
+#else
+	buff[0] = 0;
+#endif
+	return buff;
+}
+
+/*
+ * VENDOR_ALERT_MASK2,0x83,0b11111111,0xff
+ * MSK_SBU_OVP,MSK_USB_OVP,MSK_CC_OVP,SPR_4_3[1:0],,MSK_CCVCNSCInt,MSK_FLASH_ADCInt
+ */
+#define MAX77759_USB_VENDOR_ALERT_MASK2	0x83
+#define MAX77759_USB_VENDOR_ALERT_MASK2_MSK_SBU_OVP	(0x1 << 7)
+#define MAX77759_USB_VENDOR_ALERT_MASK2_MSK_USB_OVP	(0x1 << 6)
+#define MAX77759_USB_VENDOR_ALERT_MASK2_MSK_CC_OVP	(0x1 << 5)
+#define MAX77759_USB_VENDOR_ALERT_MASK2_MSK_CCVCNSCINT	(0x1 << 2)
+#define MAX77759_USB_VENDOR_ALERT_MASK2_MSK_FLASH_ADCINT	(0x1 << 1)
+#define MAX77759_USB_VENDOR_ALERT_MASK2_MSK_RX_MSG_DISC	(0x1 << 0)
+
+#define MAX77759_USB_VENDOR_ALERT_MASK2_MSK_SBU_OVP_SHIFT	7
+#define MAX77759_USB_VENDOR_ALERT_MASK2_MSK_SBU_OVP_MASK	(0x1 << 7)
+#define MAX77759_USB_VENDOR_ALERT_MASK2_MSK_SBU_OVP_CLEAR	(~(0x1 << 7))
+#define MAX77759_USB_VENDOR_ALERT_MASK2_MSK_USB_OVP_SHIFT	6
+#define MAX77759_USB_VENDOR_ALERT_MASK2_MSK_USB_OVP_MASK	(0x1 << 6)
+#define MAX77759_USB_VENDOR_ALERT_MASK2_MSK_USB_OVP_CLEAR	(~(0x1 << 6))
+#define MAX77759_USB_VENDOR_ALERT_MASK2_MSK_CC_OVP_SHIFT	5
+#define MAX77759_USB_VENDOR_ALERT_MASK2_MSK_CC_OVP_MASK	(0x1 << 5)
+#define MAX77759_USB_VENDOR_ALERT_MASK2_MSK_CC_OVP_CLEAR	(~(0x1 << 5))
+#define MAX77759_USB_VENDOR_ALERT_MASK2_SPR_4_3_SHIFT	3
+#define MAX77759_USB_VENDOR_ALERT_MASK2_SPR_4_3_MASK	(0x3 << 3)
+#define MAX77759_USB_VENDOR_ALERT_MASK2_SPR_4_3_CLEAR	(~(0x3 << 3))
+#define MAX77759_USB_VENDOR_ALERT_MASK2_MSK_CCVCNSCINT_SHIFT	2
+#define MAX77759_USB_VENDOR_ALERT_MASK2_MSK_CCVCNSCINT_MASK	(0x1 << 2)
+#define MAX77759_USB_VENDOR_ALERT_MASK2_MSK_CCVCNSCINT_CLEAR	(~(0x1 << 2))
+#define MAX77759_USB_VENDOR_ALERT_MASK2_MSK_FLASH_ADCINT_SHIFT	1
+#define MAX77759_USB_VENDOR_ALERT_MASK2_MSK_FLASH_ADCINT_MASK	(0x1 << 1)
+#define MAX77759_USB_VENDOR_ALERT_MASK2_MSK_FLASH_ADCINT_CLEAR	(~(0x1 << 1))
+#define MAX77759_USB_VENDOR_ALERT_MASK2_MSK_RX_MSG_DISC_SHIFT	0
+#define MAX77759_USB_VENDOR_ALERT_MASK2_MSK_RX_MSG_DISC_MASK	(0x1 << 0)
+#define MAX77759_USB_VENDOR_ALERT_MASK2_MSK_RX_MSG_DISC_CLEAR	(~(0x1 << 0))
+
+MAX77759_BFF(usb_vendor_alert_mask2_msk_sbu_ovp,7,7)
+MAX77759_BFF(usb_vendor_alert_mask2_msk_usb_ovp,6,6)
+MAX77759_BFF(usb_vendor_alert_mask2_msk_cc_ovp,5,5)
+MAX77759_BFF(usb_vendor_alert_mask2_spr_4_3,4,3)
+MAX77759_BFF(usb_vendor_alert_mask2_msk_ccvcnscint,2,2)
+MAX77759_BFF(usb_vendor_alert_mask2_msk_flash_adcint,1,1)
+MAX77759_BFF(usb_vendor_alert_mask2_msk_rx_msg_disc,0,0)
+static inline const char *
+max77759_usb_vendor_alert_mask2_cstr(char *buff, size_t len, int val)
+{
+#ifdef SCNPRINTF
+	int i = 0;
+
+	i += SCNPRINTF(&buff[i], len - i, " MSK_SBU_OVP=%x",
+		FIELD2VALUE(MAX77759_USB_VENDOR_ALERT_MASK2_MSK_SBU_OVP, val));
+	i += SCNPRINTF(&buff[i], len - i, " MSK_USB_OVP=%x",
+		FIELD2VALUE(MAX77759_USB_VENDOR_ALERT_MASK2_MSK_USB_OVP, val));
+	i += SCNPRINTF(&buff[i], len - i, " MSK_CC_OVP=%x",
+		FIELD2VALUE(MAX77759_USB_VENDOR_ALERT_MASK2_MSK_CC_OVP, val));
+	i += SCNPRINTF(&buff[i], len - i, " SPR_4_3=%x",
+		FIELD2VALUE(MAX77759_USB_VENDOR_ALERT_MASK2_SPR_4_3, val));
+	i += SCNPRINTF(&buff[i], len - i, " MSK_CCVCNSCINT=%x",
+		FIELD2VALUE(MAX77759_USB_VENDOR_ALERT_MASK2_MSK_CCVCNSCINT, val));
+	i += SCNPRINTF(&buff[i], len - i, " MSK_FLASH_ADCINT=%x",
+		FIELD2VALUE(MAX77759_USB_VENDOR_ALERT_MASK2_MSK_FLASH_ADCINT, val));
+	i += SCNPRINTF(&buff[i], len - i, " MSK_RX_MSG_DISC=%x",
+		FIELD2VALUE(MAX77759_USB_VENDOR_ALERT_MASK2_MSK_RX_MSG_DISC, val));
+#else
+	buff[0] = 0;
+#endif
+	return buff;
+}
+
+/*
+ * VENDOR_CC_STATUS1,0x84,0b00000000,0x00
+ * SBU2_OVP,SBU1_OVP,USBDP_OVP,USBDN_OVP,CC2_OVP,CC1_OVP,SPR_1_0[1:0]
+ */
+#define MAX77759_USB_VENDOR_CC_STATUS1	0x84
+#define MAX77759_USB_VENDOR_CC_STATUS1_SBU2_OVP	(0x1 << 7)
+#define MAX77759_USB_VENDOR_CC_STATUS1_SBU1_OVP	(0x1 << 6)
+#define MAX77759_USB_VENDOR_CC_STATUS1_USBDP_OVP	(0x1 << 5)
+#define MAX77759_USB_VENDOR_CC_STATUS1_USBDN_OVP	(0x1 << 4)
+#define MAX77759_USB_VENDOR_CC_STATUS1_CC2_OVP	(0x1 << 3)
+#define MAX77759_USB_VENDOR_CC_STATUS1_CC1_OVP	(0x1 << 2)
+
+#define MAX77759_USB_VENDOR_CC_STATUS1_SBU2_OVP_SHIFT	7
+#define MAX77759_USB_VENDOR_CC_STATUS1_SBU2_OVP_MASK	(0x1 << 7)
+#define MAX77759_USB_VENDOR_CC_STATUS1_SBU2_OVP_CLEAR	(~(0x1 << 7))
+#define MAX77759_USB_VENDOR_CC_STATUS1_SBU1_OVP_SHIFT	6
+#define MAX77759_USB_VENDOR_CC_STATUS1_SBU1_OVP_MASK	(0x1 << 6)
+#define MAX77759_USB_VENDOR_CC_STATUS1_SBU1_OVP_CLEAR	(~(0x1 << 6))
+#define MAX77759_USB_VENDOR_CC_STATUS1_USBDP_OVP_SHIFT	5
+#define MAX77759_USB_VENDOR_CC_STATUS1_USBDP_OVP_MASK	(0x1 << 5)
+#define MAX77759_USB_VENDOR_CC_STATUS1_USBDP_OVP_CLEAR	(~(0x1 << 5))
+#define MAX77759_USB_VENDOR_CC_STATUS1_USBDN_OVP_SHIFT	4
+#define MAX77759_USB_VENDOR_CC_STATUS1_USBDN_OVP_MASK	(0x1 << 4)
+#define MAX77759_USB_VENDOR_CC_STATUS1_USBDN_OVP_CLEAR	(~(0x1 << 4))
+#define MAX77759_USB_VENDOR_CC_STATUS1_CC2_OVP_SHIFT	3
+#define MAX77759_USB_VENDOR_CC_STATUS1_CC2_OVP_MASK	(0x1 << 3)
+#define MAX77759_USB_VENDOR_CC_STATUS1_CC2_OVP_CLEAR	(~(0x1 << 3))
+#define MAX77759_USB_VENDOR_CC_STATUS1_CC1_OVP_SHIFT	2
+#define MAX77759_USB_VENDOR_CC_STATUS1_CC1_OVP_MASK	(0x1 << 2)
+#define MAX77759_USB_VENDOR_CC_STATUS1_CC1_OVP_CLEAR	(~(0x1 << 2))
+#define MAX77759_USB_VENDOR_CC_STATUS1_SPR_1_0_SHIFT	0
+#define MAX77759_USB_VENDOR_CC_STATUS1_SPR_1_0_MASK	(0x3 << 0)
+#define MAX77759_USB_VENDOR_CC_STATUS1_SPR_1_0_CLEAR	(~(0x3 << 0))
+
+MAX77759_BFF(usb_vendor_cc_status1_sbu2_ovp,7,7)
+MAX77759_BFF(usb_vendor_cc_status1_sbu1_ovp,6,6)
+MAX77759_BFF(usb_vendor_cc_status1_usbdp_ovp,5,5)
+MAX77759_BFF(usb_vendor_cc_status1_usbdn_ovp,4,4)
+MAX77759_BFF(usb_vendor_cc_status1_cc2_ovp,3,3)
+MAX77759_BFF(usb_vendor_cc_status1_cc1_ovp,2,2)
+MAX77759_BFF(usb_vendor_cc_status1_spr_1_0,1,0)
+static inline const char *
+max77759_usb_vendor_cc_status1_cstr(char *buff, size_t len, int val)
+{
+#ifdef SCNPRINTF
+	int i = 0;
+
+	i += SCNPRINTF(&buff[i], len - i, " SBU2_OVP=%x",
+		FIELD2VALUE(MAX77759_USB_VENDOR_CC_STATUS1_SBU2_OVP, val));
+	i += SCNPRINTF(&buff[i], len - i, " SBU1_OVP=%x",
+		FIELD2VALUE(MAX77759_USB_VENDOR_CC_STATUS1_SBU1_OVP, val));
+	i += SCNPRINTF(&buff[i], len - i, " USBDP_OVP=%x",
+		FIELD2VALUE(MAX77759_USB_VENDOR_CC_STATUS1_USBDP_OVP, val));
+	i += SCNPRINTF(&buff[i], len - i, " USBDN_OVP=%x",
+		FIELD2VALUE(MAX77759_USB_VENDOR_CC_STATUS1_USBDN_OVP, val));
+	i += SCNPRINTF(&buff[i], len - i, " CC2_OVP=%x",
+		FIELD2VALUE(MAX77759_USB_VENDOR_CC_STATUS1_CC2_OVP, val));
+	i += SCNPRINTF(&buff[i], len - i, " CC1_OVP=%x",
+		FIELD2VALUE(MAX77759_USB_VENDOR_CC_STATUS1_CC1_OVP, val));
+	i += SCNPRINTF(&buff[i], len - i, " SPR_1_0=%x",
+		FIELD2VALUE(MAX77759_USB_VENDOR_CC_STATUS1_SPR_1_0, val));
+#else
+	buff[0] = 0;
+#endif
+	return buff;
+}
+
+/*
+ * VENDOR_CC_STATUS2,0x85,0b00000000,0x00
+ * CC2_VDFP_OPEN,CC2_VUFP_RD1P5,CC2_VUFP_RD0P5,CC2_VRA_RD0P5,CC1_VDFP_OPEN,CC1_VUFP_RD1P5,CC1_VUFP_RD0P5
+ */
+#define MAX77759_USB_VENDOR_CC_STATUS2	0x85
+#define MAX77759_USB_VENDOR_CC_STATUS2_CC2_VDFP_OPEN	(0x1 << 7)
+#define MAX77759_USB_VENDOR_CC_STATUS2_CC2_VUFP_RD1P5	(0x1 << 6)
+#define MAX77759_USB_VENDOR_CC_STATUS2_CC2_VUFP_RD0P5	(0x1 << 5)
+#define MAX77759_USB_VENDOR_CC_STATUS2_CC2_VRA_RD0P5	(0x1 << 4)
+#define MAX77759_USB_VENDOR_CC_STATUS2_CC1_VDFP_OPEN	(0x1 << 3)
+#define MAX77759_USB_VENDOR_CC_STATUS2_CC1_VUFP_RD1P5	(0x1 << 2)
+#define MAX77759_USB_VENDOR_CC_STATUS2_CC1_VUFP_RD0P5	(0x1 << 1)
+#define MAX77759_USB_VENDOR_CC_STATUS2_CC1_VRA_RD0P5	(0x1 << 0)
+
+#define MAX77759_USB_VENDOR_CC_STATUS2_CC2_VDFP_OPEN_SHIFT	7
+#define MAX77759_USB_VENDOR_CC_STATUS2_CC2_VDFP_OPEN_MASK	(0x1 << 7)
+#define MAX77759_USB_VENDOR_CC_STATUS2_CC2_VDFP_OPEN_CLEAR	(~(0x1 << 7))
+#define MAX77759_USB_VENDOR_CC_STATUS2_CC2_VUFP_RD1P5_SHIFT	6
+#define MAX77759_USB_VENDOR_CC_STATUS2_CC2_VUFP_RD1P5_MASK	(0x1 << 6)
+#define MAX77759_USB_VENDOR_CC_STATUS2_CC2_VUFP_RD1P5_CLEAR	(~(0x1 << 6))
+#define MAX77759_USB_VENDOR_CC_STATUS2_CC2_VUFP_RD0P5_SHIFT	5
+#define MAX77759_USB_VENDOR_CC_STATUS2_CC2_VUFP_RD0P5_MASK	(0x1 << 5)
+#define MAX77759_USB_VENDOR_CC_STATUS2_CC2_VUFP_RD0P5_CLEAR	(~(0x1 << 5))
+#define MAX77759_USB_VENDOR_CC_STATUS2_CC2_VRA_RD0P5_SHIFT	4
+#define MAX77759_USB_VENDOR_CC_STATUS2_CC2_VRA_RD0P5_MASK	(0x1 << 4)
+#define MAX77759_USB_VENDOR_CC_STATUS2_CC2_VRA_RD0P5_CLEAR	(~(0x1 << 4))
+#define MAX77759_USB_VENDOR_CC_STATUS2_CC1_VDFP_OPEN_SHIFT	3
+#define MAX77759_USB_VENDOR_CC_STATUS2_CC1_VDFP_OPEN_MASK	(0x1 << 3)
+#define MAX77759_USB_VENDOR_CC_STATUS2_CC1_VDFP_OPEN_CLEAR	(~(0x1 << 3))
+#define MAX77759_USB_VENDOR_CC_STATUS2_CC1_VUFP_RD1P5_SHIFT	2
+#define MAX77759_USB_VENDOR_CC_STATUS2_CC1_VUFP_RD1P5_MASK	(0x1 << 2)
+#define MAX77759_USB_VENDOR_CC_STATUS2_CC1_VUFP_RD1P5_CLEAR	(~(0x1 << 2))
+#define MAX77759_USB_VENDOR_CC_STATUS2_CC1_VUFP_RD0P5_SHIFT	1
+#define MAX77759_USB_VENDOR_CC_STATUS2_CC1_VUFP_RD0P5_MASK	(0x1 << 1)
+#define MAX77759_USB_VENDOR_CC_STATUS2_CC1_VUFP_RD0P5_CLEAR	(~(0x1 << 1))
+#define MAX77759_USB_VENDOR_CC_STATUS2_CC1_VRA_RD0P5_SHIFT	0
+#define MAX77759_USB_VENDOR_CC_STATUS2_CC1_VRA_RD0P5_MASK	(0x1 << 0)
+#define MAX77759_USB_VENDOR_CC_STATUS2_CC1_VRA_RD0P5_CLEAR	(~(0x1 << 0))
+
+MAX77759_BFF(usb_vendor_cc_status2_cc2_vdfp_open,7,7)
+MAX77759_BFF(usb_vendor_cc_status2_cc2_vufp_rd1p5,6,6)
+MAX77759_BFF(usb_vendor_cc_status2_cc2_vufp_rd0p5,5,5)
+MAX77759_BFF(usb_vendor_cc_status2_cc2_vra_rd0p5,4,4)
+MAX77759_BFF(usb_vendor_cc_status2_cc1_vdfp_open,3,3)
+MAX77759_BFF(usb_vendor_cc_status2_cc1_vufp_rd1p5,2,2)
+MAX77759_BFF(usb_vendor_cc_status2_cc1_vufp_rd0p5,1,1)
+MAX77759_BFF(usb_vendor_cc_status2_cc1_vra_rd0p5,0,0)
+static inline const char *
+max77759_usb_vendor_cc_status2_cstr(char *buff, size_t len, int val)
+{
+#ifdef SCNPRINTF
+	int i = 0;
+
+	i += SCNPRINTF(&buff[i], len - i, " CC2_VDFP_OPEN=%x",
+		FIELD2VALUE(MAX77759_USB_VENDOR_CC_STATUS2_CC2_VDFP_OPEN, val));
+	i += SCNPRINTF(&buff[i], len - i, " CC2_VUFP_RD1P5=%x",
+		FIELD2VALUE(MAX77759_USB_VENDOR_CC_STATUS2_CC2_VUFP_RD1P5, val));
+	i += SCNPRINTF(&buff[i], len - i, " CC2_VUFP_RD0P5=%x",
+		FIELD2VALUE(MAX77759_USB_VENDOR_CC_STATUS2_CC2_VUFP_RD0P5, val));
+	i += SCNPRINTF(&buff[i], len - i, " CC2_VRA_RD0P5=%x",
+		FIELD2VALUE(MAX77759_USB_VENDOR_CC_STATUS2_CC2_VRA_RD0P5, val));
+	i += SCNPRINTF(&buff[i], len - i, " CC1_VDFP_OPEN=%x",
+		FIELD2VALUE(MAX77759_USB_VENDOR_CC_STATUS2_CC1_VDFP_OPEN, val));
+	i += SCNPRINTF(&buff[i], len - i, " CC1_VUFP_RD1P5=%x",
+		FIELD2VALUE(MAX77759_USB_VENDOR_CC_STATUS2_CC1_VUFP_RD1P5, val));
+	i += SCNPRINTF(&buff[i], len - i, " CC1_VUFP_RD0P5=%x",
+		FIELD2VALUE(MAX77759_USB_VENDOR_CC_STATUS2_CC1_VUFP_RD0P5, val));
+	i += SCNPRINTF(&buff[i], len - i, " CC1_VRA_RD0P5=%x",
+		FIELD2VALUE(MAX77759_USB_VENDOR_CC_STATUS2_CC1_VRA_RD0P5, val));
+#else
+	buff[0] = 0;
+#endif
+	return buff;
+}
+
+/*
+ * VENDOR_CC_STATUS3,0x86,0b00000000,0x00
+ * ccVcnSc,ccVcnOCP,SPR_5_1[4:0],,,,
+ */
+#define MAX77759_USB_VENDOR_CC_STATUS3	0x86
+#define MAX77759_USB_VENDOR_CC_STATUS3_CCVCNSC	(0x1 << 7)
+#define MAX77759_USB_VENDOR_CC_STATUS3_CCVCNOCP	(0x1 << 6)
+#define MAX77759_USB_VENDOR_CC_STATUS3_CCVCNSTAT	(0x1 << 0)
+
+#define MAX77759_USB_VENDOR_CC_STATUS3_CCVCNSC_SHIFT	7
+#define MAX77759_USB_VENDOR_CC_STATUS3_CCVCNSC_MASK	(0x1 << 7)
+#define MAX77759_USB_VENDOR_CC_STATUS3_CCVCNSC_CLEAR	(~(0x1 << 7))
+#define MAX77759_USB_VENDOR_CC_STATUS3_CCVCNOCP_SHIFT	6
+#define MAX77759_USB_VENDOR_CC_STATUS3_CCVCNOCP_MASK	(0x1 << 6)
+#define MAX77759_USB_VENDOR_CC_STATUS3_CCVCNOCP_CLEAR	(~(0x1 << 6))
+#define MAX77759_USB_VENDOR_CC_STATUS3_SPR_5_1_SHIFT	1
+#define MAX77759_USB_VENDOR_CC_STATUS3_SPR_5_1_MASK	(0x1f << 1)
+#define MAX77759_USB_VENDOR_CC_STATUS3_SPR_5_1_CLEAR	(~(0x1f << 1))
+#define MAX77759_USB_VENDOR_CC_STATUS3_CCVCNSTAT_SHIFT	0
+#define MAX77759_USB_VENDOR_CC_STATUS3_CCVCNSTAT_MASK	(0x1 << 0)
+#define MAX77759_USB_VENDOR_CC_STATUS3_CCVCNSTAT_CLEAR	(~(0x1 << 0))
+
+MAX77759_BFF(usb_vendor_cc_status3_ccvcnsc,7,7)
+MAX77759_BFF(usb_vendor_cc_status3_ccvcnocp,6,6)
+MAX77759_BFF(usb_vendor_cc_status3_spr_5_1,5,1)
+MAX77759_BFF(usb_vendor_cc_status3_ccvcnstat,0,0)
+static inline const char *
+max77759_usb_vendor_cc_status3_cstr(char *buff, size_t len, int val)
+{
+#ifdef SCNPRINTF
+	int i = 0;
+
+	i += SCNPRINTF(&buff[i], len - i, " CCVCNSC=%x",
+		FIELD2VALUE(MAX77759_USB_VENDOR_CC_STATUS3_CCVCNSC, val));
+	i += SCNPRINTF(&buff[i], len - i, " CCVCNOCP=%x",
+		FIELD2VALUE(MAX77759_USB_VENDOR_CC_STATUS3_CCVCNOCP, val));
+	i += SCNPRINTF(&buff[i], len - i, " SPR_5_1=%x",
+		FIELD2VALUE(MAX77759_USB_VENDOR_CC_STATUS3_SPR_5_1, val));
+	i += SCNPRINTF(&buff[i], len - i, " CCVCNSTAT=%x",
+		FIELD2VALUE(MAX77759_USB_VENDOR_CC_STATUS3_CCVCNSTAT, val));
+#else
+	buff[0] = 0;
+#endif
+	return buff;
+}
+
+/*
+ * VENDOR_BC_STATUS1,0x87,0b00000000,0x00
+ * SPR_7,ChgTypRun,PrChgTyp[2:0],,,DCDTmo,ChgTyp[1:0]
+ */
+#define MAX77759_USB_VENDOR_BC_STATUS1	0x87
+#define MAX77759_USB_VENDOR_BC_STATUS1_SPR_7	(0x1 << 7)
+#define MAX77759_USB_VENDOR_BC_STATUS1_CHGTYPRUN	(0x1 << 6)
+#define MAX77759_USB_VENDOR_BC_STATUS1_DCDTMO	(0x1 << 2)
+
+#define MAX77759_USB_VENDOR_BC_STATUS1_SPR_7_SHIFT	7
+#define MAX77759_USB_VENDOR_BC_STATUS1_SPR_7_MASK	(0x1 << 7)
+#define MAX77759_USB_VENDOR_BC_STATUS1_SPR_7_CLEAR	(~(0x1 << 7))
+#define MAX77759_USB_VENDOR_BC_STATUS1_CHGTYPRUN_SHIFT	6
+#define MAX77759_USB_VENDOR_BC_STATUS1_CHGTYPRUN_MASK	(0x1 << 6)
+#define MAX77759_USB_VENDOR_BC_STATUS1_CHGTYPRUN_CLEAR	(~(0x1 << 6))
+#define MAX77759_USB_VENDOR_BC_STATUS1_PRCHGTYP_SHIFT	3
+#define MAX77759_USB_VENDOR_BC_STATUS1_PRCHGTYP_MASK	(0x7 << 3)
+#define MAX77759_USB_VENDOR_BC_STATUS1_PRCHGTYP_CLEAR	(~(0x7 << 3))
+#define MAX77759_USB_VENDOR_BC_STATUS1_DCDTMO_SHIFT	2
+#define MAX77759_USB_VENDOR_BC_STATUS1_DCDTMO_MASK	(0x1 << 2)
+#define MAX77759_USB_VENDOR_BC_STATUS1_DCDTMO_CLEAR	(~(0x1 << 2))
+#define MAX77759_USB_VENDOR_BC_STATUS1_CHGTYP_SHIFT	0
+#define MAX77759_USB_VENDOR_BC_STATUS1_CHGTYP_MASK	(0x3 << 0)
+#define MAX77759_USB_VENDOR_BC_STATUS1_CHGTYP_CLEAR	(~(0x3 << 0))
+
+MAX77759_BFF(usb_vendor_bc_status1_spr_7,7,7)
+MAX77759_BFF(usb_vendor_bc_status1_chgtyprun,6,6)
+MAX77759_BFF(usb_vendor_bc_status1_prchgtyp,5,3)
+MAX77759_BFF(usb_vendor_bc_status1_dcdtmo,2,2)
+MAX77759_BFF(usb_vendor_bc_status1_chgtyp,1,0)
+static inline const char *
+max77759_usb_vendor_bc_status1_cstr(char *buff, size_t len, int val)
+{
+#ifdef SCNPRINTF
+	int i = 0;
+
+	i += SCNPRINTF(&buff[i], len - i, " SPR_7=%x",
+		FIELD2VALUE(MAX77759_USB_VENDOR_BC_STATUS1_SPR_7, val));
+	i += SCNPRINTF(&buff[i], len - i, " CHGTYPRUN=%x",
+		FIELD2VALUE(MAX77759_USB_VENDOR_BC_STATUS1_CHGTYPRUN, val));
+	i += SCNPRINTF(&buff[i], len - i, " PRCHGTYP=%x",
+		FIELD2VALUE(MAX77759_USB_VENDOR_BC_STATUS1_PRCHGTYP, val));
+	i += SCNPRINTF(&buff[i], len - i, " DCDTMO=%x",
+		FIELD2VALUE(MAX77759_USB_VENDOR_BC_STATUS1_DCDTMO, val));
+	i += SCNPRINTF(&buff[i], len - i, " CHGTYP=%x",
+		FIELD2VALUE(MAX77759_USB_VENDOR_BC_STATUS1_CHGTYP, val));
+#else
+	buff[0] = 0;
+#endif
+	return buff;
+}
+
+/*
+ * VENDOR_BC_STATUS2,0x88,0b00000000,0x00
+ * dnDebOk,SPR_6,dnVlgc,dnVdatRef,dpDebOk,SPR_2,dpVlgc
+ */
+#define MAX77759_USB_VENDOR_BC_STATUS2	0x88
+#define MAX77759_USB_VENDOR_BC_STATUS2_DNDEBOK	(0x1 << 7)
+#define MAX77759_USB_VENDOR_BC_STATUS2_SPR_6	(0x1 << 6)
+#define MAX77759_USB_VENDOR_BC_STATUS2_DNVLGC	(0x1 << 5)
+#define MAX77759_USB_VENDOR_BC_STATUS2_DNVDATREF	(0x1 << 4)
+#define MAX77759_USB_VENDOR_BC_STATUS2_DPDEBOK	(0x1 << 3)
+#define MAX77759_USB_VENDOR_BC_STATUS2_SPR_2	(0x1 << 2)
+#define MAX77759_USB_VENDOR_BC_STATUS2_DPVLGC	(0x1 << 1)
+#define MAX77759_USB_VENDOR_BC_STATUS2_DPVDATREF	(0x1 << 0)
+
+#define MAX77759_USB_VENDOR_BC_STATUS2_DNDEBOK_SHIFT	7
+#define MAX77759_USB_VENDOR_BC_STATUS2_DNDEBOK_MASK	(0x1 << 7)
+#define MAX77759_USB_VENDOR_BC_STATUS2_DNDEBOK_CLEAR	(~(0x1 << 7))
+#define MAX77759_USB_VENDOR_BC_STATUS2_SPR_6_SHIFT	6
+#define MAX77759_USB_VENDOR_BC_STATUS2_SPR_6_MASK	(0x1 << 6)
+#define MAX77759_USB_VENDOR_BC_STATUS2_SPR_6_CLEAR	(~(0x1 << 6))
+#define MAX77759_USB_VENDOR_BC_STATUS2_DNVLGC_SHIFT	5
+#define MAX77759_USB_VENDOR_BC_STATUS2_DNVLGC_MASK	(0x1 << 5)
+#define MAX77759_USB_VENDOR_BC_STATUS2_DNVLGC_CLEAR	(~(0x1 << 5))
+#define MAX77759_USB_VENDOR_BC_STATUS2_DNVDATREF_SHIFT	4
+#define MAX77759_USB_VENDOR_BC_STATUS2_DNVDATREF_MASK	(0x1 << 4)
+#define MAX77759_USB_VENDOR_BC_STATUS2_DNVDATREF_CLEAR	(~(0x1 << 4))
+#define MAX77759_USB_VENDOR_BC_STATUS2_DPDEBOK_SHIFT	3
+#define MAX77759_USB_VENDOR_BC_STATUS2_DPDEBOK_MASK	(0x1 << 3)
+#define MAX77759_USB_VENDOR_BC_STATUS2_DPDEBOK_CLEAR	(~(0x1 << 3))
+#define MAX77759_USB_VENDOR_BC_STATUS2_SPR_2_SHIFT	2
+#define MAX77759_USB_VENDOR_BC_STATUS2_SPR_2_MASK	(0x1 << 2)
+#define MAX77759_USB_VENDOR_BC_STATUS2_SPR_2_CLEAR	(~(0x1 << 2))
+#define MAX77759_USB_VENDOR_BC_STATUS2_DPVLGC_SHIFT	1
+#define MAX77759_USB_VENDOR_BC_STATUS2_DPVLGC_MASK	(0x1 << 1)
+#define MAX77759_USB_VENDOR_BC_STATUS2_DPVLGC_CLEAR	(~(0x1 << 1))
+#define MAX77759_USB_VENDOR_BC_STATUS2_DPVDATREF_SHIFT	0
+#define MAX77759_USB_VENDOR_BC_STATUS2_DPVDATREF_MASK	(0x1 << 0)
+#define MAX77759_USB_VENDOR_BC_STATUS2_DPVDATREF_CLEAR	(~(0x1 << 0))
+
+MAX77759_BFF(usb_vendor_bc_status2_dndebok,7,7)
+MAX77759_BFF(usb_vendor_bc_status2_spr_6,6,6)
+MAX77759_BFF(usb_vendor_bc_status2_dnvlgc,5,5)
+MAX77759_BFF(usb_vendor_bc_status2_dnvdatref,4,4)
+MAX77759_BFF(usb_vendor_bc_status2_dpdebok,3,3)
+MAX77759_BFF(usb_vendor_bc_status2_spr_2,2,2)
+MAX77759_BFF(usb_vendor_bc_status2_dpvlgc,1,1)
+MAX77759_BFF(usb_vendor_bc_status2_dpvdatref,0,0)
+static inline const char *
+max77759_usb_vendor_bc_status2_cstr(char *buff, size_t len, int val)
+{
+#ifdef SCNPRINTF
+	int i = 0;
+
+	i += SCNPRINTF(&buff[i], len - i, " DNDEBOK=%x",
+		FIELD2VALUE(MAX77759_USB_VENDOR_BC_STATUS2_DNDEBOK, val));
+	i += SCNPRINTF(&buff[i], len - i, " SPR_6=%x",
+		FIELD2VALUE(MAX77759_USB_VENDOR_BC_STATUS2_SPR_6, val));
+	i += SCNPRINTF(&buff[i], len - i, " DNVLGC=%x",
+		FIELD2VALUE(MAX77759_USB_VENDOR_BC_STATUS2_DNVLGC, val));
+	i += SCNPRINTF(&buff[i], len - i, " DNVDATREF=%x",
+		FIELD2VALUE(MAX77759_USB_VENDOR_BC_STATUS2_DNVDATREF, val));
+	i += SCNPRINTF(&buff[i], len - i, " DPDEBOK=%x",
+		FIELD2VALUE(MAX77759_USB_VENDOR_BC_STATUS2_DPDEBOK, val));
+	i += SCNPRINTF(&buff[i], len - i, " SPR_2=%x",
+		FIELD2VALUE(MAX77759_USB_VENDOR_BC_STATUS2_SPR_2, val));
+	i += SCNPRINTF(&buff[i], len - i, " DPVLGC=%x",
+		FIELD2VALUE(MAX77759_USB_VENDOR_BC_STATUS2_DPVLGC, val));
+	i += SCNPRINTF(&buff[i], len - i, " DPVDATREF=%x",
+		FIELD2VALUE(MAX77759_USB_VENDOR_BC_STATUS2_DPVDATREF, val));
+#else
+	buff[0] = 0;
+#endif
+	return buff;
+}
+
+/*
+ * VENDOR_FLADC_STATUS,0x89,0b00000000,0x00
+ * ADC_VAL[7:0],,,,,,
+ */
+#define MAX77759_USB_VENDOR_FLADC_STATUS	0x89
+
+/*
+ * VENDOR_WDG_CTRL,0x8A,0b00000000,0x00
+ * RSVD_7_2[5:0],,,,,,WD_TIMEOUT[1:0]
+ */
+#define MAX77759_USB_VENDOR_WDG_CTRL	0x8A
+
+#define MAX77759_USB_VENDOR_WDG_CTRL_RSVD_7_2_SHIFT	2
+#define MAX77759_USB_VENDOR_WDG_CTRL_RSVD_7_2_MASK	(0x3f << 2)
+#define MAX77759_USB_VENDOR_WDG_CTRL_RSVD_7_2_CLEAR	(~(0x3f << 2))
+#define MAX77759_USB_VENDOR_WDG_CTRL_WD_TIMEOUT_SHIFT	0
+#define MAX77759_USB_VENDOR_WDG_CTRL_WD_TIMEOUT_MASK	(0x3 << 0)
+#define MAX77759_USB_VENDOR_WDG_CTRL_WD_TIMEOUT_CLEAR	(~(0x3 << 0))
+
+MAX77759_BFF(usb_vendor_wdg_ctrl_rsvd_7_2,7,2)
+MAX77759_BFF(usb_vendor_wdg_ctrl_wd_timeout,1,0)
+static inline const char *
+max77759_usb_vendor_wdg_ctrl_cstr(char *buff, size_t len, int val)
+{
+#ifdef SCNPRINTF
+	int i = 0;
+
+	i += SCNPRINTF(&buff[i], len - i, " RSVD_7_2=%x",
+		FIELD2VALUE(MAX77759_USB_VENDOR_WDG_CTRL_RSVD_7_2, val));
+	i += SCNPRINTF(&buff[i], len - i, " WD_TIMEOUT=%x",
+		FIELD2VALUE(MAX77759_USB_VENDOR_WDG_CTRL_WD_TIMEOUT, val));
+#else
+	buff[0] = 0;
+#endif
+	return buff;
+}
+
+/*
+ * VENDOR_VCON_CTRL,0x8B,0b10000001,0x81
+ * VcnOcpEn,SPR_6_5[1:0],,VcnSoftStartDis,VcnSc_Deb,VcnIlim[2:0],
+ */
+#define MAX77759_USB_VENDOR_VCON_CTRL	0x8B
+#define MAX77759_USB_VENDOR_VCON_CTRL_VCNOCPEN	(0x1 << 7)
+#define MAX77759_USB_VENDOR_VCON_CTRL_VCNSOFTSTARTDIS	(0x1 << 4)
+#define MAX77759_USB_VENDOR_VCON_CTRL_VCNSC_DEB	(0x1 << 3)
+
+#define MAX77759_USB_VENDOR_VCON_CTRL_VCNOCPEN_SHIFT	7
+#define MAX77759_USB_VENDOR_VCON_CTRL_VCNOCPEN_MASK	(0x1 << 7)
+#define MAX77759_USB_VENDOR_VCON_CTRL_VCNOCPEN_CLEAR	(~(0x1 << 7))
+#define MAX77759_USB_VENDOR_VCON_CTRL_SPR_6_5_SHIFT	5
+#define MAX77759_USB_VENDOR_VCON_CTRL_SPR_6_5_MASK	(0x3 << 5)
+#define MAX77759_USB_VENDOR_VCON_CTRL_SPR_6_5_CLEAR	(~(0x3 << 5))
+#define MAX77759_USB_VENDOR_VCON_CTRL_VCNSOFTSTARTDIS_SHIFT	4
+#define MAX77759_USB_VENDOR_VCON_CTRL_VCNSOFTSTARTDIS_MASK	(0x1 << 4)
+#define MAX77759_USB_VENDOR_VCON_CTRL_VCNSOFTSTARTDIS_CLEAR	(~(0x1 << 4))
+#define MAX77759_USB_VENDOR_VCON_CTRL_VCNSC_DEB_SHIFT	3
+#define MAX77759_USB_VENDOR_VCON_CTRL_VCNSC_DEB_MASK	(0x1 << 3)
+#define MAX77759_USB_VENDOR_VCON_CTRL_VCNSC_DEB_CLEAR	(~(0x1 << 3))
+#define MAX77759_USB_VENDOR_VCON_CTRL_VCNILIM_SHIFT	0
+#define MAX77759_USB_VENDOR_VCON_CTRL_VCNILIM_MASK	(0x7 << 0)
+#define MAX77759_USB_VENDOR_VCON_CTRL_VCNILIM_CLEAR	(~(0x7 << 0))
+
+MAX77759_BFF(usb_vendor_vcon_ctrl_vcnocpen,7,7)
+MAX77759_BFF(usb_vendor_vcon_ctrl_spr_6_5,6,5)
+MAX77759_BFF(usb_vendor_vcon_ctrl_vcnsoftstartdis,4,4)
+MAX77759_BFF(usb_vendor_vcon_ctrl_vcnsc_deb,3,3)
+MAX77759_BFF(usb_vendor_vcon_ctrl_vcnilim,2,0)
+static inline const char *
+max77759_usb_vendor_vcon_ctrl_cstr(char *buff, size_t len, int val)
+{
+#ifdef SCNPRINTF
+	int i = 0;
+
+	i += SCNPRINTF(&buff[i], len - i, " VCNOCPEN=%x",
+		FIELD2VALUE(MAX77759_USB_VENDOR_VCON_CTRL_VCNOCPEN, val));
+	i += SCNPRINTF(&buff[i], len - i, " SPR_6_5=%x",
+		FIELD2VALUE(MAX77759_USB_VENDOR_VCON_CTRL_SPR_6_5, val));
+	i += SCNPRINTF(&buff[i], len - i, " VCNSOFTSTARTDIS=%x",
+		FIELD2VALUE(MAX77759_USB_VENDOR_VCON_CTRL_VCNSOFTSTARTDIS, val));
+	i += SCNPRINTF(&buff[i], len - i, " VCNSC_DEB=%x",
+		FIELD2VALUE(MAX77759_USB_VENDOR_VCON_CTRL_VCNSC_DEB, val));
+	i += SCNPRINTF(&buff[i], len - i, " VCNILIM=%x",
+		FIELD2VALUE(MAX77759_USB_VENDOR_VCON_CTRL_VCNILIM, val));
+#else
+	buff[0] = 0;
+#endif
+	return buff;
+}
+
+/*
+ * VENDOR_CC_CTRL1,0x8C,0b00000010,0x02
+ * ccConnDry,RdOpenDis,ccCompEn,ccSnkExitEn,ccLpDrpCycle[1:0],,ccDrpPhase[1:0]
+ */
+#define MAX77759_USB_VENDOR_CC_CTRL1	0x8C
+#define MAX77759_USB_VENDOR_CC_CTRL1_CCCONNDRY	(0x1 << 7)
+#define MAX77759_USB_VENDOR_CC_CTRL1_RDOPENDIS	(0x1 << 6)
+#define MAX77759_USB_VENDOR_CC_CTRL1_CCCOMPEN	(0x1 << 5)
+#define MAX77759_USB_VENDOR_CC_CTRL1_CCSNKEXITEN	(0x1 << 4)
+
+#define MAX77759_USB_VENDOR_CC_CTRL1_CCCONNDRY_SHIFT	7
+#define MAX77759_USB_VENDOR_CC_CTRL1_CCCONNDRY_MASK	(0x1 << 7)
+#define MAX77759_USB_VENDOR_CC_CTRL1_CCCONNDRY_CLEAR	(~(0x1 << 7))
+#define MAX77759_USB_VENDOR_CC_CTRL1_RDOPENDIS_SHIFT	6
+#define MAX77759_USB_VENDOR_CC_CTRL1_RDOPENDIS_MASK	(0x1 << 6)
+#define MAX77759_USB_VENDOR_CC_CTRL1_RDOPENDIS_CLEAR	(~(0x1 << 6))
+#define MAX77759_USB_VENDOR_CC_CTRL1_CCCOMPEN_SHIFT	5
+#define MAX77759_USB_VENDOR_CC_CTRL1_CCCOMPEN_MASK	(0x1 << 5)
+#define MAX77759_USB_VENDOR_CC_CTRL1_CCCOMPEN_CLEAR	(~(0x1 << 5))
+#define MAX77759_USB_VENDOR_CC_CTRL1_CCSNKEXITEN_SHIFT	4
+#define MAX77759_USB_VENDOR_CC_CTRL1_CCSNKEXITEN_MASK	(0x1 << 4)
+#define MAX77759_USB_VENDOR_CC_CTRL1_CCSNKEXITEN_CLEAR	(~(0x1 << 4))
+#define MAX77759_USB_VENDOR_CC_CTRL1_CCLPDRPCYCLE_SHIFT	2
+#define MAX77759_USB_VENDOR_CC_CTRL1_CCLPDRPCYCLE_MASK	(0x3 << 2)
+#define MAX77759_USB_VENDOR_CC_CTRL1_CCLPDRPCYCLE_CLEAR	(~(0x3 << 2))
+#define MAX77759_USB_VENDOR_CC_CTRL1_CCDRPPHASE_SHIFT	0
+#define MAX77759_USB_VENDOR_CC_CTRL1_CCDRPPHASE_MASK	(0x3 << 0)
+#define MAX77759_USB_VENDOR_CC_CTRL1_CCDRPPHASE_CLEAR	(~(0x3 << 0))
+
+MAX77759_BFF(usb_vendor_cc_ctrl1_ccconndry,7,7)
+MAX77759_BFF(usb_vendor_cc_ctrl1_rdopendis,6,6)
+MAX77759_BFF(usb_vendor_cc_ctrl1_cccompen,5,5)
+MAX77759_BFF(usb_vendor_cc_ctrl1_ccsnkexiten,4,4)
+MAX77759_BFF(usb_vendor_cc_ctrl1_cclpdrpcycle,3,2)
+MAX77759_BFF(usb_vendor_cc_ctrl1_ccdrpphase,1,0)
+static inline const char *
+max77759_usb_vendor_cc_ctrl1_cstr(char *buff, size_t len, int val)
+{
+#ifdef SCNPRINTF
+	int i = 0;
+
+	i += SCNPRINTF(&buff[i], len - i, " CCCONNDRY=%x",
+		FIELD2VALUE(MAX77759_USB_VENDOR_CC_CTRL1_CCCONNDRY, val));
+	i += SCNPRINTF(&buff[i], len - i, " RDOPENDIS=%x",
+		FIELD2VALUE(MAX77759_USB_VENDOR_CC_CTRL1_RDOPENDIS, val));
+	i += SCNPRINTF(&buff[i], len - i, " CCCOMPEN=%x",
+		FIELD2VALUE(MAX77759_USB_VENDOR_CC_CTRL1_CCCOMPEN, val));
+	i += SCNPRINTF(&buff[i], len - i, " CCSNKEXITEN=%x",
+		FIELD2VALUE(MAX77759_USB_VENDOR_CC_CTRL1_CCSNKEXITEN, val));
+	i += SCNPRINTF(&buff[i], len - i, " CCLPDRPCYCLE=%x",
+		FIELD2VALUE(MAX77759_USB_VENDOR_CC_CTRL1_CCLPDRPCYCLE, val));
+	i += SCNPRINTF(&buff[i], len - i, " CCDRPPHASE=%x",
+		FIELD2VALUE(MAX77759_USB_VENDOR_CC_CTRL1_CCDRPPHASE, val));
+#else
+	buff[0] = 0;
+#endif
+	return buff;
+}
+
+/*
+ * VENDOR_CC_CTRL2,0x8D,0b00000000,0x00
+ * sbuOvpDis,ccOvpDis,sbuRpCtrl,ccLpModeSel[1:0],,ccRpCtrl[2:0],
+ */
+#define MAX77759_USB_VENDOR_CC_CTRL2	0x8D
+#define MAX77759_USB_VENDOR_CC_CTRL2_SBUOVPDIS	(0x1 << 7)
+#define MAX77759_USB_VENDOR_CC_CTRL2_CCOVPDIS	(0x1 << 6)
+#define MAX77759_USB_VENDOR_CC_CTRL2_SBURPCTRL	(0x1 << 5)
+
+#define MAX77759_USB_VENDOR_CC_CTRL2_SBUOVPDIS_SHIFT	7
+#define MAX77759_USB_VENDOR_CC_CTRL2_SBUOVPDIS_MASK	(0x1 << 7)
+#define MAX77759_USB_VENDOR_CC_CTRL2_SBUOVPDIS_CLEAR	(~(0x1 << 7))
+#define MAX77759_USB_VENDOR_CC_CTRL2_CCOVPDIS_SHIFT	6
+#define MAX77759_USB_VENDOR_CC_CTRL2_CCOVPDIS_MASK	(0x1 << 6)
+#define MAX77759_USB_VENDOR_CC_CTRL2_CCOVPDIS_CLEAR	(~(0x1 << 6))
+#define MAX77759_USB_VENDOR_CC_CTRL2_SBURPCTRL_SHIFT	5
+#define MAX77759_USB_VENDOR_CC_CTRL2_SBURPCTRL_MASK	(0x1 << 5)
+#define MAX77759_USB_VENDOR_CC_CTRL2_SBURPCTRL_CLEAR	(~(0x1 << 5))
+#define MAX77759_USB_VENDOR_CC_CTRL2_CCLPMODESEL_SHIFT	3
+#define MAX77759_USB_VENDOR_CC_CTRL2_CCLPMODESEL_MASK	(0x3 << 3)
+#define MAX77759_USB_VENDOR_CC_CTRL2_CCLPMODESEL_CLEAR	(~(0x3 << 3))
+#define MAX77759_USB_VENDOR_CC_CTRL2_CCRPCTRL_SHIFT	0
+#define MAX77759_USB_VENDOR_CC_CTRL2_CCRPCTRL_MASK	(0x7 << 0)
+#define MAX77759_USB_VENDOR_CC_CTRL2_CCRPCTRL_CLEAR	(~(0x7 << 0))
+
+MAX77759_BFF(usb_vendor_cc_ctrl2_sbuovpdis,7,7)
+MAX77759_BFF(usb_vendor_cc_ctrl2_ccovpdis,6,6)
+MAX77759_BFF(usb_vendor_cc_ctrl2_sburpctrl,5,5)
+MAX77759_BFF(usb_vendor_cc_ctrl2_cclpmodesel,4,3)
+MAX77759_BFF(usb_vendor_cc_ctrl2_ccrpctrl,2,0)
+static inline const char *
+max77759_usb_vendor_cc_ctrl2_cstr(char *buff, size_t len, int val)
+{
+#ifdef SCNPRINTF
+	int i = 0;
+
+	i += SCNPRINTF(&buff[i], len - i, " SBUOVPDIS=%x",
+		FIELD2VALUE(MAX77759_USB_VENDOR_CC_CTRL2_SBUOVPDIS, val));
+	i += SCNPRINTF(&buff[i], len - i, " CCOVPDIS=%x",
+		FIELD2VALUE(MAX77759_USB_VENDOR_CC_CTRL2_CCOVPDIS, val));
+	i += SCNPRINTF(&buff[i], len - i, " SBURPCTRL=%x",
+		FIELD2VALUE(MAX77759_USB_VENDOR_CC_CTRL2_SBURPCTRL, val));
+	i += SCNPRINTF(&buff[i], len - i, " CCLPMODESEL=%x",
+		FIELD2VALUE(MAX77759_USB_VENDOR_CC_CTRL2_CCLPMODESEL, val));
+	i += SCNPRINTF(&buff[i], len - i, " CCRPCTRL=%x",
+		FIELD2VALUE(MAX77759_USB_VENDOR_CC_CTRL2_CCRPCTRL, val));
+#else
+	buff[0] = 0;
+#endif
+	return buff;
+}
+
+/*
+ * VENDOR_CC_CTRL3,0x8E,0b00100000,0x20
+ * ccWtrDeb[1:0],,ccWtrSel[2:0],,,ccLadderDis,SPR_1
+ */
+#define MAX77759_USB_VENDOR_CC_CTRL3	0x8E
+#define MAX77759_USB_VENDOR_CC_CTRL3_CCLADDERDIS	(0x1 << 2)
+#define MAX77759_USB_VENDOR_CC_CTRL3_SPR_1	(0x1 << 1)
+#define MAX77759_USB_VENDOR_CC_CTRL3_WTRCYCLE	(0x1 << 0)
+
+#define MAX77759_USB_VENDOR_CC_CTRL3_CCWTRDEB_SHIFT	6
+#define MAX77759_USB_VENDOR_CC_CTRL3_CCWTRDEB_MASK	(0x3 << 6)
+#define MAX77759_USB_VENDOR_CC_CTRL3_CCWTRDEB_CLEAR	(~(0x3 << 6))
+#define MAX77759_USB_VENDOR_CC_CTRL3_CCWTRSEL_SHIFT	3
+#define MAX77759_USB_VENDOR_CC_CTRL3_CCWTRSEL_MASK	(0x7 << 3)
+#define MAX77759_USB_VENDOR_CC_CTRL3_CCWTRSEL_CLEAR	(~(0x7 << 3))
+#define MAX77759_USB_VENDOR_CC_CTRL3_CCLADDERDIS_SHIFT	2
+#define MAX77759_USB_VENDOR_CC_CTRL3_CCLADDERDIS_MASK	(0x1 << 2)
+#define MAX77759_USB_VENDOR_CC_CTRL3_CCLADDERDIS_CLEAR	(~(0x1 << 2))
+#define MAX77759_USB_VENDOR_CC_CTRL3_SPR_1_SHIFT	1
+#define MAX77759_USB_VENDOR_CC_CTRL3_SPR_1_MASK	(0x1 << 1)
+#define MAX77759_USB_VENDOR_CC_CTRL3_SPR_1_CLEAR	(~(0x1 << 1))
+#define MAX77759_USB_VENDOR_CC_CTRL3_WTRCYCLE_SHIFT	0
+#define MAX77759_USB_VENDOR_CC_CTRL3_WTRCYCLE_MASK	(0x1 << 0)
+#define MAX77759_USB_VENDOR_CC_CTRL3_WTRCYCLE_CLEAR	(~(0x1 << 0))
+
+MAX77759_BFF(usb_vendor_cc_ctrl3_ccwtrdeb,7,6)
+MAX77759_BFF(usb_vendor_cc_ctrl3_ccwtrsel,5,3)
+MAX77759_BFF(usb_vendor_cc_ctrl3_ccladderdis,2,2)
+MAX77759_BFF(usb_vendor_cc_ctrl3_spr_1,1,1)
+MAX77759_BFF(usb_vendor_cc_ctrl3_wtrcycle,0,0)
+static inline const char *
+max77759_usb_vendor_cc_ctrl3_cstr(char *buff, size_t len, int val)
+{
+#ifdef SCNPRINTF
+	int i = 0;
+
+	i += SCNPRINTF(&buff[i], len - i, " CCWTRDEB=%x",
+		FIELD2VALUE(MAX77759_USB_VENDOR_CC_CTRL3_CCWTRDEB, val));
+	i += SCNPRINTF(&buff[i], len - i, " CCWTRSEL=%x",
+		FIELD2VALUE(MAX77759_USB_VENDOR_CC_CTRL3_CCWTRSEL, val));
+	i += SCNPRINTF(&buff[i], len - i, " CCLADDERDIS=%x",
+		FIELD2VALUE(MAX77759_USB_VENDOR_CC_CTRL3_CCLADDERDIS, val));
+	i += SCNPRINTF(&buff[i], len - i, " SPR_1=%x",
+		FIELD2VALUE(MAX77759_USB_VENDOR_CC_CTRL3_SPR_1, val));
+	i += SCNPRINTF(&buff[i], len - i, " WTRCYCLE=%x",
+		FIELD2VALUE(MAX77759_USB_VENDOR_CC_CTRL3_WTRCYCLE, val));
+#else
+	buff[0] = 0;
+#endif
+	return buff;
+}
+
+/*
+ * VENDOR_BC_CTRL1,0x8F,0b10100001,0xa1
+ * dcdCpl,SPR_6,noBcComp,SPR_4_2[2:0],,,chgDetMan
+ */
+#define MAX77759_USB_VENDOR_BC_CTRL1	0x8F
+#define MAX77759_USB_VENDOR_BC_CTRL1_DCDCPL	(0x1 << 7)
+#define MAX77759_USB_VENDOR_BC_CTRL1_SPR_6	(0x1 << 6)
+#define MAX77759_USB_VENDOR_BC_CTRL1_NOBCCOMP	(0x1 << 5)
+#define MAX77759_USB_VENDOR_BC_CTRL1_CHGDETMAN	(0x1 << 1)
+#define MAX77759_USB_VENDOR_BC_CTRL1_CHGDETEN	(0x1 << 0)
+
+#define MAX77759_USB_VENDOR_BC_CTRL1_DCDCPL_SHIFT	7
+#define MAX77759_USB_VENDOR_BC_CTRL1_DCDCPL_MASK	(0x1 << 7)
+#define MAX77759_USB_VENDOR_BC_CTRL1_DCDCPL_CLEAR	(~(0x1 << 7))
+#define MAX77759_USB_VENDOR_BC_CTRL1_SPR_6_SHIFT	6
+#define MAX77759_USB_VENDOR_BC_CTRL1_SPR_6_MASK	(0x1 << 6)
+#define MAX77759_USB_VENDOR_BC_CTRL1_SPR_6_CLEAR	(~(0x1 << 6))
+#define MAX77759_USB_VENDOR_BC_CTRL1_NOBCCOMP_SHIFT	5
+#define MAX77759_USB_VENDOR_BC_CTRL1_NOBCCOMP_MASK	(0x1 << 5)
+#define MAX77759_USB_VENDOR_BC_CTRL1_NOBCCOMP_CLEAR	(~(0x1 << 5))
+#define MAX77759_USB_VENDOR_BC_CTRL1_SPR_4_2_SHIFT	2
+#define MAX77759_USB_VENDOR_BC_CTRL1_SPR_4_2_MASK	(0x7 << 2)
+#define MAX77759_USB_VENDOR_BC_CTRL1_SPR_4_2_CLEAR	(~(0x7 << 2))
+#define MAX77759_USB_VENDOR_BC_CTRL1_CHGDETMAN_SHIFT	1
+#define MAX77759_USB_VENDOR_BC_CTRL1_CHGDETMAN_MASK	(0x1 << 1)
+#define MAX77759_USB_VENDOR_BC_CTRL1_CHGDETMAN_CLEAR	(~(0x1 << 1))
+#define MAX77759_USB_VENDOR_BC_CTRL1_CHGDETEN_SHIFT	0
+#define MAX77759_USB_VENDOR_BC_CTRL1_CHGDETEN_MASK	(0x1 << 0)
+#define MAX77759_USB_VENDOR_BC_CTRL1_CHGDETEN_CLEAR	(~(0x1 << 0))
+
+MAX77759_BFF(usb_vendor_bc_ctrl1_dcdcpl,7,7)
+MAX77759_BFF(usb_vendor_bc_ctrl1_spr_6,6,6)
+MAX77759_BFF(usb_vendor_bc_ctrl1_nobccomp,5,5)
+MAX77759_BFF(usb_vendor_bc_ctrl1_spr_4_2,4,2)
+MAX77759_BFF(usb_vendor_bc_ctrl1_chgdetman,1,1)
+MAX77759_BFF(usb_vendor_bc_ctrl1_chgdeten,0,0)
+static inline const char *
+max77759_usb_vendor_bc_ctrl1_cstr(char *buff, size_t len, int val)
+{
+#ifdef SCNPRINTF
+	int i = 0;
+
+	i += SCNPRINTF(&buff[i], len - i, " DCDCPL=%x",
+		FIELD2VALUE(MAX77759_USB_VENDOR_BC_CTRL1_DCDCPL, val));
+	i += SCNPRINTF(&buff[i], len - i, " SPR_6=%x",
+		FIELD2VALUE(MAX77759_USB_VENDOR_BC_CTRL1_SPR_6, val));
+	i += SCNPRINTF(&buff[i], len - i, " NOBCCOMP=%x",
+		FIELD2VALUE(MAX77759_USB_VENDOR_BC_CTRL1_NOBCCOMP, val));
+	i += SCNPRINTF(&buff[i], len - i, " SPR_4_2=%x",
+		FIELD2VALUE(MAX77759_USB_VENDOR_BC_CTRL1_SPR_4_2, val));
+	i += SCNPRINTF(&buff[i], len - i, " CHGDETMAN=%x",
+		FIELD2VALUE(MAX77759_USB_VENDOR_BC_CTRL1_CHGDETMAN, val));
+	i += SCNPRINTF(&buff[i], len - i, " CHGDETEN=%x",
+		FIELD2VALUE(MAX77759_USB_VENDOR_BC_CTRL1_CHGDETEN, val));
+#else
+	buff[0] = 0;
+#endif
+	return buff;
+}
+
+/*
+ * VENDOR_BC_CTRL2,0x90,0b00000000,0x00
+ * dpMonEn,SPR_6,dnMonEn,dpDnMan,dpDrv[1:0],,dnDrv[1:0]
+ */
+#define MAX77759_USB_VENDOR_BC_CTRL2	0x90
+#define MAX77759_USB_VENDOR_BC_CTRL2_DPMONEN	(0x1 << 7)
+#define MAX77759_USB_VENDOR_BC_CTRL2_SPR_6	(0x1 << 6)
+#define MAX77759_USB_VENDOR_BC_CTRL2_DNMONEN	(0x1 << 5)
+#define MAX77759_USB_VENDOR_BC_CTRL2_DPDNMAN	(0x1 << 4)
+
+#define MAX77759_USB_VENDOR_BC_CTRL2_DPMONEN_SHIFT	7
+#define MAX77759_USB_VENDOR_BC_CTRL2_DPMONEN_MASK	(0x1 << 7)
+#define MAX77759_USB_VENDOR_BC_CTRL2_DPMONEN_CLEAR	(~(0x1 << 7))
+#define MAX77759_USB_VENDOR_BC_CTRL2_SPR_6_SHIFT	6
+#define MAX77759_USB_VENDOR_BC_CTRL2_SPR_6_MASK	(0x1 << 6)
+#define MAX77759_USB_VENDOR_BC_CTRL2_SPR_6_CLEAR	(~(0x1 << 6))
+#define MAX77759_USB_VENDOR_BC_CTRL2_DNMONEN_SHIFT	5
+#define MAX77759_USB_VENDOR_BC_CTRL2_DNMONEN_MASK	(0x1 << 5)
+#define MAX77759_USB_VENDOR_BC_CTRL2_DNMONEN_CLEAR	(~(0x1 << 5))
+#define MAX77759_USB_VENDOR_BC_CTRL2_DPDNMAN_SHIFT	4
+#define MAX77759_USB_VENDOR_BC_CTRL2_DPDNMAN_MASK	(0x1 << 4)
+#define MAX77759_USB_VENDOR_BC_CTRL2_DPDNMAN_CLEAR	(~(0x1 << 4))
+#define MAX77759_USB_VENDOR_BC_CTRL2_DPDRV_SHIFT	2
+#define MAX77759_USB_VENDOR_BC_CTRL2_DPDRV_MASK	(0x3 << 2)
+#define MAX77759_USB_VENDOR_BC_CTRL2_DPDRV_CLEAR	(~(0x3 << 2))
+#define MAX77759_USB_VENDOR_BC_CTRL2_DNDRV_SHIFT	0
+#define MAX77759_USB_VENDOR_BC_CTRL2_DNDRV_MASK	(0x3 << 0)
+#define MAX77759_USB_VENDOR_BC_CTRL2_DNDRV_CLEAR	(~(0x3 << 0))
+
+MAX77759_BFF(usb_vendor_bc_ctrl2_dpmonen,7,7)
+MAX77759_BFF(usb_vendor_bc_ctrl2_spr_6,6,6)
+MAX77759_BFF(usb_vendor_bc_ctrl2_dnmonen,5,5)
+MAX77759_BFF(usb_vendor_bc_ctrl2_dpdnman,4,4)
+MAX77759_BFF(usb_vendor_bc_ctrl2_dpdrv,3,2)
+MAX77759_BFF(usb_vendor_bc_ctrl2_dndrv,1,0)
+static inline const char *
+max77759_usb_vendor_bc_ctrl2_cstr(char *buff, size_t len, int val)
+{
+#ifdef SCNPRINTF
+	int i = 0;
+
+	i += SCNPRINTF(&buff[i], len - i, " DPMONEN=%x",
+		FIELD2VALUE(MAX77759_USB_VENDOR_BC_CTRL2_DPMONEN, val));
+	i += SCNPRINTF(&buff[i], len - i, " SPR_6=%x",
+		FIELD2VALUE(MAX77759_USB_VENDOR_BC_CTRL2_SPR_6, val));
+	i += SCNPRINTF(&buff[i], len - i, " DNMONEN=%x",
+		FIELD2VALUE(MAX77759_USB_VENDOR_BC_CTRL2_DNMONEN, val));
+	i += SCNPRINTF(&buff[i], len - i, " DPDNMAN=%x",
+		FIELD2VALUE(MAX77759_USB_VENDOR_BC_CTRL2_DPDNMAN, val));
+	i += SCNPRINTF(&buff[i], len - i, " DPDRV=%x",
+		FIELD2VALUE(MAX77759_USB_VENDOR_BC_CTRL2_DPDRV, val));
+	i += SCNPRINTF(&buff[i], len - i, " DNDRV=%x",
+		FIELD2VALUE(MAX77759_USB_VENDOR_BC_CTRL2_DNDRV, val));
+#else
+	buff[0] = 0;
+#endif
+	return buff;
+}
+
+/*
+ * VENDOR_ADC_CTRL1,0x91,0b00000000,0x00
+ * adcinSel[2:0],,,SPR_4_1[3:0],,,
+ */
+#define MAX77759_USB_VENDOR_ADC_CTRL1	0x91
+#define MAX77759_USB_VENDOR_ADC_CTRL1_ADCEN	(0x1 << 0)
+
+#define MAX77759_USB_VENDOR_ADC_CTRL1_ADCINSEL_SHIFT	5
+#define MAX77759_USB_VENDOR_ADC_CTRL1_ADCINSEL_MASK	(0x7 << 5)
+#define MAX77759_USB_VENDOR_ADC_CTRL1_ADCINSEL_CLEAR	(~(0x7 << 5))
+#define MAX77759_USB_VENDOR_ADC_CTRL1_SPR_4_1_SHIFT	1
+#define MAX77759_USB_VENDOR_ADC_CTRL1_SPR_4_1_MASK	(0xf << 1)
+#define MAX77759_USB_VENDOR_ADC_CTRL1_SPR_4_1_CLEAR	(~(0xf << 1))
+#define MAX77759_USB_VENDOR_ADC_CTRL1_ADCEN_SHIFT	0
+#define MAX77759_USB_VENDOR_ADC_CTRL1_ADCEN_MASK	(0x1 << 0)
+#define MAX77759_USB_VENDOR_ADC_CTRL1_ADCEN_CLEAR	(~(0x1 << 0))
+
+MAX77759_BFF(usb_vendor_adc_ctrl1_adcinsel,7,5)
+MAX77759_BFF(usb_vendor_adc_ctrl1_spr_4_1,4,1)
+MAX77759_BFF(usb_vendor_adc_ctrl1_adcen,0,0)
+static inline const char *
+max77759_usb_vendor_adc_ctrl1_cstr(char *buff, size_t len, int val)
+{
+#ifdef SCNPRINTF
+	int i = 0;
+
+	i += SCNPRINTF(&buff[i], len - i, " ADCINSEL=%x",
+		FIELD2VALUE(MAX77759_USB_VENDOR_ADC_CTRL1_ADCINSEL, val));
+	i += SCNPRINTF(&buff[i], len - i, " SPR_4_1=%x",
+		FIELD2VALUE(MAX77759_USB_VENDOR_ADC_CTRL1_SPR_4_1, val));
+	i += SCNPRINTF(&buff[i], len - i, " ADCEN=%x",
+		FIELD2VALUE(MAX77759_USB_VENDOR_ADC_CTRL1_ADCEN, val));
+#else
+	buff[0] = 0;
+#endif
+	return buff;
+}
+
+/*
+ * VENDOR_EXTBST_CTRL,0x92,0b00000000,0x00
+ * SPR_7_1[6:0],,,,,,
+ */
+#define MAX77759_USB_VENDOR_EXTBST_CTRL	0x92
+#define MAX77759_USB_VENDOR_EXTBST_CTRL_EXT_BST_EN	(0x1 << 0)
+
+#define MAX77759_USB_VENDOR_EXTBST_CTRL_SPR_7_1_SHIFT	1
+#define MAX77759_USB_VENDOR_EXTBST_CTRL_SPR_7_1_MASK	(0x7f << 1)
+#define MAX77759_USB_VENDOR_EXTBST_CTRL_SPR_7_1_CLEAR	(~(0x7f << 1))
+#define MAX77759_USB_VENDOR_EXTBST_CTRL_EXT_BST_EN_SHIFT	0
+#define MAX77759_USB_VENDOR_EXTBST_CTRL_EXT_BST_EN_MASK	(0x1 << 0)
+#define MAX77759_USB_VENDOR_EXTBST_CTRL_EXT_BST_EN_CLEAR	(~(0x1 << 0))
+
+MAX77759_BFF(usb_vendor_extbst_ctrl_spr_7_1,7,1)
+MAX77759_BFF(usb_vendor_extbst_ctrl_ext_bst_en,0,0)
+static inline const char *
+max77759_usb_vendor_extbst_ctrl_cstr(char *buff, size_t len, int val)
+{
+#ifdef SCNPRINTF
+	int i = 0;
+
+	i += SCNPRINTF(&buff[i], len - i, " SPR_7_1=%x",
+		FIELD2VALUE(MAX77759_USB_VENDOR_EXTBST_CTRL_SPR_7_1, val));
+	i += SCNPRINTF(&buff[i], len - i, " EXT_BST_EN=%x",
+		FIELD2VALUE(MAX77759_USB_VENDOR_EXTBST_CTRL_EXT_BST_EN, val));
+#else
+	buff[0] = 0;
+#endif
+	return buff;
+}
+
+/*
+ * VENDOR_USBSW_CTRL,0x93,0b00000000,0x00
+ * SPR_7_6[1:0],,DPSw[2:0],,,DNSw[2:0],
+ */
+#define MAX77759_USB_VENDOR_USBSW_CTRL	0x93
+
+#define MAX77759_USB_VENDOR_USBSW_CTRL_SPR_7_6_SHIFT	6
+#define MAX77759_USB_VENDOR_USBSW_CTRL_SPR_7_6_MASK	(0x3 << 6)
+#define MAX77759_USB_VENDOR_USBSW_CTRL_SPR_7_6_CLEAR	(~(0x3 << 6))
+#define MAX77759_USB_VENDOR_USBSW_CTRL_DPSW_SHIFT	3
+#define MAX77759_USB_VENDOR_USBSW_CTRL_DPSW_MASK	(0x7 << 3)
+#define MAX77759_USB_VENDOR_USBSW_CTRL_DPSW_CLEAR	(~(0x7 << 3))
+#define MAX77759_USB_VENDOR_USBSW_CTRL_DNSW_SHIFT	0
+#define MAX77759_USB_VENDOR_USBSW_CTRL_DNSW_MASK	(0x7 << 0)
+#define MAX77759_USB_VENDOR_USBSW_CTRL_DNSW_CLEAR	(~(0x7 << 0))
+
+MAX77759_BFF(usb_vendor_usbsw_ctrl_spr_7_6,7,6)
+MAX77759_BFF(usb_vendor_usbsw_ctrl_dpsw,5,3)
+MAX77759_BFF(usb_vendor_usbsw_ctrl_dnsw,2,0)
+static inline const char *
+max77759_usb_vendor_usbsw_ctrl_cstr(char *buff, size_t len, int val)
+{
+#ifdef SCNPRINTF
+	int i = 0;
+
+	i += SCNPRINTF(&buff[i], len - i, " SPR_7_6=%x",
+		FIELD2VALUE(MAX77759_USB_VENDOR_USBSW_CTRL_SPR_7_6, val));
+	i += SCNPRINTF(&buff[i], len - i, " DPSW=%x",
+		FIELD2VALUE(MAX77759_USB_VENDOR_USBSW_CTRL_DPSW, val));
+	i += SCNPRINTF(&buff[i], len - i, " DNSW=%x",
+		FIELD2VALUE(MAX77759_USB_VENDOR_USBSW_CTRL_DNSW, val));
+#else
+	buff[0] = 0;
+#endif
+	return buff;
+}
+
+/*
+ * VENDOR_SBUSW_CTRL,0x94,0b00000000,0x00
+ * SPR_7_6[1:0],,SBU2Sw[2:0],,,SBU1Sw[2:0],
+ */
+#define MAX77759_USB_VENDOR_SBUSW_CTRL	0x94
+
+#define MAX77759_USB_VENDOR_SBUSW_CTRL_SPR_7_6_SHIFT	6
+#define MAX77759_USB_VENDOR_SBUSW_CTRL_SPR_7_6_MASK	(0x3 << 6)
+#define MAX77759_USB_VENDOR_SBUSW_CTRL_SPR_7_6_CLEAR	(~(0x3 << 6))
+#define MAX77759_USB_VENDOR_SBUSW_CTRL_SBU2SW_SHIFT	3
+#define MAX77759_USB_VENDOR_SBUSW_CTRL_SBU2SW_MASK	(0x7 << 3)
+#define MAX77759_USB_VENDOR_SBUSW_CTRL_SBU2SW_CLEAR	(~(0x7 << 3))
+#define MAX77759_USB_VENDOR_SBUSW_CTRL_SBU1SW_SHIFT	0
+#define MAX77759_USB_VENDOR_SBUSW_CTRL_SBU1SW_MASK	(0x7 << 0)
+#define MAX77759_USB_VENDOR_SBUSW_CTRL_SBU1SW_CLEAR	(~(0x7 << 0))
+
+MAX77759_BFF(usb_vendor_sbusw_ctrl_spr_7_6,7,6)
+MAX77759_BFF(usb_vendor_sbusw_ctrl_sbu2sw,5,3)
+MAX77759_BFF(usb_vendor_sbusw_ctrl_sbu1sw,2,0)
+static inline const char *
+max77759_usb_vendor_sbusw_ctrl_cstr(char *buff, size_t len, int val)
+{
+#ifdef SCNPRINTF
+	int i = 0;
+
+	i += SCNPRINTF(&buff[i], len - i, " SPR_7_6=%x",
+		FIELD2VALUE(MAX77759_USB_VENDOR_SBUSW_CTRL_SPR_7_6, val));
+	i += SCNPRINTF(&buff[i], len - i, " SBU2SW=%x",
+		FIELD2VALUE(MAX77759_USB_VENDOR_SBUSW_CTRL_SBU2SW, val));
+	i += SCNPRINTF(&buff[i], len - i, " SBU1SW=%x",
+		FIELD2VALUE(MAX77759_USB_VENDOR_SBUSW_CTRL_SBU1SW, val));
+#else
+	buff[0] = 0;
+#endif
+	return buff;
+}
+
+/*
+ * VENDOR_SW_CTRL,0x95,0b00000000,0x00
+ * SPR_7_1[6:0],,,,,,
+ */
+#define MAX77759_USB_VENDOR_SW_CTRL	0x95
+
+#endif /* MAX77759_REG_H_ */
diff --git a/drivers/soc/qcom/max77759_charger.h b/drivers/soc/qcom/max77759_charger.h
new file mode 100644
index 000000000000..57e1ae450d52
--- /dev/null
+++ b/drivers/soc/qcom/max77759_charger.h
@@ -0,0 +1,80 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Copyright 2021 Google, LLC
+ *
+ */
+
+#if IS_ENABLED(CONFIG_GOOGLE_BCL)
+#include <soc/google/bcl.h>
+#endif
+#include "gs101_usecase.h"
+
+#ifndef MAX77759_CHARGER_H_
+#define MAX77759_CHARGER_H_
+
+struct max77759_chgr_data {
+	struct device *dev;
+
+	struct power_supply *psy;
+	struct power_supply *wcin_psy;
+	struct power_supply *chgin_psy;
+
+	struct power_supply *wlc_psy;
+	struct regmap *regmap;
+
+	struct gvotable_election *mode_votable;
+	struct max77759_usecase_data uc_data;
+	struct delayed_work mode_rerun_work;
+
+	struct gvotable_election *dc_icl_votable;
+	struct gvotable_election *dc_suspend_votable;
+
+	bool charge_done;
+	bool chgin_input_suspend;
+	bool wcin_input_suspend;
+	bool thm2_sts;
+
+	int irq_gpio;
+	int irq_int;
+	bool irq_disabled;
+
+	struct i2c_client *fg_i2c_client;
+	struct i2c_client *pmic_i2c_client;
+
+	struct dentry *de;
+
+	atomic_t insel_cnt;
+	bool insel_clear;	/* when set, irq clears CHGINSEL_MASK */
+
+	atomic_t early_topoff_cnt;
+
+	struct mutex io_lock;
+	bool resume_complete;
+	bool init_complete;
+	struct wakeup_source *usecase_wake_lock;
+
+	int fship_dtls;
+	bool online;
+	bool wden;
+
+	/* Force to change FCCM mode during OTG at high battery voltage */
+	bool otg_changed;
+	bool otg_fccm_reset;
+	int otg_fccm_vbatt_lowerbd;
+	int otg_fccm_vbatt_upperbd;
+	struct delayed_work otg_fccm_worker;
+	struct wakeup_source *otg_fccm_wake_lock;
+
+	/* debug interface, register to read or write */
+	u32 debug_reg_address;
+
+	/* thermal BCL */
+#if IS_ENABLED(CONFIG_GOOGLE_BCL)
+	struct bcl_device *bcl_dev;
+	struct delayed_work init_bcl;
+#endif
+
+	int chg_term_voltage;
+	int chg_term_volt_debounce;
+};
+#endif
diff --git a/drivers/soc/qcom/max77759_maxq.h b/drivers/soc/qcom/max77759_maxq.h
new file mode 100644
index 000000000000..fae1f4524cee
--- /dev/null
+++ b/drivers/soc/qcom/max77759_maxq.h
@@ -0,0 +1,64 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * MAX77759 MAXQ interface.
+ *
+ * Copyright 2020 Google, LLC
+ *
+ */
+
+#if IS_ENABLED(CONFIG_MAXQ_MAX77759)
+
+struct max77759_maxq;
+extern struct max77759_maxq *maxq_init(struct device *dev,
+				       struct regmap *regmap,
+				       bool poll);
+extern void maxq_remove(struct max77759_maxq *maxq);
+extern void maxq_irq(struct max77759_maxq *maxq);
+/* Helpers */
+extern int maxq_query_contaminant(struct max77759_maxq *maxq, u8 cc1_raw,
+				  u8 cc2_raw, u8 sbu1_raw,
+				  u8 sbu2_raw, u8 cc1_rd, u8 cc2_rd,
+				  u8 type, u8 cc_adc_skipped,
+				  u8 *response, u8 response_len);
+extern int maxq_gpio_control_read(struct max77759_maxq *maxq, u8 *gpio);
+extern int maxq_gpio_control_write(struct max77759_maxq *maxq, u8 gpio);
+extern int maxq_gpio_trigger_read(struct max77759_maxq *maxq, u8 gpio, bool *trigger_falling);
+extern int maxq_gpio_trigger_write(struct max77759_maxq *maxq, u8 gpio, bool trigger_falling);
+# else
+static inline int maxq_gpio_trigger_read(struct max77759_maxq *maxq, u8 gpio, bool *trigger_falling)
+{
+	return -EINVAL;
+}
+
+static inline int maxq_gpio_trigger_write(struct max77759_maxq *maxq, u8 gpio,
+					  bool trigger_falling)
+{
+	return -EINVAL;
+}
+static inline struct max77759_maxq *maxq_init(struct device *dev,
+					      struct regmap *regmap,
+					      bool poll)
+{
+	return NULL;
+}
+static inline void maxq_remove(struct max77759_maxq *maxq) {}
+static inline void maxq_irq(struct max77759_maxq *maxq) {}
+/* Helpers */
+static inline int maxq_query_contaminant(struct max77759_maxq *maxq,
+					 u8 cc1_raw, u8 cc2_raw,
+					 u8 sbu1_raw, u8 sbu2_raw,
+					 u8 cc1_rd, u8 cc2_rd,
+					 u8 type, u8 cc_adc_skipped,
+					 u8 *response, u8 response_len)
+{
+	return -EINVAL;
+}
+extern int maxq_gpio_control_read(struct max77759_maxq *maxq, u8 *gpio)
+{
+	return -EINVAL;
+}
+extern int maxq_gpio_control_write(struct max77759_maxq *maxq, u8 gpio)
+{
+	return -EINVAL;
+}
+#endif
diff --git a/drivers/soc/qcom/max77759_regs.h b/drivers/soc/qcom/max77759_regs.h
new file mode 100644
index 000000000000..abc6cc93f7af
--- /dev/null
+++ b/drivers/soc/qcom/max77759_regs.h
@@ -0,0 +1,66 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * machine generated DO NOT MODIFY
+ * source MW_regmap_ds_v0p65_121919.csv
+ * 2020-03-19
+ */
+
+#ifndef MAX77759_REG_H_
+#define MAX77759_REG_H_
+
+#include "max77759_A1_regs.h"
+
+/*
+ * b/156527175: workaround for read only MAX77759_CHG_DETAILS_03
+ * MAX77759_PMIC_TOPSYS_INT_MASK_SPR_7 is used to detect exit from fshipmode.
+ * The register (MAX77759_PMIC_TOPSYS_INT_MASK) is type S and the bit is reset
+ * to 1 on power loss. The reports MAX77759_CHG_DETAILS_03 when the bit
+ * is 1 and report 0 when the bit is set to 0.
+ */
+#define MAX77759_FSHIP_EXIT_DTLS	  MAX77759_PMIC_TOPSYS_INT_MASK
+#define MAX77759_FSHIP_EXIT_DTLS_RD \
+				MAX77759_PMIC_TOPSYS_INT_MASK_SPR_7
+#define MAX77759_FSHIP_EXIT_DTLS_RD_SHIFT \
+				MAX77759_PMIC_TOPSYS_INT_MASK_SPR_7_SHIFT
+#define MAX77759_FSHIP_EXIT_DTLS_RD_MASK \
+				MAX77759_PMIC_TOPSYS_INT_MASK_SPR_7_MASK
+#define MAX77759_FSHIP_EXIT_DTLS_RD_CLEAR \
+				MAX77759_PMIC_TOPSYS_INT_MASK_SPR_7_CLEAR
+
+/* */
+#define MAX77759_CHG_CNFG_11_OTG_VBYP_5000MV	0x0
+#define MAX77759_CHG_CNFG_11_OTG_VBYP_5100MV	0x2
+
+/* */
+#define MAX77759_CHG_CNFG_05_OTG_ILIM_DISABLE	0x00
+#define MAX77759_CHG_CNFG_05_OTG_ILIM_500MA	0x01
+#define MAX77759_CHG_CNFG_05_OTG_ILIM_1500MA	0x0b
+
+/* b/179816224 */
+#define MAX77759_CHG_CNFG_12_WCIN_REG_4_5  (0x0 << MAX77759_CHG_CNFG_12_WCIN_REG_SHIFT)
+#define MAX77759_CHG_CNFG_12_WCIN_REG_4_85 (0x3 << MAX77759_CHG_CNFG_12_WCIN_REG_SHIFT)
+
+/* mux configuration in MAX77759_PMIC_CONTROL_FG */
+#define THMIO_MUX_BATT_PACK	0
+#define THMIO_MUX_USB_TEMP	1
+#define THMIO_MUX_BATT_ID	2
+
+/* ----------------------------------------------------------------------------
+ * Mode Register
+ */
+
+enum max77759_charger_modes {
+	MAX77759_CHGR_MODE_ALL_OFF = 0x00,
+	MAX77759_CHGR_MODE_BUCK_ON = 0x04,
+	MAX77759_CHGR_MODE_CHGR_BUCK_ON = 0x05,
+	MAX77759_CHGR_MODE_BOOST_UNO_ON = 0x08,
+	MAX77759_CHGR_MODE_BOOST_ON = 0x09,
+	MAX77759_CHGR_MODE_OTG_BOOST_ON = 0x0a,
+	MAX77759_CHGR_MODE_BUCK_BOOST_UNO_ON = 0x0c,
+	MAX77759_CHGR_MODE_CHGR_BUCK_BOOST_UNO_ON = 0x0d,
+	MAX77759_CHGR_MODE_OTG_BUCK_BOOST_ON = 0x0e,
+	MAX77759_CHGR_MODE_CHGR_OTG_BUCK_BOOST_ON = 0x0f,
+};
+
+
+#endif /* MAX77759_REG_H_ */
diff --git a/drivers/soc/qcom/max77759_v0p65_121919_regs.h b/drivers/soc/qcom/max77759_v0p65_121919_regs.h
new file mode 100644
index 000000000000..6e2bb7417d8e
--- /dev/null
+++ b/drivers/soc/qcom/max77759_v0p65_121919_regs.h
@@ -0,0 +1,7408 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * machine generated DO NOT MODIFY
+ * source MW_regmap_ds_v0p65_121919.csv
+ * 2020-03-19
+ */
+
+#ifndef MAX77759_REG_v0p65_121919_H_
+#define MAX77759_REG_v0p65_121919_H_
+
+#ifndef BITS_PER_LONG
+#define BITS_PER_LONG 32
+#endif
+#define GENMASK(h, l) \
+	(((~0UL) - (1UL << (l)) + 1) & (~0UL >> (BITS_PER_LONG - 1 - (h))))
+#define MAX77759_BFF(name, h, l) \
+static inline uint8_t _ ## name ## _set(uint8_t r, uint8_t v) \
+{ \
+	return ((r & ~GENMASK(h, l)) | v << l); \
+} \
+\
+static inline uint8_t _ ## name ## _get(uint8_t r) \
+{ \
+	return ((r & GENMASK(h, l)) >> l); \
+}
+
+
+#define FIELD2VALUE(field,value) \
+	(((value) & field##_MASK) >> field##_SHIFT)
+#define VALUE2FIELD(field,       value) \
+	(((value) << field##_SHIFT) & field##_MASK)
+
+
+
+/* section:  PMIC  */
+
+/*
+ * PMIC_ID,0x0,0b00111011,0x3b
+ * ID[7:0],,,,,,
+ */
+#define MAX77759_PMIC_PMIC_ID	0x0
+
+/*
+ * PMIC_REVISION,0x1,0b00000001,0x01
+ * VER[4:0],,,,,REV[2:0],
+ */
+#define MAX77759_PMIC_PMIC_REVISION	0x1
+
+#define MAX77759_PMIC_PMIC_REVISION_VER_SHIFT	3
+#define MAX77759_PMIC_PMIC_REVISION_VER_MASK	(0x1f << 3)
+#define MAX77759_PMIC_PMIC_REVISION_VER_CLEAR	(~(0x1f << 3))
+#define MAX77759_PMIC_PMIC_REVISION_REV_SHIFT	0
+#define MAX77759_PMIC_PMIC_REVISION_REV_MASK	(0x7 << 0)
+#define MAX77759_PMIC_PMIC_REVISION_REV_CLEAR	(~(0x7 << 0))
+
+MAX77759_BFF(pmic_pmic_revision_ver,7,3)
+MAX77759_BFF(pmic_pmic_revision_rev,2,0)
+static inline const char *
+max77759_pmic_pmic_revision_cstr(char *buff, size_t len, int val)
+{
+#ifdef SCNPRINTF
+	int i = 0;
+
+	i += SCNPRINTF(&buff[i], len - i, " VER=%x",
+		FIELD2VALUE(MAX77759_PMIC_PMIC_REVISION_VER, val));
+	i += SCNPRINTF(&buff[i], len - i, " REV=%x",
+		FIELD2VALUE(MAX77759_PMIC_PMIC_REVISION_REV, val));
+#else
+	buff[0] = 0;
+#endif
+	return buff;
+}
+
+/*
+ * OTP_REVISION,0x2,0b00000000,0x00
+ * OTP_REV[7:0],,,,,,
+ */
+#define MAX77759_PMIC_OTP_REVISION	0x2
+
+/*
+ * INTSRC,0x22,0b00000000,0x00
+ * SPR_7_4[3:0],,,,MAXQ_INT,SPR_3,TOPSYS_INT
+ */
+#define MAX77759_PMIC_INTSRC	0x22
+#define MAX77759_PMIC_INTSRC_MAXQ_INT	(0x1 << 3)
+#define MAX77759_PMIC_INTSRC_SPR_3	(0x1 << 2)
+#define MAX77759_PMIC_INTSRC_TOPSYS_INT	(0x1 << 1)
+#define MAX77759_PMIC_INTSRC_CHGR_INT	(0x1 << 0)
+
+#define MAX77759_PMIC_INTSRC_SPR_7_4_SHIFT	4
+#define MAX77759_PMIC_INTSRC_SPR_7_4_MASK	(0xf << 4)
+#define MAX77759_PMIC_INTSRC_SPR_7_4_CLEAR	(~(0xf << 4))
+#define MAX77759_PMIC_INTSRC_MAXQ_INT_SHIFT	3
+#define MAX77759_PMIC_INTSRC_MAXQ_INT_MASK	(0x1 << 3)
+#define MAX77759_PMIC_INTSRC_MAXQ_INT_CLEAR	(~(0x1 << 3))
+#define MAX77759_PMIC_INTSRC_SPR_3_SHIFT	2
+#define MAX77759_PMIC_INTSRC_SPR_3_MASK	(0x1 << 2)
+#define MAX77759_PMIC_INTSRC_SPR_3_CLEAR	(~(0x1 << 2))
+#define MAX77759_PMIC_INTSRC_TOPSYS_INT_SHIFT	1
+#define MAX77759_PMIC_INTSRC_TOPSYS_INT_MASK	(0x1 << 1)
+#define MAX77759_PMIC_INTSRC_TOPSYS_INT_CLEAR	(~(0x1 << 1))
+#define MAX77759_PMIC_INTSRC_CHGR_INT_SHIFT	0
+#define MAX77759_PMIC_INTSRC_CHGR_INT_MASK	(0x1 << 0)
+#define MAX77759_PMIC_INTSRC_CHGR_INT_CLEAR	(~(0x1 << 0))
+
+MAX77759_BFF(pmic_intsrc_spr_7_4,7,4)
+MAX77759_BFF(pmic_intsrc_maxq_int,3,3)
+MAX77759_BFF(pmic_intsrc_spr_3,2,2)
+MAX77759_BFF(pmic_intsrc_topsys_int,1,1)
+MAX77759_BFF(pmic_intsrc_chgr_int,0,0)
+static inline const char *
+max77759_pmic_intsrc_cstr(char *buff, size_t len, int val)
+{
+#ifdef SCNPRINTF
+	int i = 0;
+
+	i += SCNPRINTF(&buff[i], len - i, " SPR_7_4=%x",
+		FIELD2VALUE(MAX77759_PMIC_INTSRC_SPR_7_4, val));
+	i += SCNPRINTF(&buff[i], len - i, " MAXQ_INT=%x",
+		FIELD2VALUE(MAX77759_PMIC_INTSRC_MAXQ_INT, val));
+	i += SCNPRINTF(&buff[i], len - i, " SPR_3=%x",
+		FIELD2VALUE(MAX77759_PMIC_INTSRC_SPR_3, val));
+	i += SCNPRINTF(&buff[i], len - i, " TOPSYS_INT=%x",
+		FIELD2VALUE(MAX77759_PMIC_INTSRC_TOPSYS_INT, val));
+	i += SCNPRINTF(&buff[i], len - i, " CHGR_INT=%x",
+		FIELD2VALUE(MAX77759_PMIC_INTSRC_CHGR_INT, val));
+#else
+	buff[0] = 0;
+#endif
+	return buff;
+}
+
+/*
+ * INTSRCMASK,0x23,0b11111111,0xff
+ * SPR_7_4[3:0],,,,MAXQ_INT_M,SPR_3,TOPSYS_INT_M
+ */
+#define MAX77759_PMIC_INTSRCMASK	0x23
+#define MAX77759_PMIC_INTSRCMASK_MAXQ_INT_M	(0x1 << 3)
+#define MAX77759_PMIC_INTSRCMASK_SPR_3	(0x1 << 2)
+#define MAX77759_PMIC_INTSRCMASK_TOPSYS_INT_M	(0x1 << 1)
+#define MAX77759_PMIC_INTSRCMASK_CHGR_INT_M	(0x1 << 0)
+
+#define MAX77759_PMIC_INTSRCMASK_SPR_7_4_SHIFT	4
+#define MAX77759_PMIC_INTSRCMASK_SPR_7_4_MASK	(0xf << 4)
+#define MAX77759_PMIC_INTSRCMASK_SPR_7_4_CLEAR	(~(0xf << 4))
+#define MAX77759_PMIC_INTSRCMASK_MAXQ_INT_M_SHIFT	3
+#define MAX77759_PMIC_INTSRCMASK_MAXQ_INT_M_MASK	(0x1 << 3)
+#define MAX77759_PMIC_INTSRCMASK_MAXQ_INT_M_CLEAR	(~(0x1 << 3))
+#define MAX77759_PMIC_INTSRCMASK_SPR_3_SHIFT	2
+#define MAX77759_PMIC_INTSRCMASK_SPR_3_MASK	(0x1 << 2)
+#define MAX77759_PMIC_INTSRCMASK_SPR_3_CLEAR	(~(0x1 << 2))
+#define MAX77759_PMIC_INTSRCMASK_TOPSYS_INT_M_SHIFT	1
+#define MAX77759_PMIC_INTSRCMASK_TOPSYS_INT_M_MASK	(0x1 << 1)
+#define MAX77759_PMIC_INTSRCMASK_TOPSYS_INT_M_CLEAR	(~(0x1 << 1))
+#define MAX77759_PMIC_INTSRCMASK_CHGR_INT_M_SHIFT	0
+#define MAX77759_PMIC_INTSRCMASK_CHGR_INT_M_MASK	(0x1 << 0)
+#define MAX77759_PMIC_INTSRCMASK_CHGR_INT_M_CLEAR	(~(0x1 << 0))
+
+MAX77759_BFF(pmic_intsrcmask_spr_7_4,7,4)
+MAX77759_BFF(pmic_intsrcmask_maxq_int_m,3,3)
+MAX77759_BFF(pmic_intsrcmask_spr_3,2,2)
+MAX77759_BFF(pmic_intsrcmask_topsys_int_m,1,1)
+MAX77759_BFF(pmic_intsrcmask_chgr_int_m,0,0)
+static inline const char *
+max77759_pmic_intsrcmask_cstr(char *buff, size_t len, int val)
+{
+#ifdef SCNPRINTF
+	int i = 0;
+
+	i += SCNPRINTF(&buff[i], len - i, " SPR_7_4=%x",
+		FIELD2VALUE(MAX77759_PMIC_INTSRCMASK_SPR_7_4, val));
+	i += SCNPRINTF(&buff[i], len - i, " MAXQ_INT_M=%x",
+		FIELD2VALUE(MAX77759_PMIC_INTSRCMASK_MAXQ_INT_M, val));
+	i += SCNPRINTF(&buff[i], len - i, " SPR_3=%x",
+		FIELD2VALUE(MAX77759_PMIC_INTSRCMASK_SPR_3, val));
+	i += SCNPRINTF(&buff[i], len - i, " TOPSYS_INT_M=%x",
+		FIELD2VALUE(MAX77759_PMIC_INTSRCMASK_TOPSYS_INT_M, val));
+	i += SCNPRINTF(&buff[i], len - i, " CHGR_INT_M=%x",
+		FIELD2VALUE(MAX77759_PMIC_INTSRCMASK_CHGR_INT_M, val));
+#else
+	buff[0] = 0;
+#endif
+	return buff;
+}
+
+/*
+ * TOPSYS_INT,0x24,0b00000000,0x00
+ * SPR_7,TSHDN_INT,SYSOVLO_INT,SYSUVLO_INT,SPR_3_0[3:0],,
+ */
+#define MAX77759_PMIC_TOPSYS_INT	0x24
+#define MAX77759_PMIC_TOPSYS_INT_SPR_7	(0x1 << 7)
+#define MAX77759_PMIC_TOPSYS_INT_TSHDN_INT	(0x1 << 6)
+#define MAX77759_PMIC_TOPSYS_INT_SYSOVLO_INT	(0x1 << 5)
+#define MAX77759_PMIC_TOPSYS_INT_SYSUVLO_INT	(0x1 << 4)
+
+#define MAX77759_PMIC_TOPSYS_INT_SPR_7_SHIFT	7
+#define MAX77759_PMIC_TOPSYS_INT_SPR_7_MASK	(0x1 << 7)
+#define MAX77759_PMIC_TOPSYS_INT_SPR_7_CLEAR	(~(0x1 << 7))
+#define MAX77759_PMIC_TOPSYS_INT_TSHDN_INT_SHIFT	6
+#define MAX77759_PMIC_TOPSYS_INT_TSHDN_INT_MASK	(0x1 << 6)
+#define MAX77759_PMIC_TOPSYS_INT_TSHDN_INT_CLEAR	(~(0x1 << 6))
+#define MAX77759_PMIC_TOPSYS_INT_SYSOVLO_INT_SHIFT	5
+#define MAX77759_PMIC_TOPSYS_INT_SYSOVLO_INT_MASK	(0x1 << 5)
+#define MAX77759_PMIC_TOPSYS_INT_SYSOVLO_INT_CLEAR	(~(0x1 << 5))
+#define MAX77759_PMIC_TOPSYS_INT_SYSUVLO_INT_SHIFT	4
+#define MAX77759_PMIC_TOPSYS_INT_SYSUVLO_INT_MASK	(0x1 << 4)
+#define MAX77759_PMIC_TOPSYS_INT_SYSUVLO_INT_CLEAR	(~(0x1 << 4))
+#define MAX77759_PMIC_TOPSYS_INT_SPR_3_0_SHIFT	0
+#define MAX77759_PMIC_TOPSYS_INT_SPR_3_0_MASK	(0xf << 0)
+#define MAX77759_PMIC_TOPSYS_INT_SPR_3_0_CLEAR	(~(0xf << 0))
+
+MAX77759_BFF(pmic_topsys_int_spr_7,7,7)
+MAX77759_BFF(pmic_topsys_int_tshdn_int,6,6)
+MAX77759_BFF(pmic_topsys_int_sysovlo_int,5,5)
+MAX77759_BFF(pmic_topsys_int_sysuvlo_int,4,4)
+MAX77759_BFF(pmic_topsys_int_spr_3_0,3,0)
+static inline const char *
+max77759_pmic_topsys_int_cstr(char *buff, size_t len, int val)
+{
+#ifdef SCNPRINTF
+	int i = 0;
+
+	i += SCNPRINTF(&buff[i], len - i, " SPR_7=%x",
+		FIELD2VALUE(MAX77759_PMIC_TOPSYS_INT_SPR_7, val));
+	i += SCNPRINTF(&buff[i], len - i, " TSHDN_INT=%x",
+		FIELD2VALUE(MAX77759_PMIC_TOPSYS_INT_TSHDN_INT, val));
+	i += SCNPRINTF(&buff[i], len - i, " SYSOVLO_INT=%x",
+		FIELD2VALUE(MAX77759_PMIC_TOPSYS_INT_SYSOVLO_INT, val));
+	i += SCNPRINTF(&buff[i], len - i, " SYSUVLO_INT=%x",
+		FIELD2VALUE(MAX77759_PMIC_TOPSYS_INT_SYSUVLO_INT, val));
+	i += SCNPRINTF(&buff[i], len - i, " SPR_3_0=%x",
+		FIELD2VALUE(MAX77759_PMIC_TOPSYS_INT_SPR_3_0, val));
+#else
+	buff[0] = 0;
+#endif
+	return buff;
+}
+
+/*
+ * TOPSYS_INT_MASK,0x26,0b11111111,0xff
+ * SPR_7,TSHDN_INT_M,SYSOVLO_INT_M,SYSUVLO_INT_M,SPR_3_0[3:0],,
+ */
+#define MAX77759_PMIC_TOPSYS_INT_MASK	0x26
+#define MAX77759_PMIC_TOPSYS_INT_MASK_SPR_7	(0x1 << 7)
+#define MAX77759_PMIC_TOPSYS_INT_MASK_TSHDN_INT_M	(0x1 << 6)
+#define MAX77759_PMIC_TOPSYS_INT_MASK_SYSOVLO_INT_M	(0x1 << 5)
+#define MAX77759_PMIC_TOPSYS_INT_MASK_SYSUVLO_INT_M	(0x1 << 4)
+
+#define MAX77759_PMIC_TOPSYS_INT_MASK_SPR_7_SHIFT	7
+#define MAX77759_PMIC_TOPSYS_INT_MASK_SPR_7_MASK	(0x1 << 7)
+#define MAX77759_PMIC_TOPSYS_INT_MASK_SPR_7_CLEAR	(~(0x1 << 7))
+#define MAX77759_PMIC_TOPSYS_INT_MASK_TSHDN_INT_M_SHIFT	6
+#define MAX77759_PMIC_TOPSYS_INT_MASK_TSHDN_INT_M_MASK	(0x1 << 6)
+#define MAX77759_PMIC_TOPSYS_INT_MASK_TSHDN_INT_M_CLEAR	(~(0x1 << 6))
+#define MAX77759_PMIC_TOPSYS_INT_MASK_SYSOVLO_INT_M_SHIFT	5
+#define MAX77759_PMIC_TOPSYS_INT_MASK_SYSOVLO_INT_M_MASK	(0x1 << 5)
+#define MAX77759_PMIC_TOPSYS_INT_MASK_SYSOVLO_INT_M_CLEAR	(~(0x1 << 5))
+#define MAX77759_PMIC_TOPSYS_INT_MASK_SYSUVLO_INT_M_SHIFT	4
+#define MAX77759_PMIC_TOPSYS_INT_MASK_SYSUVLO_INT_M_MASK	(0x1 << 4)
+#define MAX77759_PMIC_TOPSYS_INT_MASK_SYSUVLO_INT_M_CLEAR	(~(0x1 << 4))
+#define MAX77759_PMIC_TOPSYS_INT_MASK_SPR_3_0_SHIFT	0
+#define MAX77759_PMIC_TOPSYS_INT_MASK_SPR_3_0_MASK	(0xf << 0)
+#define MAX77759_PMIC_TOPSYS_INT_MASK_SPR_3_0_CLEAR	(~(0xf << 0))
+
+MAX77759_BFF(pmic_topsys_int_mask_spr_7,7,7)
+MAX77759_BFF(pmic_topsys_int_mask_tshdn_int_m,6,6)
+MAX77759_BFF(pmic_topsys_int_mask_sysovlo_int_m,5,5)
+MAX77759_BFF(pmic_topsys_int_mask_sysuvlo_int_m,4,4)
+MAX77759_BFF(pmic_topsys_int_mask_spr_3_0,3,0)
+static inline const char *
+max77759_pmic_topsys_int_mask_cstr(char *buff, size_t len, int val)
+{
+#ifdef SCNPRINTF
+	int i = 0;
+
+	i += SCNPRINTF(&buff[i], len - i, " SPR_7=%x",
+		FIELD2VALUE(MAX77759_PMIC_TOPSYS_INT_MASK_SPR_7, val));
+	i += SCNPRINTF(&buff[i], len - i, " TSHDN_INT_M=%x",
+		FIELD2VALUE(MAX77759_PMIC_TOPSYS_INT_MASK_TSHDN_INT_M, val));
+	i += SCNPRINTF(&buff[i], len - i, " SYSOVLO_INT_M=%x",
+		FIELD2VALUE(MAX77759_PMIC_TOPSYS_INT_MASK_SYSOVLO_INT_M, val));
+	i += SCNPRINTF(&buff[i], len - i, " SYSUVLO_INT_M=%x",
+		FIELD2VALUE(MAX77759_PMIC_TOPSYS_INT_MASK_SYSUVLO_INT_M, val));
+	i += SCNPRINTF(&buff[i], len - i, " SPR_3_0=%x",
+		FIELD2VALUE(MAX77759_PMIC_TOPSYS_INT_MASK_SPR_3_0, val));
+#else
+	buff[0] = 0;
+#endif
+	return buff;
+}
+
+/*
+ * I2C_CNFG,0x40,0b00000000,0x00
+ * SPR_7,PAIR[2:0],,,SPR_3_1[2:0],,
+ */
+#define MAX77759_PMIC_I2C_CNFG	0x40
+#define MAX77759_PMIC_I2C_CNFG_SPR_7	(0x1 << 7)
+#define MAX77759_PMIC_I2C_CNFG_HS_EXT_EN	(0x1 << 0)
+
+#define MAX77759_PMIC_I2C_CNFG_SPR_7_SHIFT	7
+#define MAX77759_PMIC_I2C_CNFG_SPR_7_MASK	(0x1 << 7)
+#define MAX77759_PMIC_I2C_CNFG_SPR_7_CLEAR	(~(0x1 << 7))
+#define MAX77759_PMIC_I2C_CNFG_PAIR_SHIFT	4
+#define MAX77759_PMIC_I2C_CNFG_PAIR_MASK	(0x7 << 4)
+#define MAX77759_PMIC_I2C_CNFG_PAIR_CLEAR	(~(0x7 << 4))
+#define MAX77759_PMIC_I2C_CNFG_SPR_3_1_SHIFT	1
+#define MAX77759_PMIC_I2C_CNFG_SPR_3_1_MASK	(0x7 << 1)
+#define MAX77759_PMIC_I2C_CNFG_SPR_3_1_CLEAR	(~(0x7 << 1))
+#define MAX77759_PMIC_I2C_CNFG_HS_EXT_EN_SHIFT	0
+#define MAX77759_PMIC_I2C_CNFG_HS_EXT_EN_MASK	(0x1 << 0)
+#define MAX77759_PMIC_I2C_CNFG_HS_EXT_EN_CLEAR	(~(0x1 << 0))
+
+MAX77759_BFF(pmic_i2c_cnfg_spr_7,7,7)
+MAX77759_BFF(pmic_i2c_cnfg_pair,6,4)
+MAX77759_BFF(pmic_i2c_cnfg_spr_3_1,3,1)
+MAX77759_BFF(pmic_i2c_cnfg_hs_ext_en,0,0)
+static inline const char *
+max77759_pmic_i2c_cnfg_cstr(char *buff, size_t len, int val)
+{
+#ifdef SCNPRINTF
+	int i = 0;
+
+	i += SCNPRINTF(&buff[i], len - i, " SPR_7=%x",
+		FIELD2VALUE(MAX77759_PMIC_I2C_CNFG_SPR_7, val));
+	i += SCNPRINTF(&buff[i], len - i, " PAIR=%x",
+		FIELD2VALUE(MAX77759_PMIC_I2C_CNFG_PAIR, val));
+	i += SCNPRINTF(&buff[i], len - i, " SPR_3_1=%x",
+		FIELD2VALUE(MAX77759_PMIC_I2C_CNFG_SPR_3_1, val));
+	i += SCNPRINTF(&buff[i], len - i, " HS_EXT_EN=%x",
+		FIELD2VALUE(MAX77759_PMIC_I2C_CNFG_HS_EXT_EN, val));
+#else
+	buff[0] = 0;
+#endif
+	return buff;
+}
+
+/*
+ * SWRESET,0x50,0b00000000,0x00
+ * VIO_OK_MASK,IC_RST_MASK,SWR_RST[5:0],,,,
+ */
+#define MAX77759_PMIC_SWRESET	0x50
+#define MAX77759_PMIC_SWRESET_VIO_OK_MASK	(0x1 << 7)
+#define MAX77759_PMIC_SWRESET_IC_RST_MASK	(0x1 << 6)
+
+#define MAX77759_PMIC_SWRESET_VIO_OK_MASK_SHIFT	7
+#define MAX77759_PMIC_SWRESET_VIO_OK_MASK_MASK	(0x1 << 7)
+#define MAX77759_PMIC_SWRESET_VIO_OK_MASK_CLEAR	(~(0x1 << 7))
+#define MAX77759_PMIC_SWRESET_IC_RST_MASK_SHIFT	6
+#define MAX77759_PMIC_SWRESET_IC_RST_MASK_MASK	(0x1 << 6)
+#define MAX77759_PMIC_SWRESET_IC_RST_MASK_CLEAR	(~(0x1 << 6))
+#define MAX77759_PMIC_SWRESET_SWR_RST_SHIFT	0
+#define MAX77759_PMIC_SWRESET_SWR_RST_MASK	(0x3f << 0)
+#define MAX77759_PMIC_SWRESET_SWR_RST_CLEAR	(~(0x3f << 0))
+
+MAX77759_BFF(pmic_swreset_vio_ok_mask,7,7)
+MAX77759_BFF(pmic_swreset_ic_rst_mask,6,6)
+MAX77759_BFF(pmic_swreset_swr_rst,5,0)
+static inline const char *
+max77759_pmic_swreset_cstr(char *buff, size_t len, int val)
+{
+#ifdef SCNPRINTF
+	int i = 0;
+
+	i += SCNPRINTF(&buff[i], len - i, " VIO_OK_MASK=%x",
+		FIELD2VALUE(MAX77759_PMIC_SWRESET_VIO_OK_MASK, val));
+	i += SCNPRINTF(&buff[i], len - i, " IC_RST_MASK=%x",
+		FIELD2VALUE(MAX77759_PMIC_SWRESET_IC_RST_MASK, val));
+	i += SCNPRINTF(&buff[i], len - i, " SWR_RST=%x",
+		FIELD2VALUE(MAX77759_PMIC_SWRESET_SWR_RST, val));
+#else
+	buff[0] = 0;
+#endif
+	return buff;
+}
+
+/*
+ * CONTROL_FG,0x51,0b00010000,0x10
+ * SPR_7_5[2:0],,,TSHDN_DIS,SPR_3_0[1:0],,THMIO_MUX[1:0]
+ */
+#define MAX77759_PMIC_CONTROL_FG	0x51
+#define MAX77759_PMIC_CONTROL_FG_TSHDN_DIS	(0x1 << 4)
+
+#define MAX77759_PMIC_CONTROL_FG_SPR_7_5_SHIFT	5
+#define MAX77759_PMIC_CONTROL_FG_SPR_7_5_MASK	(0x7 << 5)
+#define MAX77759_PMIC_CONTROL_FG_SPR_7_5_CLEAR	(~(0x7 << 5))
+#define MAX77759_PMIC_CONTROL_FG_TSHDN_DIS_SHIFT	4
+#define MAX77759_PMIC_CONTROL_FG_TSHDN_DIS_MASK	(0x1 << 4)
+#define MAX77759_PMIC_CONTROL_FG_TSHDN_DIS_CLEAR	(~(0x1 << 4))
+#define MAX77759_PMIC_CONTROL_FG_SPR_3_0_SHIFT	2
+#define MAX77759_PMIC_CONTROL_FG_SPR_3_0_MASK	(0x3 << 2)
+#define MAX77759_PMIC_CONTROL_FG_SPR_3_0_CLEAR	(~(0x3 << 2))
+#define MAX77759_PMIC_CONTROL_FG_THMIO_MUX_SHIFT	0
+#define MAX77759_PMIC_CONTROL_FG_THMIO_MUX_MASK	(0x3 << 0)
+#define MAX77759_PMIC_CONTROL_FG_THMIO_MUX_CLEAR	(~(0x3 << 0))
+
+MAX77759_BFF(pmic_control_fg_spr_7_5,7,5)
+MAX77759_BFF(pmic_control_fg_tshdn_dis,4,4)
+MAX77759_BFF(pmic_control_fg_spr_3_0,3,2)
+MAX77759_BFF(pmic_control_fg_thmio_mux,1,0)
+static inline const char *
+max77759_pmic_control_fg_cstr(char *buff, size_t len, int val)
+{
+#ifdef SCNPRINTF
+	int i = 0;
+
+	i += SCNPRINTF(&buff[i], len - i, " SPR_7_5=%x",
+		FIELD2VALUE(MAX77759_PMIC_CONTROL_FG_SPR_7_5, val));
+	i += SCNPRINTF(&buff[i], len - i, " TSHDN_DIS=%x",
+		FIELD2VALUE(MAX77759_PMIC_CONTROL_FG_TSHDN_DIS, val));
+	i += SCNPRINTF(&buff[i], len - i, " SPR_3_0=%x",
+		FIELD2VALUE(MAX77759_PMIC_CONTROL_FG_SPR_3_0, val));
+	i += SCNPRINTF(&buff[i], len - i, " THMIO_MUX=%x",
+		FIELD2VALUE(MAX77759_PMIC_CONTROL_FG_THMIO_MUX, val));
+#else
+	buff[0] = 0;
+#endif
+	return buff;
+}
+
+/*
+ * DEVICE_ID,0x60,0b01011001,0x59
+ * DeviceID[7:0],,,,,,
+ */
+#define MAX77759_PMIC_DEVICE_ID	0x60
+
+/*
+ * DEVICE_REV,0x61,0b00000000,0x00
+ * DeviceRev[7:0],,,,,,
+ */
+#define MAX77759_PMIC_DEVICE_REV	0x61
+
+/*
+ * UIC_INT1,0x64,0b00000000,0x00
+ * APCmdResI,UIC_INT1I[6:0],,,,,
+ */
+#define MAX77759_PMIC_UIC_INT1	0x64
+#define MAX77759_PMIC_UIC_INT1_APCMDRESI	(0x1 << 7)
+
+#define MAX77759_PMIC_UIC_INT1_APCMDRESI_SHIFT	7
+#define MAX77759_PMIC_UIC_INT1_APCMDRESI_MASK	(0x1 << 7)
+#define MAX77759_PMIC_UIC_INT1_APCMDRESI_CLEAR	(~(0x1 << 7))
+#define MAX77759_PMIC_UIC_INT1_UIC_INT1I_SHIFT	0
+#define MAX77759_PMIC_UIC_INT1_UIC_INT1I_MASK	(0x7f << 0)
+#define MAX77759_PMIC_UIC_INT1_UIC_INT1I_CLEAR	(~(0x7f << 0))
+
+MAX77759_BFF(pmic_uic_int1_apcmdresi,7,7)
+MAX77759_BFF(pmic_uic_int1_uic_int1i,6,0)
+static inline const char *
+max77759_pmic_uic_int1_cstr(char *buff, size_t len, int val)
+{
+#ifdef SCNPRINTF
+	int i = 0;
+
+	i += SCNPRINTF(&buff[i], len - i, " APCMDRESI=%x",
+		FIELD2VALUE(MAX77759_PMIC_UIC_INT1_APCMDRESI, val));
+	i += SCNPRINTF(&buff[i], len - i, " UIC_INT1I=%x",
+		FIELD2VALUE(MAX77759_PMIC_UIC_INT1_UIC_INT1I, val));
+#else
+	buff[0] = 0;
+#endif
+	return buff;
+}
+
+/*
+ * UIC_INT2,0x65,0b00000000,0x00
+ * UIC_INT2I[7:0],,,,,,
+ */
+#define MAX77759_PMIC_UIC_INT2	0x65
+
+/*
+ * UIC_INT3,0x66,0b00000000,0x00
+ * UIC_INT3I[7:0],,,,,,
+ */
+#define MAX77759_PMIC_UIC_INT3	0x66
+
+/*
+ * UIC_INT4,0x67,0b00000000,0x00
+ * UIC_INT4I[7:0],,,,,,
+ */
+#define MAX77759_PMIC_UIC_INT4	0x67
+
+/*
+ * UIC_STATUS1,0x68,0b00000000,0x00
+ * UIC_STATUS1[7:0],,,,,,
+ */
+#define MAX77759_PMIC_UIC_STATUS1	0x68
+
+/*
+ * UIC_STATUS2,0x69,0b00000000,0x00
+ * UIC_STATUS2[7:0],,,,,,
+ */
+#define MAX77759_PMIC_UIC_STATUS2	0x69
+
+/*
+ * UIC_STATUS3,0x6A,0b00000000,0x00
+ * UIC_STATUS3[7:0],,,,,,
+ */
+#define MAX77759_PMIC_UIC_STATUS3	0x6A
+
+/*
+ * UIC_STATUS4,0x6B,0b00000000,0x00
+ * UIC_STATUS4[7:0],,,,,,
+ */
+#define MAX77759_PMIC_UIC_STATUS4	0x6B
+
+/*
+ * UIC_STATUS5,0x6C,0b00000000,0x00
+ * UIC_STATUS5[7:0],,,,,,
+ */
+#define MAX77759_PMIC_UIC_STATUS5	0x6C
+
+/*
+ * UIC_STATUS6,0x6D,0b00000000,0x00
+ * UIC_STATUS6[7:0],,,,,,
+ */
+#define MAX77759_PMIC_UIC_STATUS6	0x6D
+
+/*
+ * UIC_STATUS7,0x6E,0b00000000,0x00
+ * UIC_STATUS7[7:0],,,,,,
+ */
+#define MAX77759_PMIC_UIC_STATUS7	0x6E
+
+/*
+ * UIC_STATUS8,0x6F,0b00000000,0x00
+ * UIC_STATUS8[7:0],,,,,,
+ */
+#define MAX77759_PMIC_UIC_STATUS8	0x6F
+
+/*
+ * UIC_INT1_M,0x70,0b10111111,0xbf
+ * APCmdRes_M,UIC_INT1_M[6:0],,,,,
+ */
+#define MAX77759_PMIC_UIC_INT1_M	0x70
+#define MAX77759_PMIC_UIC_INT1_M_APCMDRES_M	(0x1 << 7)
+
+#define MAX77759_PMIC_UIC_INT1_M_APCMDRES_M_SHIFT	7
+#define MAX77759_PMIC_UIC_INT1_M_APCMDRES_M_MASK	(0x1 << 7)
+#define MAX77759_PMIC_UIC_INT1_M_APCMDRES_M_CLEAR	(~(0x1 << 7))
+#define MAX77759_PMIC_UIC_INT1_M_UIC_INT1_M_SHIFT	0
+#define MAX77759_PMIC_UIC_INT1_M_UIC_INT1_M_MASK	(0x7f << 0)
+#define MAX77759_PMIC_UIC_INT1_M_UIC_INT1_M_CLEAR	(~(0x7f << 0))
+
+MAX77759_BFF(pmic_uic_int1_m_apcmdres_m,7,7)
+MAX77759_BFF(pmic_uic_int1_m_uic_int1_m,6,0)
+static inline const char *
+max77759_pmic_uic_int1_m_cstr(char *buff, size_t len, int val)
+{
+#ifdef SCNPRINTF
+	int i = 0;
+
+	i += SCNPRINTF(&buff[i], len - i, " APCMDRES_M=%x",
+		FIELD2VALUE(MAX77759_PMIC_UIC_INT1_M_APCMDRES_M, val));
+	i += SCNPRINTF(&buff[i], len - i, " UIC_INT1_M=%x",
+		FIELD2VALUE(MAX77759_PMIC_UIC_INT1_M_UIC_INT1_M, val));
+#else
+	buff[0] = 0;
+#endif
+	return buff;
+}
+
+/*
+ * UIC_INT2_M,0x71,0b11111111,0xff
+ * UIC_INT2_M[7:0],,,,,,
+ */
+#define MAX77759_PMIC_UIC_INT2_M	0x71
+
+/*
+ * UIC_INT3_M,0x72,0b11111111,0xff
+ * UIC_INT3_M[7:0],,,,,,
+ */
+#define MAX77759_PMIC_UIC_INT3_M	0x72
+
+/*
+ * UIC_INT4_M,0x73,0b11111111,0xff
+ * UIC_INT4_M[7:0],,,,,,
+ */
+#define MAX77759_PMIC_UIC_INT4_M	0x73
+
+/*
+ * AP_DATAOUT0,0x81,0b00000000,0x00
+ * AP_REQUEST_OPCODE[7:0],,,,,,
+ */
+#define MAX77759_PMIC_AP_DATAOUT0	0x81
+
+/*
+ * AP_DATAOUT1,0x82,0b00000000,0x00
+ * OPCODE_DATAOUT_01[7:0],,,,,,
+ */
+#define MAX77759_PMIC_AP_DATAOUT1	0x82
+
+/*
+ * AP_DATAOUT2,0x83,0b00000000,0x00
+ * OPCODE_DATAOUT_02[7:0],,,,,,
+ */
+#define MAX77759_PMIC_AP_DATAOUT2	0x83
+
+/*
+ * AP_DATAOUT3,0x84,0b00000000,0x00
+ * OPCODE_DATAOUT_03[7:0],,,,,,
+ */
+#define MAX77759_PMIC_AP_DATAOUT3	0x84
+
+/*
+ * AP_DATAOUT4,0x85,0b00000000,0x00
+ * OPCODE_DATAOUT_04[7:0],,,,,,
+ */
+#define MAX77759_PMIC_AP_DATAOUT4	0x85
+
+/*
+ * AP_DATAOUT5,0x86,0b00000000,0x00
+ * OPCODE_DATAOUT_05[7:0],,,,,,
+ */
+#define MAX77759_PMIC_AP_DATAOUT5	0x86
+
+/*
+ * AP_DATAOUT6,0x87,0b00000000,0x00
+ * OPCODE_DATAOUT_06[7:0],,,,,,
+ */
+#define MAX77759_PMIC_AP_DATAOUT6	0x87
+
+/*
+ * AP_DATAOUT7,0x88,0b00000000,0x00
+ * OPCODE_DATAOUT_07[7:0],,,,,,
+ */
+#define MAX77759_PMIC_AP_DATAOUT7	0x88
+
+/*
+ * AP_DATAOUT8,0x89,0b00000000,0x00
+ * OPCODE_DATAOUT_08[7:0],,,,,,
+ */
+#define MAX77759_PMIC_AP_DATAOUT8	0x89
+
+/*
+ * AP_DATAOUT9,0x8A,0b00000000,0x00
+ * OPCODE_DATAOUT_09[7:0],,,,,,
+ */
+#define MAX77759_PMIC_AP_DATAOUT9	0x8A
+
+/*
+ * AP_DATAOUT10,0x8B,0b00000000,0x00
+ * OPCODE_DATAOUT_10[7:0],,,,,,
+ */
+#define MAX77759_PMIC_AP_DATAOUT10	0x8B
+
+/*
+ * AP_DATAOUT11,0x8C,0b00000000,0x00
+ * OPCODE_DATAOUT_11[7:0],,,,,,
+ */
+#define MAX77759_PMIC_AP_DATAOUT11	0x8C
+
+/*
+ * AP_DATAOUT12,0x8D,0b00000000,0x00
+ * OPCODE_DATAOUT_12[7:0],,,,,,
+ */
+#define MAX77759_PMIC_AP_DATAOUT12	0x8D
+
+/*
+ * AP_DATAOUT13,0x8E,0b00000000,0x00
+ * OPCODE_DATAOUT_13[7:0],,,,,,
+ */
+#define MAX77759_PMIC_AP_DATAOUT13	0x8E
+
+/*
+ * AP_DATAOUT14,0x8F,0b00000000,0x00
+ * OPCODE_DATAOUT_14[7:0],,,,,,
+ */
+#define MAX77759_PMIC_AP_DATAOUT14	0x8F
+
+/*
+ * AP_DATAOUT15,0x90,0b00000000,0x00
+ * OPCODE_DATAOUT_15[7:0],,,,,,
+ */
+#define MAX77759_PMIC_AP_DATAOUT15	0x90
+
+/*
+ * AP_DATAOUT16,0x91,0b00000000,0x00
+ * OPCODE_DATAOUT_16[7:0],,,,,,
+ */
+#define MAX77759_PMIC_AP_DATAOUT16	0x91
+
+/*
+ * AP_DATAOUT17,0x92,0b00000000,0x00
+ * OPCODE_DATAOUT_17[7:0],,,,,,
+ */
+#define MAX77759_PMIC_AP_DATAOUT17	0x92
+
+/*
+ * AP_DATAOUT18,0x93,0b00000000,0x00
+ * OPCODE_DATAOUT_18[7:0],,,,,,
+ */
+#define MAX77759_PMIC_AP_DATAOUT18	0x93
+
+/*
+ * AP_DATAOUT19,0x94,0b00000000,0x00
+ * OPCODE_DATAOUT_19[7:0],,,,,,
+ */
+#define MAX77759_PMIC_AP_DATAOUT19	0x94
+
+/*
+ * AP_DATAOUT20,0x95,0b00000000,0x00
+ * OPCODE_DATAOUT_20[7:0],,,,,,
+ */
+#define MAX77759_PMIC_AP_DATAOUT20	0x95
+
+/*
+ * AP_DATAOUT21,0x96,0b00000000,0x00
+ * OPCODE_DATAOUT_21[7:0],,,,,,
+ */
+#define MAX77759_PMIC_AP_DATAOUT21	0x96
+
+/*
+ * AP_DATAOUT22,0x97,0b00000000,0x00
+ * OPCODE_DATAOUT_22[7:0],,,,,,
+ */
+#define MAX77759_PMIC_AP_DATAOUT22	0x97
+
+/*
+ * AP_DATAOUT23,0x98,0b00000000,0x00
+ * OPCODE_DATAOUT_23[7:0],,,,,,
+ */
+#define MAX77759_PMIC_AP_DATAOUT23	0x98
+
+/*
+ * AP_DATAOUT24,0x99,0b00000000,0x00
+ * OPCODE_DATAOUT_24[7:0],,,,,,
+ */
+#define MAX77759_PMIC_AP_DATAOUT24	0x99
+
+/*
+ * AP_DATAOUT25,0x9A,0b00000000,0x00
+ * OPCODE_DATAOUT_25[7:0],,,,,,
+ */
+#define MAX77759_PMIC_AP_DATAOUT25	0x9A
+
+/*
+ * AP_DATAOUT26,0x9B,0b00000000,0x00
+ * OPCODE_DATAOUT_26[7:0],,,,,,
+ */
+#define MAX77759_PMIC_AP_DATAOUT26	0x9B
+
+/*
+ * AP_DATAOUT27,0x9C,0b00000000,0x00
+ * OPCODE_DATAOUT_27[7:0],,,,,,
+ */
+#define MAX77759_PMIC_AP_DATAOUT27	0x9C
+
+/*
+ * AP_DATAOUT28,0x9D,0b00000000,0x00
+ * OPCODE_DATAOUT_28[7:0],,,,,,
+ */
+#define MAX77759_PMIC_AP_DATAOUT28	0x9D
+
+/*
+ * AP_DATAOUT29,0x9E,0b00000000,0x00
+ * OPCODE_DATAOUT_29[7:0],,,,,,
+ */
+#define MAX77759_PMIC_AP_DATAOUT29	0x9E
+
+/*
+ * AP_DATAOUT30,0x9F,0b00000000,0x00
+ * OPCODE_DATAOUT_30[7:0],,,,,,
+ */
+#define MAX77759_PMIC_AP_DATAOUT30	0x9F
+
+/*
+ * AP_DATAOUT31,0xA0,0b00000000,0x00
+ * OPCODE_DATAOUT_31[7:0],,,,,,
+ */
+#define MAX77759_PMIC_AP_DATAOUT31	0xA0
+
+/*
+ * AP_DATAOUT32,0xA1,0b00000000,0x00
+ * OPCODE_DATAOUT_32[7:0],,,,,,
+ */
+#define MAX77759_PMIC_AP_DATAOUT32	0xA1
+
+/*
+ * AP_DATAIN0,0xB1,0b00000000,0x00
+ * MAXQ_RESPONSE_OPCODE[7:0],,,,,,
+ */
+#define MAX77759_PMIC_AP_DATAIN0	0xB1
+
+/*
+ * AP_DATAIN1,0xB2,0b00000000,0x00
+ * OPCODE_DATAIN_01[7:0],,,,,,
+ */
+#define MAX77759_PMIC_AP_DATAIN1	0xB2
+
+/*
+ * AP_DATAIN2,0xB3,0b00000000,0x00
+ * OPCODE_DATAIN_02[7:0],,,,,,
+ */
+#define MAX77759_PMIC_AP_DATAIN2	0xB3
+
+/*
+ * AP_DATAIN3,0xB4,0b00000000,0x00
+ * OPCODE_DATAIN_03[7:0],,,,,,
+ */
+#define MAX77759_PMIC_AP_DATAIN3	0xB4
+
+/*
+ * AP_DATAIN4,0xB5,0b00000000,0x00
+ * OPCODE_DATAIN_04[7:0],,,,,,
+ */
+#define MAX77759_PMIC_AP_DATAIN4	0xB5
+
+/*
+ * AP_DATAIN5,0xB6,0b00000000,0x00
+ * OPCODE_DATAIN_05[7:0],,,,,,
+ */
+#define MAX77759_PMIC_AP_DATAIN5	0xB6
+
+/*
+ * AP_DATAIN6,0xB7,0b00000000,0x00
+ * OPCODE_DATAIN_06[7:0],,,,,,
+ */
+#define MAX77759_PMIC_AP_DATAIN6	0xB7
+
+/*
+ * AP_DATAIN7,0xB8,0b00000000,0x00
+ * OPCODE_DATAIN_07[7:0],,,,,,
+ */
+#define MAX77759_PMIC_AP_DATAIN7	0xB8
+
+/*
+ * AP_DATAIN8,0xB9,0b00000000,0x00
+ * OPCODE_DATAIN_08[7:0],,,,,,
+ */
+#define MAX77759_PMIC_AP_DATAIN8	0xB9
+
+/*
+ * AP_DATAIN9,0xBA,0b00000000,0x00
+ * OPCODE_DATAIN_09[7:0],,,,,,
+ */
+#define MAX77759_PMIC_AP_DATAIN9	0xBA
+
+/*
+ * AP_DATAIN10,0xBB,0b00000000,0x00
+ * OPCODE_DATAIN_10[7:0],,,,,,
+ */
+#define MAX77759_PMIC_AP_DATAIN10	0xBB
+
+/*
+ * AP_DATAIN11,0xBC,0b00000000,0x00
+ * OPCODE_DATAIN_11[7:0],,,,,,
+ */
+#define MAX77759_PMIC_AP_DATAIN11	0xBC
+
+/*
+ * AP_DATAIN12,0xBD,0b00000000,0x00
+ * OPCODE_DATAIN_12[7:0],,,,,,
+ */
+#define MAX77759_PMIC_AP_DATAIN12	0xBD
+
+/*
+ * AP_DATAIN13,0xBE,0b00000000,0x00
+ * OPCODE_DATAIN_13[7:0],,,,,,
+ */
+#define MAX77759_PMIC_AP_DATAIN13	0xBE
+
+/*
+ * AP_DATAIN14,0xBF,0b00000000,0x00
+ * OPCODE_DATAIN_14[7:0],,,,,,
+ */
+#define MAX77759_PMIC_AP_DATAIN14	0xBF
+
+/*
+ * AP_DATAIN15,0xC0,0b00000000,0x00
+ * OPCODE_DATAIN_15[7:0],,,,,,
+ */
+#define MAX77759_PMIC_AP_DATAIN15	0xC0
+
+/*
+ * AP_DATAIN16,0xC1,0b00000000,0x00
+ * OPCODE_DATAIN_16[7:0],,,,,,
+ */
+#define MAX77759_PMIC_AP_DATAIN16	0xC1
+
+/*
+ * AP_DATAIN17,0xC2,0b00000000,0x00
+ * OPCODE_DATAIN_17[7:0],,,,,,
+ */
+#define MAX77759_PMIC_AP_DATAIN17	0xC2
+
+/*
+ * AP_DATAIN18,0xC3,0b00000000,0x00
+ * OPCODE_DATAIN_18[7:0],,,,,,
+ */
+#define MAX77759_PMIC_AP_DATAIN18	0xC3
+
+/*
+ * AP_DATAIN19,0xC4,0b00000000,0x00
+ * OPCODE_DATAIN_19[7:0],,,,,,
+ */
+#define MAX77759_PMIC_AP_DATAIN19	0xC4
+
+/*
+ * AP_DATAIN20,0xC5,0b00000000,0x00
+ * OPCODE_DATAIN_20[7:0],,,,,,
+ */
+#define MAX77759_PMIC_AP_DATAIN20	0xC5
+
+/*
+ * AP_DATAIN21,0xC6,0b00000000,0x00
+ * OPCODE_DATAIN_21[7:0],,,,,,
+ */
+#define MAX77759_PMIC_AP_DATAIN21	0xC6
+
+/*
+ * AP_DATAIN22,0xC7,0b00000000,0x00
+ * OPCODE_DATAIN_22[7:0],,,,,,
+ */
+#define MAX77759_PMIC_AP_DATAIN22	0xC7
+
+/*
+ * AP_DATAIN23,0xC8,0b00000000,0x00
+ * OPCODE_DATAIN_23[7:0],,,,,,
+ */
+#define MAX77759_PMIC_AP_DATAIN23	0xC8
+
+/*
+ * AP_DATAIN24,0xC9,0b00000000,0x00
+ * OPCODE_DATAIN_24[7:0],,,,,,
+ */
+#define MAX77759_PMIC_AP_DATAIN24	0xC9
+
+/*
+ * AP_DATAIN25,0xCA,0b00000000,0x00
+ * OPCODE_DATAIN_25[7:0],,,,,,
+ */
+#define MAX77759_PMIC_AP_DATAIN25	0xCA
+
+/*
+ * AP_DATAIN26,0xCB,0b00000000,0x00
+ * OPCODE_DATAIN_26[7:0],,,,,,
+ */
+#define MAX77759_PMIC_AP_DATAIN26	0xCB
+
+/*
+ * AP_DATAIN27,0xCC,0b00000000,0x00
+ * OPCODE_DATAIN_27[7:0],,,,,,
+ */
+#define MAX77759_PMIC_AP_DATAIN27	0xCC
+
+/*
+ * AP_DATAIN28,0xCD,0b00000000,0x00
+ * OPCODE_DATAIN_28[7:0],,,,,,
+ */
+#define MAX77759_PMIC_AP_DATAIN28	0xCD
+
+/*
+ * AP_DATAIN29,0xCE,0b00000000,0x00
+ * OPCODE_DATAIN_29[7:0],,,,,,
+ */
+#define MAX77759_PMIC_AP_DATAIN29	0xCE
+
+/*
+ * AP_DATAIN30,0xCF,0b00000000,0x00
+ * OPCODE_DATAIN_30[7:0],,,,,,
+ */
+#define MAX77759_PMIC_AP_DATAIN30	0xCF
+
+/*
+ * AP_DATAIN31,0xD0,0b00000000,0x00
+ * OPCODE_DATAIN_31[7:0],,,,,,
+ */
+#define MAX77759_PMIC_AP_DATAIN31	0xD0
+
+/*
+ * AP_DATAIN32,0xD1,0b00000000,0x00
+ * OPCODE_DATAIN_32[7:0],,,,,,
+ */
+#define MAX77759_PMIC_AP_DATAIN32	0xD1
+
+/*
+ * UIC_SWRST,0xE0,0b00000000,0x00
+ * UIC_SWRST[7:0],,,,,,
+ */
+#define MAX77759_PMIC_UIC_SWRST	0xE0
+
+/* section:  Charger  */
+
+/*
+ * CHG_INT,0xB0,0b00000000,0x00
+ * AICL_I,CHGIN_I,WCIN_I,CHG_I,BAT_I,INLIM_I,THM2_I
+ */
+#define MAX77759_CHG_INT	0xB0
+#define MAX77759_CHG_INT_AICL_I	(0x1 << 7)
+#define MAX77759_CHG_INT_CHGIN_I	(0x1 << 6)
+#define MAX77759_CHG_INT_WCIN_I	(0x1 << 5)
+#define MAX77759_CHG_INT_CHG_I	(0x1 << 4)
+#define MAX77759_CHG_INT_BAT_I	(0x1 << 3)
+#define MAX77759_CHG_INT_INLIM_I	(0x1 << 2)
+#define MAX77759_CHG_INT_THM2_I	(0x1 << 1)
+#define MAX77759_CHG_INT_BYP_I	(0x1 << 0)
+
+#define MAX77759_CHG_INT_AICL_I_SHIFT	7
+#define MAX77759_CHG_INT_AICL_I_MASK	(0x1 << 7)
+#define MAX77759_CHG_INT_AICL_I_CLEAR	(~(0x1 << 7))
+#define MAX77759_CHG_INT_CHGIN_I_SHIFT	6
+#define MAX77759_CHG_INT_CHGIN_I_MASK	(0x1 << 6)
+#define MAX77759_CHG_INT_CHGIN_I_CLEAR	(~(0x1 << 6))
+#define MAX77759_CHG_INT_WCIN_I_SHIFT	5
+#define MAX77759_CHG_INT_WCIN_I_MASK	(0x1 << 5)
+#define MAX77759_CHG_INT_WCIN_I_CLEAR	(~(0x1 << 5))
+#define MAX77759_CHG_INT_CHG_I_SHIFT	4
+#define MAX77759_CHG_INT_CHG_I_MASK	(0x1 << 4)
+#define MAX77759_CHG_INT_CHG_I_CLEAR	(~(0x1 << 4))
+#define MAX77759_CHG_INT_BAT_I_SHIFT	3
+#define MAX77759_CHG_INT_BAT_I_MASK	(0x1 << 3)
+#define MAX77759_CHG_INT_BAT_I_CLEAR	(~(0x1 << 3))
+#define MAX77759_CHG_INT_INLIM_I_SHIFT	2
+#define MAX77759_CHG_INT_INLIM_I_MASK	(0x1 << 2)
+#define MAX77759_CHG_INT_INLIM_I_CLEAR	(~(0x1 << 2))
+#define MAX77759_CHG_INT_THM2_I_SHIFT	1
+#define MAX77759_CHG_INT_THM2_I_MASK	(0x1 << 1)
+#define MAX77759_CHG_INT_THM2_I_CLEAR	(~(0x1 << 1))
+#define MAX77759_CHG_INT_BYP_I_SHIFT	0
+#define MAX77759_CHG_INT_BYP_I_MASK	(0x1 << 0)
+#define MAX77759_CHG_INT_BYP_I_CLEAR	(~(0x1 << 0))
+
+MAX77759_BFF(chg_int_aicl_i,7,7)
+MAX77759_BFF(chg_int_chgin_i,6,6)
+MAX77759_BFF(chg_int_wcin_i,5,5)
+MAX77759_BFF(chg_int_chg_i,4,4)
+MAX77759_BFF(chg_int_bat_i,3,3)
+MAX77759_BFF(chg_int_inlim_i,2,2)
+MAX77759_BFF(chg_int_thm2_i,1,1)
+MAX77759_BFF(chg_int_byp_i,0,0)
+static inline const char *
+max77759_chg_int_cstr(char *buff, size_t len, int val)
+{
+#ifdef SCNPRINTF
+	int i = 0;
+
+	i += SCNPRINTF(&buff[i], len - i, " AICL_I=%x",
+		FIELD2VALUE(MAX77759_CHG_INT_AICL_I, val));
+	i += SCNPRINTF(&buff[i], len - i, " CHGIN_I=%x",
+		FIELD2VALUE(MAX77759_CHG_INT_CHGIN_I, val));
+	i += SCNPRINTF(&buff[i], len - i, " WCIN_I=%x",
+		FIELD2VALUE(MAX77759_CHG_INT_WCIN_I, val));
+	i += SCNPRINTF(&buff[i], len - i, " CHG_I=%x",
+		FIELD2VALUE(MAX77759_CHG_INT_CHG_I, val));
+	i += SCNPRINTF(&buff[i], len - i, " BAT_I=%x",
+		FIELD2VALUE(MAX77759_CHG_INT_BAT_I, val));
+	i += SCNPRINTF(&buff[i], len - i, " INLIM_I=%x",
+		FIELD2VALUE(MAX77759_CHG_INT_INLIM_I, val));
+	i += SCNPRINTF(&buff[i], len - i, " THM2_I=%x",
+		FIELD2VALUE(MAX77759_CHG_INT_THM2_I, val));
+	i += SCNPRINTF(&buff[i], len - i, " BYP_I=%x",
+		FIELD2VALUE(MAX77759_CHG_INT_BYP_I, val));
+#else
+	buff[0] = 0;
+#endif
+	return buff;
+}
+
+/*
+ * CHG_INT2,0xB1,0b00000000,0x00
+ * INSEL_I,SYS_UVLO1_I,SYS_UVLO2_I,BAT_OILO_I,CHG_STA_CC_I,CHG_STA_CV_I,CHG_STA_TO_I
+ */
+#define MAX77759_CHG_INT2	0xB1
+#define MAX77759_CHG_INT2_INSEL_I	(0x1 << 7)
+#define MAX77759_CHG_INT2_SYS_UVLO1_I	(0x1 << 6)
+#define MAX77759_CHG_INT2_SYS_UVLO2_I	(0x1 << 5)
+#define MAX77759_CHG_INT2_BAT_OILO_I	(0x1 << 4)
+#define MAX77759_CHG_INT2_CHG_STA_CC_I	(0x1 << 3)
+#define MAX77759_CHG_INT2_CHG_STA_CV_I	(0x1 << 2)
+#define MAX77759_CHG_INT2_CHG_STA_TO_I	(0x1 << 1)
+#define MAX77759_CHG_INT2_CHG_STA_DONE_I	(0x1 << 0)
+
+#define MAX77759_CHG_INT2_INSEL_I_SHIFT	7
+#define MAX77759_CHG_INT2_INSEL_I_MASK	(0x1 << 7)
+#define MAX77759_CHG_INT2_INSEL_I_CLEAR	(~(0x1 << 7))
+#define MAX77759_CHG_INT2_SYS_UVLO1_I_SHIFT	6
+#define MAX77759_CHG_INT2_SYS_UVLO1_I_MASK	(0x1 << 6)
+#define MAX77759_CHG_INT2_SYS_UVLO1_I_CLEAR	(~(0x1 << 6))
+#define MAX77759_CHG_INT2_SYS_UVLO2_I_SHIFT	5
+#define MAX77759_CHG_INT2_SYS_UVLO2_I_MASK	(0x1 << 5)
+#define MAX77759_CHG_INT2_SYS_UVLO2_I_CLEAR	(~(0x1 << 5))
+#define MAX77759_CHG_INT2_BAT_OILO_I_SHIFT	4
+#define MAX77759_CHG_INT2_BAT_OILO_I_MASK	(0x1 << 4)
+#define MAX77759_CHG_INT2_BAT_OILO_I_CLEAR	(~(0x1 << 4))
+#define MAX77759_CHG_INT2_CHG_STA_CC_I_SHIFT	3
+#define MAX77759_CHG_INT2_CHG_STA_CC_I_MASK	(0x1 << 3)
+#define MAX77759_CHG_INT2_CHG_STA_CC_I_CLEAR	(~(0x1 << 3))
+#define MAX77759_CHG_INT2_CHG_STA_CV_I_SHIFT	2
+#define MAX77759_CHG_INT2_CHG_STA_CV_I_MASK	(0x1 << 2)
+#define MAX77759_CHG_INT2_CHG_STA_CV_I_CLEAR	(~(0x1 << 2))
+#define MAX77759_CHG_INT2_CHG_STA_TO_I_SHIFT	1
+#define MAX77759_CHG_INT2_CHG_STA_TO_I_MASK	(0x1 << 1)
+#define MAX77759_CHG_INT2_CHG_STA_TO_I_CLEAR	(~(0x1 << 1))
+#define MAX77759_CHG_INT2_CHG_STA_DONE_I_SHIFT	0
+#define MAX77759_CHG_INT2_CHG_STA_DONE_I_MASK	(0x1 << 0)
+#define MAX77759_CHG_INT2_CHG_STA_DONE_I_CLEAR	(~(0x1 << 0))
+
+MAX77759_BFF(chg_int2_insel_i,7,7)
+MAX77759_BFF(chg_int2_sys_uvlo1_i,6,6)
+MAX77759_BFF(chg_int2_sys_uvlo2_i,5,5)
+MAX77759_BFF(chg_int2_bat_oilo_i,4,4)
+MAX77759_BFF(chg_int2_chg_sta_cc_i,3,3)
+MAX77759_BFF(chg_int2_chg_sta_cv_i,2,2)
+MAX77759_BFF(chg_int2_chg_sta_to_i,1,1)
+MAX77759_BFF(chg_int2_chg_sta_done_i,0,0)
+static inline const char *
+max77759_chg_int2_cstr(char *buff, size_t len, int val)
+{
+#ifdef SCNPRINTF
+	int i = 0;
+
+	i += SCNPRINTF(&buff[i], len - i, " INSEL_I=%x",
+		FIELD2VALUE(MAX77759_CHG_INT2_INSEL_I, val));
+	i += SCNPRINTF(&buff[i], len - i, " SYS_UVLO1_I=%x",
+		FIELD2VALUE(MAX77759_CHG_INT2_SYS_UVLO1_I, val));
+	i += SCNPRINTF(&buff[i], len - i, " SYS_UVLO2_I=%x",
+		FIELD2VALUE(MAX77759_CHG_INT2_SYS_UVLO2_I, val));
+	i += SCNPRINTF(&buff[i], len - i, " BAT_OILO_I=%x",
+		FIELD2VALUE(MAX77759_CHG_INT2_BAT_OILO_I, val));
+	i += SCNPRINTF(&buff[i], len - i, " CHG_STA_CC_I=%x",
+		FIELD2VALUE(MAX77759_CHG_INT2_CHG_STA_CC_I, val));
+	i += SCNPRINTF(&buff[i], len - i, " CHG_STA_CV_I=%x",
+		FIELD2VALUE(MAX77759_CHG_INT2_CHG_STA_CV_I, val));
+	i += SCNPRINTF(&buff[i], len - i, " CHG_STA_TO_I=%x",
+		FIELD2VALUE(MAX77759_CHG_INT2_CHG_STA_TO_I, val));
+	i += SCNPRINTF(&buff[i], len - i, " CHG_STA_DONE_I=%x",
+		FIELD2VALUE(MAX77759_CHG_INT2_CHG_STA_DONE_I, val));
+#else
+	buff[0] = 0;
+#endif
+	return buff;
+}
+
+/*
+ * CHG_INT_MASK,0xB2,0b11111111,0xff
+ * AICL_M,CHGIN_M,WCIN_M,CHG_M,BAT_M,INLIM_M,THM2_M
+ */
+#define MAX77759_CHG_INT_MASK	0xB2
+#define MAX77759_CHG_INT_MASK_AICL_M	(0x1 << 7)
+#define MAX77759_CHG_INT_MASK_CHGIN_M	(0x1 << 6)
+#define MAX77759_CHG_INT_MASK_WCIN_M	(0x1 << 5)
+#define MAX77759_CHG_INT_MASK_CHG_M	(0x1 << 4)
+#define MAX77759_CHG_INT_MASK_BAT_M	(0x1 << 3)
+#define MAX77759_CHG_INT_MASK_INLIM_M	(0x1 << 2)
+#define MAX77759_CHG_INT_MASK_THM2_M	(0x1 << 1)
+#define MAX77759_CHG_INT_MASK_BYP_M	(0x1 << 0)
+
+#define MAX77759_CHG_INT_MASK_AICL_M_SHIFT	7
+#define MAX77759_CHG_INT_MASK_AICL_M_MASK	(0x1 << 7)
+#define MAX77759_CHG_INT_MASK_AICL_M_CLEAR	(~(0x1 << 7))
+#define MAX77759_CHG_INT_MASK_CHGIN_M_SHIFT	6
+#define MAX77759_CHG_INT_MASK_CHGIN_M_MASK	(0x1 << 6)
+#define MAX77759_CHG_INT_MASK_CHGIN_M_CLEAR	(~(0x1 << 6))
+#define MAX77759_CHG_INT_MASK_WCIN_M_SHIFT	5
+#define MAX77759_CHG_INT_MASK_WCIN_M_MASK	(0x1 << 5)
+#define MAX77759_CHG_INT_MASK_WCIN_M_CLEAR	(~(0x1 << 5))
+#define MAX77759_CHG_INT_MASK_CHG_M_SHIFT	4
+#define MAX77759_CHG_INT_MASK_CHG_M_MASK	(0x1 << 4)
+#define MAX77759_CHG_INT_MASK_CHG_M_CLEAR	(~(0x1 << 4))
+#define MAX77759_CHG_INT_MASK_BAT_M_SHIFT	3
+#define MAX77759_CHG_INT_MASK_BAT_M_MASK	(0x1 << 3)
+#define MAX77759_CHG_INT_MASK_BAT_M_CLEAR	(~(0x1 << 3))
+#define MAX77759_CHG_INT_MASK_INLIM_M_SHIFT	2
+#define MAX77759_CHG_INT_MASK_INLIM_M_MASK	(0x1 << 2)
+#define MAX77759_CHG_INT_MASK_INLIM_M_CLEAR	(~(0x1 << 2))
+#define MAX77759_CHG_INT_MASK_THM2_M_SHIFT	1
+#define MAX77759_CHG_INT_MASK_THM2_M_MASK	(0x1 << 1)
+#define MAX77759_CHG_INT_MASK_THM2_M_CLEAR	(~(0x1 << 1))
+#define MAX77759_CHG_INT_MASK_BYP_M_SHIFT	0
+#define MAX77759_CHG_INT_MASK_BYP_M_MASK	(0x1 << 0)
+#define MAX77759_CHG_INT_MASK_BYP_M_CLEAR	(~(0x1 << 0))
+
+MAX77759_BFF(chg_int_mask_aicl_m,7,7)
+MAX77759_BFF(chg_int_mask_chgin_m,6,6)
+MAX77759_BFF(chg_int_mask_wcin_m,5,5)
+MAX77759_BFF(chg_int_mask_chg_m,4,4)
+MAX77759_BFF(chg_int_mask_bat_m,3,3)
+MAX77759_BFF(chg_int_mask_inlim_m,2,2)
+MAX77759_BFF(chg_int_mask_thm2_m,1,1)
+MAX77759_BFF(chg_int_mask_byp_m,0,0)
+static inline const char *
+max77759_chg_int_mask_cstr(char *buff, size_t len, int val)
+{
+#ifdef SCNPRINTF
+	int i = 0;
+
+	i += SCNPRINTF(&buff[i], len - i, " AICL_M=%x",
+		FIELD2VALUE(MAX77759_CHG_INT_MASK_AICL_M, val));
+	i += SCNPRINTF(&buff[i], len - i, " CHGIN_M=%x",
+		FIELD2VALUE(MAX77759_CHG_INT_MASK_CHGIN_M, val));
+	i += SCNPRINTF(&buff[i], len - i, " WCIN_M=%x",
+		FIELD2VALUE(MAX77759_CHG_INT_MASK_WCIN_M, val));
+	i += SCNPRINTF(&buff[i], len - i, " CHG_M=%x",
+		FIELD2VALUE(MAX77759_CHG_INT_MASK_CHG_M, val));
+	i += SCNPRINTF(&buff[i], len - i, " BAT_M=%x",
+		FIELD2VALUE(MAX77759_CHG_INT_MASK_BAT_M, val));
+	i += SCNPRINTF(&buff[i], len - i, " INLIM_M=%x",
+		FIELD2VALUE(MAX77759_CHG_INT_MASK_INLIM_M, val));
+	i += SCNPRINTF(&buff[i], len - i, " THM2_M=%x",
+		FIELD2VALUE(MAX77759_CHG_INT_MASK_THM2_M, val));
+	i += SCNPRINTF(&buff[i], len - i, " BYP_M=%x",
+		FIELD2VALUE(MAX77759_CHG_INT_MASK_BYP_M, val));
+#else
+	buff[0] = 0;
+#endif
+	return buff;
+}
+
+/*
+ * CHG_INT2_MASK,0xB3,0b11111111,0xff
+ * INSEL_M,SYS_UVLO1_M,SYS_UVLO2_M,BAT_OILO_M,CHG_STA_CC_M,CHG_STA_CV_M,CHG_STA_TO_M
+ */
+#define MAX77759_CHG_INT2_MASK	0xB3
+#define MAX77759_CHG_INT2_MASK_INSEL_M	(0x1 << 7)
+#define MAX77759_CHG_INT2_MASK_SYS_UVLO1_M	(0x1 << 6)
+#define MAX77759_CHG_INT2_MASK_SYS_UVLO2_M	(0x1 << 5)
+#define MAX77759_CHG_INT2_MASK_BAT_OILO_M	(0x1 << 4)
+#define MAX77759_CHG_INT2_MASK_CHG_STA_CC_M	(0x1 << 3)
+#define MAX77759_CHG_INT2_MASK_CHG_STA_CV_M	(0x1 << 2)
+#define MAX77759_CHG_INT2_MASK_CHG_STA_TO_M	(0x1 << 1)
+#define MAX77759_CHG_INT2_MASK_CHG_STA_DONE_M	(0x1 << 0)
+
+#define MAX77759_CHG_INT2_MASK_INSEL_M_SHIFT	7
+#define MAX77759_CHG_INT2_MASK_INSEL_M_MASK	(0x1 << 7)
+#define MAX77759_CHG_INT2_MASK_INSEL_M_CLEAR	(~(0x1 << 7))
+#define MAX77759_CHG_INT2_MASK_SYS_UVLO1_M_SHIFT	6
+#define MAX77759_CHG_INT2_MASK_SYS_UVLO1_M_MASK	(0x1 << 6)
+#define MAX77759_CHG_INT2_MASK_SYS_UVLO1_M_CLEAR	(~(0x1 << 6))
+#define MAX77759_CHG_INT2_MASK_SYS_UVLO2_M_SHIFT	5
+#define MAX77759_CHG_INT2_MASK_SYS_UVLO2_M_MASK	(0x1 << 5)
+#define MAX77759_CHG_INT2_MASK_SYS_UVLO2_M_CLEAR	(~(0x1 << 5))
+#define MAX77759_CHG_INT2_MASK_BAT_OILO_M_SHIFT	4
+#define MAX77759_CHG_INT2_MASK_BAT_OILO_M_MASK	(0x1 << 4)
+#define MAX77759_CHG_INT2_MASK_BAT_OILO_M_CLEAR	(~(0x1 << 4))
+#define MAX77759_CHG_INT2_MASK_CHG_STA_CC_M_SHIFT	3
+#define MAX77759_CHG_INT2_MASK_CHG_STA_CC_M_MASK	(0x1 << 3)
+#define MAX77759_CHG_INT2_MASK_CHG_STA_CC_M_CLEAR	(~(0x1 << 3))
+#define MAX77759_CHG_INT2_MASK_CHG_STA_CV_M_SHIFT	2
+#define MAX77759_CHG_INT2_MASK_CHG_STA_CV_M_MASK	(0x1 << 2)
+#define MAX77759_CHG_INT2_MASK_CHG_STA_CV_M_CLEAR	(~(0x1 << 2))
+#define MAX77759_CHG_INT2_MASK_CHG_STA_TO_M_SHIFT	1
+#define MAX77759_CHG_INT2_MASK_CHG_STA_TO_M_MASK	(0x1 << 1)
+#define MAX77759_CHG_INT2_MASK_CHG_STA_TO_M_CLEAR	(~(0x1 << 1))
+#define MAX77759_CHG_INT2_MASK_CHG_STA_DONE_M_SHIFT	0
+#define MAX77759_CHG_INT2_MASK_CHG_STA_DONE_M_MASK	(0x1 << 0)
+#define MAX77759_CHG_INT2_MASK_CHG_STA_DONE_M_CLEAR	(~(0x1 << 0))
+
+MAX77759_BFF(chg_int2_mask_insel_m,7,7)
+MAX77759_BFF(chg_int2_mask_sys_uvlo1_m,6,6)
+MAX77759_BFF(chg_int2_mask_sys_uvlo2_m,5,5)
+MAX77759_BFF(chg_int2_mask_bat_oilo_m,4,4)
+MAX77759_BFF(chg_int2_mask_chg_sta_cc_m,3,3)
+MAX77759_BFF(chg_int2_mask_chg_sta_cv_m,2,2)
+MAX77759_BFF(chg_int2_mask_chg_sta_to_m,1,1)
+MAX77759_BFF(chg_int2_mask_chg_sta_done_m,0,0)
+static inline const char *
+max77759_chg_int2_mask_cstr(char *buff, size_t len, int val)
+{
+#ifdef SCNPRINTF
+	int i = 0;
+
+	i += SCNPRINTF(&buff[i], len - i, " INSEL_M=%x",
+		FIELD2VALUE(MAX77759_CHG_INT2_MASK_INSEL_M, val));
+	i += SCNPRINTF(&buff[i], len - i, " SYS_UVLO1_M=%x",
+		FIELD2VALUE(MAX77759_CHG_INT2_MASK_SYS_UVLO1_M, val));
+	i += SCNPRINTF(&buff[i], len - i, " SYS_UVLO2_M=%x",
+		FIELD2VALUE(MAX77759_CHG_INT2_MASK_SYS_UVLO2_M, val));
+	i += SCNPRINTF(&buff[i], len - i, " BAT_OILO_M=%x",
+		FIELD2VALUE(MAX77759_CHG_INT2_MASK_BAT_OILO_M, val));
+	i += SCNPRINTF(&buff[i], len - i, " CHG_STA_CC_M=%x",
+		FIELD2VALUE(MAX77759_CHG_INT2_MASK_CHG_STA_CC_M, val));
+	i += SCNPRINTF(&buff[i], len - i, " CHG_STA_CV_M=%x",
+		FIELD2VALUE(MAX77759_CHG_INT2_MASK_CHG_STA_CV_M, val));
+	i += SCNPRINTF(&buff[i], len - i, " CHG_STA_TO_M=%x",
+		FIELD2VALUE(MAX77759_CHG_INT2_MASK_CHG_STA_TO_M, val));
+	i += SCNPRINTF(&buff[i], len - i, " CHG_STA_DONE_M=%x",
+		FIELD2VALUE(MAX77759_CHG_INT2_MASK_CHG_STA_DONE_M, val));
+#else
+	buff[0] = 0;
+#endif
+	return buff;
+}
+
+/*
+ * CHG_INT_OK,0xB4,0b10011111,0x9f
+ * AICL_OK,CHGIN_OK,WCIN_OK,CHG_OK,BAT_OK,INLIM_OK,THM2_OK
+ */
+#define MAX77759_CHG_INT_OK	0xB4
+#define MAX77759_CHG_INT_OK_AICL_OK	(0x1 << 7)
+#define MAX77759_CHG_INT_OK_CHGIN_OK	(0x1 << 6)
+#define MAX77759_CHG_INT_OK_WCIN_OK	(0x1 << 5)
+#define MAX77759_CHG_INT_OK_CHG_OK	(0x1 << 4)
+#define MAX77759_CHG_INT_OK_BAT_OK	(0x1 << 3)
+#define MAX77759_CHG_INT_OK_INLIM_OK	(0x1 << 2)
+#define MAX77759_CHG_INT_OK_THM2_OK	(0x1 << 1)
+#define MAX77759_CHG_INT_OK_BYP_OK	(0x1 << 0)
+
+#define MAX77759_CHG_INT_OK_AICL_OK_SHIFT	7
+#define MAX77759_CHG_INT_OK_AICL_OK_MASK	(0x1 << 7)
+#define MAX77759_CHG_INT_OK_AICL_OK_CLEAR	(~(0x1 << 7))
+#define MAX77759_CHG_INT_OK_CHGIN_OK_SHIFT	6
+#define MAX77759_CHG_INT_OK_CHGIN_OK_MASK	(0x1 << 6)
+#define MAX77759_CHG_INT_OK_CHGIN_OK_CLEAR	(~(0x1 << 6))
+#define MAX77759_CHG_INT_OK_WCIN_OK_SHIFT	5
+#define MAX77759_CHG_INT_OK_WCIN_OK_MASK	(0x1 << 5)
+#define MAX77759_CHG_INT_OK_WCIN_OK_CLEAR	(~(0x1 << 5))
+#define MAX77759_CHG_INT_OK_CHG_OK_SHIFT	4
+#define MAX77759_CHG_INT_OK_CHG_OK_MASK	(0x1 << 4)
+#define MAX77759_CHG_INT_OK_CHG_OK_CLEAR	(~(0x1 << 4))
+#define MAX77759_CHG_INT_OK_BAT_OK_SHIFT	3
+#define MAX77759_CHG_INT_OK_BAT_OK_MASK	(0x1 << 3)
+#define MAX77759_CHG_INT_OK_BAT_OK_CLEAR	(~(0x1 << 3))
+#define MAX77759_CHG_INT_OK_INLIM_OK_SHIFT	2
+#define MAX77759_CHG_INT_OK_INLIM_OK_MASK	(0x1 << 2)
+#define MAX77759_CHG_INT_OK_INLIM_OK_CLEAR	(~(0x1 << 2))
+#define MAX77759_CHG_INT_OK_THM2_OK_SHIFT	1
+#define MAX77759_CHG_INT_OK_THM2_OK_MASK	(0x1 << 1)
+#define MAX77759_CHG_INT_OK_THM2_OK_CLEAR	(~(0x1 << 1))
+#define MAX77759_CHG_INT_OK_BYP_OK_SHIFT	0
+#define MAX77759_CHG_INT_OK_BYP_OK_MASK	(0x1 << 0)
+#define MAX77759_CHG_INT_OK_BYP_OK_CLEAR	(~(0x1 << 0))
+
+MAX77759_BFF(chg_int_ok_aicl_ok,7,7)
+MAX77759_BFF(chg_int_ok_chgin_ok,6,6)
+MAX77759_BFF(chg_int_ok_wcin_ok,5,5)
+MAX77759_BFF(chg_int_ok_chg_ok,4,4)
+MAX77759_BFF(chg_int_ok_bat_ok,3,3)
+MAX77759_BFF(chg_int_ok_inlim_ok,2,2)
+MAX77759_BFF(chg_int_ok_thm2_ok,1,1)
+MAX77759_BFF(chg_int_ok_byp_ok,0,0)
+static inline const char *
+max77759_chg_int_ok_cstr(char *buff, size_t len, int val)
+{
+#ifdef SCNPRINTF
+	int i = 0;
+
+	i += SCNPRINTF(&buff[i], len - i, " AICL_OK=%x",
+		FIELD2VALUE(MAX77759_CHG_INT_OK_AICL_OK, val));
+	i += SCNPRINTF(&buff[i], len - i, " CHGIN_OK=%x",
+		FIELD2VALUE(MAX77759_CHG_INT_OK_CHGIN_OK, val));
+	i += SCNPRINTF(&buff[i], len - i, " WCIN_OK=%x",
+		FIELD2VALUE(MAX77759_CHG_INT_OK_WCIN_OK, val));
+	i += SCNPRINTF(&buff[i], len - i, " CHG_OK=%x",
+		FIELD2VALUE(MAX77759_CHG_INT_OK_CHG_OK, val));
+	i += SCNPRINTF(&buff[i], len - i, " BAT_OK=%x",
+		FIELD2VALUE(MAX77759_CHG_INT_OK_BAT_OK, val));
+	i += SCNPRINTF(&buff[i], len - i, " INLIM_OK=%x",
+		FIELD2VALUE(MAX77759_CHG_INT_OK_INLIM_OK, val));
+	i += SCNPRINTF(&buff[i], len - i, " THM2_OK=%x",
+		FIELD2VALUE(MAX77759_CHG_INT_OK_THM2_OK, val));
+	i += SCNPRINTF(&buff[i], len - i, " BYP_OK=%x",
+		FIELD2VALUE(MAX77759_CHG_INT_OK_BYP_OK, val));
+#else
+	buff[0] = 0;
+#endif
+	return buff;
+}
+
+/*
+ * CHG_DETAILS_00,0xB5,0b00000000,0x00
+ * RSVD,CHGIN_DTLS[1:0],,WCIN_DTLS[1:0],,SPSN_DTLS[1:0],
+ */
+#define MAX77759_CHG_DETAILS_00	0xB5
+#define MAX77759_CHG_DETAILS_00_RSVD	(0x1 << 7)
+#define MAX77759_CHG_DETAILS_00_TREG	(0x1 << 0)
+
+#define MAX77759_CHG_DETAILS_00_RSVD_SHIFT	7
+#define MAX77759_CHG_DETAILS_00_RSVD_MASK	(0x1 << 7)
+#define MAX77759_CHG_DETAILS_00_RSVD_CLEAR	(~(0x1 << 7))
+#define MAX77759_CHG_DETAILS_00_CHGIN_DTLS_SHIFT	5
+#define MAX77759_CHG_DETAILS_00_CHGIN_DTLS_MASK	(0x3 << 5)
+#define MAX77759_CHG_DETAILS_00_CHGIN_DTLS_CLEAR	(~(0x3 << 5))
+#define MAX77759_CHG_DETAILS_00_WCIN_DTLS_SHIFT	3
+#define MAX77759_CHG_DETAILS_00_WCIN_DTLS_MASK	(0x3 << 3)
+#define MAX77759_CHG_DETAILS_00_WCIN_DTLS_CLEAR	(~(0x3 << 3))
+#define MAX77759_CHG_DETAILS_00_SPSN_DTLS_SHIFT	1
+#define MAX77759_CHG_DETAILS_00_SPSN_DTLS_MASK	(0x3 << 1)
+#define MAX77759_CHG_DETAILS_00_SPSN_DTLS_CLEAR	(~(0x3 << 1))
+#define MAX77759_CHG_DETAILS_00_TREG_SHIFT	0
+#define MAX77759_CHG_DETAILS_00_TREG_MASK	(0x1 << 0)
+#define MAX77759_CHG_DETAILS_00_TREG_CLEAR	(~(0x1 << 0))
+
+MAX77759_BFF(chg_details_00_rsvd,7,7)
+MAX77759_BFF(chg_details_00_chgin_dtls,6,5)
+MAX77759_BFF(chg_details_00_wcin_dtls,4,3)
+MAX77759_BFF(chg_details_00_spsn_dtls,2,1)
+MAX77759_BFF(chg_details_00_treg,0,0)
+static inline const char *
+max77759_chg_details_00_cstr(char *buff, size_t len, int val)
+{
+#ifdef SCNPRINTF
+	int i = 0;
+
+	i += SCNPRINTF(&buff[i], len - i, " RSVD=%x",
+		FIELD2VALUE(MAX77759_CHG_DETAILS_00_RSVD, val));
+	i += SCNPRINTF(&buff[i], len - i, " CHGIN_DTLS=%x",
+		FIELD2VALUE(MAX77759_CHG_DETAILS_00_CHGIN_DTLS, val));
+	i += SCNPRINTF(&buff[i], len - i, " WCIN_DTLS=%x",
+		FIELD2VALUE(MAX77759_CHG_DETAILS_00_WCIN_DTLS, val));
+	i += SCNPRINTF(&buff[i], len - i, " SPSN_DTLS=%x",
+		FIELD2VALUE(MAX77759_CHG_DETAILS_00_SPSN_DTLS, val));
+	i += SCNPRINTF(&buff[i], len - i, " TREG=%x",
+		FIELD2VALUE(MAX77759_CHG_DETAILS_00_TREG, val));
+#else
+	buff[0] = 0;
+#endif
+	return buff;
+}
+
+/*
+ * CHG_DETAILS_01,0xB6,0b01111000,0x78
+ * VDROOP2_OK,BAT_DTLS[2:0],,,CHG_DTLS[3:0],,
+ */
+#define MAX77759_CHG_DETAILS_01	0xB6
+#define MAX77759_CHG_DETAILS_01_VDROOP2_OK	(0x1 << 7)
+
+#define MAX77759_CHG_DETAILS_01_VDROOP2_OK_SHIFT	7
+#define MAX77759_CHG_DETAILS_01_VDROOP2_OK_MASK	(0x1 << 7)
+#define MAX77759_CHG_DETAILS_01_VDROOP2_OK_CLEAR	(~(0x1 << 7))
+#define MAX77759_CHG_DETAILS_01_BAT_DTLS_SHIFT	4
+#define MAX77759_CHG_DETAILS_01_BAT_DTLS_MASK	(0x7 << 4)
+#define MAX77759_CHG_DETAILS_01_BAT_DTLS_CLEAR	(~(0x7 << 4))
+#define MAX77759_CHG_DETAILS_01_CHG_DTLS_SHIFT	0
+#define MAX77759_CHG_DETAILS_01_CHG_DTLS_MASK	(0xf << 0)
+#define MAX77759_CHG_DETAILS_01_CHG_DTLS_CLEAR	(~(0xf << 0))
+
+MAX77759_BFF(chg_details_01_vdroop2_ok,7,7)
+MAX77759_BFF(chg_details_01_bat_dtls,6,4)
+MAX77759_BFF(chg_details_01_chg_dtls,3,0)
+static inline const char *
+max77759_chg_details_01_cstr(char *buff, size_t len, int val)
+{
+#ifdef SCNPRINTF
+	int i = 0;
+
+	i += SCNPRINTF(&buff[i], len - i, " VDROOP2_OK=%x",
+		FIELD2VALUE(MAX77759_CHG_DETAILS_01_VDROOP2_OK, val));
+	i += SCNPRINTF(&buff[i], len - i, " BAT_DTLS=%x",
+		FIELD2VALUE(MAX77759_CHG_DETAILS_01_BAT_DTLS, val));
+	i += SCNPRINTF(&buff[i], len - i, " CHG_DTLS=%x",
+		FIELD2VALUE(MAX77759_CHG_DETAILS_01_CHG_DTLS, val));
+#else
+	buff[0] = 0;
+#endif
+	return buff;
+}
+
+/*
+ * CHG_DETAILS_02,0xB7,0b00000000,0x00
+ * RSVD[1:0],,CHGIN_STS,WCIN_STS,BYP_DTLS[3:0],,
+ */
+#define MAX77759_CHG_DETAILS_02	0xB7
+#define MAX77759_CHG_DETAILS_02_CHGIN_STS	(0x1 << 5)
+#define MAX77759_CHG_DETAILS_02_WCIN_STS	(0x1 << 4)
+
+#define MAX77759_CHG_DETAILS_02_RSVD_SHIFT	6
+#define MAX77759_CHG_DETAILS_02_RSVD_MASK	(0x3 << 6)
+#define MAX77759_CHG_DETAILS_02_RSVD_CLEAR	(~(0x3 << 6))
+#define MAX77759_CHG_DETAILS_02_CHGIN_STS_SHIFT	5
+#define MAX77759_CHG_DETAILS_02_CHGIN_STS_MASK	(0x1 << 5)
+#define MAX77759_CHG_DETAILS_02_CHGIN_STS_CLEAR	(~(0x1 << 5))
+#define MAX77759_CHG_DETAILS_02_WCIN_STS_SHIFT	4
+#define MAX77759_CHG_DETAILS_02_WCIN_STS_MASK	(0x1 << 4)
+#define MAX77759_CHG_DETAILS_02_WCIN_STS_CLEAR	(~(0x1 << 4))
+#define MAX77759_CHG_DETAILS_02_BYP_DTLS_SHIFT	0
+#define MAX77759_CHG_DETAILS_02_BYP_DTLS_MASK	(0xf << 0)
+#define MAX77759_CHG_DETAILS_02_BYP_DTLS_CLEAR	(~(0xf << 0))
+
+MAX77759_BFF(chg_details_02_rsvd,7,6)
+MAX77759_BFF(chg_details_02_chgin_sts,5,5)
+MAX77759_BFF(chg_details_02_wcin_sts,4,4)
+MAX77759_BFF(chg_details_02_byp_dtls,3,0)
+static inline const char *
+max77759_chg_details_02_cstr(char *buff, size_t len, int val)
+{
+#ifdef SCNPRINTF
+	int i = 0;
+
+	i += SCNPRINTF(&buff[i], len - i, " RSVD=%x",
+		FIELD2VALUE(MAX77759_CHG_DETAILS_02_RSVD, val));
+	i += SCNPRINTF(&buff[i], len - i, " CHGIN_STS=%x",
+		FIELD2VALUE(MAX77759_CHG_DETAILS_02_CHGIN_STS, val));
+	i += SCNPRINTF(&buff[i], len - i, " WCIN_STS=%x",
+		FIELD2VALUE(MAX77759_CHG_DETAILS_02_WCIN_STS, val));
+	i += SCNPRINTF(&buff[i], len - i, " BYP_DTLS=%x",
+		FIELD2VALUE(MAX77759_CHG_DETAILS_02_BYP_DTLS, val));
+#else
+	buff[0] = 0;
+#endif
+	return buff;
+}
+
+/*
+ * CHG_DETAILS_03,0xB8,0b00000000,0x00
+ * FSHIP_EXIT_DTLS[1:0],,MD_DTLS[1:0],,RSVD,THM_DTLS[2:0],
+ */
+#define MAX77759_CHG_DETAILS_03	0xB8
+#define MAX77759_CHG_DETAILS_03_RSVD	(0x1 << 3)
+
+#define MAX77759_CHG_DETAILS_03_FSHIP_EXIT_DTLS_SHIFT	6
+#define MAX77759_CHG_DETAILS_03_FSHIP_EXIT_DTLS_MASK	(0x3 << 6)
+#define MAX77759_CHG_DETAILS_03_FSHIP_EXIT_DTLS_CLEAR	(~(0x3 << 6))
+#define MAX77759_CHG_DETAILS_03_MD_DTLS_SHIFT	4
+#define MAX77759_CHG_DETAILS_03_MD_DTLS_MASK	(0x3 << 4)
+#define MAX77759_CHG_DETAILS_03_MD_DTLS_CLEAR	(~(0x3 << 4))
+#define MAX77759_CHG_DETAILS_03_RSVD_SHIFT	3
+#define MAX77759_CHG_DETAILS_03_RSVD_MASK	(0x1 << 3)
+#define MAX77759_CHG_DETAILS_03_RSVD_CLEAR	(~(0x1 << 3))
+#define MAX77759_CHG_DETAILS_03_THM_DTLS_SHIFT	0
+#define MAX77759_CHG_DETAILS_03_THM_DTLS_MASK	(0x7 << 0)
+#define MAX77759_CHG_DETAILS_03_THM_DTLS_CLEAR	(~(0x7 << 0))
+
+MAX77759_BFF(chg_details_03_fship_exit_dtls,7,6)
+MAX77759_BFF(chg_details_03_md_dtls,5,4)
+MAX77759_BFF(chg_details_03_rsvd,3,3)
+MAX77759_BFF(chg_details_03_thm_dtls,2,0)
+static inline const char *
+max77759_chg_details_03_cstr(char *buff, size_t len, int val)
+{
+#ifdef SCNPRINTF
+	int i = 0;
+
+	i += SCNPRINTF(&buff[i], len - i, " FSHIP_EXIT_DTLS=%x",
+		FIELD2VALUE(MAX77759_CHG_DETAILS_03_FSHIP_EXIT_DTLS, val));
+	i += SCNPRINTF(&buff[i], len - i, " MD_DTLS=%x",
+		FIELD2VALUE(MAX77759_CHG_DETAILS_03_MD_DTLS, val));
+	i += SCNPRINTF(&buff[i], len - i, " RSVD=%x",
+		FIELD2VALUE(MAX77759_CHG_DETAILS_03_RSVD, val));
+	i += SCNPRINTF(&buff[i], len - i, " THM_DTLS=%x",
+		FIELD2VALUE(MAX77759_CHG_DETAILS_03_THM_DTLS, val));
+#else
+	buff[0] = 0;
+#endif
+	return buff;
+}
+
+/*
+ * CHG_CNFG_00,0xB9,0b00000100,0x04
+ * WDTCLR[1:0],,CP_EN,SPR_4,MODE[3:0],,
+ */
+#define MAX77759_CHG_CNFG_00	0xB9
+#define MAX77759_CHG_CNFG_00_CP_EN	(0x1 << 5)
+#define MAX77759_CHG_CNFG_00_SPR_4	(0x1 << 4)
+
+#define MAX77759_CHG_CNFG_00_WDTCLR_SHIFT	6
+#define MAX77759_CHG_CNFG_00_WDTCLR_MASK	(0x3 << 6)
+#define MAX77759_CHG_CNFG_00_WDTCLR_CLEAR	(~(0x3 << 6))
+#define MAX77759_CHG_CNFG_00_CP_EN_SHIFT	5
+#define MAX77759_CHG_CNFG_00_CP_EN_MASK	(0x1 << 5)
+#define MAX77759_CHG_CNFG_00_CP_EN_CLEAR	(~(0x1 << 5))
+#define MAX77759_CHG_CNFG_00_SPR_4_SHIFT	4
+#define MAX77759_CHG_CNFG_00_SPR_4_MASK	(0x1 << 4)
+#define MAX77759_CHG_CNFG_00_SPR_4_CLEAR	(~(0x1 << 4))
+#define MAX77759_CHG_CNFG_00_MODE_SHIFT	0
+#define MAX77759_CHG_CNFG_00_MODE_MASK	(0xf << 0)
+#define MAX77759_CHG_CNFG_00_MODE_CLEAR	(~(0xf << 0))
+
+MAX77759_BFF(chg_cnfg_00_wdtclr,7,6)
+MAX77759_BFF(chg_cnfg_00_cp_en,5,5)
+MAX77759_BFF(chg_cnfg_00_spr_4,4,4)
+MAX77759_BFF(chg_cnfg_00_mode,3,0)
+static inline const char *
+max77759_chg_cnfg_00_cstr(char *buff, size_t len, int val)
+{
+#ifdef SCNPRINTF
+	int i = 0;
+
+	i += SCNPRINTF(&buff[i], len - i, " WDTCLR=%x",
+		FIELD2VALUE(MAX77759_CHG_CNFG_00_WDTCLR, val));
+	i += SCNPRINTF(&buff[i], len - i, " CP_EN=%x",
+		FIELD2VALUE(MAX77759_CHG_CNFG_00_CP_EN, val));
+	i += SCNPRINTF(&buff[i], len - i, " SPR_4=%x",
+		FIELD2VALUE(MAX77759_CHG_CNFG_00_SPR_4, val));
+	i += SCNPRINTF(&buff[i], len - i, " MODE=%x",
+		FIELD2VALUE(MAX77759_CHG_CNFG_00_MODE, val));
+#else
+	buff[0] = 0;
+#endif
+	return buff;
+}
+
+/*
+ * CHG_CNFG_01,0xBA,0b10010001,0x91
+ * PQEN,LSEL,CHG_RSTRT[1:0],,RECYCLE_EN,FCHGTIME[2:0],
+ */
+#define MAX77759_CHG_CNFG_01	0xBA
+#define MAX77759_CHG_CNFG_01_PQEN	(0x1 << 7)
+#define MAX77759_CHG_CNFG_01_LSEL	(0x1 << 6)
+#define MAX77759_CHG_CNFG_01_RECYCLE_EN	(0x1 << 3)
+
+#define MAX77759_CHG_CNFG_01_PQEN_SHIFT	7
+#define MAX77759_CHG_CNFG_01_PQEN_MASK	(0x1 << 7)
+#define MAX77759_CHG_CNFG_01_PQEN_CLEAR	(~(0x1 << 7))
+#define MAX77759_CHG_CNFG_01_LSEL_SHIFT	6
+#define MAX77759_CHG_CNFG_01_LSEL_MASK	(0x1 << 6)
+#define MAX77759_CHG_CNFG_01_LSEL_CLEAR	(~(0x1 << 6))
+#define MAX77759_CHG_CNFG_01_CHG_RSTRT_SHIFT	4
+#define MAX77759_CHG_CNFG_01_CHG_RSTRT_MASK	(0x3 << 4)
+#define MAX77759_CHG_CNFG_01_CHG_RSTRT_CLEAR	(~(0x3 << 4))
+#define MAX77759_CHG_CNFG_01_RECYCLE_EN_SHIFT	3
+#define MAX77759_CHG_CNFG_01_RECYCLE_EN_MASK	(0x1 << 3)
+#define MAX77759_CHG_CNFG_01_RECYCLE_EN_CLEAR	(~(0x1 << 3))
+#define MAX77759_CHG_CNFG_01_FCHGTIME_SHIFT	0
+#define MAX77759_CHG_CNFG_01_FCHGTIME_MASK	(0x7 << 0)
+#define MAX77759_CHG_CNFG_01_FCHGTIME_CLEAR	(~(0x7 << 0))
+
+MAX77759_BFF(chg_cnfg_01_pqen,7,7)
+MAX77759_BFF(chg_cnfg_01_lsel,6,6)
+MAX77759_BFF(chg_cnfg_01_chg_rstrt,5,4)
+MAX77759_BFF(chg_cnfg_01_recycle_en,3,3)
+MAX77759_BFF(chg_cnfg_01_fchgtime,2,0)
+static inline const char *
+max77759_chg_cnfg_01_cstr(char *buff, size_t len, int val)
+{
+#ifdef SCNPRINTF
+	int i = 0;
+
+	i += SCNPRINTF(&buff[i], len - i, " PQEN=%x",
+		FIELD2VALUE(MAX77759_CHG_CNFG_01_PQEN, val));
+	i += SCNPRINTF(&buff[i], len - i, " LSEL=%x",
+		FIELD2VALUE(MAX77759_CHG_CNFG_01_LSEL, val));
+	i += SCNPRINTF(&buff[i], len - i, " CHG_RSTRT=%x",
+		FIELD2VALUE(MAX77759_CHG_CNFG_01_CHG_RSTRT, val));
+	i += SCNPRINTF(&buff[i], len - i, " RECYCLE_EN=%x",
+		FIELD2VALUE(MAX77759_CHG_CNFG_01_RECYCLE_EN, val));
+	i += SCNPRINTF(&buff[i], len - i, " FCHGTIME=%x",
+		FIELD2VALUE(MAX77759_CHG_CNFG_01_FCHGTIME, val));
+#else
+	buff[0] = 0;
+#endif
+	return buff;
+}
+
+/*
+ * CHG_CNFG_02,0xBB,0b00000111,0x07
+ * SPR_7_6[1:0],,CHGCC[5:0],,,,
+ */
+#define MAX77759_CHG_CNFG_02	0xBB
+
+#define MAX77759_CHG_CNFG_02_SPR_7_6_SHIFT	6
+#define MAX77759_CHG_CNFG_02_SPR_7_6_MASK	(0x3 << 6)
+#define MAX77759_CHG_CNFG_02_SPR_7_6_CLEAR	(~(0x3 << 6))
+#define MAX77759_CHG_CNFG_02_CHGCC_SHIFT	0
+#define MAX77759_CHG_CNFG_02_CHGCC_MASK	(0x3f << 0)
+#define MAX77759_CHG_CNFG_02_CHGCC_CLEAR	(~(0x3f << 0))
+
+MAX77759_BFF(chg_cnfg_02_spr_7_6,7,6)
+MAX77759_BFF(chg_cnfg_02_chgcc,5,0)
+static inline const char *
+max77759_chg_cnfg_02_cstr(char *buff, size_t len, int val)
+{
+#ifdef SCNPRINTF
+	int i = 0;
+
+	i += SCNPRINTF(&buff[i], len - i, " SPR_7_6=%x",
+		FIELD2VALUE(MAX77759_CHG_CNFG_02_SPR_7_6, val));
+	i += SCNPRINTF(&buff[i], len - i, " CHGCC=%x",
+		FIELD2VALUE(MAX77759_CHG_CNFG_02_CHGCC, val));
+#else
+	buff[0] = 0;
+#endif
+	return buff;
+}
+
+/*
+ * CHG_CNFG_03,0xBC,0b11011001,0xd9
+ * SYS_TRACK_DIS,AUTO_FSHIP_MODE_EN,TO_TIME[2:0],,,TO_ITH[2:0],
+ */
+#define MAX77759_CHG_CNFG_03	0xBC
+#define MAX77759_CHG_CNFG_03_SYS_TRACK_DIS	(0x1 << 7)
+#define MAX77759_CHG_CNFG_03_AUTO_FSHIP_MODE_EN	(0x1 << 6)
+
+#define MAX77759_CHG_CNFG_03_SYS_TRACK_DIS_SHIFT	7
+#define MAX77759_CHG_CNFG_03_SYS_TRACK_DIS_MASK	(0x1 << 7)
+#define MAX77759_CHG_CNFG_03_SYS_TRACK_DIS_CLEAR	(~(0x1 << 7))
+#define MAX77759_CHG_CNFG_03_AUTO_FSHIP_MODE_EN_SHIFT	6
+#define MAX77759_CHG_CNFG_03_AUTO_FSHIP_MODE_EN_MASK	(0x1 << 6)
+#define MAX77759_CHG_CNFG_03_AUTO_FSHIP_MODE_EN_CLEAR	(~(0x1 << 6))
+#define MAX77759_CHG_CNFG_03_TO_TIME_SHIFT	3
+#define MAX77759_CHG_CNFG_03_TO_TIME_MASK	(0x7 << 3)
+#define MAX77759_CHG_CNFG_03_TO_TIME_CLEAR	(~(0x7 << 3))
+#define MAX77759_CHG_CNFG_03_TO_ITH_SHIFT	0
+#define MAX77759_CHG_CNFG_03_TO_ITH_MASK	(0x7 << 0)
+#define MAX77759_CHG_CNFG_03_TO_ITH_CLEAR	(~(0x7 << 0))
+
+MAX77759_BFF(chg_cnfg_03_sys_track_dis,7,7)
+MAX77759_BFF(chg_cnfg_03_auto_fship_mode_en,6,6)
+MAX77759_BFF(chg_cnfg_03_to_time,5,3)
+MAX77759_BFF(chg_cnfg_03_to_ith,2,0)
+static inline const char *
+max77759_chg_cnfg_03_cstr(char *buff, size_t len, int val)
+{
+#ifdef SCNPRINTF
+	int i = 0;
+
+	i += SCNPRINTF(&buff[i], len - i, " SYS_TRACK_DIS=%x",
+		FIELD2VALUE(MAX77759_CHG_CNFG_03_SYS_TRACK_DIS, val));
+	i += SCNPRINTF(&buff[i], len - i, " AUTO_FSHIP_MODE_EN=%x",
+		FIELD2VALUE(MAX77759_CHG_CNFG_03_AUTO_FSHIP_MODE_EN, val));
+	i += SCNPRINTF(&buff[i], len - i, " TO_TIME=%x",
+		FIELD2VALUE(MAX77759_CHG_CNFG_03_TO_TIME, val));
+	i += SCNPRINTF(&buff[i], len - i, " TO_ITH=%x",
+		FIELD2VALUE(MAX77759_CHG_CNFG_03_TO_ITH, val));
+#else
+	buff[0] = 0;
+#endif
+	return buff;
+}
+
+/*
+ * CHG_CNFG_04,0xBD,0b00010100,0x14
+ * SPR_7_6[1:0],,CHG_CV_PRM[5:0],,,,
+ */
+#define MAX77759_CHG_CNFG_04	0xBD
+
+#define MAX77759_CHG_CNFG_04_SPR_7_6_SHIFT	6
+#define MAX77759_CHG_CNFG_04_SPR_7_6_MASK	(0x3 << 6)
+#define MAX77759_CHG_CNFG_04_SPR_7_6_CLEAR	(~(0x3 << 6))
+#define MAX77759_CHG_CNFG_04_CHG_CV_PRM_SHIFT	0
+#define MAX77759_CHG_CNFG_04_CHG_CV_PRM_MASK	(0x3f << 0)
+#define MAX77759_CHG_CNFG_04_CHG_CV_PRM_CLEAR	(~(0x3f << 0))
+
+MAX77759_BFF(chg_cnfg_04_spr_7_6,7,6)
+MAX77759_BFF(chg_cnfg_04_chg_cv_prm,5,0)
+static inline const char *
+max77759_chg_cnfg_04_cstr(char *buff, size_t len, int val)
+{
+#ifdef SCNPRINTF
+	int i = 0;
+
+	i += SCNPRINTF(&buff[i], len - i, " SPR_7_6=%x",
+		FIELD2VALUE(MAX77759_CHG_CNFG_04_SPR_7_6, val));
+	i += SCNPRINTF(&buff[i], len - i, " CHG_CV_PRM=%x",
+		FIELD2VALUE(MAX77759_CHG_CNFG_04_CHG_CV_PRM, val));
+#else
+	buff[0] = 0;
+#endif
+	return buff;
+}
+
+/*
+ * CHG_CNFG_05,0xBE,0b00110110,0x36
+ * UNO_ILIM[3:0],,,,OTG_ILIM[3:0],,
+ */
+#define MAX77759_CHG_CNFG_05	0xBE
+
+#define MAX77759_CHG_CNFG_05_UNO_ILIM_SHIFT	4
+#define MAX77759_CHG_CNFG_05_UNO_ILIM_MASK	(0xf << 4)
+#define MAX77759_CHG_CNFG_05_UNO_ILIM_CLEAR	(~(0xf << 4))
+#define MAX77759_CHG_CNFG_05_OTG_ILIM_SHIFT	0
+#define MAX77759_CHG_CNFG_05_OTG_ILIM_MASK	(0xf << 0)
+#define MAX77759_CHG_CNFG_05_OTG_ILIM_CLEAR	(~(0xf << 0))
+
+MAX77759_BFF(chg_cnfg_05_uno_ilim,7,4)
+MAX77759_BFF(chg_cnfg_05_otg_ilim,3,0)
+static inline const char *
+max77759_chg_cnfg_05_cstr(char *buff, size_t len, int val)
+{
+#ifdef SCNPRINTF
+	int i = 0;
+
+	i += SCNPRINTF(&buff[i], len - i, " UNO_ILIM=%x",
+		FIELD2VALUE(MAX77759_CHG_CNFG_05_UNO_ILIM, val));
+	i += SCNPRINTF(&buff[i], len - i, " OTG_ILIM=%x",
+		FIELD2VALUE(MAX77759_CHG_CNFG_05_OTG_ILIM, val));
+#else
+	buff[0] = 0;
+#endif
+	return buff;
+}
+
+/*
+ * CHG_CNFG_06,0xBF,0b00000000,0x00
+ * SPR_7_4[3:0],,,,CHGPROT[1:0],,SPR_1_0[1:0]
+ */
+#define MAX77759_CHG_CNFG_06	0xBF
+
+#define MAX77759_CHG_CNFG_06_SPR_7_4_SHIFT	4
+#define MAX77759_CHG_CNFG_06_SPR_7_4_MASK	(0xf << 4)
+#define MAX77759_CHG_CNFG_06_SPR_7_4_CLEAR	(~(0xf << 4))
+#define MAX77759_CHG_CNFG_06_CHGPROT_SHIFT	2
+#define MAX77759_CHG_CNFG_06_CHGPROT_MASK	(0x3 << 2)
+#define MAX77759_CHG_CNFG_06_CHGPROT_CLEAR	(~(0x3 << 2))
+#define MAX77759_CHG_CNFG_06_SPR_1_0_SHIFT	0
+#define MAX77759_CHG_CNFG_06_SPR_1_0_MASK	(0x3 << 0)
+#define MAX77759_CHG_CNFG_06_SPR_1_0_CLEAR	(~(0x3 << 0))
+
+MAX77759_BFF(chg_cnfg_06_spr_7_4,7,4)
+MAX77759_BFF(chg_cnfg_06_chgprot,3,2)
+MAX77759_BFF(chg_cnfg_06_spr_1_0,1,0)
+static inline const char *
+max77759_chg_cnfg_06_cstr(char *buff, size_t len, int val)
+{
+#ifdef SCNPRINTF
+	int i = 0;
+
+	i += SCNPRINTF(&buff[i], len - i, " SPR_7_4=%x",
+		FIELD2VALUE(MAX77759_CHG_CNFG_06_SPR_7_4, val));
+	i += SCNPRINTF(&buff[i], len - i, " CHGPROT=%x",
+		FIELD2VALUE(MAX77759_CHG_CNFG_06_CHGPROT, val));
+	i += SCNPRINTF(&buff[i], len - i, " SPR_1_0=%x",
+		FIELD2VALUE(MAX77759_CHG_CNFG_06_SPR_1_0, val));
+#else
+	buff[0] = 0;
+#endif
+	return buff;
+}
+
+/*
+ * CHG_CNFG_07,0xC0,0b00110000,0x30
+ * WD_QBATOFF,REGTEMP[3:0],,,,SPR_2,FGSRC
+ */
+#define MAX77759_CHG_CNFG_07	0xC0
+#define MAX77759_CHG_CNFG_07_WD_QBATOFF	(0x1 << 7)
+#define MAX77759_CHG_CNFG_07_SPR_2	(0x1 << 2)
+#define MAX77759_CHG_CNFG_07_FGSRC	(0x1 << 1)
+#define MAX77759_CHG_CNFG_07_FSHIP_MODE	(0x1 << 0)
+
+#define MAX77759_CHG_CNFG_07_WD_QBATOFF_SHIFT	7
+#define MAX77759_CHG_CNFG_07_WD_QBATOFF_MASK	(0x1 << 7)
+#define MAX77759_CHG_CNFG_07_WD_QBATOFF_CLEAR	(~(0x1 << 7))
+#define MAX77759_CHG_CNFG_07_REGTEMP_SHIFT	3
+#define MAX77759_CHG_CNFG_07_REGTEMP_MASK	(0xf << 3)
+#define MAX77759_CHG_CNFG_07_REGTEMP_CLEAR	(~(0xf << 3))
+#define MAX77759_CHG_CNFG_07_SPR_2_SHIFT	2
+#define MAX77759_CHG_CNFG_07_SPR_2_MASK	(0x1 << 2)
+#define MAX77759_CHG_CNFG_07_SPR_2_CLEAR	(~(0x1 << 2))
+#define MAX77759_CHG_CNFG_07_FGSRC_SHIFT	1
+#define MAX77759_CHG_CNFG_07_FGSRC_MASK	(0x1 << 1)
+#define MAX77759_CHG_CNFG_07_FGSRC_CLEAR	(~(0x1 << 1))
+#define MAX77759_CHG_CNFG_07_FSHIP_MODE_SHIFT	0
+#define MAX77759_CHG_CNFG_07_FSHIP_MODE_MASK	(0x1 << 0)
+#define MAX77759_CHG_CNFG_07_FSHIP_MODE_CLEAR	(~(0x1 << 0))
+
+MAX77759_BFF(chg_cnfg_07_wd_qbatoff,7,7)
+MAX77759_BFF(chg_cnfg_07_regtemp,6,3)
+MAX77759_BFF(chg_cnfg_07_spr_2,2,2)
+MAX77759_BFF(chg_cnfg_07_fgsrc,1,1)
+MAX77759_BFF(chg_cnfg_07_fship_mode,0,0)
+static inline const char *
+max77759_chg_cnfg_07_cstr(char *buff, size_t len, int val)
+{
+#ifdef SCNPRINTF
+	int i = 0;
+
+	i += SCNPRINTF(&buff[i], len - i, " WD_QBATOFF=%x",
+		FIELD2VALUE(MAX77759_CHG_CNFG_07_WD_QBATOFF, val));
+	i += SCNPRINTF(&buff[i], len - i, " REGTEMP=%x",
+		FIELD2VALUE(MAX77759_CHG_CNFG_07_REGTEMP, val));
+	i += SCNPRINTF(&buff[i], len - i, " SPR_2=%x",
+		FIELD2VALUE(MAX77759_CHG_CNFG_07_SPR_2, val));
+	i += SCNPRINTF(&buff[i], len - i, " FGSRC=%x",
+		FIELD2VALUE(MAX77759_CHG_CNFG_07_FGSRC, val));
+	i += SCNPRINTF(&buff[i], len - i, " FSHIP_MODE=%x",
+		FIELD2VALUE(MAX77759_CHG_CNFG_07_FSHIP_MODE, val));
+#else
+	buff[0] = 0;
+#endif
+	return buff;
+}
+
+/*
+ * CHG_CNFG_08,0xC1,0b00000101,0x05
+ * SPR_7,VCHGCV_WARM,ICHGCC_WARM,VCHGCV_COOL,ICHGCC_COOL,JEITA_EN,FSW[1:0]
+ */
+#define MAX77759_CHG_CNFG_08	0xC1
+#define MAX77759_CHG_CNFG_08_SPR_7	(0x1 << 7)
+#define MAX77759_CHG_CNFG_08_VCHGCV_WARM	(0x1 << 6)
+#define MAX77759_CHG_CNFG_08_ICHGCC_WARM	(0x1 << 5)
+#define MAX77759_CHG_CNFG_08_VCHGCV_COOL	(0x1 << 4)
+#define MAX77759_CHG_CNFG_08_ICHGCC_COOL	(0x1 << 3)
+#define MAX77759_CHG_CNFG_08_JEITA_EN	(0x1 << 2)
+
+#define MAX77759_CHG_CNFG_08_SPR_7_SHIFT	7
+#define MAX77759_CHG_CNFG_08_SPR_7_MASK	(0x1 << 7)
+#define MAX77759_CHG_CNFG_08_SPR_7_CLEAR	(~(0x1 << 7))
+#define MAX77759_CHG_CNFG_08_VCHGCV_WARM_SHIFT	6
+#define MAX77759_CHG_CNFG_08_VCHGCV_WARM_MASK	(0x1 << 6)
+#define MAX77759_CHG_CNFG_08_VCHGCV_WARM_CLEAR	(~(0x1 << 6))
+#define MAX77759_CHG_CNFG_08_ICHGCC_WARM_SHIFT	5
+#define MAX77759_CHG_CNFG_08_ICHGCC_WARM_MASK	(0x1 << 5)
+#define MAX77759_CHG_CNFG_08_ICHGCC_WARM_CLEAR	(~(0x1 << 5))
+#define MAX77759_CHG_CNFG_08_VCHGCV_COOL_SHIFT	4
+#define MAX77759_CHG_CNFG_08_VCHGCV_COOL_MASK	(0x1 << 4)
+#define MAX77759_CHG_CNFG_08_VCHGCV_COOL_CLEAR	(~(0x1 << 4))
+#define MAX77759_CHG_CNFG_08_ICHGCC_COOL_SHIFT	3
+#define MAX77759_CHG_CNFG_08_ICHGCC_COOL_MASK	(0x1 << 3)
+#define MAX77759_CHG_CNFG_08_ICHGCC_COOL_CLEAR	(~(0x1 << 3))
+#define MAX77759_CHG_CNFG_08_JEITA_EN_SHIFT	2
+#define MAX77759_CHG_CNFG_08_JEITA_EN_MASK	(0x1 << 2)
+#define MAX77759_CHG_CNFG_08_JEITA_EN_CLEAR	(~(0x1 << 2))
+#define MAX77759_CHG_CNFG_08_FSW_SHIFT	0
+#define MAX77759_CHG_CNFG_08_FSW_MASK	(0x3 << 0)
+#define MAX77759_CHG_CNFG_08_FSW_CLEAR	(~(0x3 << 0))
+
+MAX77759_BFF(chg_cnfg_08_spr_7,7,7)
+MAX77759_BFF(chg_cnfg_08_vchgcv_warm,6,6)
+MAX77759_BFF(chg_cnfg_08_ichgcc_warm,5,5)
+MAX77759_BFF(chg_cnfg_08_vchgcv_cool,4,4)
+MAX77759_BFF(chg_cnfg_08_ichgcc_cool,3,3)
+MAX77759_BFF(chg_cnfg_08_jeita_en,2,2)
+MAX77759_BFF(chg_cnfg_08_fsw,1,0)
+static inline const char *
+max77759_chg_cnfg_08_cstr(char *buff, size_t len, int val)
+{
+#ifdef SCNPRINTF
+	int i = 0;
+
+	i += SCNPRINTF(&buff[i], len - i, " SPR_7=%x",
+		FIELD2VALUE(MAX77759_CHG_CNFG_08_SPR_7, val));
+	i += SCNPRINTF(&buff[i], len - i, " VCHGCV_WARM=%x",
+		FIELD2VALUE(MAX77759_CHG_CNFG_08_VCHGCV_WARM, val));
+	i += SCNPRINTF(&buff[i], len - i, " ICHGCC_WARM=%x",
+		FIELD2VALUE(MAX77759_CHG_CNFG_08_ICHGCC_WARM, val));
+	i += SCNPRINTF(&buff[i], len - i, " VCHGCV_COOL=%x",
+		FIELD2VALUE(MAX77759_CHG_CNFG_08_VCHGCV_COOL, val));
+	i += SCNPRINTF(&buff[i], len - i, " ICHGCC_COOL=%x",
+		FIELD2VALUE(MAX77759_CHG_CNFG_08_ICHGCC_COOL, val));
+	i += SCNPRINTF(&buff[i], len - i, " JEITA_EN=%x",
+		FIELD2VALUE(MAX77759_CHG_CNFG_08_JEITA_EN, val));
+	i += SCNPRINTF(&buff[i], len - i, " FSW=%x",
+		FIELD2VALUE(MAX77759_CHG_CNFG_08_FSW, val));
+#else
+	buff[0] = 0;
+#endif
+	return buff;
+}
+
+/*
+ * CHG_CNFG_09,0xC2,0b00010011,0x13
+ * NO_AUTOIBUS,CHGIN_ILIM[6:0],,,,,
+ */
+#define MAX77759_CHG_CNFG_09	0xC2
+#define MAX77759_CHG_CNFG_09_NO_AUTOIBUS	(0x1 << 7)
+
+#define MAX77759_CHG_CNFG_09_NO_AUTOIBUS_SHIFT	7
+#define MAX77759_CHG_CNFG_09_NO_AUTOIBUS_MASK	(0x1 << 7)
+#define MAX77759_CHG_CNFG_09_NO_AUTOIBUS_CLEAR	(~(0x1 << 7))
+#define MAX77759_CHG_CNFG_09_CHGIN_ILIM_SHIFT	0
+#define MAX77759_CHG_CNFG_09_CHGIN_ILIM_MASK	(0x7f << 0)
+#define MAX77759_CHG_CNFG_09_CHGIN_ILIM_CLEAR	(~(0x7f << 0))
+
+MAX77759_BFF(chg_cnfg_09_no_autoibus,7,7)
+MAX77759_BFF(chg_cnfg_09_chgin_ilim,6,0)
+static inline const char *
+max77759_chg_cnfg_09_cstr(char *buff, size_t len, int val)
+{
+#ifdef SCNPRINTF
+	int i = 0;
+
+	i += SCNPRINTF(&buff[i], len - i, " NO_AUTOIBUS=%x",
+		FIELD2VALUE(MAX77759_CHG_CNFG_09_NO_AUTOIBUS, val));
+	i += SCNPRINTF(&buff[i], len - i, " CHGIN_ILIM=%x",
+		FIELD2VALUE(MAX77759_CHG_CNFG_09_CHGIN_ILIM, val));
+#else
+	buff[0] = 0;
+#endif
+	return buff;
+}
+
+/*
+ * CHG_CNFG_10,0xC3,0b00001111,0x0f
+ * SPR_7_6[1:0],,WCIN_ILIM[5:0],,,,
+ */
+#define MAX77759_CHG_CNFG_10	0xC3
+
+#define MAX77759_CHG_CNFG_10_SPR_7_6_SHIFT	6
+#define MAX77759_CHG_CNFG_10_SPR_7_6_MASK	(0x3 << 6)
+#define MAX77759_CHG_CNFG_10_SPR_7_6_CLEAR	(~(0x3 << 6))
+#define MAX77759_CHG_CNFG_10_WCIN_ILIM_SHIFT	0
+#define MAX77759_CHG_CNFG_10_WCIN_ILIM_MASK	(0x3f << 0)
+#define MAX77759_CHG_CNFG_10_WCIN_ILIM_CLEAR	(~(0x3f << 0))
+
+MAX77759_BFF(chg_cnfg_10_spr_7_6,7,6)
+MAX77759_BFF(chg_cnfg_10_wcin_ilim,5,0)
+static inline const char *
+max77759_chg_cnfg_10_cstr(char *buff, size_t len, int val)
+{
+#ifdef SCNPRINTF
+	int i = 0;
+
+	i += SCNPRINTF(&buff[i], len - i, " SPR_7_6=%x",
+		FIELD2VALUE(MAX77759_CHG_CNFG_10_SPR_7_6, val));
+	i += SCNPRINTF(&buff[i], len - i, " WCIN_ILIM=%x",
+		FIELD2VALUE(MAX77759_CHG_CNFG_10_WCIN_ILIM, val));
+#else
+	buff[0] = 0;
+#endif
+	return buff;
+}
+
+/*
+ * CHG_CNFG_11,0xC4,0b00000000,0x00
+ * VBYPSET[7:0],,,,,,
+ */
+#define MAX77759_CHG_CNFG_11	0xC4
+
+/*
+ * CHG_CNFG_12,0xC5,0b01101010,0x6a
+ * CHG_EN,WCINSEL,CHGINSEL,VCHGIN_REG[1:0],,WCIN_REG[1:0],
+ */
+#define MAX77759_CHG_CNFG_12	0xC5
+#define MAX77759_CHG_CNFG_12_CHG_EN	(0x1 << 7)
+#define MAX77759_CHG_CNFG_12_WCINSEL	(0x1 << 6)
+#define MAX77759_CHG_CNFG_12_CHGINSEL	(0x1 << 5)
+#define MAX77759_CHG_CNFG_12_DISKIP	(0x1 << 0)
+
+#define MAX77759_CHG_CNFG_12_CHG_EN_SHIFT	7
+#define MAX77759_CHG_CNFG_12_CHG_EN_MASK	(0x1 << 7)
+#define MAX77759_CHG_CNFG_12_CHG_EN_CLEAR	(~(0x1 << 7))
+#define MAX77759_CHG_CNFG_12_WCINSEL_SHIFT	6
+#define MAX77759_CHG_CNFG_12_WCINSEL_MASK	(0x1 << 6)
+#define MAX77759_CHG_CNFG_12_WCINSEL_CLEAR	(~(0x1 << 6))
+#define MAX77759_CHG_CNFG_12_CHGINSEL_SHIFT	5
+#define MAX77759_CHG_CNFG_12_CHGINSEL_MASK	(0x1 << 5)
+#define MAX77759_CHG_CNFG_12_CHGINSEL_CLEAR	(~(0x1 << 5))
+#define MAX77759_CHG_CNFG_12_VCHGIN_REG_SHIFT	3
+#define MAX77759_CHG_CNFG_12_VCHGIN_REG_MASK	(0x3 << 3)
+#define MAX77759_CHG_CNFG_12_VCHGIN_REG_CLEAR	(~(0x3 << 3))
+#define MAX77759_CHG_CNFG_12_WCIN_REG_SHIFT	1
+#define MAX77759_CHG_CNFG_12_WCIN_REG_MASK	(0x3 << 1)
+#define MAX77759_CHG_CNFG_12_WCIN_REG_CLEAR	(~(0x3 << 1))
+#define MAX77759_CHG_CNFG_12_DISKIP_SHIFT	0
+#define MAX77759_CHG_CNFG_12_DISKIP_MASK	(0x1 << 0)
+#define MAX77759_CHG_CNFG_12_DISKIP_CLEAR	(~(0x1 << 0))
+
+MAX77759_BFF(chg_cnfg_12_chg_en,7,7)
+MAX77759_BFF(chg_cnfg_12_wcinsel,6,6)
+MAX77759_BFF(chg_cnfg_12_chginsel,5,5)
+MAX77759_BFF(chg_cnfg_12_vchgin_reg,4,3)
+MAX77759_BFF(chg_cnfg_12_wcin_reg,2,1)
+MAX77759_BFF(chg_cnfg_12_diskip,0,0)
+static inline const char *
+max77759_chg_cnfg_12_cstr(char *buff, size_t len, int val)
+{
+#ifdef SCNPRINTF
+	int i = 0;
+
+	i += SCNPRINTF(&buff[i], len - i, " CHG_EN=%x",
+		FIELD2VALUE(MAX77759_CHG_CNFG_12_CHG_EN, val));
+	i += SCNPRINTF(&buff[i], len - i, " WCINSEL=%x",
+		FIELD2VALUE(MAX77759_CHG_CNFG_12_WCINSEL, val));
+	i += SCNPRINTF(&buff[i], len - i, " CHGINSEL=%x",
+		FIELD2VALUE(MAX77759_CHG_CNFG_12_CHGINSEL, val));
+	i += SCNPRINTF(&buff[i], len - i, " VCHGIN_REG=%x",
+		FIELD2VALUE(MAX77759_CHG_CNFG_12_VCHGIN_REG, val));
+	i += SCNPRINTF(&buff[i], len - i, " WCIN_REG=%x",
+		FIELD2VALUE(MAX77759_CHG_CNFG_12_WCIN_REG, val));
+	i += SCNPRINTF(&buff[i], len - i, " DISKIP=%x",
+		FIELD2VALUE(MAX77759_CHG_CNFG_12_DISKIP, val));
+#else
+	buff[0] = 0;
+#endif
+	return buff;
+}
+
+/*
+ * CHG_CNFG_13,0xC6,0b00000011,0x03
+ * EN_FG_ILIM_CTRL,THM_CHR_RSTART,THM_CC_HZ,THM_BUCK_DIS,THM2_HW_CTRL,USB_TEMP[2:0],
+ */
+#define MAX77759_CHG_CNFG_13	0xC6
+#define MAX77759_CHG_CNFG_13_EN_FG_ILIM_CTRL	(0x1 << 7)
+#define MAX77759_CHG_CNFG_13_THM_CHR_RSTART	(0x1 << 6)
+#define MAX77759_CHG_CNFG_13_THM_CC_HZ	(0x1 << 5)
+#define MAX77759_CHG_CNFG_13_THM_BUCK_DIS	(0x1 << 4)
+#define MAX77759_CHG_CNFG_13_THM2_HW_CTRL	(0x1 << 3)
+
+#define MAX77759_CHG_CNFG_13_EN_FG_ILIM_CTRL_SHIFT	7
+#define MAX77759_CHG_CNFG_13_EN_FG_ILIM_CTRL_MASK	(0x1 << 7)
+#define MAX77759_CHG_CNFG_13_EN_FG_ILIM_CTRL_CLEAR	(~(0x1 << 7))
+#define MAX77759_CHG_CNFG_13_THM_CHR_RSTART_SHIFT	6
+#define MAX77759_CHG_CNFG_13_THM_CHR_RSTART_MASK	(0x1 << 6)
+#define MAX77759_CHG_CNFG_13_THM_CHR_RSTART_CLEAR	(~(0x1 << 6))
+#define MAX77759_CHG_CNFG_13_THM_CC_HZ_SHIFT	5
+#define MAX77759_CHG_CNFG_13_THM_CC_HZ_MASK	(0x1 << 5)
+#define MAX77759_CHG_CNFG_13_THM_CC_HZ_CLEAR	(~(0x1 << 5))
+#define MAX77759_CHG_CNFG_13_THM_BUCK_DIS_SHIFT	4
+#define MAX77759_CHG_CNFG_13_THM_BUCK_DIS_MASK	(0x1 << 4)
+#define MAX77759_CHG_CNFG_13_THM_BUCK_DIS_CLEAR	(~(0x1 << 4))
+#define MAX77759_CHG_CNFG_13_THM2_HW_CTRL_SHIFT	3
+#define MAX77759_CHG_CNFG_13_THM2_HW_CTRL_MASK	(0x1 << 3)
+#define MAX77759_CHG_CNFG_13_THM2_HW_CTRL_CLEAR	(~(0x1 << 3))
+#define MAX77759_CHG_CNFG_13_USB_TEMP_SHIFT	0
+#define MAX77759_CHG_CNFG_13_USB_TEMP_MASK	(0x7 << 0)
+#define MAX77759_CHG_CNFG_13_USB_TEMP_CLEAR	(~(0x7 << 0))
+
+MAX77759_BFF(chg_cnfg_13_en_fg_ilim_ctrl,7,7)
+MAX77759_BFF(chg_cnfg_13_thm_chr_rstart,6,6)
+MAX77759_BFF(chg_cnfg_13_thm_cc_hz,5,5)
+MAX77759_BFF(chg_cnfg_13_thm_buck_dis,4,4)
+MAX77759_BFF(chg_cnfg_13_thm2_hw_ctrl,3,3)
+MAX77759_BFF(chg_cnfg_13_usb_temp,2,0)
+static inline const char *
+max77759_chg_cnfg_13_cstr(char *buff, size_t len, int val)
+{
+#ifdef SCNPRINTF
+	int i = 0;
+
+	i += SCNPRINTF(&buff[i], len - i, " EN_FG_ILIM_CTRL=%x",
+		FIELD2VALUE(MAX77759_CHG_CNFG_13_EN_FG_ILIM_CTRL, val));
+	i += SCNPRINTF(&buff[i], len - i, " THM_CHR_RSTART=%x",
+		FIELD2VALUE(MAX77759_CHG_CNFG_13_THM_CHR_RSTART, val));
+	i += SCNPRINTF(&buff[i], len - i, " THM_CC_HZ=%x",
+		FIELD2VALUE(MAX77759_CHG_CNFG_13_THM_CC_HZ, val));
+	i += SCNPRINTF(&buff[i], len - i, " THM_BUCK_DIS=%x",
+		FIELD2VALUE(MAX77759_CHG_CNFG_13_THM_BUCK_DIS, val));
+	i += SCNPRINTF(&buff[i], len - i, " THM2_HW_CTRL=%x",
+		FIELD2VALUE(MAX77759_CHG_CNFG_13_THM2_HW_CTRL, val));
+	i += SCNPRINTF(&buff[i], len - i, " USB_TEMP=%x",
+		FIELD2VALUE(MAX77759_CHG_CNFG_13_USB_TEMP, val));
+#else
+	buff[0] = 0;
+#endif
+	return buff;
+}
+
+/*
+ * CHG_CNFG_14,0xC7,0b00000110,0x06
+ * BAT_OILO_REL[1:0],,BAT_OPEN_TO[1:0],,BAT_OILO[3:0],,
+ */
+#define MAX77759_CHG_CNFG_14	0xC7
+
+#define MAX77759_CHG_CNFG_14_BAT_OILO_REL_SHIFT	6
+#define MAX77759_CHG_CNFG_14_BAT_OILO_REL_MASK	(0x3 << 6)
+#define MAX77759_CHG_CNFG_14_BAT_OILO_REL_CLEAR	(~(0x3 << 6))
+#define MAX77759_CHG_CNFG_14_BAT_OPEN_TO_SHIFT	4
+#define MAX77759_CHG_CNFG_14_BAT_OPEN_TO_MASK	(0x3 << 4)
+#define MAX77759_CHG_CNFG_14_BAT_OPEN_TO_CLEAR	(~(0x3 << 4))
+#define MAX77759_CHG_CNFG_14_BAT_OILO_SHIFT	0
+#define MAX77759_CHG_CNFG_14_BAT_OILO_MASK	(0xf << 0)
+#define MAX77759_CHG_CNFG_14_BAT_OILO_CLEAR	(~(0xf << 0))
+
+MAX77759_BFF(chg_cnfg_14_bat_oilo_rel,7,6)
+MAX77759_BFF(chg_cnfg_14_bat_open_to,5,4)
+MAX77759_BFF(chg_cnfg_14_bat_oilo,3,0)
+static inline const char *
+max77759_chg_cnfg_14_cstr(char *buff, size_t len, int val)
+{
+#ifdef SCNPRINTF
+	int i = 0;
+
+	i += SCNPRINTF(&buff[i], len - i, " BAT_OILO_REL=%x",
+		FIELD2VALUE(MAX77759_CHG_CNFG_14_BAT_OILO_REL, val));
+	i += SCNPRINTF(&buff[i], len - i, " BAT_OPEN_TO=%x",
+		FIELD2VALUE(MAX77759_CHG_CNFG_14_BAT_OPEN_TO, val));
+	i += SCNPRINTF(&buff[i], len - i, " BAT_OILO=%x",
+		FIELD2VALUE(MAX77759_CHG_CNFG_14_BAT_OILO, val));
+#else
+	buff[0] = 0;
+#endif
+	return buff;
+}
+
+/*
+ * CHG_CNFG_15,0xC8,0b00001000,0x08
+ * SYS_UVLO1_REL[1:0],,SYS_UVLO1_HYST[1:0],,SYS_UVLO1[3:0],,
+ */
+#define MAX77759_CHG_CNFG_15	0xC8
+
+#define MAX77759_CHG_CNFG_15_SYS_UVLO1_REL_SHIFT	6
+#define MAX77759_CHG_CNFG_15_SYS_UVLO1_REL_MASK	(0x3 << 6)
+#define MAX77759_CHG_CNFG_15_SYS_UVLO1_REL_CLEAR	(~(0x3 << 6))
+#define MAX77759_CHG_CNFG_15_SYS_UVLO1_HYST_SHIFT	4
+#define MAX77759_CHG_CNFG_15_SYS_UVLO1_HYST_MASK	(0x3 << 4)
+#define MAX77759_CHG_CNFG_15_SYS_UVLO1_HYST_CLEAR	(~(0x3 << 4))
+#define MAX77759_CHG_CNFG_15_SYS_UVLO1_SHIFT	0
+#define MAX77759_CHG_CNFG_15_SYS_UVLO1_MASK	(0xf << 0)
+#define MAX77759_CHG_CNFG_15_SYS_UVLO1_CLEAR	(~(0xf << 0))
+
+MAX77759_BFF(chg_cnfg_15_sys_uvlo1_rel,7,6)
+MAX77759_BFF(chg_cnfg_15_sys_uvlo1_hyst,5,4)
+MAX77759_BFF(chg_cnfg_15_sys_uvlo1,3,0)
+static inline const char *
+max77759_chg_cnfg_15_cstr(char *buff, size_t len, int val)
+{
+#ifdef SCNPRINTF
+	int i = 0;
+
+	i += SCNPRINTF(&buff[i], len - i, " SYS_UVLO1_REL=%x",
+		FIELD2VALUE(MAX77759_CHG_CNFG_15_SYS_UVLO1_REL, val));
+	i += SCNPRINTF(&buff[i], len - i, " SYS_UVLO1_HYST=%x",
+		FIELD2VALUE(MAX77759_CHG_CNFG_15_SYS_UVLO1_HYST, val));
+	i += SCNPRINTF(&buff[i], len - i, " SYS_UVLO1=%x",
+		FIELD2VALUE(MAX77759_CHG_CNFG_15_SYS_UVLO1, val));
+#else
+	buff[0] = 0;
+#endif
+	return buff;
+}
+
+/*
+ * CHG_CNFG_16,0xC9,0b00000100,0x04
+ * SYS_UVLO2_REL[1:0],,SYS_UVLO2_HYST[1:0],,SYS_UVLO2[3:0],,
+ */
+#define MAX77759_CHG_CNFG_16	0xC9
+
+#define MAX77759_CHG_CNFG_16_SYS_UVLO2_REL_SHIFT	6
+#define MAX77759_CHG_CNFG_16_SYS_UVLO2_REL_MASK	(0x3 << 6)
+#define MAX77759_CHG_CNFG_16_SYS_UVLO2_REL_CLEAR	(~(0x3 << 6))
+#define MAX77759_CHG_CNFG_16_SYS_UVLO2_HYST_SHIFT	4
+#define MAX77759_CHG_CNFG_16_SYS_UVLO2_HYST_MASK	(0x3 << 4)
+#define MAX77759_CHG_CNFG_16_SYS_UVLO2_HYST_CLEAR	(~(0x3 << 4))
+#define MAX77759_CHG_CNFG_16_SYS_UVLO2_SHIFT	0
+#define MAX77759_CHG_CNFG_16_SYS_UVLO2_MASK	(0xf << 0)
+#define MAX77759_CHG_CNFG_16_SYS_UVLO2_CLEAR	(~(0xf << 0))
+
+MAX77759_BFF(chg_cnfg_16_sys_uvlo2_rel,7,6)
+MAX77759_BFF(chg_cnfg_16_sys_uvlo2_hyst,5,4)
+MAX77759_BFF(chg_cnfg_16_sys_uvlo2,3,0)
+static inline const char *
+max77759_chg_cnfg_16_cstr(char *buff, size_t len, int val)
+{
+#ifdef SCNPRINTF
+	int i = 0;
+
+	i += SCNPRINTF(&buff[i], len - i, " SYS_UVLO2_REL=%x",
+		FIELD2VALUE(MAX77759_CHG_CNFG_16_SYS_UVLO2_REL, val));
+	i += SCNPRINTF(&buff[i], len - i, " SYS_UVLO2_HYST=%x",
+		FIELD2VALUE(MAX77759_CHG_CNFG_16_SYS_UVLO2_HYST, val));
+	i += SCNPRINTF(&buff[i], len - i, " SYS_UVLO2=%x",
+		FIELD2VALUE(MAX77759_CHG_CNFG_16_SYS_UVLO2, val));
+#else
+	buff[0] = 0;
+#endif
+	return buff;
+}
+
+/*
+ * CHG_CNFG_17,0xCA,0b01000000,0x40
+ * AICL[1:0],,SPR_5_3[2:0],,,BAT_OILO_DET,SYS_UVLO2_DET
+ */
+#define MAX77759_CHG_CNFG_17	0xCA
+#define MAX77759_CHG_CNFG_17_BAT_OILO_DET	(0x1 << 2)
+#define MAX77759_CHG_CNFG_17_SYS_UVLO2_DET	(0x1 << 1)
+#define MAX77759_CHG_CNFG_17_SYS_UVLO1_DET	(0x1 << 0)
+
+#define MAX77759_CHG_CNFG_17_AICL_SHIFT	6
+#define MAX77759_CHG_CNFG_17_AICL_MASK	(0x3 << 6)
+#define MAX77759_CHG_CNFG_17_AICL_CLEAR	(~(0x3 << 6))
+#define MAX77759_CHG_CNFG_17_SPR_5_3_SHIFT	3
+#define MAX77759_CHG_CNFG_17_SPR_5_3_MASK	(0x7 << 3)
+#define MAX77759_CHG_CNFG_17_SPR_5_3_CLEAR	(~(0x7 << 3))
+#define MAX77759_CHG_CNFG_17_BAT_OILO_DET_SHIFT	2
+#define MAX77759_CHG_CNFG_17_BAT_OILO_DET_MASK	(0x1 << 2)
+#define MAX77759_CHG_CNFG_17_BAT_OILO_DET_CLEAR	(~(0x1 << 2))
+#define MAX77759_CHG_CNFG_17_SYS_UVLO2_DET_SHIFT	1
+#define MAX77759_CHG_CNFG_17_SYS_UVLO2_DET_MASK	(0x1 << 1)
+#define MAX77759_CHG_CNFG_17_SYS_UVLO2_DET_CLEAR	(~(0x1 << 1))
+#define MAX77759_CHG_CNFG_17_SYS_UVLO1_DET_SHIFT	0
+#define MAX77759_CHG_CNFG_17_SYS_UVLO1_DET_MASK	(0x1 << 0)
+#define MAX77759_CHG_CNFG_17_SYS_UVLO1_DET_CLEAR	(~(0x1 << 0))
+
+MAX77759_BFF(chg_cnfg_17_aicl,7,6)
+MAX77759_BFF(chg_cnfg_17_spr_5_3,5,3)
+MAX77759_BFF(chg_cnfg_17_bat_oilo_det,2,2)
+MAX77759_BFF(chg_cnfg_17_sys_uvlo2_det,1,1)
+MAX77759_BFF(chg_cnfg_17_sys_uvlo1_det,0,0)
+static inline const char *
+max77759_chg_cnfg_17_cstr(char *buff, size_t len, int val)
+{
+#ifdef SCNPRINTF
+	int i = 0;
+
+	i += SCNPRINTF(&buff[i], len - i, " AICL=%x",
+		FIELD2VALUE(MAX77759_CHG_CNFG_17_AICL, val));
+	i += SCNPRINTF(&buff[i], len - i, " SPR_5_3=%x",
+		FIELD2VALUE(MAX77759_CHG_CNFG_17_SPR_5_3, val));
+	i += SCNPRINTF(&buff[i], len - i, " BAT_OILO_DET=%x",
+		FIELD2VALUE(MAX77759_CHG_CNFG_17_BAT_OILO_DET, val));
+	i += SCNPRINTF(&buff[i], len - i, " SYS_UVLO2_DET=%x",
+		FIELD2VALUE(MAX77759_CHG_CNFG_17_SYS_UVLO2_DET, val));
+	i += SCNPRINTF(&buff[i], len - i, " SYS_UVLO1_DET=%x",
+		FIELD2VALUE(MAX77759_CHG_CNFG_17_SYS_UVLO1_DET, val));
+#else
+	buff[0] = 0;
+#endif
+	return buff;
+}
+
+/*
+ * CHG_CNFG_18,0xCB,0b11000000,0xc0
+ * VDP1_STP_BST,VDP2_STP_BST,MINVSYS[1:0],,OTG_V_PGM,SPSN_DET_EN,MASTER_DC
+ */
+#define MAX77759_CHG_CNFG_18	0xCB
+#define MAX77759_CHG_CNFG_18_VDP1_STP_BST	(0x1 << 7)
+#define MAX77759_CHG_CNFG_18_VDP2_STP_BST	(0x1 << 6)
+#define MAX77759_CHG_CNFG_18_OTG_V_PGM	(0x1 << 3)
+#define MAX77759_CHG_CNFG_18_SPSN_DET_EN	(0x1 << 2)
+#define MAX77759_CHG_CNFG_18_MASTER_DC	(0x1 << 1)
+#define MAX77759_CHG_CNFG_18_WDTEN	(0x1 << 0)
+
+#define MAX77759_CHG_CNFG_18_VDP1_STP_BST_SHIFT	7
+#define MAX77759_CHG_CNFG_18_VDP1_STP_BST_MASK	(0x1 << 7)
+#define MAX77759_CHG_CNFG_18_VDP1_STP_BST_CLEAR	(~(0x1 << 7))
+#define MAX77759_CHG_CNFG_18_VDP2_STP_BST_SHIFT	6
+#define MAX77759_CHG_CNFG_18_VDP2_STP_BST_MASK	(0x1 << 6)
+#define MAX77759_CHG_CNFG_18_VDP2_STP_BST_CLEAR	(~(0x1 << 6))
+#define MAX77759_CHG_CNFG_18_MINVSYS_SHIFT	4
+#define MAX77759_CHG_CNFG_18_MINVSYS_MASK	(0x3 << 4)
+#define MAX77759_CHG_CNFG_18_MINVSYS_CLEAR	(~(0x3 << 4))
+#define MAX77759_CHG_CNFG_18_OTG_V_PGM_SHIFT	3
+#define MAX77759_CHG_CNFG_18_OTG_V_PGM_MASK	(0x1 << 3)
+#define MAX77759_CHG_CNFG_18_OTG_V_PGM_CLEAR	(~(0x1 << 3))
+#define MAX77759_CHG_CNFG_18_SPSN_DET_EN_SHIFT	2
+#define MAX77759_CHG_CNFG_18_SPSN_DET_EN_MASK	(0x1 << 2)
+#define MAX77759_CHG_CNFG_18_SPSN_DET_EN_CLEAR	(~(0x1 << 2))
+#define MAX77759_CHG_CNFG_18_MASTER_DC_SHIFT	1
+#define MAX77759_CHG_CNFG_18_MASTER_DC_MASK	(0x1 << 1)
+#define MAX77759_CHG_CNFG_18_MASTER_DC_CLEAR	(~(0x1 << 1))
+#define MAX77759_CHG_CNFG_18_WDTEN_SHIFT	0
+#define MAX77759_CHG_CNFG_18_WDTEN_MASK	(0x1 << 0)
+#define MAX77759_CHG_CNFG_18_WDTEN_CLEAR	(~(0x1 << 0))
+
+MAX77759_BFF(chg_cnfg_18_vdp1_stp_bst,7,7)
+MAX77759_BFF(chg_cnfg_18_vdp2_stp_bst,6,6)
+MAX77759_BFF(chg_cnfg_18_minvsys,5,4)
+MAX77759_BFF(chg_cnfg_18_otg_v_pgm,3,3)
+MAX77759_BFF(chg_cnfg_18_spsn_det_en,2,2)
+MAX77759_BFF(chg_cnfg_18_master_dc,1,1)
+MAX77759_BFF(chg_cnfg_18_wdten,0,0)
+static inline const char *
+max77759_chg_cnfg_18_cstr(char *buff, size_t len, int val)
+{
+#ifdef SCNPRINTF
+	int i = 0;
+
+	i += SCNPRINTF(&buff[i], len - i, " VDP1_STP_BST=%x",
+		FIELD2VALUE(MAX77759_CHG_CNFG_18_VDP1_STP_BST, val));
+	i += SCNPRINTF(&buff[i], len - i, " VDP2_STP_BST=%x",
+		FIELD2VALUE(MAX77759_CHG_CNFG_18_VDP2_STP_BST, val));
+	i += SCNPRINTF(&buff[i], len - i, " MINVSYS=%x",
+		FIELD2VALUE(MAX77759_CHG_CNFG_18_MINVSYS, val));
+	i += SCNPRINTF(&buff[i], len - i, " OTG_V_PGM=%x",
+		FIELD2VALUE(MAX77759_CHG_CNFG_18_OTG_V_PGM, val));
+	i += SCNPRINTF(&buff[i], len - i, " SPSN_DET_EN=%x",
+		FIELD2VALUE(MAX77759_CHG_CNFG_18_SPSN_DET_EN, val));
+	i += SCNPRINTF(&buff[i], len - i, " MASTER_DC=%x",
+		FIELD2VALUE(MAX77759_CHG_CNFG_18_MASTER_DC, val));
+	i += SCNPRINTF(&buff[i], len - i, " WDTEN=%x",
+		FIELD2VALUE(MAX77759_CHG_CNFG_18_WDTEN, val));
+#else
+	buff[0] = 0;
+#endif
+	return buff;
+}
+
+/*
+ * CHG_CNFG_19,0xCC,0b00010000,0x10
+ * SPR_7_5[2:0],,,INLIM_CLK[1:0],,DIS_IR_CTRL,SLOWLX[1:0]
+ */
+#define MAX77759_CHG_CNFG_19	0xCC
+
+/* section:  FuelGauge  */
+#define MAX77759_CHG_CNFG_19_DIS_IR_CTRL	(0x1 << 2)
+
+#define MAX77759_CHG_CNFG_19_SPR_7_5_SHIFT	5
+#define MAX77759_CHG_CNFG_19_SPR_7_5_MASK	(0x7 << 5)
+#define MAX77759_CHG_CNFG_19_SPR_7_5_CLEAR	(~(0x7 << 5))
+#define MAX77759_CHG_CNFG_19_INLIM_CLK_SHIFT	3
+#define MAX77759_CHG_CNFG_19_INLIM_CLK_MASK	(0x3 << 3)
+#define MAX77759_CHG_CNFG_19_INLIM_CLK_CLEAR	(~(0x3 << 3))
+#define MAX77759_CHG_CNFG_19_DIS_IR_CTRL_SHIFT	2
+#define MAX77759_CHG_CNFG_19_DIS_IR_CTRL_MASK	(0x1 << 2)
+#define MAX77759_CHG_CNFG_19_DIS_IR_CTRL_CLEAR	(~(0x1 << 2))
+#define MAX77759_CHG_CNFG_19_SLOWLX_SHIFT	0
+#define MAX77759_CHG_CNFG_19_SLOWLX_MASK	(0x3 << 0)
+#define MAX77759_CHG_CNFG_19_SLOWLX_CLEAR	(~(0x3 << 0))
+
+MAX77759_BFF(chg_cnfg_19_spr_7_5,7,5)
+MAX77759_BFF(chg_cnfg_19_inlim_clk,4,3)
+MAX77759_BFF(chg_cnfg_19_dis_ir_ctrl,2,2)
+MAX77759_BFF(chg_cnfg_19_slowlx,1,0)
+static inline const char *
+max77759_chg_cnfg_19_cstr(char *buff, size_t len, int val)
+{
+#ifdef SCNPRINTF
+	int i = 0;
+
+	i += SCNPRINTF(&buff[i], len - i, " SPR_7_5=%x",
+		FIELD2VALUE(MAX77759_CHG_CNFG_19_SPR_7_5, val));
+	i += SCNPRINTF(&buff[i], len - i, " INLIM_CLK=%x",
+		FIELD2VALUE(MAX77759_CHG_CNFG_19_INLIM_CLK, val));
+	i += SCNPRINTF(&buff[i], len - i, " DIS_IR_CTRL=%x",
+		FIELD2VALUE(MAX77759_CHG_CNFG_19_DIS_IR_CTRL, val));
+	i += SCNPRINTF(&buff[i], len - i, " SLOWLX=%x",
+		FIELD2VALUE(MAX77759_CHG_CNFG_19_SLOWLX, val));
+#else
+	buff[0] = 0;
+#endif
+	return buff;
+}
+
+/*
+ * Status,0x0,0b00000010,0x02
+ * Br,Smx,Tmx,Vmx,Bi,Smn,Tmn
+ */
+#define MAX77759_FG_STATUS	0x0
+#define MAX77759_FG_STATUS_BR	(0x1 << 15)
+#define MAX77759_FG_STATUS_SMX	(0x1 << 14)
+#define MAX77759_FG_STATUS_TMX	(0x1 << 13)
+#define MAX77759_FG_STATUS_VMX	(0x1 << 12)
+#define MAX77759_FG_STATUS_BI	(0x1 << 11)
+#define MAX77759_FG_STATUS_SMN	(0x1 << 10)
+#define MAX77759_FG_STATUS_TMN	(0x1 << 9)
+#define MAX77759_FG_STATUS_VMN	(0x1 << 8)
+#define MAX77759_FG_STATUS_DSOCI	(0x1 << 7)
+#define MAX77759_FG_STATUS_THMHOT	(0x1 << 6)
+#define MAX77759_FG_STATUS_SPR_5	(0x1 << 5)
+#define MAX77759_FG_STATUS_ISYSMX	(0x1 << 4)
+#define MAX77759_FG_STATUS_BST	(0x1 << 3)
+#define MAX77759_FG_STATUS_SPR_2	(0x1 << 2)
+#define MAX77759_FG_STATUS_POR	(0x1 << 1)
+#define MAX77759_FG_STATUS_IMN	(0x1 << 0)
+
+#define MAX77759_FG_STATUS_BR_SHIFT	15
+#define MAX77759_FG_STATUS_BR_MASK	(0x1 << 15)
+#define MAX77759_FG_STATUS_BR_CLEAR	(~(0x1 << 15))
+#define MAX77759_FG_STATUS_SMX_SHIFT	14
+#define MAX77759_FG_STATUS_SMX_MASK	(0x1 << 14)
+#define MAX77759_FG_STATUS_SMX_CLEAR	(~(0x1 << 14))
+#define MAX77759_FG_STATUS_TMX_SHIFT	13
+#define MAX77759_FG_STATUS_TMX_MASK	(0x1 << 13)
+#define MAX77759_FG_STATUS_TMX_CLEAR	(~(0x1 << 13))
+#define MAX77759_FG_STATUS_VMX_SHIFT	12
+#define MAX77759_FG_STATUS_VMX_MASK	(0x1 << 12)
+#define MAX77759_FG_STATUS_VMX_CLEAR	(~(0x1 << 12))
+#define MAX77759_FG_STATUS_BI_SHIFT	11
+#define MAX77759_FG_STATUS_BI_MASK	(0x1 << 11)
+#define MAX77759_FG_STATUS_BI_CLEAR	(~(0x1 << 11))
+#define MAX77759_FG_STATUS_SMN_SHIFT	10
+#define MAX77759_FG_STATUS_SMN_MASK	(0x1 << 10)
+#define MAX77759_FG_STATUS_SMN_CLEAR	(~(0x1 << 10))
+#define MAX77759_FG_STATUS_TMN_SHIFT	9
+#define MAX77759_FG_STATUS_TMN_MASK	(0x1 << 9)
+#define MAX77759_FG_STATUS_TMN_CLEAR	(~(0x1 << 9))
+#define MAX77759_FG_STATUS_VMN_SHIFT	8
+#define MAX77759_FG_STATUS_VMN_MASK	(0x1 << 8)
+#define MAX77759_FG_STATUS_VMN_CLEAR	(~(0x1 << 8))
+#define MAX77759_FG_STATUS_DSOCI_SHIFT	7
+#define MAX77759_FG_STATUS_DSOCI_MASK	(0x1 << 7)
+#define MAX77759_FG_STATUS_DSOCI_CLEAR	(~(0x1 << 7))
+#define MAX77759_FG_STATUS_THMHOT_SHIFT	6
+#define MAX77759_FG_STATUS_THMHOT_MASK	(0x1 << 6)
+#define MAX77759_FG_STATUS_THMHOT_CLEAR	(~(0x1 << 6))
+#define MAX77759_FG_STATUS_SPR_5_SHIFT	5
+#define MAX77759_FG_STATUS_SPR_5_MASK	(0x1 << 5)
+#define MAX77759_FG_STATUS_SPR_5_CLEAR	(~(0x1 << 5))
+#define MAX77759_FG_STATUS_ISYSMX_SHIFT	4
+#define MAX77759_FG_STATUS_ISYSMX_MASK	(0x1 << 4)
+#define MAX77759_FG_STATUS_ISYSMX_CLEAR	(~(0x1 << 4))
+#define MAX77759_FG_STATUS_BST_SHIFT	3
+#define MAX77759_FG_STATUS_BST_MASK	(0x1 << 3)
+#define MAX77759_FG_STATUS_BST_CLEAR	(~(0x1 << 3))
+#define MAX77759_FG_STATUS_SPR_2_SHIFT	2
+#define MAX77759_FG_STATUS_SPR_2_MASK	(0x1 << 2)
+#define MAX77759_FG_STATUS_SPR_2_CLEAR	(~(0x1 << 2))
+#define MAX77759_FG_STATUS_POR_SHIFT	1
+#define MAX77759_FG_STATUS_POR_MASK	(0x1 << 1)
+#define MAX77759_FG_STATUS_POR_CLEAR	(~(0x1 << 1))
+#define MAX77759_FG_STATUS_IMN_SHIFT	0
+#define MAX77759_FG_STATUS_IMN_MASK	(0x1 << 0)
+#define MAX77759_FG_STATUS_IMN_CLEAR	(~(0x1 << 0))
+
+MAX77759_BFF(fg_status_br,15,15)
+MAX77759_BFF(fg_status_smx,14,14)
+MAX77759_BFF(fg_status_tmx,13,13)
+MAX77759_BFF(fg_status_vmx,12,12)
+MAX77759_BFF(fg_status_bi,11,11)
+MAX77759_BFF(fg_status_smn,10,10)
+MAX77759_BFF(fg_status_tmn,9,9)
+MAX77759_BFF(fg_status_vmn,8,8)
+MAX77759_BFF(fg_status_dsoci,7,7)
+MAX77759_BFF(fg_status_thmhot,6,6)
+MAX77759_BFF(fg_status_spr_5,5,5)
+MAX77759_BFF(fg_status_isysmx,4,4)
+MAX77759_BFF(fg_status_bst,3,3)
+MAX77759_BFF(fg_status_spr_2,2,2)
+MAX77759_BFF(fg_status_por,1,1)
+MAX77759_BFF(fg_status_imn,0,0)
+static inline const char *
+max77759_fg_status_cstr(char *buff, size_t len, int val)
+{
+#ifdef SCNPRINTF
+	int i = 0;
+
+	i += SCNPRINTF(&buff[i], len - i, " BR=%x",
+		FIELD2VALUE(MAX77759_FG_STATUS_BR, val));
+	i += SCNPRINTF(&buff[i], len - i, " SMX=%x",
+		FIELD2VALUE(MAX77759_FG_STATUS_SMX, val));
+	i += SCNPRINTF(&buff[i], len - i, " TMX=%x",
+		FIELD2VALUE(MAX77759_FG_STATUS_TMX, val));
+	i += SCNPRINTF(&buff[i], len - i, " VMX=%x",
+		FIELD2VALUE(MAX77759_FG_STATUS_VMX, val));
+	i += SCNPRINTF(&buff[i], len - i, " BI=%x",
+		FIELD2VALUE(MAX77759_FG_STATUS_BI, val));
+	i += SCNPRINTF(&buff[i], len - i, " SMN=%x",
+		FIELD2VALUE(MAX77759_FG_STATUS_SMN, val));
+	i += SCNPRINTF(&buff[i], len - i, " TMN=%x",
+		FIELD2VALUE(MAX77759_FG_STATUS_TMN, val));
+	i += SCNPRINTF(&buff[i], len - i, " VMN=%x",
+		FIELD2VALUE(MAX77759_FG_STATUS_VMN, val));
+	i += SCNPRINTF(&buff[i], len - i, " DSOCI=%x",
+		FIELD2VALUE(MAX77759_FG_STATUS_DSOCI, val));
+	i += SCNPRINTF(&buff[i], len - i, " THMHOT=%x",
+		FIELD2VALUE(MAX77759_FG_STATUS_THMHOT, val));
+	i += SCNPRINTF(&buff[i], len - i, " SPR_5=%x",
+		FIELD2VALUE(MAX77759_FG_STATUS_SPR_5, val));
+	i += SCNPRINTF(&buff[i], len - i, " ISYSMX=%x",
+		FIELD2VALUE(MAX77759_FG_STATUS_ISYSMX, val));
+	i += SCNPRINTF(&buff[i], len - i, " BST=%x",
+		FIELD2VALUE(MAX77759_FG_STATUS_BST, val));
+	i += SCNPRINTF(&buff[i], len - i, " SPR_2=%x",
+		FIELD2VALUE(MAX77759_FG_STATUS_SPR_2, val));
+	i += SCNPRINTF(&buff[i], len - i, " POR=%x",
+		FIELD2VALUE(MAX77759_FG_STATUS_POR, val));
+	i += SCNPRINTF(&buff[i], len - i, " IMN=%x",
+		FIELD2VALUE(MAX77759_FG_STATUS_IMN, val));
+#else
+	buff[0] = 0;
+#endif
+	return buff;
+}
+
+/*
+ * VAlrtTh,0x1,0b1111111100000000,0xff00
+ * MaxVoltageAlrt[7:0],,,,,,
+ */
+#define MAX77759_FG_VALRTTH	0x1
+
+#define MAX77759_FG_VALRTTH_MAXVOLTAGEALRT_SHIFT	8
+#define MAX77759_FG_VALRTTH_MAXVOLTAGEALRT_MASK	(0xff << 8)
+#define MAX77759_FG_VALRTTH_MAXVOLTAGEALRT_CLEAR	(~(0xff << 8))
+#define MAX77759_FG_VALRTTH_MINVOLTAGEALRT_SHIFT	0
+#define MAX77759_FG_VALRTTH_MINVOLTAGEALRT_MASK	(0xff << 0)
+#define MAX77759_FG_VALRTTH_MINVOLTAGEALRT_CLEAR	(~(0xff << 0))
+
+MAX77759_BFF(fg_valrtth_maxvoltagealrt,15,8)
+MAX77759_BFF(fg_valrtth_minvoltagealrt,7,0)
+static inline const char *
+max77759_fg_valrtth_cstr(char *buff, size_t len, int val)
+{
+#ifdef SCNPRINTF
+	int i = 0;
+
+	i += SCNPRINTF(&buff[i], len - i, " MAXVOLTAGEALRT=%x",
+		FIELD2VALUE(MAX77759_FG_VALRTTH_MAXVOLTAGEALRT, val));
+	i += SCNPRINTF(&buff[i], len - i, " MINVOLTAGEALRT=%x",
+		FIELD2VALUE(MAX77759_FG_VALRTTH_MINVOLTAGEALRT, val));
+#else
+	buff[0] = 0;
+#endif
+	return buff;
+}
+
+/*
+ * TAlrtTh,0x2,0b111111110000000,0x7f80
+ * MaxTempAlrt[7:0],,,,,,
+ */
+#define MAX77759_FG_TALRTTH	0x2
+
+#define MAX77759_FG_TALRTTH_MAXTEMPALRT_SHIFT	8
+#define MAX77759_FG_TALRTTH_MAXTEMPALRT_MASK	(0xff << 8)
+#define MAX77759_FG_TALRTTH_MAXTEMPALRT_CLEAR	(~(0xff << 8))
+#define MAX77759_FG_TALRTTH_MINTEMPALRT_SHIFT	0
+#define MAX77759_FG_TALRTTH_MINTEMPALRT_MASK	(0xff << 0)
+#define MAX77759_FG_TALRTTH_MINTEMPALRT_CLEAR	(~(0xff << 0))
+
+MAX77759_BFF(fg_talrtth_maxtempalrt,15,8)
+MAX77759_BFF(fg_talrtth_mintempalrt,7,0)
+static inline const char *
+max77759_fg_talrtth_cstr(char *buff, size_t len, int val)
+{
+#ifdef SCNPRINTF
+	int i = 0;
+
+	i += SCNPRINTF(&buff[i], len - i, " MAXTEMPALRT=%x",
+		FIELD2VALUE(MAX77759_FG_TALRTTH_MAXTEMPALRT, val));
+	i += SCNPRINTF(&buff[i], len - i, " MINTEMPALRT=%x",
+		FIELD2VALUE(MAX77759_FG_TALRTTH_MINTEMPALRT, val));
+#else
+	buff[0] = 0;
+#endif
+	return buff;
+}
+
+/*
+ * SAlrtTh,0x3,0b1111111100000000,0xff00
+ * MaxSocAlrt[7:0],,,,,,
+ */
+#define MAX77759_FG_SALRTTH	0x3
+
+#define MAX77759_FG_SALRTTH_MAXSOCALRT_SHIFT	8
+#define MAX77759_FG_SALRTTH_MAXSOCALRT_MASK	(0xff << 8)
+#define MAX77759_FG_SALRTTH_MAXSOCALRT_CLEAR	(~(0xff << 8))
+#define MAX77759_FG_SALRTTH_MINSOCALRT_SHIFT	0
+#define MAX77759_FG_SALRTTH_MINSOCALRT_MASK	(0xff << 0)
+#define MAX77759_FG_SALRTTH_MINSOCALRT_CLEAR	(~(0xff << 0))
+
+MAX77759_BFF(fg_salrtth_maxsocalrt,15,8)
+MAX77759_BFF(fg_salrtth_minsocalrt,7,0)
+static inline const char *
+max77759_fg_salrtth_cstr(char *buff, size_t len, int val)
+{
+#ifdef SCNPRINTF
+	int i = 0;
+
+	i += SCNPRINTF(&buff[i], len - i, " MAXSOCALRT=%x",
+		FIELD2VALUE(MAX77759_FG_SALRTTH_MAXSOCALRT, val));
+	i += SCNPRINTF(&buff[i], len - i, " MINSOCALRT=%x",
+		FIELD2VALUE(MAX77759_FG_SALRTTH_MINSOCALRT, val));
+#else
+	buff[0] = 0;
+#endif
+	return buff;
+}
+
+/*
+ * AtRate,0x4,0b00000000,0x00
+ * AtRate[15:8],,,,,,
+ */
+#define MAX77759_FG_ATRATE	0x4
+
+/*
+ * RepCap,0x5,0b10111011100,0x5dc
+ * RepCap[15:8],,,,,,
+ */
+#define MAX77759_FG_REPCAP	0x5
+
+/*
+ * RepSOC,0x6,0b11001000000000,0x3200
+ * RepSOC[15:8],,,,,,
+ */
+#define MAX77759_FG_REPSOC	0x6
+
+/*
+ * Age,0x7,0b110010000000000,0x6400
+ * Age[15:8],,,,,,
+ */
+#define MAX77759_FG_AGE	0x7
+
+/*
+ * Temp,0x8,0b1011000000000,0x1600
+ * TEMP[15:8],,,,,,
+ */
+#define MAX77759_FG_TEMP	0x8
+
+/*
+ * Vcell,0x9,0b1011010000000000,0xb400
+ * VCELL[15:8],,,,,,
+ */
+#define MAX77759_FG_VCELL	0x9
+
+/*
+ * Current,0xA,0b00000000,0x00
+ * Current[15:8],,,,,,
+ */
+#define MAX77759_FG_CURRENT	0xA
+
+/*
+ * AvgCurrent,0xB,0b00000000,0x00
+ * AvgCurrent[15:8],,,,,,
+ */
+#define MAX77759_FG_AVGCURRENT	0xB
+
+/*
+ * QResidual,0xC,0b00000000,0x00
+ * Qresidual[15:8],,,,,,
+ */
+#define MAX77759_FG_QRESIDUAL	0xC
+
+/*
+ * MixSOC,0xD,0b11001000000000,0x3200
+ * MixSOC[15:8],,,,,,
+ */
+#define MAX77759_FG_MIXSOC	0xD
+
+/*
+ * AvSOC,0xE,0b11001000000000,0x3200
+ * AvSOC[15:8],,,,,,
+ */
+#define MAX77759_FG_AVSOC	0xE
+
+/*
+ * MixCap,0xF,0b10111011100,0x5dc
+ * MixCapH[15:8],,,,,,
+ */
+#define MAX77759_FG_MIXCAP	0xF
+
+/*
+ * FullCap,0x10,0b101110111000,0xbb8
+ * FullCAP[15:8],,,,,,
+ */
+#define MAX77759_FG_FULLCAP	0x10
+
+/*
+ * TTE,0x11,0b00000000,0x00
+ * hr[5:0],,,,,,mn[5:4]
+ */
+#define MAX77759_FG_TTE	0x11
+
+#define MAX77759_FG_TTE_HR_SHIFT	10
+#define MAX77759_FG_TTE_HR_MASK	(0x3f << 10)
+#define MAX77759_FG_TTE_HR_CLEAR	(~(0x3f << 10))
+#define MAX77759_FG_TTE_MN_SHIFT	4
+#define MAX77759_FG_TTE_MN_MASK	(0x3f << 4)
+#define MAX77759_FG_TTE_MN_CLEAR	(~(0x3f << 4))
+#define MAX77759_FG_TTE_SEC_SHIFT	0
+#define MAX77759_FG_TTE_SEC_MASK	(0xf << 0)
+#define MAX77759_FG_TTE_SEC_CLEAR	(~(0xf << 0))
+
+MAX77759_BFF(fg_tte_hr,15,10)
+MAX77759_BFF(fg_tte_mn,9,4)
+MAX77759_BFF(fg_tte_sec,3,0)
+static inline const char *
+max77759_fg_tte_cstr(char *buff, size_t len, int val)
+{
+#ifdef SCNPRINTF
+	int i = 0;
+
+	i += SCNPRINTF(&buff[i], len - i, " HR=%x",
+		FIELD2VALUE(MAX77759_FG_TTE_HR, val));
+	i += SCNPRINTF(&buff[i], len - i, " MN=%x",
+		FIELD2VALUE(MAX77759_FG_TTE_MN, val));
+	i += SCNPRINTF(&buff[i], len - i, " SEC=%x",
+		FIELD2VALUE(MAX77759_FG_TTE_SEC, val));
+#else
+	buff[0] = 0;
+#endif
+	return buff;
+}
+
+/*
+ * QRTable00,0x12,0b11110000000000,0x3c00
+ * QRTable00[15:8],,,,,,
+ */
+#define MAX77759_FG_QRTABLE00	0x12
+
+/*
+ * FullSocThr,0x13,0b101000000000000,0x5000
+ * FullSOCThr[15:8],,,,,,
+ */
+#define MAX77759_FG_FULLSOCTHR	0x13
+
+/*
+ * Rslow,0x14,0b1010010000,0x290
+ * RSLOW[15:8],,,,,,
+ */
+#define MAX77759_FG_RSLOW	0x14
+
+/*
+ * RFast,0x15,0b101001000,0x148
+ * RFAST[15:8],,,,,,
+ */
+#define MAX77759_FG_RFAST	0x15
+
+/*
+ * AvgTA,0x16,0b1011000000000,0x1600
+ * AvgTA[15:8],,,,,,
+ */
+#define MAX77759_FG_AVGTA	0x16
+
+/*
+ * Cycles,0x17,0b00000000,0x00
+ * Cycles[15:8],,,,,,
+ */
+#define MAX77759_FG_CYCLES	0x17
+
+/*
+ * DesignCap,0x18,0b101110111000,0xbb8
+ * DesignCap[15:8],,,,,,
+ */
+#define MAX77759_FG_DESIGNCAP	0x18
+
+/*
+ * AvgVCell,0x19,0b1011010000000000,0xb400
+ * AvgVCELL[15:8],,,,,,
+ */
+#define MAX77759_FG_AVGVCELL	0x19
+
+/*
+ * MaxMinTemp,0x1A,0b1000000001111111,0x807f
+ * MaxTemperature[7:0],,,,,,
+ */
+#define MAX77759_FG_MAXMINTEMP	0x1A
+
+#define MAX77759_FG_MAXMINTEMP_MAXTEMPERATURE_SHIFT	8
+#define MAX77759_FG_MAXMINTEMP_MAXTEMPERATURE_MASK	(0xff << 8)
+#define MAX77759_FG_MAXMINTEMP_MAXTEMPERATURE_CLEAR	(~(0xff << 8))
+#define MAX77759_FG_MAXMINTEMP_MINTEMPERATURE_SHIFT	0
+#define MAX77759_FG_MAXMINTEMP_MINTEMPERATURE_MASK	(0xff << 0)
+#define MAX77759_FG_MAXMINTEMP_MINTEMPERATURE_CLEAR	(~(0xff << 0))
+
+MAX77759_BFF(fg_maxmintemp_maxtemperature,15,8)
+MAX77759_BFF(fg_maxmintemp_mintemperature,7,0)
+static inline const char *
+max77759_fg_maxmintemp_cstr(char *buff, size_t len, int val)
+{
+#ifdef SCNPRINTF
+	int i = 0;
+
+	i += SCNPRINTF(&buff[i], len - i, " MAXTEMPERATURE=%x",
+		FIELD2VALUE(MAX77759_FG_MAXMINTEMP_MAXTEMPERATURE, val));
+	i += SCNPRINTF(&buff[i], len - i, " MINTEMPERATURE=%x",
+		FIELD2VALUE(MAX77759_FG_MAXMINTEMP_MINTEMPERATURE, val));
+#else
+	buff[0] = 0;
+#endif
+	return buff;
+}
+
+/*
+ * MaxMinVolt,0x1B,0b11111111,0xff
+ * MaxVoltage[7:0],,,,,,
+ */
+#define MAX77759_FG_MAXMINVOLT	0x1B
+
+#define MAX77759_FG_MAXMINVOLT_MAXVOLTAGE_SHIFT	8
+#define MAX77759_FG_MAXMINVOLT_MAXVOLTAGE_MASK	(0xff << 8)
+#define MAX77759_FG_MAXMINVOLT_MAXVOLTAGE_CLEAR	(~(0xff << 8))
+#define MAX77759_FG_MAXMINVOLT_MINVOLTAGE_SHIFT	0
+#define MAX77759_FG_MAXMINVOLT_MINVOLTAGE_MASK	(0xff << 0)
+#define MAX77759_FG_MAXMINVOLT_MINVOLTAGE_CLEAR	(~(0xff << 0))
+
+MAX77759_BFF(fg_maxminvolt_maxvoltage,15,8)
+MAX77759_BFF(fg_maxminvolt_minvoltage,7,0)
+static inline const char *
+max77759_fg_maxminvolt_cstr(char *buff, size_t len, int val)
+{
+#ifdef SCNPRINTF
+	int i = 0;
+
+	i += SCNPRINTF(&buff[i], len - i, " MAXVOLTAGE=%x",
+		FIELD2VALUE(MAX77759_FG_MAXMINVOLT_MAXVOLTAGE, val));
+	i += SCNPRINTF(&buff[i], len - i, " MINVOLTAGE=%x",
+		FIELD2VALUE(MAX77759_FG_MAXMINVOLT_MINVOLTAGE, val));
+#else
+	buff[0] = 0;
+#endif
+	return buff;
+}
+
+/*
+ * MaxMinCurr,0x1C,0b1000000001111111,0x807f
+ * MaxChargeCurrent[7:0],,,,,,
+ */
+#define MAX77759_FG_MAXMINCURR	0x1C
+
+#define MAX77759_FG_MAXMINCURR_MAXCHARGECURRENT_SHIFT	8
+#define MAX77759_FG_MAXMINCURR_MAXCHARGECURRENT_MASK	(0xff << 8)
+#define MAX77759_FG_MAXMINCURR_MAXCHARGECURRENT_CLEAR	(~(0xff << 8))
+#define MAX77759_FG_MAXMINCURR_MAXDISCURRENT_SHIFT	0
+#define MAX77759_FG_MAXMINCURR_MAXDISCURRENT_MASK	(0xff << 0)
+#define MAX77759_FG_MAXMINCURR_MAXDISCURRENT_CLEAR	(~(0xff << 0))
+
+MAX77759_BFF(fg_maxmincurr_maxchargecurrent,15,8)
+MAX77759_BFF(fg_maxmincurr_maxdiscurrent,7,0)
+static inline const char *
+max77759_fg_maxmincurr_cstr(char *buff, size_t len, int val)
+{
+#ifdef SCNPRINTF
+	int i = 0;
+
+	i += SCNPRINTF(&buff[i], len - i, " MAXCHARGECURRENT=%x",
+		FIELD2VALUE(MAX77759_FG_MAXMINCURR_MAXCHARGECURRENT, val));
+	i += SCNPRINTF(&buff[i], len - i, " MAXDISCURRENT=%x",
+		FIELD2VALUE(MAX77759_FG_MAXMINCURR_MAXDISCURRENT, val));
+#else
+	buff[0] = 0;
+#endif
+	return buff;
+}
+
+/*
+ * Config,0x1D,0b10001101010000,0x2350
+ * FCFE,Ss,Ts,Vs,FGCC,AINSH,Ten
+ */
+#define MAX77759_FG_CONFIG	0x1D
+#define MAX77759_FG_CONFIG_FCFE	(0x1 << 15)
+#define MAX77759_FG_CONFIG_SS	(0x1 << 14)
+#define MAX77759_FG_CONFIG_TS	(0x1 << 13)
+#define MAX77759_FG_CONFIG_VS	(0x1 << 12)
+#define MAX77759_FG_CONFIG_FGCC	(0x1 << 11)
+#define MAX77759_FG_CONFIG_AINSH	(0x1 << 10)
+#define MAX77759_FG_CONFIG_TEN	(0x1 << 9)
+#define MAX77759_FG_CONFIG_TEX	(0x1 << 8)
+#define MAX77759_FG_CONFIG_SHDN	(0x1 << 7)
+#define MAX77759_FG_CONFIG_I2CSH	(0x1 << 6)
+#define MAX77759_FG_CONFIG_ICFE	(0x1 << 5)
+#define MAX77759_FG_CONFIG_ETHRM	(0x1 << 4)
+#define MAX77759_FG_CONFIG_FTHRM	(0x1 << 3)
+#define MAX77759_FG_CONFIG_AEN	(0x1 << 2)
+#define MAX77759_FG_CONFIG_BEI	(0x1 << 1)
+#define MAX77759_FG_CONFIG_BER	(0x1 << 0)
+
+#define MAX77759_FG_CONFIG_FCFE_SHIFT	15
+#define MAX77759_FG_CONFIG_FCFE_MASK	(0x1 << 15)
+#define MAX77759_FG_CONFIG_FCFE_CLEAR	(~(0x1 << 15))
+#define MAX77759_FG_CONFIG_SS_SHIFT	14
+#define MAX77759_FG_CONFIG_SS_MASK	(0x1 << 14)
+#define MAX77759_FG_CONFIG_SS_CLEAR	(~(0x1 << 14))
+#define MAX77759_FG_CONFIG_TS_SHIFT	13
+#define MAX77759_FG_CONFIG_TS_MASK	(0x1 << 13)
+#define MAX77759_FG_CONFIG_TS_CLEAR	(~(0x1 << 13))
+#define MAX77759_FG_CONFIG_VS_SHIFT	12
+#define MAX77759_FG_CONFIG_VS_MASK	(0x1 << 12)
+#define MAX77759_FG_CONFIG_VS_CLEAR	(~(0x1 << 12))
+#define MAX77759_FG_CONFIG_FGCC_SHIFT	11
+#define MAX77759_FG_CONFIG_FGCC_MASK	(0x1 << 11)
+#define MAX77759_FG_CONFIG_FGCC_CLEAR	(~(0x1 << 11))
+#define MAX77759_FG_CONFIG_AINSH_SHIFT	10
+#define MAX77759_FG_CONFIG_AINSH_MASK	(0x1 << 10)
+#define MAX77759_FG_CONFIG_AINSH_CLEAR	(~(0x1 << 10))
+#define MAX77759_FG_CONFIG_TEN_SHIFT	9
+#define MAX77759_FG_CONFIG_TEN_MASK	(0x1 << 9)
+#define MAX77759_FG_CONFIG_TEN_CLEAR	(~(0x1 << 9))
+#define MAX77759_FG_CONFIG_TEX_SHIFT	8
+#define MAX77759_FG_CONFIG_TEX_MASK	(0x1 << 8)
+#define MAX77759_FG_CONFIG_TEX_CLEAR	(~(0x1 << 8))
+#define MAX77759_FG_CONFIG_SHDN_SHIFT	7
+#define MAX77759_FG_CONFIG_SHDN_MASK	(0x1 << 7)
+#define MAX77759_FG_CONFIG_SHDN_CLEAR	(~(0x1 << 7))
+#define MAX77759_FG_CONFIG_I2CSH_SHIFT	6
+#define MAX77759_FG_CONFIG_I2CSH_MASK	(0x1 << 6)
+#define MAX77759_FG_CONFIG_I2CSH_CLEAR	(~(0x1 << 6))
+#define MAX77759_FG_CONFIG_ICFE_SHIFT	5
+#define MAX77759_FG_CONFIG_ICFE_MASK	(0x1 << 5)
+#define MAX77759_FG_CONFIG_ICFE_CLEAR	(~(0x1 << 5))
+#define MAX77759_FG_CONFIG_ETHRM_SHIFT	4
+#define MAX77759_FG_CONFIG_ETHRM_MASK	(0x1 << 4)
+#define MAX77759_FG_CONFIG_ETHRM_CLEAR	(~(0x1 << 4))
+#define MAX77759_FG_CONFIG_FTHRM_SHIFT	3
+#define MAX77759_FG_CONFIG_FTHRM_MASK	(0x1 << 3)
+#define MAX77759_FG_CONFIG_FTHRM_CLEAR	(~(0x1 << 3))
+#define MAX77759_FG_CONFIG_AEN_SHIFT	2
+#define MAX77759_FG_CONFIG_AEN_MASK	(0x1 << 2)
+#define MAX77759_FG_CONFIG_AEN_CLEAR	(~(0x1 << 2))
+#define MAX77759_FG_CONFIG_BEI_SHIFT	1
+#define MAX77759_FG_CONFIG_BEI_MASK	(0x1 << 1)
+#define MAX77759_FG_CONFIG_BEI_CLEAR	(~(0x1 << 1))
+#define MAX77759_FG_CONFIG_BER_SHIFT	0
+#define MAX77759_FG_CONFIG_BER_MASK	(0x1 << 0)
+#define MAX77759_FG_CONFIG_BER_CLEAR	(~(0x1 << 0))
+
+MAX77759_BFF(fg_config_fcfe,15,15)
+MAX77759_BFF(fg_config_ss,14,14)
+MAX77759_BFF(fg_config_ts,13,13)
+MAX77759_BFF(fg_config_vs,12,12)
+MAX77759_BFF(fg_config_fgcc,11,11)
+MAX77759_BFF(fg_config_ainsh,10,10)
+MAX77759_BFF(fg_config_ten,9,9)
+MAX77759_BFF(fg_config_tex,8,8)
+MAX77759_BFF(fg_config_shdn,7,7)
+MAX77759_BFF(fg_config_i2csh,6,6)
+MAX77759_BFF(fg_config_icfe,5,5)
+MAX77759_BFF(fg_config_ethrm,4,4)
+MAX77759_BFF(fg_config_fthrm,3,3)
+MAX77759_BFF(fg_config_aen,2,2)
+MAX77759_BFF(fg_config_bei,1,1)
+MAX77759_BFF(fg_config_ber,0,0)
+static inline const char *
+max77759_fg_config_cstr(char *buff, size_t len, int val)
+{
+#ifdef SCNPRINTF
+	int i = 0;
+
+	i += SCNPRINTF(&buff[i], len - i, " FCFE=%x",
+		FIELD2VALUE(MAX77759_FG_CONFIG_FCFE, val));
+	i += SCNPRINTF(&buff[i], len - i, " SS=%x",
+		FIELD2VALUE(MAX77759_FG_CONFIG_SS, val));
+	i += SCNPRINTF(&buff[i], len - i, " TS=%x",
+		FIELD2VALUE(MAX77759_FG_CONFIG_TS, val));
+	i += SCNPRINTF(&buff[i], len - i, " VS=%x",
+		FIELD2VALUE(MAX77759_FG_CONFIG_VS, val));
+	i += SCNPRINTF(&buff[i], len - i, " FGCC=%x",
+		FIELD2VALUE(MAX77759_FG_CONFIG_FGCC, val));
+	i += SCNPRINTF(&buff[i], len - i, " AINSH=%x",
+		FIELD2VALUE(MAX77759_FG_CONFIG_AINSH, val));
+	i += SCNPRINTF(&buff[i], len - i, " TEN=%x",
+		FIELD2VALUE(MAX77759_FG_CONFIG_TEN, val));
+	i += SCNPRINTF(&buff[i], len - i, " TEX=%x",
+		FIELD2VALUE(MAX77759_FG_CONFIG_TEX, val));
+	i += SCNPRINTF(&buff[i], len - i, " SHDN=%x",
+		FIELD2VALUE(MAX77759_FG_CONFIG_SHDN, val));
+	i += SCNPRINTF(&buff[i], len - i, " I2CSH=%x",
+		FIELD2VALUE(MAX77759_FG_CONFIG_I2CSH, val));
+	i += SCNPRINTF(&buff[i], len - i, " ICFE=%x",
+		FIELD2VALUE(MAX77759_FG_CONFIG_ICFE, val));
+	i += SCNPRINTF(&buff[i], len - i, " ETHRM=%x",
+		FIELD2VALUE(MAX77759_FG_CONFIG_ETHRM, val));
+	i += SCNPRINTF(&buff[i], len - i, " FTHRM=%x",
+		FIELD2VALUE(MAX77759_FG_CONFIG_FTHRM, val));
+	i += SCNPRINTF(&buff[i], len - i, " AEN=%x",
+		FIELD2VALUE(MAX77759_FG_CONFIG_AEN, val));
+	i += SCNPRINTF(&buff[i], len - i, " BEI=%x",
+		FIELD2VALUE(MAX77759_FG_CONFIG_BEI, val));
+	i += SCNPRINTF(&buff[i], len - i, " BER=%x",
+		FIELD2VALUE(MAX77759_FG_CONFIG_BER, val));
+#else
+	buff[0] = 0;
+#endif
+	return buff;
+}
+
+/*
+ * IChgTerm,0x1E,0b1111000000,0x3c0
+ * ICHGTerm[15:8],,,,,,
+ */
+#define MAX77759_FG_ICHGTERM	0x1E
+
+/*
+ * AvCap,0x1F,0b10111011100,0x5dc
+ * AvCap[15:8],,,,,,
+ */
+#define MAX77759_FG_AVCAP	0x1F
+
+/*
+ * TTF,0x20,0b1111111111111111,0xffff
+ * hr[5:0],,,,,,mn[5:4]
+ */
+#define MAX77759_FG_TTF	0x20
+
+#define MAX77759_FG_TTF_HR_SHIFT	10
+#define MAX77759_FG_TTF_HR_MASK	(0x3f << 10)
+#define MAX77759_FG_TTF_HR_CLEAR	(~(0x3f << 10))
+#define MAX77759_FG_TTF_MN_SHIFT	4
+#define MAX77759_FG_TTF_MN_MASK	(0x3f << 4)
+#define MAX77759_FG_TTF_MN_CLEAR	(~(0x3f << 4))
+#define MAX77759_FG_TTF_SEC_SHIFT	0
+#define MAX77759_FG_TTF_SEC_MASK	(0xf << 0)
+#define MAX77759_FG_TTF_SEC_CLEAR	(~(0xf << 0))
+
+MAX77759_BFF(fg_ttf_hr,15,10)
+MAX77759_BFF(fg_ttf_mn,9,4)
+MAX77759_BFF(fg_ttf_sec,3,0)
+static inline const char *
+max77759_fg_ttf_cstr(char *buff, size_t len, int val)
+{
+#ifdef SCNPRINTF
+	int i = 0;
+
+	i += SCNPRINTF(&buff[i], len - i, " HR=%x",
+		FIELD2VALUE(MAX77759_FG_TTF_HR, val));
+	i += SCNPRINTF(&buff[i], len - i, " MN=%x",
+		FIELD2VALUE(MAX77759_FG_TTF_MN, val));
+	i += SCNPRINTF(&buff[i], len - i, " SEC=%x",
+		FIELD2VALUE(MAX77759_FG_TTF_SEC, val));
+#else
+	buff[0] = 0;
+#endif
+	return buff;
+}
+
+/*
+ * DevName,0x21,0b110001000000000,0x6200
+ * DevName[15:8],,,,,,
+ */
+#define MAX77759_FG_DEVNAME	0x21
+
+/*
+ * QRTable10,0x22,0b1101110000000,0x1b80
+ * QRTable10[15:8],,,,,,
+ */
+#define MAX77759_FG_QRTABLE10	0x22
+
+/*
+ * FullCapNom,0x23,0b101110111000,0xbb8
+ * FullCapNom[15:8],,,,,,
+ */
+#define MAX77759_FG_FULLCAPNOM	0x23
+
+/*
+ * TempNom,0x24,0b1010000000000,0x1400
+ * TempNom[9:2],,,,,,
+ */
+#define MAX77759_FG_TEMPNOM	0x24
+
+#define MAX77759_FG_TEMPNOM_TEMPNOM_SHIFT	6
+#define MAX77759_FG_TEMPNOM_TEMPNOM_MASK	(0x3ff << 6)
+#define MAX77759_FG_TEMPNOM_TEMPNOM_CLEAR	(~(0x3ff << 6))
+#define MAX77759_FG_TEMPNOM_SPR_5_0_SHIFT	0
+#define MAX77759_FG_TEMPNOM_SPR_5_0_MASK	(0x3f << 0)
+#define MAX77759_FG_TEMPNOM_SPR_5_0_CLEAR	(~(0x3f << 0))
+
+MAX77759_BFF(fg_tempnom_tempnom,15,6)
+MAX77759_BFF(fg_tempnom_spr_5_0,5,0)
+static inline const char *
+max77759_fg_tempnom_cstr(char *buff, size_t len, int val)
+{
+#ifdef SCNPRINTF
+	int i = 0;
+
+	i += SCNPRINTF(&buff[i], len - i, " TEMPNOM=%x",
+		FIELD2VALUE(MAX77759_FG_TEMPNOM_TEMPNOM, val));
+	i += SCNPRINTF(&buff[i], len - i, " SPR_5_0=%x",
+		FIELD2VALUE(MAX77759_FG_TEMPNOM_SPR_5_0, val));
+#else
+	buff[0] = 0;
+#endif
+	return buff;
+}
+
+/*
+ * TempLim,0x25,0b10001100000101,0x2305
+ * TempHot[7:0],,,,,,
+ */
+#define MAX77759_FG_TEMPLIM	0x25
+
+#define MAX77759_FG_TEMPLIM_TEMPHOT_SHIFT	8
+#define MAX77759_FG_TEMPLIM_TEMPHOT_MASK	(0xff << 8)
+#define MAX77759_FG_TEMPLIM_TEMPHOT_CLEAR	(~(0xff << 8))
+#define MAX77759_FG_TEMPLIM_TEMPCOLD_SHIFT	0
+#define MAX77759_FG_TEMPLIM_TEMPCOLD_MASK	(0xff << 0)
+#define MAX77759_FG_TEMPLIM_TEMPCOLD_CLEAR	(~(0xff << 0))
+
+MAX77759_BFF(fg_templim_temphot,15,8)
+MAX77759_BFF(fg_templim_tempcold,7,0)
+static inline const char *
+max77759_fg_templim_cstr(char *buff, size_t len, int val)
+{
+#ifdef SCNPRINTF
+	int i = 0;
+
+	i += SCNPRINTF(&buff[i], len - i, " TEMPHOT=%x",
+		FIELD2VALUE(MAX77759_FG_TEMPLIM_TEMPHOT, val));
+	i += SCNPRINTF(&buff[i], len - i, " TEMPCOLD=%x",
+		FIELD2VALUE(MAX77759_FG_TEMPLIM_TEMPCOLD, val));
+#else
+	buff[0] = 0;
+#endif
+	return buff;
+}
+
+/*
+ * AvgTA0,0x26,0b1011000000000,0x1600
+ * AvgTA0[15:8],,,,,,
+ */
+#define MAX77759_FG_AVGTA0	0x26
+
+/*
+ * AIN0,0x27,0b1000100011010000,0x88d0
+ * AIN0[15:8],,,,,,
+ */
+#define MAX77759_FG_AIN0	0x27
+
+/*
+ * LearnCfg,0x28,0b10011000000011,0x2603
+ * LearnRCOMP[2:0],,,LearnTCO[2:0],,,FCLm[1:0]
+ */
+#define MAX77759_FG_LEARNCFG	0x28
+#define MAX77759_FG_LEARNCFG_FCX	(0x1 << 7)
+#define MAX77759_FG_LEARNCFG_SPR_3	(0x1 << 3)
+#define MAX77759_FG_LEARNCFG_FILLEMPTY	(0x1 << 2)
+#define MAX77759_FG_LEARNCFG_MIXEN	(0x1 << 1)
+#define MAX77759_FG_LEARNCFG_SPR_0	(0x1 << 0)
+
+#define MAX77759_FG_LEARNCFG_LEARNRCOMP_SHIFT	13
+#define MAX77759_FG_LEARNCFG_LEARNRCOMP_MASK	(0x7 << 13)
+#define MAX77759_FG_LEARNCFG_LEARNRCOMP_CLEAR	(~(0x7 << 13))
+#define MAX77759_FG_LEARNCFG_LEARNTCO_SHIFT	10
+#define MAX77759_FG_LEARNCFG_LEARNTCO_MASK	(0x7 << 10)
+#define MAX77759_FG_LEARNCFG_LEARNTCO_CLEAR	(~(0x7 << 10))
+#define MAX77759_FG_LEARNCFG_FCLM_SHIFT	8
+#define MAX77759_FG_LEARNCFG_FCLM_MASK	(0x3 << 8)
+#define MAX77759_FG_LEARNCFG_FCLM_CLEAR	(~(0x3 << 8))
+#define MAX77759_FG_LEARNCFG_FCX_SHIFT	7
+#define MAX77759_FG_LEARNCFG_FCX_MASK	(0x1 << 7)
+#define MAX77759_FG_LEARNCFG_FCX_CLEAR	(~(0x1 << 7))
+#define MAX77759_FG_LEARNCFG_FCLRNSTAGE_SHIFT	4
+#define MAX77759_FG_LEARNCFG_FCLRNSTAGE_MASK	(0x7 << 4)
+#define MAX77759_FG_LEARNCFG_FCLRNSTAGE_CLEAR	(~(0x7 << 4))
+#define MAX77759_FG_LEARNCFG_SPR_3_SHIFT	3
+#define MAX77759_FG_LEARNCFG_SPR_3_MASK	(0x1 << 3)
+#define MAX77759_FG_LEARNCFG_SPR_3_CLEAR	(~(0x1 << 3))
+#define MAX77759_FG_LEARNCFG_FILLEMPTY_SHIFT	2
+#define MAX77759_FG_LEARNCFG_FILLEMPTY_MASK	(0x1 << 2)
+#define MAX77759_FG_LEARNCFG_FILLEMPTY_CLEAR	(~(0x1 << 2))
+#define MAX77759_FG_LEARNCFG_MIXEN_SHIFT	1
+#define MAX77759_FG_LEARNCFG_MIXEN_MASK	(0x1 << 1)
+#define MAX77759_FG_LEARNCFG_MIXEN_CLEAR	(~(0x1 << 1))
+#define MAX77759_FG_LEARNCFG_SPR_0_SHIFT	0
+#define MAX77759_FG_LEARNCFG_SPR_0_MASK	(0x1 << 0)
+#define MAX77759_FG_LEARNCFG_SPR_0_CLEAR	(~(0x1 << 0))
+
+MAX77759_BFF(fg_learncfg_learnrcomp,15,13)
+MAX77759_BFF(fg_learncfg_learntco,12,10)
+MAX77759_BFF(fg_learncfg_fclm,9,8)
+MAX77759_BFF(fg_learncfg_fcx,7,7)
+MAX77759_BFF(fg_learncfg_fclrnstage,6,4)
+MAX77759_BFF(fg_learncfg_spr_3,3,3)
+MAX77759_BFF(fg_learncfg_fillempty,2,2)
+MAX77759_BFF(fg_learncfg_mixen,1,1)
+MAX77759_BFF(fg_learncfg_spr_0,0,0)
+static inline const char *
+max77759_fg_learncfg_cstr(char *buff, size_t len, int val)
+{
+#ifdef SCNPRINTF
+	int i = 0;
+
+	i += SCNPRINTF(&buff[i], len - i, " LEARNRCOMP=%x",
+		FIELD2VALUE(MAX77759_FG_LEARNCFG_LEARNRCOMP, val));
+	i += SCNPRINTF(&buff[i], len - i, " LEARNTCO=%x",
+		FIELD2VALUE(MAX77759_FG_LEARNCFG_LEARNTCO, val));
+	i += SCNPRINTF(&buff[i], len - i, " FCLM=%x",
+		FIELD2VALUE(MAX77759_FG_LEARNCFG_FCLM, val));
+	i += SCNPRINTF(&buff[i], len - i, " FCX=%x",
+		FIELD2VALUE(MAX77759_FG_LEARNCFG_FCX, val));
+	i += SCNPRINTF(&buff[i], len - i, " FCLRNSTAGE=%x",
+		FIELD2VALUE(MAX77759_FG_LEARNCFG_FCLRNSTAGE, val));
+	i += SCNPRINTF(&buff[i], len - i, " SPR_3=%x",
+		FIELD2VALUE(MAX77759_FG_LEARNCFG_SPR_3, val));
+	i += SCNPRINTF(&buff[i], len - i, " FILLEMPTY=%x",
+		FIELD2VALUE(MAX77759_FG_LEARNCFG_FILLEMPTY, val));
+	i += SCNPRINTF(&buff[i], len - i, " MIXEN=%x",
+		FIELD2VALUE(MAX77759_FG_LEARNCFG_MIXEN, val));
+	i += SCNPRINTF(&buff[i], len - i, " SPR_0=%x",
+		FIELD2VALUE(MAX77759_FG_LEARNCFG_SPR_0, val));
+#else
+	buff[0] = 0;
+#endif
+	return buff;
+}
+
+/*
+ * FilterCfg,0x29,0b1100111010100100,0xcea4
+ * NEMPTY[1:0],,NTEMP[2:0],,,NMIX[3:1],
+ */
+#define MAX77759_FG_FILTERCFG	0x29
+
+#define MAX77759_FG_FILTERCFG_NEMPTY_SHIFT	14
+#define MAX77759_FG_FILTERCFG_NEMPTY_MASK	(0x3 << 14)
+#define MAX77759_FG_FILTERCFG_NEMPTY_CLEAR	(~(0x3 << 14))
+#define MAX77759_FG_FILTERCFG_NTEMP_SHIFT	11
+#define MAX77759_FG_FILTERCFG_NTEMP_MASK	(0x7 << 11)
+#define MAX77759_FG_FILTERCFG_NTEMP_CLEAR	(~(0x7 << 11))
+#define MAX77759_FG_FILTERCFG_NMIX_SHIFT	8
+#define MAX77759_FG_FILTERCFG_NMIX_MASK	(0x7 << 8)
+#define MAX77759_FG_FILTERCFG_NMIX_CLEAR	(~(0x7 << 8))
+#define MAX77759_FG_FILTERCFG_NAVGCELL_SHIFT	5
+#define MAX77759_FG_FILTERCFG_NAVGCELL_MASK	(0x7 << 5)
+#define MAX77759_FG_FILTERCFG_NAVGCELL_CLEAR	(~(0x7 << 5))
+#define MAX77759_FG_FILTERCFG_NCURR_SHIFT	1
+#define MAX77759_FG_FILTERCFG_NCURR_MASK	(0xf << 1)
+#define MAX77759_FG_FILTERCFG_NCURR_CLEAR	(~(0xf << 1))
+
+MAX77759_BFF(fg_filtercfg_nempty,15,14)
+MAX77759_BFF(fg_filtercfg_ntemp,13,11)
+MAX77759_BFF(fg_filtercfg_nmix,10,8)
+MAX77759_BFF(fg_filtercfg_navgcell,7,5)
+MAX77759_BFF(fg_filtercfg_ncurr,4,1)
+static inline const char *
+max77759_fg_filtercfg_cstr(char *buff, size_t len, int val)
+{
+#ifdef SCNPRINTF
+	int i = 0;
+
+	i += SCNPRINTF(&buff[i], len - i, " NEMPTY=%x",
+		FIELD2VALUE(MAX77759_FG_FILTERCFG_NEMPTY, val));
+	i += SCNPRINTF(&buff[i], len - i, " NTEMP=%x",
+		FIELD2VALUE(MAX77759_FG_FILTERCFG_NTEMP, val));
+	i += SCNPRINTF(&buff[i], len - i, " NMIX=%x",
+		FIELD2VALUE(MAX77759_FG_FILTERCFG_NMIX, val));
+	i += SCNPRINTF(&buff[i], len - i, " NAVGCELL=%x",
+		FIELD2VALUE(MAX77759_FG_FILTERCFG_NAVGCELL, val));
+	i += SCNPRINTF(&buff[i], len - i, " NCURR=%x",
+		FIELD2VALUE(MAX77759_FG_FILTERCFG_NCURR, val));
+#else
+	buff[0] = 0;
+#endif
+	return buff;
+}
+
+/*
+ * RelaxCfg,0x2A,0b10000011001001,0x20c9
+ * LoadThr[6:0],,,,,,
+ */
+#define MAX77759_FG_RELAXCFG	0x2A
+
+#define MAX77759_FG_RELAXCFG_LOADTHR_SHIFT	9
+#define MAX77759_FG_RELAXCFG_LOADTHR_MASK	(0x7f << 9)
+#define MAX77759_FG_RELAXCFG_LOADTHR_CLEAR	(~(0x7f << 9))
+#define MAX77759_FG_RELAXCFG_DVTHR_SHIFT	4
+#define MAX77759_FG_RELAXCFG_DVTHR_MASK	(0xf << 4)
+#define MAX77759_FG_RELAXCFG_DVTHR_CLEAR	(~(0xf << 4))
+#define MAX77759_FG_RELAXCFG_DTTHR_SHIFT	0
+#define MAX77759_FG_RELAXCFG_DTTHR_MASK	(0xf << 0)
+#define MAX77759_FG_RELAXCFG_DTTHR_CLEAR	(~(0xf << 0))
+
+MAX77759_BFF(fg_relaxcfg_loadthr,15,9)
+MAX77759_BFF(fg_relaxcfg_dvthr,7,4)
+MAX77759_BFF(fg_relaxcfg_dtthr,3,0)
+static inline const char *
+max77759_fg_relaxcfg_cstr(char *buff, size_t len, int val)
+{
+#ifdef SCNPRINTF
+	int i = 0;
+
+	i += SCNPRINTF(&buff[i], len - i, " LOADTHR=%x",
+		FIELD2VALUE(MAX77759_FG_RELAXCFG_LOADTHR, val));
+	i += SCNPRINTF(&buff[i], len - i, " DVTHR=%x",
+		FIELD2VALUE(MAX77759_FG_RELAXCFG_DVTHR, val));
+	i += SCNPRINTF(&buff[i], len - i, " DTTHR=%x",
+		FIELD2VALUE(MAX77759_FG_RELAXCFG_DTTHR, val));
+#else
+	buff[0] = 0;
+#endif
+	return buff;
+}
+
+/*
+ * MiscCfg,0x2B,0b100111010000,0x9d0
+ * OopsFilter[3:0],,,,EnBi1,InitVFG,MixRate[4:3]
+ */
+#define MAX77759_FG_MISCCFG	0x2B
+#define MAX77759_FG_MISCCFG_ENBI1	(0x1 << 11)
+#define MAX77759_FG_MISCCFG_INITVFG	(0x1 << 10)
+#define MAX77759_FG_MISCCFG_RDFCLRN	(0x1 << 4)
+#define MAX77759_FG_MISCCFG_VTTL	(0x1 << 3)
+#define MAX77759_FG_MISCCFG_VEX	(0x1 << 2)
+
+#define MAX77759_FG_MISCCFG_OOPSFILTER_SHIFT	12
+#define MAX77759_FG_MISCCFG_OOPSFILTER_MASK	(0xf << 12)
+#define MAX77759_FG_MISCCFG_OOPSFILTER_CLEAR	(~(0xf << 12))
+#define MAX77759_FG_MISCCFG_ENBI1_SHIFT	11
+#define MAX77759_FG_MISCCFG_ENBI1_MASK	(0x1 << 11)
+#define MAX77759_FG_MISCCFG_ENBI1_CLEAR	(~(0x1 << 11))
+#define MAX77759_FG_MISCCFG_INITVFG_SHIFT	10
+#define MAX77759_FG_MISCCFG_INITVFG_MASK	(0x1 << 10)
+#define MAX77759_FG_MISCCFG_INITVFG_CLEAR	(~(0x1 << 10))
+#define MAX77759_FG_MISCCFG_MIXRATE_SHIFT	5
+#define MAX77759_FG_MISCCFG_MIXRATE_MASK	(0x1f << 5)
+#define MAX77759_FG_MISCCFG_MIXRATE_CLEAR	(~(0x1f << 5))
+#define MAX77759_FG_MISCCFG_RDFCLRN_SHIFT	4
+#define MAX77759_FG_MISCCFG_RDFCLRN_MASK	(0x1 << 4)
+#define MAX77759_FG_MISCCFG_RDFCLRN_CLEAR	(~(0x1 << 4))
+#define MAX77759_FG_MISCCFG_VTTL_SHIFT	3
+#define MAX77759_FG_MISCCFG_VTTL_MASK	(0x1 << 3)
+#define MAX77759_FG_MISCCFG_VTTL_CLEAR	(~(0x1 << 3))
+#define MAX77759_FG_MISCCFG_VEX_SHIFT	2
+#define MAX77759_FG_MISCCFG_VEX_MASK	(0x1 << 2)
+#define MAX77759_FG_MISCCFG_VEX_CLEAR	(~(0x1 << 2))
+#define MAX77759_FG_MISCCFG_SACFG_SHIFT	0
+#define MAX77759_FG_MISCCFG_SACFG_MASK	(0x3 << 0)
+#define MAX77759_FG_MISCCFG_SACFG_CLEAR	(~(0x3 << 0))
+
+MAX77759_BFF(fg_misccfg_oopsfilter,15,12)
+MAX77759_BFF(fg_misccfg_enbi1,11,11)
+MAX77759_BFF(fg_misccfg_initvfg,10,10)
+MAX77759_BFF(fg_misccfg_mixrate,9,5)
+MAX77759_BFF(fg_misccfg_rdfclrn,4,4)
+MAX77759_BFF(fg_misccfg_vttl,3,3)
+MAX77759_BFF(fg_misccfg_vex,2,2)
+MAX77759_BFF(fg_misccfg_sacfg,1,0)
+static inline const char *
+max77759_fg_misccfg_cstr(char *buff, size_t len, int val)
+{
+#ifdef SCNPRINTF
+	int i = 0;
+
+	i += SCNPRINTF(&buff[i], len - i, " OOPSFILTER=%x",
+		FIELD2VALUE(MAX77759_FG_MISCCFG_OOPSFILTER, val));
+	i += SCNPRINTF(&buff[i], len - i, " ENBI1=%x",
+		FIELD2VALUE(MAX77759_FG_MISCCFG_ENBI1, val));
+	i += SCNPRINTF(&buff[i], len - i, " INITVFG=%x",
+		FIELD2VALUE(MAX77759_FG_MISCCFG_INITVFG, val));
+	i += SCNPRINTF(&buff[i], len - i, " MIXRATE=%x",
+		FIELD2VALUE(MAX77759_FG_MISCCFG_MIXRATE, val));
+	i += SCNPRINTF(&buff[i], len - i, " RDFCLRN=%x",
+		FIELD2VALUE(MAX77759_FG_MISCCFG_RDFCLRN, val));
+	i += SCNPRINTF(&buff[i], len - i, " VTTL=%x",
+		FIELD2VALUE(MAX77759_FG_MISCCFG_VTTL, val));
+	i += SCNPRINTF(&buff[i], len - i, " VEX=%x",
+		FIELD2VALUE(MAX77759_FG_MISCCFG_VEX, val));
+	i += SCNPRINTF(&buff[i], len - i, " SACFG=%x",
+		FIELD2VALUE(MAX77759_FG_MISCCFG_SACFG, val));
+#else
+	buff[0] = 0;
+#endif
+	return buff;
+}
+
+/*
+ * TGain,0x2C,0b1110101110001101,0xeb8d
+ * TGAIN[15:8],,,,,,
+ */
+#define MAX77759_FG_TGAIN	0x2C
+
+/*
+ * TOff,0x2D,0b10000010101010,0x20aa
+ * TOFF[15:8],,,,,,
+ */
+#define MAX77759_FG_TOFF	0x2D
+
+/*
+ * CGain,0x2E,0b10000000000,0x400
+ * CGAIN[15:8],,,,,,
+ */
+#define MAX77759_FG_CGAIN	0x2E
+
+/*
+ * COff,0x2F,0b00000000,0x00
+ * COFF[15:8],,,,,,
+ */
+#define MAX77759_FG_COFF	0x2F
+
+/*
+ * dV_acc,0x30,0b10000000000,0x400
+ * dV_acc[15:8],,,,,,
+ */
+#define MAX77759_FG_DV_ACC	0x30
+
+/*
+ * dI_acc,0x31,0b11001000000,0x640
+ * dI_acc[15:8],,,,,,
+ */
+#define MAX77759_FG_DI_ACC	0x31
+
+/*
+ * QRTable20,0x32,0b101100000100,0xb04
+ * QRTable20[15:8],,,,,,
+ */
+#define MAX77759_FG_QRTABLE20	0x32
+
+/*
+ * AtTTF,0x33,0b1111111111111111,0xffff
+ * AtTTF[15:8],,,,,,
+ */
+#define MAX77759_FG_ATTTF	0x33
+
+/*
+ * TConvert,0x34,0b1011000000000,0x1600
+ * TConvert[15:8],,,,,,
+ */
+#define MAX77759_FG_TCONVERT	0x34
+
+/*
+ * FullCapRep,0x35,0b101110111000,0xbb8
+ * FullCapRep[15:8],,,,,,
+ */
+#define MAX77759_FG_FULLCAPREP	0x35
+
+/*
+ * IAvgEmpty,0x36,0b1111010001001000,0xf448
+ * Iavg_empty[15:8],,,,,,
+ */
+#define MAX77759_FG_IAVGEMPTY	0x36
+
+/*
+ * FCTC,0x37,0b10111100000,0x5e0
+ * FCTC[15:8],,,,,,
+ */
+#define MAX77759_FG_FCTC	0x37
+
+/*
+ * RComp0,0x38,0b01110000,0x70
+ * SPR_15_8[7:0],,,,,,
+ */
+#define MAX77759_FG_RCOMP0	0x38
+
+#define MAX77759_FG_RCOMP0_SPR_15_8_SHIFT	8
+#define MAX77759_FG_RCOMP0_SPR_15_8_MASK	(0xff << 8)
+#define MAX77759_FG_RCOMP0_SPR_15_8_CLEAR	(~(0xff << 8))
+#define MAX77759_FG_RCOMP0_RCOMP0_SHIFT	0
+#define MAX77759_FG_RCOMP0_RCOMP0_MASK	(0xff << 0)
+#define MAX77759_FG_RCOMP0_RCOMP0_CLEAR	(~(0xff << 0))
+
+MAX77759_BFF(fg_rcomp0_spr_15_8,15,8)
+MAX77759_BFF(fg_rcomp0_rcomp0,7,0)
+static inline const char *
+max77759_fg_rcomp0_cstr(char *buff, size_t len, int val)
+{
+#ifdef SCNPRINTF
+	int i = 0;
+
+	i += SCNPRINTF(&buff[i], len - i, " SPR_15_8=%x",
+		FIELD2VALUE(MAX77759_FG_RCOMP0_SPR_15_8, val));
+	i += SCNPRINTF(&buff[i], len - i, " RCOMP0=%x",
+		FIELD2VALUE(MAX77759_FG_RCOMP0_RCOMP0, val));
+#else
+	buff[0] = 0;
+#endif
+	return buff;
+}
+
+/*
+ * TempCo,0x39,0b10011000111101,0x263d
+ * TempCoHot[7:0],,,,,,
+ */
+#define MAX77759_FG_TEMPCO	0x39
+
+#define MAX77759_FG_TEMPCO_TEMPCOHOT_SHIFT	8
+#define MAX77759_FG_TEMPCO_TEMPCOHOT_MASK	(0xff << 8)
+#define MAX77759_FG_TEMPCO_TEMPCOHOT_CLEAR	(~(0xff << 8))
+#define MAX77759_FG_TEMPCO_TEMPCOCOLD_SHIFT	0
+#define MAX77759_FG_TEMPCO_TEMPCOCOLD_MASK	(0xff << 0)
+#define MAX77759_FG_TEMPCO_TEMPCOCOLD_CLEAR	(~(0xff << 0))
+
+MAX77759_BFF(fg_tempco_tempcohot,15,8)
+MAX77759_BFF(fg_tempco_tempcocold,7,0)
+static inline const char *
+max77759_fg_tempco_cstr(char *buff, size_t len, int val)
+{
+#ifdef SCNPRINTF
+	int i = 0;
+
+	i += SCNPRINTF(&buff[i], len - i, " TEMPCOHOT=%x",
+		FIELD2VALUE(MAX77759_FG_TEMPCO_TEMPCOHOT, val));
+	i += SCNPRINTF(&buff[i], len - i, " TEMPCOCOLD=%x",
+		FIELD2VALUE(MAX77759_FG_TEMPCO_TEMPCOCOLD, val));
+#else
+	buff[0] = 0;
+#endif
+	return buff;
+}
+
+/*
+ * VEmpty,0x3A,0b1010010101100001,0xa561
+ * V_Empty[8:1],,,,,,
+ */
+#define MAX77759_FG_VEMPTY	0x3A
+
+#define MAX77759_FG_VEMPTY_V_EMPTY_SHIFT	8
+#define MAX77759_FG_VEMPTY_V_EMPTY_MASK	(0xff << 8)
+#define MAX77759_FG_VEMPTY_V_EMPTY_CLEAR	(~(0xff << 8))
+#define MAX77759_FG_VEMPTY_V_RECOVER_SHIFT	1
+#define MAX77759_FG_VEMPTY_V_RECOVER_MASK	(0x7f << 1)
+#define MAX77759_FG_VEMPTY_V_RECOVER_CLEAR	(~(0x7f << 1))
+
+MAX77759_BFF(fg_vempty_v_empty,15,8)
+MAX77759_BFF(fg_vempty_v_recover,7,1)
+static inline const char *
+max77759_fg_vempty_cstr(char *buff, size_t len, int val)
+{
+#ifdef SCNPRINTF
+	int i = 0;
+
+	i += SCNPRINTF(&buff[i], len - i, " V_EMPTY=%x",
+		FIELD2VALUE(MAX77759_FG_VEMPTY_V_EMPTY, val));
+	i += SCNPRINTF(&buff[i], len - i, " V_RECOVER=%x",
+		FIELD2VALUE(MAX77759_FG_VEMPTY_V_RECOVER, val));
+#else
+	buff[0] = 0;
+#endif
+	return buff;
+}
+
+/*
+ * AvgCurrent0,0x3B,0b111111111111111,0x7fff
+ * AvgCurrent0[15:8],,,,,,
+ */
+#define MAX77759_FG_AVGCURRENT0	0x3B
+
+/*
+ * TaskPeriod,0x3C,0b1011010000000,0x1680
+ * TaskPeriod[15:8],,,,,,
+ */
+#define MAX77759_FG_TASKPERIOD	0x3C
+
+/*
+ * FStat,0x3D,0b00000001,0x01
+ * xBr,RDF,tmode,DeBn,xBi,Relck,RelDt
+ */
+#define MAX77759_FG_FSTAT	0x3D
+#define MAX77759_FG_FSTAT_XBR	(0x1 << 15)
+#define MAX77759_FG_FSTAT_RDF	(0x1 << 14)
+#define MAX77759_FG_FSTAT_TMODE	(0x1 << 13)
+#define MAX77759_FG_FSTAT_DEBN	(0x1 << 12)
+#define MAX77759_FG_FSTAT_XBI	(0x1 << 11)
+#define MAX77759_FG_FSTAT_RELCK	(0x1 << 10)
+#define MAX77759_FG_FSTAT_RELDT	(0x1 << 9)
+#define MAX77759_FG_FSTAT_EDET	(0x1 << 8)
+#define MAX77759_FG_FSTAT_FQ	(0x1 << 7)
+#define MAX77759_FG_FSTAT_RELDT2	(0x1 << 6)
+#define MAX77759_FG_FSTAT_TIMER_START	(0x1 << 5)
+#define MAX77759_FG_FSTAT_XBST	(0x1 << 4)
+#define MAX77759_FG_FSTAT_ACCEN	(0x1 << 3)
+#define MAX77759_FG_FSTAT_WK	(0x1 << 2)
+#define MAX77759_FG_FSTAT_LDMDL	(0x1 << 1)
+#define MAX77759_FG_FSTAT_DNR	(0x1 << 0)
+
+#define MAX77759_FG_FSTAT_XBR_SHIFT	15
+#define MAX77759_FG_FSTAT_XBR_MASK	(0x1 << 15)
+#define MAX77759_FG_FSTAT_XBR_CLEAR	(~(0x1 << 15))
+#define MAX77759_FG_FSTAT_RDF_SHIFT	14
+#define MAX77759_FG_FSTAT_RDF_MASK	(0x1 << 14)
+#define MAX77759_FG_FSTAT_RDF_CLEAR	(~(0x1 << 14))
+#define MAX77759_FG_FSTAT_TMODE_SHIFT	13
+#define MAX77759_FG_FSTAT_TMODE_MASK	(0x1 << 13)
+#define MAX77759_FG_FSTAT_TMODE_CLEAR	(~(0x1 << 13))
+#define MAX77759_FG_FSTAT_DEBN_SHIFT	12
+#define MAX77759_FG_FSTAT_DEBN_MASK	(0x1 << 12)
+#define MAX77759_FG_FSTAT_DEBN_CLEAR	(~(0x1 << 12))
+#define MAX77759_FG_FSTAT_XBI_SHIFT	11
+#define MAX77759_FG_FSTAT_XBI_MASK	(0x1 << 11)
+#define MAX77759_FG_FSTAT_XBI_CLEAR	(~(0x1 << 11))
+#define MAX77759_FG_FSTAT_RELCK_SHIFT	10
+#define MAX77759_FG_FSTAT_RELCK_MASK	(0x1 << 10)
+#define MAX77759_FG_FSTAT_RELCK_CLEAR	(~(0x1 << 10))
+#define MAX77759_FG_FSTAT_RELDT_SHIFT	9
+#define MAX77759_FG_FSTAT_RELDT_MASK	(0x1 << 9)
+#define MAX77759_FG_FSTAT_RELDT_CLEAR	(~(0x1 << 9))
+#define MAX77759_FG_FSTAT_EDET_SHIFT	8
+#define MAX77759_FG_FSTAT_EDET_MASK	(0x1 << 8)
+#define MAX77759_FG_FSTAT_EDET_CLEAR	(~(0x1 << 8))
+#define MAX77759_FG_FSTAT_FQ_SHIFT	7
+#define MAX77759_FG_FSTAT_FQ_MASK	(0x1 << 7)
+#define MAX77759_FG_FSTAT_FQ_CLEAR	(~(0x1 << 7))
+#define MAX77759_FG_FSTAT_RELDT2_SHIFT	6
+#define MAX77759_FG_FSTAT_RELDT2_MASK	(0x1 << 6)
+#define MAX77759_FG_FSTAT_RELDT2_CLEAR	(~(0x1 << 6))
+#define MAX77759_FG_FSTAT_TIMER_START_SHIFT	5
+#define MAX77759_FG_FSTAT_TIMER_START_MASK	(0x1 << 5)
+#define MAX77759_FG_FSTAT_TIMER_START_CLEAR	(~(0x1 << 5))
+#define MAX77759_FG_FSTAT_XBST_SHIFT	4
+#define MAX77759_FG_FSTAT_XBST_MASK	(0x1 << 4)
+#define MAX77759_FG_FSTAT_XBST_CLEAR	(~(0x1 << 4))
+#define MAX77759_FG_FSTAT_ACCEN_SHIFT	3
+#define MAX77759_FG_FSTAT_ACCEN_MASK	(0x1 << 3)
+#define MAX77759_FG_FSTAT_ACCEN_CLEAR	(~(0x1 << 3))
+#define MAX77759_FG_FSTAT_WK_SHIFT	2
+#define MAX77759_FG_FSTAT_WK_MASK	(0x1 << 2)
+#define MAX77759_FG_FSTAT_WK_CLEAR	(~(0x1 << 2))
+#define MAX77759_FG_FSTAT_LDMDL_SHIFT	1
+#define MAX77759_FG_FSTAT_LDMDL_MASK	(0x1 << 1)
+#define MAX77759_FG_FSTAT_LDMDL_CLEAR	(~(0x1 << 1))
+#define MAX77759_FG_FSTAT_DNR_SHIFT	0
+#define MAX77759_FG_FSTAT_DNR_MASK	(0x1 << 0)
+#define MAX77759_FG_FSTAT_DNR_CLEAR	(~(0x1 << 0))
+
+MAX77759_BFF(fg_fstat_xbr,15,15)
+MAX77759_BFF(fg_fstat_rdf,14,14)
+MAX77759_BFF(fg_fstat_tmode,13,13)
+MAX77759_BFF(fg_fstat_debn,12,12)
+MAX77759_BFF(fg_fstat_xbi,11,11)
+MAX77759_BFF(fg_fstat_relck,10,10)
+MAX77759_BFF(fg_fstat_reldt,9,9)
+MAX77759_BFF(fg_fstat_edet,8,8)
+MAX77759_BFF(fg_fstat_fq,7,7)
+MAX77759_BFF(fg_fstat_reldt2,6,6)
+MAX77759_BFF(fg_fstat_timer_start,5,5)
+MAX77759_BFF(fg_fstat_xbst,4,4)
+MAX77759_BFF(fg_fstat_accen,3,3)
+MAX77759_BFF(fg_fstat_wk,2,2)
+MAX77759_BFF(fg_fstat_ldmdl,1,1)
+MAX77759_BFF(fg_fstat_dnr,0,0)
+static inline const char *
+max77759_fg_fstat_cstr(char *buff, size_t len, int val)
+{
+#ifdef SCNPRINTF
+	int i = 0;
+
+	i += SCNPRINTF(&buff[i], len - i, " XBR=%x",
+		FIELD2VALUE(MAX77759_FG_FSTAT_XBR, val));
+	i += SCNPRINTF(&buff[i], len - i, " RDF=%x",
+		FIELD2VALUE(MAX77759_FG_FSTAT_RDF, val));
+	i += SCNPRINTF(&buff[i], len - i, " TMODE=%x",
+		FIELD2VALUE(MAX77759_FG_FSTAT_TMODE, val));
+	i += SCNPRINTF(&buff[i], len - i, " DEBN=%x",
+		FIELD2VALUE(MAX77759_FG_FSTAT_DEBN, val));
+	i += SCNPRINTF(&buff[i], len - i, " XBI=%x",
+		FIELD2VALUE(MAX77759_FG_FSTAT_XBI, val));
+	i += SCNPRINTF(&buff[i], len - i, " RELCK=%x",
+		FIELD2VALUE(MAX77759_FG_FSTAT_RELCK, val));
+	i += SCNPRINTF(&buff[i], len - i, " RELDT=%x",
+		FIELD2VALUE(MAX77759_FG_FSTAT_RELDT, val));
+	i += SCNPRINTF(&buff[i], len - i, " EDET=%x",
+		FIELD2VALUE(MAX77759_FG_FSTAT_EDET, val));
+	i += SCNPRINTF(&buff[i], len - i, " FQ=%x",
+		FIELD2VALUE(MAX77759_FG_FSTAT_FQ, val));
+	i += SCNPRINTF(&buff[i], len - i, " RELDT2=%x",
+		FIELD2VALUE(MAX77759_FG_FSTAT_RELDT2, val));
+	i += SCNPRINTF(&buff[i], len - i, " TIMER_START=%x",
+		FIELD2VALUE(MAX77759_FG_FSTAT_TIMER_START, val));
+	i += SCNPRINTF(&buff[i], len - i, " XBST=%x",
+		FIELD2VALUE(MAX77759_FG_FSTAT_XBST, val));
+	i += SCNPRINTF(&buff[i], len - i, " ACCEN=%x",
+		FIELD2VALUE(MAX77759_FG_FSTAT_ACCEN, val));
+	i += SCNPRINTF(&buff[i], len - i, " WK=%x",
+		FIELD2VALUE(MAX77759_FG_FSTAT_WK, val));
+	i += SCNPRINTF(&buff[i], len - i, " LDMDL=%x",
+		FIELD2VALUE(MAX77759_FG_FSTAT_LDMDL, val));
+	i += SCNPRINTF(&buff[i], len - i, " DNR=%x",
+		FIELD2VALUE(MAX77759_FG_FSTAT_DNR, val));
+#else
+	buff[0] = 0;
+#endif
+	return buff;
+}
+
+/*
+ * Timer,0x3E,0b00000000,0x00
+ * TIMER[15:8],,,,,,
+ */
+#define MAX77759_FG_TIMER	0x3E
+
+/*
+ * ShdnTimer,0x3F,0b1110000000000000,0xe000
+ * SHDN_THR[2:0],,,SHDNCTR[12:8],,,
+ */
+#define MAX77759_FG_SHDNTIMER	0x3F
+
+#define MAX77759_FG_SHDNTIMER_SHDN_THR_SHIFT	13
+#define MAX77759_FG_SHDNTIMER_SHDN_THR_MASK	(0x7 << 13)
+#define MAX77759_FG_SHDNTIMER_SHDN_THR_CLEAR	(~(0x7 << 13))
+#define MAX77759_FG_SHDNTIMER_SHDNCTR_SHIFT	0
+#define MAX77759_FG_SHDNTIMER_SHDNCTR_MASK	(0x1fff << 0)
+#define MAX77759_FG_SHDNTIMER_SHDNCTR_CLEAR	(~(0x1fff << 0))
+
+MAX77759_BFF(fg_shdntimer_shdn_thr,15,13)
+MAX77759_BFF(fg_shdntimer_shdnctr,12,0)
+static inline const char *
+max77759_fg_shdntimer_cstr(char *buff, size_t len, int val)
+{
+#ifdef SCNPRINTF
+	int i = 0;
+
+	i += SCNPRINTF(&buff[i], len - i, " SHDN_THR=%x",
+		FIELD2VALUE(MAX77759_FG_SHDNTIMER_SHDN_THR, val));
+	i += SCNPRINTF(&buff[i], len - i, " SHDNCTR=%x",
+		FIELD2VALUE(MAX77759_FG_SHDNTIMER_SHDNCTR, val));
+#else
+	buff[0] = 0;
+#endif
+	return buff;
+}
+
+/*
+ * THMHOT,0x40,0b11111111100,0x7fc
+ * VR[4:0],,,,,Vhys[2:0],
+ */
+#define MAX77759_FG_THMHOT	0x40
+
+#define MAX77759_FG_THMHOT_VR_SHIFT	11
+#define MAX77759_FG_THMHOT_VR_MASK	(0x1f << 11)
+#define MAX77759_FG_THMHOT_VR_CLEAR	(~(0x1f << 11))
+#define MAX77759_FG_THMHOT_VHYS_SHIFT	8
+#define MAX77759_FG_THMHOT_VHYS_MASK	(0x7 << 8)
+#define MAX77759_FG_THMHOT_VHYS_CLEAR	(~(0x7 << 8))
+#define MAX77759_FG_THMHOT_TR_SHIFT	3
+#define MAX77759_FG_THMHOT_TR_MASK	(0x1f << 3)
+#define MAX77759_FG_THMHOT_TR_CLEAR	(~(0x1f << 3))
+#define MAX77759_FG_THMHOT_THYS_SHIFT	0
+#define MAX77759_FG_THMHOT_THYS_MASK	(0x7 << 0)
+#define MAX77759_FG_THMHOT_THYS_CLEAR	(~(0x7 << 0))
+
+MAX77759_BFF(fg_thmhot_vr,15,11)
+MAX77759_BFF(fg_thmhot_vhys,10,8)
+MAX77759_BFF(fg_thmhot_tr,7,3)
+MAX77759_BFF(fg_thmhot_thys,2,0)
+static inline const char *
+max77759_fg_thmhot_cstr(char *buff, size_t len, int val)
+{
+#ifdef SCNPRINTF
+	int i = 0;
+
+	i += SCNPRINTF(&buff[i], len - i, " VR=%x",
+		FIELD2VALUE(MAX77759_FG_THMHOT_VR, val));
+	i += SCNPRINTF(&buff[i], len - i, " VHYS=%x",
+		FIELD2VALUE(MAX77759_FG_THMHOT_VHYS, val));
+	i += SCNPRINTF(&buff[i], len - i, " TR=%x",
+		FIELD2VALUE(MAX77759_FG_THMHOT_TR, val));
+	i += SCNPRINTF(&buff[i], len - i, " THYS=%x",
+		FIELD2VALUE(MAX77759_FG_THMHOT_THYS, val));
+#else
+	buff[0] = 0;
+#endif
+	return buff;
+}
+
+/*
+ * CTESample,0x41,0b00000000,0x00
+ * CTESample[15:8],,,,,,
+ */
+#define MAX77759_FG_CTESAMPLE	0x41
+
+/*
+ * QRTable30,0x42,0b100010000101,0x885
+ * QRTable30[15:8],,,,,,
+ */
+#define MAX77759_FG_QRTABLE30	0x42
+
+/*
+ * ISys,0x43,0b00000000,0x00
+ * ISYS[15:8],,,,,,
+ */
+#define MAX77759_FG_ISYS	0x43
+
+/*
+ * AvgVCell0,0x44,0b1000000000000000,0x8000
+ * AvgVCELL0[15:8],,,,,,
+ */
+#define MAX77759_FG_AVGVCELL0	0x44
+
+/*
+ * dQAcc,0x45,0b00010111,0x17
+ * dQacc[15:8],,,,,,
+ */
+#define MAX77759_FG_DQACC	0x45
+
+/*
+ * dPAcc,0x46,0b110010000,0x190
+ * dPacc[15:8],,,,,,
+ */
+#define MAX77759_FG_DPACC	0x46
+
+/*
+ * RlxSOC,0x47,0b00000000,0x00
+ * RlxSOC[15:8],,,,,,
+ */
+#define MAX77759_FG_RLXSOC	0x47
+
+/*
+ * VFSOC0,0x48,0b11001000000000,0x3200
+ * VFSOC0[15:8],,,,,,
+ */
+#define MAX77759_FG_VFSOC0	0x48
+
+/*
+ * ConvgCfg,0x49,0b10001001000001,0x2241
+ * RepLow[3:0],,,,VoltLowOff[4:1],,
+ */
+#define MAX77759_FG_CONVGCFG	0x49
+
+#define MAX77759_FG_CONVGCFG_REPLOW_SHIFT	12
+#define MAX77759_FG_CONVGCFG_REPLOW_MASK	(0xf << 12)
+#define MAX77759_FG_CONVGCFG_REPLOW_CLEAR	(~(0xf << 12))
+#define MAX77759_FG_CONVGCFG_VOLTLOWOFF_SHIFT	8
+#define MAX77759_FG_CONVGCFG_VOLTLOWOFF_MASK	(0xf << 8)
+#define MAX77759_FG_CONVGCFG_VOLTLOWOFF_CLEAR	(~(0xf << 8))
+#define MAX77759_FG_CONVGCFG_MINSLOPEX_SHIFT	4
+#define MAX77759_FG_CONVGCFG_MINSLOPEX_MASK	(0xf << 4)
+#define MAX77759_FG_CONVGCFG_MINSLOPEX_CLEAR	(~(0xf << 4))
+#define MAX77759_FG_CONVGCFG_REPL_PER_STAGE_SHIFT	1
+#define MAX77759_FG_CONVGCFG_REPL_PER_STAGE_MASK	(0x7 << 1)
+#define MAX77759_FG_CONVGCFG_REPL_PER_STAGE_CLEAR	(~(0x7 << 1))
+
+MAX77759_BFF(fg_convgcfg_replow,15,12)
+MAX77759_BFF(fg_convgcfg_voltlowoff,11,8)
+MAX77759_BFF(fg_convgcfg_minslopex,7,4)
+MAX77759_BFF(fg_convgcfg_repl_per_stage,3,1)
+static inline const char *
+max77759_fg_convgcfg_cstr(char *buff, size_t len, int val)
+{
+#ifdef SCNPRINTF
+	int i = 0;
+
+	i += SCNPRINTF(&buff[i], len - i, " REPLOW=%x",
+		FIELD2VALUE(MAX77759_FG_CONVGCFG_REPLOW, val));
+	i += SCNPRINTF(&buff[i], len - i, " VOLTLOWOFF=%x",
+		FIELD2VALUE(MAX77759_FG_CONVGCFG_VOLTLOWOFF, val));
+	i += SCNPRINTF(&buff[i], len - i, " MINSLOPEX=%x",
+		FIELD2VALUE(MAX77759_FG_CONVGCFG_MINSLOPEX, val));
+	i += SCNPRINTF(&buff[i], len - i, " REPL_PER_STAGE=%x",
+		FIELD2VALUE(MAX77759_FG_CONVGCFG_REPL_PER_STAGE, val));
+#else
+	buff[0] = 0;
+#endif
+	return buff;
+}
+
+/*
+ * VFRemCap,0x4A,0b10111011100,0x5dc
+ * VFRemCap[15:8],,,,,,
+ */
+#define MAX77759_FG_VFREMCAP	0x4A
+
+/*
+ * AvgISys,0x4B,0b00000000,0x00
+ * AVGISYS[15:8],,,,,,
+ */
+#define MAX77759_FG_AVGISYS	0x4B
+
+/*
+ * QH0,0x4C,0b00000000,0x00
+ * QH0[15:8],,,,,,
+ */
+#define MAX77759_FG_QH0	0x4C
+
+/*
+ * QH,0x4D,0b00000000,0x00
+ * QH[15:8],,,,,,
+ */
+#define MAX77759_FG_QH	0x4D
+
+/*
+ * QL,0x4E,0b00000000,0x00
+ * QL[15:8],,,,,,
+ */
+#define MAX77759_FG_QL	0x4E
+
+/*
+ * MixAtFull,0x4F,0b101110111000,0xbb8
+ * MixAtFull[15:8],,,,,,
+ */
+#define MAX77759_FG_MIXATFULL	0x4F
+
+/*
+ * Status2,0xB0,0b00000000,0x00
+ * SPR_15_6[9:2],,,,,,
+ */
+#define MAX77759_FG_STATUS2	0xB0
+#define MAX77759_FG_STATUS2_FULLDET	(0x1 << 5)
+#define MAX77759_FG_STATUS2_HIB	(0x1 << 1)
+#define MAX77759_FG_STATUS2_SPR_0	(0x1 << 0)
+
+#define MAX77759_FG_STATUS2_SPR_15_6_SHIFT	6
+#define MAX77759_FG_STATUS2_SPR_15_6_MASK	(0x3ff << 6)
+#define MAX77759_FG_STATUS2_SPR_15_6_CLEAR	(~(0x3ff << 6))
+#define MAX77759_FG_STATUS2_FULLDET_SHIFT	5
+#define MAX77759_FG_STATUS2_FULLDET_MASK	(0x1 << 5)
+#define MAX77759_FG_STATUS2_FULLDET_CLEAR	(~(0x1 << 5))
+#define MAX77759_FG_STATUS2_SPR_4_2_SHIFT	2
+#define MAX77759_FG_STATUS2_SPR_4_2_MASK	(0x7 << 2)
+#define MAX77759_FG_STATUS2_SPR_4_2_CLEAR	(~(0x7 << 2))
+#define MAX77759_FG_STATUS2_HIB_SHIFT	1
+#define MAX77759_FG_STATUS2_HIB_MASK	(0x1 << 1)
+#define MAX77759_FG_STATUS2_HIB_CLEAR	(~(0x1 << 1))
+#define MAX77759_FG_STATUS2_SPR_0_SHIFT	0
+#define MAX77759_FG_STATUS2_SPR_0_MASK	(0x1 << 0)
+#define MAX77759_FG_STATUS2_SPR_0_CLEAR	(~(0x1 << 0))
+
+MAX77759_BFF(fg_status2_spr_15_6,15,6)
+MAX77759_BFF(fg_status2_fulldet,5,5)
+MAX77759_BFF(fg_status2_spr_4_2,4,2)
+MAX77759_BFF(fg_status2_hib,1,1)
+MAX77759_BFF(fg_status2_spr_0,0,0)
+static inline const char *
+max77759_fg_status2_cstr(char *buff, size_t len, int val)
+{
+#ifdef SCNPRINTF
+	int i = 0;
+
+	i += SCNPRINTF(&buff[i], len - i, " SPR_15_6=%x",
+		FIELD2VALUE(MAX77759_FG_STATUS2_SPR_15_6, val));
+	i += SCNPRINTF(&buff[i], len - i, " FULLDET=%x",
+		FIELD2VALUE(MAX77759_FG_STATUS2_FULLDET, val));
+	i += SCNPRINTF(&buff[i], len - i, " SPR_4_2=%x",
+		FIELD2VALUE(MAX77759_FG_STATUS2_SPR_4_2, val));
+	i += SCNPRINTF(&buff[i], len - i, " HIB=%x",
+		FIELD2VALUE(MAX77759_FG_STATUS2_HIB, val));
+	i += SCNPRINTF(&buff[i], len - i, " SPR_0=%x",
+		FIELD2VALUE(MAX77759_FG_STATUS2_SPR_0, val));
+#else
+	buff[0] = 0;
+#endif
+	return buff;
+}
+
+/*
+ * VSys,0xB1,0b00000000,0x00
+ * VSys[15:8],,,,,,
+ */
+#define MAX77759_FG_VSYS	0xB1
+
+/*
+ * TAlrtTh2,0xB2,0b111111110000000,0x7f80
+ * TempWarm[7:0],,,,,,
+ */
+#define MAX77759_FG_TALRTTH2	0xB2
+
+#define MAX77759_FG_TALRTTH2_TEMPWARM_SHIFT	8
+#define MAX77759_FG_TALRTTH2_TEMPWARM_MASK	(0xff << 8)
+#define MAX77759_FG_TALRTTH2_TEMPWARM_CLEAR	(~(0xff << 8))
+#define MAX77759_FG_TALRTTH2_TEMPCOOL_SHIFT	0
+#define MAX77759_FG_TALRTTH2_TEMPCOOL_MASK	(0xff << 0)
+#define MAX77759_FG_TALRTTH2_TEMPCOOL_CLEAR	(~(0xff << 0))
+
+MAX77759_BFF(fg_talrtth2_tempwarm,15,8)
+MAX77759_BFF(fg_talrtth2_tempcool,7,0)
+static inline const char *
+max77759_fg_talrtth2_cstr(char *buff, size_t len, int val)
+{
+#ifdef SCNPRINTF
+	int i = 0;
+
+	i += SCNPRINTF(&buff[i], len - i, " TEMPWARM=%x",
+		FIELD2VALUE(MAX77759_FG_TALRTTH2_TEMPWARM, val));
+	i += SCNPRINTF(&buff[i], len - i, " TEMPCOOL=%x",
+		FIELD2VALUE(MAX77759_FG_TALRTTH2_TEMPCOOL, val));
+#else
+	buff[0] = 0;
+#endif
+	return buff;
+}
+
+/*
+ * VByp,0xB3,0b00000000,0x00
+ * VByp[15:8],,,,,,
+ */
+#define MAX77759_FG_VBYP	0xB3
+
+/*
+ * IAlrtTh,0xB4,0b111111110000000,0x7f80
+ * ISYSOCP_TH[7:0],,,,,,
+ */
+#define MAX77759_FG_IALRTTH	0xB4
+
+#define MAX77759_FG_IALRTTH_ISYSOCP_TH_SHIFT	8
+#define MAX77759_FG_IALRTTH_ISYSOCP_TH_MASK	(0xff << 8)
+#define MAX77759_FG_IALRTTH_ISYSOCP_TH_CLEAR	(~(0xff << 8))
+#define MAX77759_FG_IALRTTH_IBATTMIN_TH_SHIFT	0
+#define MAX77759_FG_IALRTTH_IBATTMIN_TH_MASK	(0xff << 0)
+#define MAX77759_FG_IALRTTH_IBATTMIN_TH_CLEAR	(~(0xff << 0))
+
+MAX77759_BFF(fg_ialrtth_isysocp_th,15,8)
+MAX77759_BFF(fg_ialrtth_ibattmin_th,7,0)
+static inline const char *
+max77759_fg_ialrtth_cstr(char *buff, size_t len, int val)
+{
+#ifdef SCNPRINTF
+	int i = 0;
+
+	i += SCNPRINTF(&buff[i], len - i, " ISYSOCP_TH=%x",
+		FIELD2VALUE(MAX77759_FG_IALRTTH_ISYSOCP_TH, val));
+	i += SCNPRINTF(&buff[i], len - i, " IBATTMIN_TH=%x",
+		FIELD2VALUE(MAX77759_FG_IALRTTH_IBATTMIN_TH, val));
+#else
+	buff[0] = 0;
+#endif
+	return buff;
+}
+
+/*
+ * TTF_CFG,0xB5,0b00000101,0x05
+ * SPR_15_3[12:5],,,,,,
+ */
+#define MAX77759_FG_TTF_CFG	0xB5
+
+#define MAX77759_FG_TTF_CFG_SPR_15_3_SHIFT	3
+#define MAX77759_FG_TTF_CFG_SPR_15_3_MASK	(0x1fff << 3)
+#define MAX77759_FG_TTF_CFG_SPR_15_3_CLEAR	(~(0x1fff << 3))
+#define MAX77759_FG_TTF_CFG_TTF_CFG_SHIFT	0
+#define MAX77759_FG_TTF_CFG_TTF_CFG_MASK	(0x7 << 0)
+#define MAX77759_FG_TTF_CFG_TTF_CFG_CLEAR	(~(0x7 << 0))
+
+MAX77759_BFF(fg_ttf_cfg_spr_15_3,15,3)
+MAX77759_BFF(fg_ttf_cfg_ttf_cfg,2,0)
+static inline const char *
+max77759_fg_ttf_cfg_cstr(char *buff, size_t len, int val)
+{
+#ifdef SCNPRINTF
+	int i = 0;
+
+	i += SCNPRINTF(&buff[i], len - i, " SPR_15_3=%x",
+		FIELD2VALUE(MAX77759_FG_TTF_CFG_SPR_15_3, val));
+	i += SCNPRINTF(&buff[i], len - i, " TTF_CFG=%x",
+		FIELD2VALUE(MAX77759_FG_TTF_CFG_TTF_CFG, val));
+#else
+	buff[0] = 0;
+#endif
+	return buff;
+}
+
+/*
+ * CV_MixCap,0xB6,0b100011001010,0x8ca
+ * CV_MixCap[15:8],,,,,,
+ */
+#define MAX77759_FG_CV_MIXCAP	0xB6
+
+/*
+ * CV_HalfTime,0xB7,0b101000000000,0xa00
+ * CV_Halftime[15:8],,,,,,
+ */
+#define MAX77759_FG_CV_HALFTIME	0xB7
+
+/*
+ * CGTempCo,0xB8,0b00000000,0x00
+ * CGTempCo[15:8],,,,,,
+ */
+#define MAX77759_FG_CGTEMPCO	0xB8
+
+/*
+ * Curve,0xB9,0b01101011,0x6b
+ * ECURVE[7:0],,,,,,
+ */
+#define MAX77759_FG_CURVE	0xB9
+
+#define MAX77759_FG_CURVE_ECURVE_SHIFT	8
+#define MAX77759_FG_CURVE_ECURVE_MASK	(0xff << 8)
+#define MAX77759_FG_CURVE_ECURVE_CLEAR	(~(0xff << 8))
+#define MAX77759_FG_CURVE_TCURVE_SHIFT	0
+#define MAX77759_FG_CURVE_TCURVE_MASK	(0xff << 0)
+#define MAX77759_FG_CURVE_TCURVE_CLEAR	(~(0xff << 0))
+
+MAX77759_BFF(fg_curve_ecurve,15,8)
+MAX77759_BFF(fg_curve_tcurve,7,0)
+static inline const char *
+max77759_fg_curve_cstr(char *buff, size_t len, int val)
+{
+#ifdef SCNPRINTF
+	int i = 0;
+
+	i += SCNPRINTF(&buff[i], len - i, " ECURVE=%x",
+		FIELD2VALUE(MAX77759_FG_CURVE_ECURVE, val));
+	i += SCNPRINTF(&buff[i], len - i, " TCURVE=%x",
+		FIELD2VALUE(MAX77759_FG_CURVE_TCURVE, val));
+#else
+	buff[0] = 0;
+#endif
+	return buff;
+}
+
+/*
+ * HibCfg,0xBA,0b100100001100,0x90c
+ * EnHib,HibEnterTime[2:0],,,HibThreshold[3:0],,
+ */
+#define MAX77759_FG_HIBCFG	0xBA
+#define MAX77759_FG_HIBCFG_ENHIB	(0x1 << 15)
+
+#define MAX77759_FG_HIBCFG_ENHIB_SHIFT	15
+#define MAX77759_FG_HIBCFG_ENHIB_MASK	(0x1 << 15)
+#define MAX77759_FG_HIBCFG_ENHIB_CLEAR	(~(0x1 << 15))
+#define MAX77759_FG_HIBCFG_HIBENTERTIME_SHIFT	12
+#define MAX77759_FG_HIBCFG_HIBENTERTIME_MASK	(0x7 << 12)
+#define MAX77759_FG_HIBCFG_HIBENTERTIME_CLEAR	(~(0x7 << 12))
+#define MAX77759_FG_HIBCFG_HIBTHRESHOLD_SHIFT	8
+#define MAX77759_FG_HIBCFG_HIBTHRESHOLD_MASK	(0xf << 8)
+#define MAX77759_FG_HIBCFG_HIBTHRESHOLD_CLEAR	(~(0xf << 8))
+#define MAX77759_FG_HIBCFG_SPR_7_5_SHIFT	5
+#define MAX77759_FG_HIBCFG_SPR_7_5_MASK	(0x7 << 5)
+#define MAX77759_FG_HIBCFG_SPR_7_5_CLEAR	(~(0x7 << 5))
+#define MAX77759_FG_HIBCFG_HIBEXITTIME_SHIFT	3
+#define MAX77759_FG_HIBCFG_HIBEXITTIME_MASK	(0x3 << 3)
+#define MAX77759_FG_HIBCFG_HIBEXITTIME_CLEAR	(~(0x3 << 3))
+#define MAX77759_FG_HIBCFG_HIBSCALAR_SHIFT	0
+#define MAX77759_FG_HIBCFG_HIBSCALAR_MASK	(0x7 << 0)
+#define MAX77759_FG_HIBCFG_HIBSCALAR_CLEAR	(~(0x7 << 0))
+
+MAX77759_BFF(fg_hibcfg_enhib,15,15)
+MAX77759_BFF(fg_hibcfg_hibentertime,14,12)
+MAX77759_BFF(fg_hibcfg_hibthreshold,11,8)
+MAX77759_BFF(fg_hibcfg_spr_7_5,7,5)
+MAX77759_BFF(fg_hibcfg_hibexittime,4,3)
+MAX77759_BFF(fg_hibcfg_hibscalar,2,0)
+static inline const char *
+max77759_fg_hibcfg_cstr(char *buff, size_t len, int val)
+{
+#ifdef SCNPRINTF
+	int i = 0;
+
+	i += SCNPRINTF(&buff[i], len - i, " ENHIB=%x",
+		FIELD2VALUE(MAX77759_FG_HIBCFG_ENHIB, val));
+	i += SCNPRINTF(&buff[i], len - i, " HIBENTERTIME=%x",
+		FIELD2VALUE(MAX77759_FG_HIBCFG_HIBENTERTIME, val));
+	i += SCNPRINTF(&buff[i], len - i, " HIBTHRESHOLD=%x",
+		FIELD2VALUE(MAX77759_FG_HIBCFG_HIBTHRESHOLD, val));
+	i += SCNPRINTF(&buff[i], len - i, " SPR_7_5=%x",
+		FIELD2VALUE(MAX77759_FG_HIBCFG_SPR_7_5, val));
+	i += SCNPRINTF(&buff[i], len - i, " HIBEXITTIME=%x",
+		FIELD2VALUE(MAX77759_FG_HIBCFG_HIBEXITTIME, val));
+	i += SCNPRINTF(&buff[i], len - i, " HIBSCALAR=%x",
+		FIELD2VALUE(MAX77759_FG_HIBCFG_HIBSCALAR, val));
+#else
+	buff[0] = 0;
+#endif
+	return buff;
+}
+
+/*
+ * Config2,0xBB,0b01010000,0x50
+ * SPR_15_11[4:0],,,,,FCThmHot,ThmHotEn
+ */
+#define MAX77759_FG_CONFIG2	0xBB
+#define MAX77759_FG_CONFIG2_FCTHMHOT	(0x1 << 10)
+#define MAX77759_FG_CONFIG2_THMHOTEN	(0x1 << 9)
+#define MAX77759_FG_CONFIG2_THMHOTALRTEN	(0x1 << 8)
+#define MAX77759_FG_CONFIG2_DSOCEN	(0x1 << 7)
+#define MAX77759_FG_CONFIG2_TALRTEN	(0x1 << 6)
+#define MAX77759_FG_CONFIG2_LDMDL	(0x1 << 5)
+#define MAX77759_FG_CONFIG2_OCVQEN	(0x1 << 4)
+
+#define MAX77759_FG_CONFIG2_SPR_15_11_SHIFT	11
+#define MAX77759_FG_CONFIG2_SPR_15_11_MASK	(0x1f << 11)
+#define MAX77759_FG_CONFIG2_SPR_15_11_CLEAR	(~(0x1f << 11))
+#define MAX77759_FG_CONFIG2_FCTHMHOT_SHIFT	10
+#define MAX77759_FG_CONFIG2_FCTHMHOT_MASK	(0x1 << 10)
+#define MAX77759_FG_CONFIG2_FCTHMHOT_CLEAR	(~(0x1 << 10))
+#define MAX77759_FG_CONFIG2_THMHOTEN_SHIFT	9
+#define MAX77759_FG_CONFIG2_THMHOTEN_MASK	(0x1 << 9)
+#define MAX77759_FG_CONFIG2_THMHOTEN_CLEAR	(~(0x1 << 9))
+#define MAX77759_FG_CONFIG2_THMHOTALRTEN_SHIFT	8
+#define MAX77759_FG_CONFIG2_THMHOTALRTEN_MASK	(0x1 << 8)
+#define MAX77759_FG_CONFIG2_THMHOTALRTEN_CLEAR	(~(0x1 << 8))
+#define MAX77759_FG_CONFIG2_DSOCEN_SHIFT	7
+#define MAX77759_FG_CONFIG2_DSOCEN_MASK	(0x1 << 7)
+#define MAX77759_FG_CONFIG2_DSOCEN_CLEAR	(~(0x1 << 7))
+#define MAX77759_FG_CONFIG2_TALRTEN_SHIFT	6
+#define MAX77759_FG_CONFIG2_TALRTEN_MASK	(0x1 << 6)
+#define MAX77759_FG_CONFIG2_TALRTEN_CLEAR	(~(0x1 << 6))
+#define MAX77759_FG_CONFIG2_LDMDL_SHIFT	5
+#define MAX77759_FG_CONFIG2_LDMDL_MASK	(0x1 << 5)
+#define MAX77759_FG_CONFIG2_LDMDL_CLEAR	(~(0x1 << 5))
+#define MAX77759_FG_CONFIG2_OCVQEN_SHIFT	4
+#define MAX77759_FG_CONFIG2_OCVQEN_MASK	(0x1 << 4)
+#define MAX77759_FG_CONFIG2_OCVQEN_CLEAR	(~(0x1 << 4))
+#define MAX77759_FG_CONFIG2_ISYSNCURR_SHIFT	0
+#define MAX77759_FG_CONFIG2_ISYSNCURR_MASK	(0xf << 0)
+#define MAX77759_FG_CONFIG2_ISYSNCURR_CLEAR	(~(0xf << 0))
+
+MAX77759_BFF(fg_config2_spr_15_11,15,11)
+MAX77759_BFF(fg_config2_fcthmhot,10,10)
+MAX77759_BFF(fg_config2_thmhoten,9,9)
+MAX77759_BFF(fg_config2_thmhotalrten,8,8)
+MAX77759_BFF(fg_config2_dsocen,7,7)
+MAX77759_BFF(fg_config2_talrten,6,6)
+MAX77759_BFF(fg_config2_ldmdl,5,5)
+MAX77759_BFF(fg_config2_ocvqen,4,4)
+MAX77759_BFF(fg_config2_isysncurr,3,0)
+static inline const char *
+max77759_fg_config2_cstr(char *buff, size_t len, int val)
+{
+#ifdef SCNPRINTF
+	int i = 0;
+
+	i += SCNPRINTF(&buff[i], len - i, " SPR_15_11=%x",
+		FIELD2VALUE(MAX77759_FG_CONFIG2_SPR_15_11, val));
+	i += SCNPRINTF(&buff[i], len - i, " FCTHMHOT=%x",
+		FIELD2VALUE(MAX77759_FG_CONFIG2_FCTHMHOT, val));
+	i += SCNPRINTF(&buff[i], len - i, " THMHOTEN=%x",
+		FIELD2VALUE(MAX77759_FG_CONFIG2_THMHOTEN, val));
+	i += SCNPRINTF(&buff[i], len - i, " THMHOTALRTEN=%x",
+		FIELD2VALUE(MAX77759_FG_CONFIG2_THMHOTALRTEN, val));
+	i += SCNPRINTF(&buff[i], len - i, " DSOCEN=%x",
+		FIELD2VALUE(MAX77759_FG_CONFIG2_DSOCEN, val));
+	i += SCNPRINTF(&buff[i], len - i, " TALRTEN=%x",
+		FIELD2VALUE(MAX77759_FG_CONFIG2_TALRTEN, val));
+	i += SCNPRINTF(&buff[i], len - i, " LDMDL=%x",
+		FIELD2VALUE(MAX77759_FG_CONFIG2_LDMDL, val));
+	i += SCNPRINTF(&buff[i], len - i, " OCVQEN=%x",
+		FIELD2VALUE(MAX77759_FG_CONFIG2_OCVQEN, val));
+	i += SCNPRINTF(&buff[i], len - i, " ISYSNCURR=%x",
+		FIELD2VALUE(MAX77759_FG_CONFIG2_ISYSNCURR, val));
+#else
+	buff[0] = 0;
+#endif
+	return buff;
+}
+
+/*
+ * VRipple,0xBC,0b00000000,0x00
+ * Vripple[15:8],,,,,,
+ */
+#define MAX77759_FG_VRIPPLE	0xBC
+
+/*
+ * RippleCfg,0xBD,0b1000000100,0x204
+ * kDV[12:5],,,,,,
+ */
+#define MAX77759_FG_RIPPLECFG	0xBD
+
+#define MAX77759_FG_RIPPLECFG_KDV_SHIFT	3
+#define MAX77759_FG_RIPPLECFG_KDV_MASK	(0x1fff << 3)
+#define MAX77759_FG_RIPPLECFG_KDV_CLEAR	(~(0x1fff << 3))
+#define MAX77759_FG_RIPPLECFG_NR_SHIFT	0
+#define MAX77759_FG_RIPPLECFG_NR_MASK	(0x7 << 0)
+#define MAX77759_FG_RIPPLECFG_NR_CLEAR	(~(0x7 << 0))
+
+MAX77759_BFF(fg_ripplecfg_kdv,15,3)
+MAX77759_BFF(fg_ripplecfg_nr,2,0)
+static inline const char *
+max77759_fg_ripplecfg_cstr(char *buff, size_t len, int val)
+{
+#ifdef SCNPRINTF
+	int i = 0;
+
+	i += SCNPRINTF(&buff[i], len - i, " KDV=%x",
+		FIELD2VALUE(MAX77759_FG_RIPPLECFG_KDV, val));
+	i += SCNPRINTF(&buff[i], len - i, " NR=%x",
+		FIELD2VALUE(MAX77759_FG_RIPPLECFG_NR, val));
+#else
+	buff[0] = 0;
+#endif
+	return buff;
+}
+
+/*
+ * TimerH,0xBE,0b00000000,0x00
+ * TIMERH[15:8],,,,,,
+ */
+#define MAX77759_FG_TIMERH	0xBE
+
+/*
+ * MaxError,0xBF,0b00000000,0x00
+ * MaxError[15:8],,,,,,
+ */
+#define MAX77759_FG_MAXERROR	0xBF
+
+/*
+ * IIn,0xD0,0b00000000,0x00
+ * IIn[15:8],,,,,,
+ */
+#define MAX77759_FG_IIN	0xD0
+
+/*
+ * AtQresidual,0xDC,0b00000000,0x00
+ * AtQresidual[15:8],,,,,,
+ */
+#define MAX77759_FG_ATQRESIDUAL	0xDC
+
+/*
+ * AtTTE,0xDD,0b00000000,0x00
+ * AtTTE[15:8],,,,,,
+ */
+#define MAX77759_FG_ATTTE	0xDD
+
+/*
+ * AtAvSOC,0xDE,0b00000000,0x00
+ * AtAvSOC[15:8],,,,,,
+ */
+#define MAX77759_FG_ATAVSOC	0xDE
+
+/*
+ * AtAvCap,0xDF,0b00000000,0x00
+ * AtAvCap[15:8],,,,,,
+ */
+#define MAX77759_FG_ATAVCAP	0xDF
+
+/* section:  USB  */
+
+/*
+ * VENDOR_ID_L,0x0,0b01101010,0x6a
+ * VENDOR_ID_L[7:0],,,,,,
+ */
+#define MAX77759_USB_VENDOR_ID_L	0x0
+
+/*
+ * VENDOR_ID_H,0x1,0b00001011,0x0b
+ * VENDOR_ID_H[7:0],,,,,,
+ */
+#define MAX77759_USB_VENDOR_ID_H	0x1
+
+/*
+ * PRODUCT_ID_L,0x2,0b01011001,0x59
+ * PRODUCT_ID_L[7:0],,,,,,
+ */
+#define MAX77759_USB_PRODUCT_ID_L	0x2
+
+/*
+ * PRODUCT_ID_H,0x3,0b01110111,0x77
+ * PRODUCT_ID_H[7:0],,,,,,
+ */
+#define MAX77759_USB_PRODUCT_ID_H	0x3
+
+/*
+ * DEVICE_ID_L,0x4,0b00000001,0x01
+ * DEVICE_ID_L[7:0],,,,,,
+ */
+#define MAX77759_USB_DEVICE_ID_L	0x4
+
+/*
+ * DEVICE_ID_H,0x5,0b00000000,0x00
+ * DEVICE_ID_H[7:0],,,,,,
+ */
+#define MAX77759_USB_DEVICE_ID_H	0x5
+
+/*
+ * USBTYPEC_REV_L,0x6,0b00010011,0x13
+ * TYPEC_REV_L[7:0],,,,,,
+ */
+#define MAX77759_USB_USBTYPEC_REV_L	0x6
+
+/*
+ * USBTYPEC_REV_H,0x7,0b00000000,0x00
+ * TYPEC_REV_H[7:0],,,,,,
+ */
+#define MAX77759_USB_USBTYPEC_REV_H	0x7
+
+/*
+ * USBPD_REV_VER_L,0x8,0b00010010,0x12
+ * PD_VER[7:0],,,,,,
+ */
+#define MAX77759_USB_USBPD_REV_VER_L	0x8
+
+/*
+ * USBPD_REV_VER_H,0x9,0b00110000,0x30
+ * PD_REV[7:0],,,,,,
+ */
+#define MAX77759_USB_USBPD_REV_VER_H	0x9
+
+/*
+ * PD_INTERFACE_REV_L,0xA,0b00010001,0x11
+ * PD_IF_REV_L[7:0],,,,,,
+ */
+#define MAX77759_USB_PD_INTERFACE_REV_L	0xA
+
+/*
+ * PD_INTERFACE_REV_H,0xB,0b00100000,0x20
+ * PD_IF_REV_H[7:0],,,,,,
+ */
+#define MAX77759_USB_PD_INTERFACE_REV_H	0xB
+
+/*
+ * ALERT_L,0x10,0b00000000,0x00
+ * VBUS_ALARM_HI,TX_SOP_MSG_SUCC,TX_SOP_MSG_DISCRD,TX_SOP_MSG_FAIL,RX_HARD_RST,RX_SOP_MSG_STAT,PWR_STAT
+ */
+#define MAX77759_USB_ALERT_L	0x10
+#define MAX77759_USB_ALERT_L_VBUS_ALARM_HI	(0x1 << 7)
+#define MAX77759_USB_ALERT_L_TX_SOP_MSG_SUCC	(0x1 << 6)
+#define MAX77759_USB_ALERT_L_TX_SOP_MSG_DISCRD	(0x1 << 5)
+#define MAX77759_USB_ALERT_L_TX_SOP_MSG_FAIL	(0x1 << 4)
+#define MAX77759_USB_ALERT_L_RX_HARD_RST	(0x1 << 3)
+#define MAX77759_USB_ALERT_L_RX_SOP_MSG_STAT	(0x1 << 2)
+#define MAX77759_USB_ALERT_L_PWR_STAT	(0x1 << 1)
+#define MAX77759_USB_ALERT_L_CC_STAT	(0x1 << 0)
+
+#define MAX77759_USB_ALERT_L_VBUS_ALARM_HI_SHIFT	7
+#define MAX77759_USB_ALERT_L_VBUS_ALARM_HI_MASK	(0x1 << 7)
+#define MAX77759_USB_ALERT_L_VBUS_ALARM_HI_CLEAR	(~(0x1 << 7))
+#define MAX77759_USB_ALERT_L_TX_SOP_MSG_SUCC_SHIFT	6
+#define MAX77759_USB_ALERT_L_TX_SOP_MSG_SUCC_MASK	(0x1 << 6)
+#define MAX77759_USB_ALERT_L_TX_SOP_MSG_SUCC_CLEAR	(~(0x1 << 6))
+#define MAX77759_USB_ALERT_L_TX_SOP_MSG_DISCRD_SHIFT	5
+#define MAX77759_USB_ALERT_L_TX_SOP_MSG_DISCRD_MASK	(0x1 << 5)
+#define MAX77759_USB_ALERT_L_TX_SOP_MSG_DISCRD_CLEAR	(~(0x1 << 5))
+#define MAX77759_USB_ALERT_L_TX_SOP_MSG_FAIL_SHIFT	4
+#define MAX77759_USB_ALERT_L_TX_SOP_MSG_FAIL_MASK	(0x1 << 4)
+#define MAX77759_USB_ALERT_L_TX_SOP_MSG_FAIL_CLEAR	(~(0x1 << 4))
+#define MAX77759_USB_ALERT_L_RX_HARD_RST_SHIFT	3
+#define MAX77759_USB_ALERT_L_RX_HARD_RST_MASK	(0x1 << 3)
+#define MAX77759_USB_ALERT_L_RX_HARD_RST_CLEAR	(~(0x1 << 3))
+#define MAX77759_USB_ALERT_L_RX_SOP_MSG_STAT_SHIFT	2
+#define MAX77759_USB_ALERT_L_RX_SOP_MSG_STAT_MASK	(0x1 << 2)
+#define MAX77759_USB_ALERT_L_RX_SOP_MSG_STAT_CLEAR	(~(0x1 << 2))
+#define MAX77759_USB_ALERT_L_PWR_STAT_SHIFT	1
+#define MAX77759_USB_ALERT_L_PWR_STAT_MASK	(0x1 << 1)
+#define MAX77759_USB_ALERT_L_PWR_STAT_CLEAR	(~(0x1 << 1))
+#define MAX77759_USB_ALERT_L_CC_STAT_SHIFT	0
+#define MAX77759_USB_ALERT_L_CC_STAT_MASK	(0x1 << 0)
+#define MAX77759_USB_ALERT_L_CC_STAT_CLEAR	(~(0x1 << 0))
+
+MAX77759_BFF(usb_alert_l_vbus_alarm_hi,7,7)
+MAX77759_BFF(usb_alert_l_tx_sop_msg_succ,6,6)
+MAX77759_BFF(usb_alert_l_tx_sop_msg_discrd,5,5)
+MAX77759_BFF(usb_alert_l_tx_sop_msg_fail,4,4)
+MAX77759_BFF(usb_alert_l_rx_hard_rst,3,3)
+MAX77759_BFF(usb_alert_l_rx_sop_msg_stat,2,2)
+MAX77759_BFF(usb_alert_l_pwr_stat,1,1)
+MAX77759_BFF(usb_alert_l_cc_stat,0,0)
+static inline const char *
+max77759_usb_alert_l_cstr(char *buff, size_t len, int val)
+{
+#ifdef SCNPRINTF
+	int i = 0;
+
+	i += SCNPRINTF(&buff[i], len - i, " VBUS_ALARM_HI=%x",
+		FIELD2VALUE(MAX77759_USB_ALERT_L_VBUS_ALARM_HI, val));
+	i += SCNPRINTF(&buff[i], len - i, " TX_SOP_MSG_SUCC=%x",
+		FIELD2VALUE(MAX77759_USB_ALERT_L_TX_SOP_MSG_SUCC, val));
+	i += SCNPRINTF(&buff[i], len - i, " TX_SOP_MSG_DISCRD=%x",
+		FIELD2VALUE(MAX77759_USB_ALERT_L_TX_SOP_MSG_DISCRD, val));
+	i += SCNPRINTF(&buff[i], len - i, " TX_SOP_MSG_FAIL=%x",
+		FIELD2VALUE(MAX77759_USB_ALERT_L_TX_SOP_MSG_FAIL, val));
+	i += SCNPRINTF(&buff[i], len - i, " RX_HARD_RST=%x",
+		FIELD2VALUE(MAX77759_USB_ALERT_L_RX_HARD_RST, val));
+	i += SCNPRINTF(&buff[i], len - i, " RX_SOP_MSG_STAT=%x",
+		FIELD2VALUE(MAX77759_USB_ALERT_L_RX_SOP_MSG_STAT, val));
+	i += SCNPRINTF(&buff[i], len - i, " PWR_STAT=%x",
+		FIELD2VALUE(MAX77759_USB_ALERT_L_PWR_STAT, val));
+	i += SCNPRINTF(&buff[i], len - i, " CC_STAT=%x",
+		FIELD2VALUE(MAX77759_USB_ALERT_L_CC_STAT, val));
+#else
+	buff[0] = 0;
+#endif
+	return buff;
+}
+
+/*
+ * ALERT_H,0x11,0b00000000,0x00
+ * VNDR_ALRT,ALERT_EXTND,EXTND_STAT,RSVD_4,VBUS_SNK_DISC_DET,RX_BUFF_OVRFL,FAULT_STAT
+ */
+#define MAX77759_USB_ALERT_H	0x11
+#define MAX77759_USB_ALERT_H_VNDR_ALRT	(0x1 << 7)
+#define MAX77759_USB_ALERT_H_ALERT_EXTND	(0x1 << 6)
+#define MAX77759_USB_ALERT_H_EXTND_STAT	(0x1 << 5)
+#define MAX77759_USB_ALERT_H_RSVD_4	(0x1 << 4)
+#define MAX77759_USB_ALERT_H_VBUS_SNK_DISC_DET	(0x1 << 3)
+#define MAX77759_USB_ALERT_H_RX_BUFF_OVRFL	(0x1 << 2)
+#define MAX77759_USB_ALERT_H_FAULT_STAT	(0x1 << 1)
+#define MAX77759_USB_ALERT_H_VBUS_ALARM_LO	(0x1 << 0)
+
+#define MAX77759_USB_ALERT_H_VNDR_ALRT_SHIFT	7
+#define MAX77759_USB_ALERT_H_VNDR_ALRT_MASK	(0x1 << 7)
+#define MAX77759_USB_ALERT_H_VNDR_ALRT_CLEAR	(~(0x1 << 7))
+#define MAX77759_USB_ALERT_H_ALERT_EXTND_SHIFT	6
+#define MAX77759_USB_ALERT_H_ALERT_EXTND_MASK	(0x1 << 6)
+#define MAX77759_USB_ALERT_H_ALERT_EXTND_CLEAR	(~(0x1 << 6))
+#define MAX77759_USB_ALERT_H_EXTND_STAT_SHIFT	5
+#define MAX77759_USB_ALERT_H_EXTND_STAT_MASK	(0x1 << 5)
+#define MAX77759_USB_ALERT_H_EXTND_STAT_CLEAR	(~(0x1 << 5))
+#define MAX77759_USB_ALERT_H_RSVD_4_SHIFT	4
+#define MAX77759_USB_ALERT_H_RSVD_4_MASK	(0x1 << 4)
+#define MAX77759_USB_ALERT_H_RSVD_4_CLEAR	(~(0x1 << 4))
+#define MAX77759_USB_ALERT_H_VBUS_SNK_DISC_DET_SHIFT	3
+#define MAX77759_USB_ALERT_H_VBUS_SNK_DISC_DET_MASK	(0x1 << 3)
+#define MAX77759_USB_ALERT_H_VBUS_SNK_DISC_DET_CLEAR	(~(0x1 << 3))
+#define MAX77759_USB_ALERT_H_RX_BUFF_OVRFL_SHIFT	2
+#define MAX77759_USB_ALERT_H_RX_BUFF_OVRFL_MASK	(0x1 << 2)
+#define MAX77759_USB_ALERT_H_RX_BUFF_OVRFL_CLEAR	(~(0x1 << 2))
+#define MAX77759_USB_ALERT_H_FAULT_STAT_SHIFT	1
+#define MAX77759_USB_ALERT_H_FAULT_STAT_MASK	(0x1 << 1)
+#define MAX77759_USB_ALERT_H_FAULT_STAT_CLEAR	(~(0x1 << 1))
+#define MAX77759_USB_ALERT_H_VBUS_ALARM_LO_SHIFT	0
+#define MAX77759_USB_ALERT_H_VBUS_ALARM_LO_MASK	(0x1 << 0)
+#define MAX77759_USB_ALERT_H_VBUS_ALARM_LO_CLEAR	(~(0x1 << 0))
+
+MAX77759_BFF(usb_alert_h_vndr_alrt,7,7)
+MAX77759_BFF(usb_alert_h_alert_extnd,6,6)
+MAX77759_BFF(usb_alert_h_extnd_stat,5,5)
+MAX77759_BFF(usb_alert_h_rsvd_4,4,4)
+MAX77759_BFF(usb_alert_h_vbus_snk_disc_det,3,3)
+MAX77759_BFF(usb_alert_h_rx_buff_ovrfl,2,2)
+MAX77759_BFF(usb_alert_h_fault_stat,1,1)
+MAX77759_BFF(usb_alert_h_vbus_alarm_lo,0,0)
+static inline const char *
+max77759_usb_alert_h_cstr(char *buff, size_t len, int val)
+{
+#ifdef SCNPRINTF
+	int i = 0;
+
+	i += SCNPRINTF(&buff[i], len - i, " VNDR_ALRT=%x",
+		FIELD2VALUE(MAX77759_USB_ALERT_H_VNDR_ALRT, val));
+	i += SCNPRINTF(&buff[i], len - i, " ALERT_EXTND=%x",
+		FIELD2VALUE(MAX77759_USB_ALERT_H_ALERT_EXTND, val));
+	i += SCNPRINTF(&buff[i], len - i, " EXTND_STAT=%x",
+		FIELD2VALUE(MAX77759_USB_ALERT_H_EXTND_STAT, val));
+	i += SCNPRINTF(&buff[i], len - i, " RSVD_4=%x",
+		FIELD2VALUE(MAX77759_USB_ALERT_H_RSVD_4, val));
+	i += SCNPRINTF(&buff[i], len - i, " VBUS_SNK_DISC_DET=%x",
+		FIELD2VALUE(MAX77759_USB_ALERT_H_VBUS_SNK_DISC_DET, val));
+	i += SCNPRINTF(&buff[i], len - i, " RX_BUFF_OVRFL=%x",
+		FIELD2VALUE(MAX77759_USB_ALERT_H_RX_BUFF_OVRFL, val));
+	i += SCNPRINTF(&buff[i], len - i, " FAULT_STAT=%x",
+		FIELD2VALUE(MAX77759_USB_ALERT_H_FAULT_STAT, val));
+	i += SCNPRINTF(&buff[i], len - i, " VBUS_ALARM_LO=%x",
+		FIELD2VALUE(MAX77759_USB_ALERT_H_VBUS_ALARM_LO, val));
+#else
+	buff[0] = 0;
+#endif
+	return buff;
+}
+
+/*
+ * ALERT_MASK_L,0x12,0b11111111,0xff
+ * MSK_VBUS_V_ALRM_HI,MSK_TX_SOP_MSG_SUCC,MSK_TX_SOP_MSG_DISCRD,MSK_TX_SOP_MSG_FAIL,MSK_RX_HARD_RST,MSK_RX_SOP_MSG_STAT,MSK_PWR_STAT
+ */
+#define MAX77759_USB_ALERT_MASK_L	0x12
+#define MAX77759_USB_ALERT_MASK_L_MSK_VBUS_V_ALRM_HI	(0x1 << 7)
+#define MAX77759_USB_ALERT_MASK_L_MSK_TX_SOP_MSG_SUCC	(0x1 << 6)
+#define MAX77759_USB_ALERT_MASK_L_MSK_TX_SOP_MSG_DISCRD	(0x1 << 5)
+#define MAX77759_USB_ALERT_MASK_L_MSK_TX_SOP_MSG_FAIL	(0x1 << 4)
+#define MAX77759_USB_ALERT_MASK_L_MSK_RX_HARD_RST	(0x1 << 3)
+#define MAX77759_USB_ALERT_MASK_L_MSK_RX_SOP_MSG_STAT	(0x1 << 2)
+#define MAX77759_USB_ALERT_MASK_L_MSK_PWR_STAT	(0x1 << 1)
+#define MAX77759_USB_ALERT_MASK_L_MSK_CC_STAT	(0x1 << 0)
+
+#define MAX77759_USB_ALERT_MASK_L_MSK_VBUS_V_ALRM_HI_SHIFT	7
+#define MAX77759_USB_ALERT_MASK_L_MSK_VBUS_V_ALRM_HI_MASK	(0x1 << 7)
+#define MAX77759_USB_ALERT_MASK_L_MSK_VBUS_V_ALRM_HI_CLEAR	(~(0x1 << 7))
+#define MAX77759_USB_ALERT_MASK_L_MSK_TX_SOP_MSG_SUCC_SHIFT	6
+#define MAX77759_USB_ALERT_MASK_L_MSK_TX_SOP_MSG_SUCC_MASK	(0x1 << 6)
+#define MAX77759_USB_ALERT_MASK_L_MSK_TX_SOP_MSG_SUCC_CLEAR	(~(0x1 << 6))
+#define MAX77759_USB_ALERT_MASK_L_MSK_TX_SOP_MSG_DISCRD_SHIFT	5
+#define MAX77759_USB_ALERT_MASK_L_MSK_TX_SOP_MSG_DISCRD_MASK	(0x1 << 5)
+#define MAX77759_USB_ALERT_MASK_L_MSK_TX_SOP_MSG_DISCRD_CLEAR	(~(0x1 << 5))
+#define MAX77759_USB_ALERT_MASK_L_MSK_TX_SOP_MSG_FAIL_SHIFT	4
+#define MAX77759_USB_ALERT_MASK_L_MSK_TX_SOP_MSG_FAIL_MASK	(0x1 << 4)
+#define MAX77759_USB_ALERT_MASK_L_MSK_TX_SOP_MSG_FAIL_CLEAR	(~(0x1 << 4))
+#define MAX77759_USB_ALERT_MASK_L_MSK_RX_HARD_RST_SHIFT	3
+#define MAX77759_USB_ALERT_MASK_L_MSK_RX_HARD_RST_MASK	(0x1 << 3)
+#define MAX77759_USB_ALERT_MASK_L_MSK_RX_HARD_RST_CLEAR	(~(0x1 << 3))
+#define MAX77759_USB_ALERT_MASK_L_MSK_RX_SOP_MSG_STAT_SHIFT	2
+#define MAX77759_USB_ALERT_MASK_L_MSK_RX_SOP_MSG_STAT_MASK	(0x1 << 2)
+#define MAX77759_USB_ALERT_MASK_L_MSK_RX_SOP_MSG_STAT_CLEAR	(~(0x1 << 2))
+#define MAX77759_USB_ALERT_MASK_L_MSK_PWR_STAT_SHIFT	1
+#define MAX77759_USB_ALERT_MASK_L_MSK_PWR_STAT_MASK	(0x1 << 1)
+#define MAX77759_USB_ALERT_MASK_L_MSK_PWR_STAT_CLEAR	(~(0x1 << 1))
+#define MAX77759_USB_ALERT_MASK_L_MSK_CC_STAT_SHIFT	0
+#define MAX77759_USB_ALERT_MASK_L_MSK_CC_STAT_MASK	(0x1 << 0)
+#define MAX77759_USB_ALERT_MASK_L_MSK_CC_STAT_CLEAR	(~(0x1 << 0))
+
+MAX77759_BFF(usb_alert_mask_l_msk_vbus_v_alrm_hi,7,7)
+MAX77759_BFF(usb_alert_mask_l_msk_tx_sop_msg_succ,6,6)
+MAX77759_BFF(usb_alert_mask_l_msk_tx_sop_msg_discrd,5,5)
+MAX77759_BFF(usb_alert_mask_l_msk_tx_sop_msg_fail,4,4)
+MAX77759_BFF(usb_alert_mask_l_msk_rx_hard_rst,3,3)
+MAX77759_BFF(usb_alert_mask_l_msk_rx_sop_msg_stat,2,2)
+MAX77759_BFF(usb_alert_mask_l_msk_pwr_stat,1,1)
+MAX77759_BFF(usb_alert_mask_l_msk_cc_stat,0,0)
+static inline const char *
+max77759_usb_alert_mask_l_cstr(char *buff, size_t len, int val)
+{
+#ifdef SCNPRINTF
+	int i = 0;
+
+	i += SCNPRINTF(&buff[i], len - i, " MSK_VBUS_V_ALRM_HI=%x",
+		FIELD2VALUE(MAX77759_USB_ALERT_MASK_L_MSK_VBUS_V_ALRM_HI, val));
+	i += SCNPRINTF(&buff[i], len - i, " MSK_TX_SOP_MSG_SUCC=%x",
+		FIELD2VALUE(MAX77759_USB_ALERT_MASK_L_MSK_TX_SOP_MSG_SUCC, val));
+	i += SCNPRINTF(&buff[i], len - i, " MSK_TX_SOP_MSG_DISCRD=%x",
+		FIELD2VALUE(MAX77759_USB_ALERT_MASK_L_MSK_TX_SOP_MSG_DISCRD, val));
+	i += SCNPRINTF(&buff[i], len - i, " MSK_TX_SOP_MSG_FAIL=%x",
+		FIELD2VALUE(MAX77759_USB_ALERT_MASK_L_MSK_TX_SOP_MSG_FAIL, val));
+	i += SCNPRINTF(&buff[i], len - i, " MSK_RX_HARD_RST=%x",
+		FIELD2VALUE(MAX77759_USB_ALERT_MASK_L_MSK_RX_HARD_RST, val));
+	i += SCNPRINTF(&buff[i], len - i, " MSK_RX_SOP_MSG_STAT=%x",
+		FIELD2VALUE(MAX77759_USB_ALERT_MASK_L_MSK_RX_SOP_MSG_STAT, val));
+	i += SCNPRINTF(&buff[i], len - i, " MSK_PWR_STAT=%x",
+		FIELD2VALUE(MAX77759_USB_ALERT_MASK_L_MSK_PWR_STAT, val));
+	i += SCNPRINTF(&buff[i], len - i, " MSK_CC_STAT=%x",
+		FIELD2VALUE(MAX77759_USB_ALERT_MASK_L_MSK_CC_STAT, val));
+#else
+	buff[0] = 0;
+#endif
+	return buff;
+}
+
+/*
+ * ALERT_MASK_H,0x13,0b01101111,0x6f
+ * MSK_VNDR_ALRT,MSK_ALRT_EXTND,MSK_EXTND_STAT,RSVD_4,MSK_VBUS_SNK_DISC_DET,MSK_RX_BUFF_OVRFL,MSK_FAULT_STAT
+ */
+#define MAX77759_USB_ALERT_MASK_H	0x13
+#define MAX77759_USB_ALERT_MASK_H_MSK_VNDR_ALRT	(0x1 << 7)
+#define MAX77759_USB_ALERT_MASK_H_MSK_ALRT_EXTND	(0x1 << 6)
+#define MAX77759_USB_ALERT_MASK_H_MSK_EXTND_STAT	(0x1 << 5)
+#define MAX77759_USB_ALERT_MASK_H_RSVD_4	(0x1 << 4)
+#define MAX77759_USB_ALERT_MASK_H_MSK_VBUS_SNK_DISC_DET	(0x1 << 3)
+#define MAX77759_USB_ALERT_MASK_H_MSK_RX_BUFF_OVRFL	(0x1 << 2)
+#define MAX77759_USB_ALERT_MASK_H_MSK_FAULT_STAT	(0x1 << 1)
+#define MAX77759_USB_ALERT_MASK_H_MSK_VBUS_V_ALRM_LO	(0x1 << 0)
+
+#define MAX77759_USB_ALERT_MASK_H_MSK_VNDR_ALRT_SHIFT	7
+#define MAX77759_USB_ALERT_MASK_H_MSK_VNDR_ALRT_MASK	(0x1 << 7)
+#define MAX77759_USB_ALERT_MASK_H_MSK_VNDR_ALRT_CLEAR	(~(0x1 << 7))
+#define MAX77759_USB_ALERT_MASK_H_MSK_ALRT_EXTND_SHIFT	6
+#define MAX77759_USB_ALERT_MASK_H_MSK_ALRT_EXTND_MASK	(0x1 << 6)
+#define MAX77759_USB_ALERT_MASK_H_MSK_ALRT_EXTND_CLEAR	(~(0x1 << 6))
+#define MAX77759_USB_ALERT_MASK_H_MSK_EXTND_STAT_SHIFT	5
+#define MAX77759_USB_ALERT_MASK_H_MSK_EXTND_STAT_MASK	(0x1 << 5)
+#define MAX77759_USB_ALERT_MASK_H_MSK_EXTND_STAT_CLEAR	(~(0x1 << 5))
+#define MAX77759_USB_ALERT_MASK_H_RSVD_4_SHIFT	4
+#define MAX77759_USB_ALERT_MASK_H_RSVD_4_MASK	(0x1 << 4)
+#define MAX77759_USB_ALERT_MASK_H_RSVD_4_CLEAR	(~(0x1 << 4))
+#define MAX77759_USB_ALERT_MASK_H_MSK_VBUS_SNK_DISC_DET_SHIFT	3
+#define MAX77759_USB_ALERT_MASK_H_MSK_VBUS_SNK_DISC_DET_MASK	(0x1 << 3)
+#define MAX77759_USB_ALERT_MASK_H_MSK_VBUS_SNK_DISC_DET_CLEAR	(~(0x1 << 3))
+#define MAX77759_USB_ALERT_MASK_H_MSK_RX_BUFF_OVRFL_SHIFT	2
+#define MAX77759_USB_ALERT_MASK_H_MSK_RX_BUFF_OVRFL_MASK	(0x1 << 2)
+#define MAX77759_USB_ALERT_MASK_H_MSK_RX_BUFF_OVRFL_CLEAR	(~(0x1 << 2))
+#define MAX77759_USB_ALERT_MASK_H_MSK_FAULT_STAT_SHIFT	1
+#define MAX77759_USB_ALERT_MASK_H_MSK_FAULT_STAT_MASK	(0x1 << 1)
+#define MAX77759_USB_ALERT_MASK_H_MSK_FAULT_STAT_CLEAR	(~(0x1 << 1))
+#define MAX77759_USB_ALERT_MASK_H_MSK_VBUS_V_ALRM_LO_SHIFT	0
+#define MAX77759_USB_ALERT_MASK_H_MSK_VBUS_V_ALRM_LO_MASK	(0x1 << 0)
+#define MAX77759_USB_ALERT_MASK_H_MSK_VBUS_V_ALRM_LO_CLEAR	(~(0x1 << 0))
+
+MAX77759_BFF(usb_alert_mask_h_msk_vndr_alrt,7,7)
+MAX77759_BFF(usb_alert_mask_h_msk_alrt_extnd,6,6)
+MAX77759_BFF(usb_alert_mask_h_msk_extnd_stat,5,5)
+MAX77759_BFF(usb_alert_mask_h_rsvd_4,4,4)
+MAX77759_BFF(usb_alert_mask_h_msk_vbus_snk_disc_det,3,3)
+MAX77759_BFF(usb_alert_mask_h_msk_rx_buff_ovrfl,2,2)
+MAX77759_BFF(usb_alert_mask_h_msk_fault_stat,1,1)
+MAX77759_BFF(usb_alert_mask_h_msk_vbus_v_alrm_lo,0,0)
+static inline const char *
+max77759_usb_alert_mask_h_cstr(char *buff, size_t len, int val)
+{
+#ifdef SCNPRINTF
+	int i = 0;
+
+	i += SCNPRINTF(&buff[i], len - i, " MSK_VNDR_ALRT=%x",
+		FIELD2VALUE(MAX77759_USB_ALERT_MASK_H_MSK_VNDR_ALRT, val));
+	i += SCNPRINTF(&buff[i], len - i, " MSK_ALRT_EXTND=%x",
+		FIELD2VALUE(MAX77759_USB_ALERT_MASK_H_MSK_ALRT_EXTND, val));
+	i += SCNPRINTF(&buff[i], len - i, " MSK_EXTND_STAT=%x",
+		FIELD2VALUE(MAX77759_USB_ALERT_MASK_H_MSK_EXTND_STAT, val));
+	i += SCNPRINTF(&buff[i], len - i, " RSVD_4=%x",
+		FIELD2VALUE(MAX77759_USB_ALERT_MASK_H_RSVD_4, val));
+	i += SCNPRINTF(&buff[i], len - i, " MSK_VBUS_SNK_DISC_DET=%x",
+		FIELD2VALUE(MAX77759_USB_ALERT_MASK_H_MSK_VBUS_SNK_DISC_DET, val));
+	i += SCNPRINTF(&buff[i], len - i, " MSK_RX_BUFF_OVRFL=%x",
+		FIELD2VALUE(MAX77759_USB_ALERT_MASK_H_MSK_RX_BUFF_OVRFL, val));
+	i += SCNPRINTF(&buff[i], len - i, " MSK_FAULT_STAT=%x",
+		FIELD2VALUE(MAX77759_USB_ALERT_MASK_H_MSK_FAULT_STAT, val));
+	i += SCNPRINTF(&buff[i], len - i, " MSK_VBUS_V_ALRM_LO=%x",
+		FIELD2VALUE(MAX77759_USB_ALERT_MASK_H_MSK_VBUS_V_ALRM_LO, val));
+#else
+	buff[0] = 0;
+#endif
+	return buff;
+}
+
+/*
+ * POWER_STATUS_MASK_REG,0x14,0b11111111,0xff
+ * MSK_DEBG_ACC_CONN_STAT,MSK_TCPC_INIT_STAT,MSK_SRC_HI_V_STAT,MSK_SRC_VBUS_STAT,MSK_VBUS_DET_STAT,MSK_VBUS_PRSN_STAT,MSK_VCONN_PRSN_STAT
+ */
+#define MAX77759_USB_POWER_STATUS_MASK_REG	0x14
+#define MAX77759_USB_POWER_STATUS_MASK_REG_MSK_DEBG_ACC_CONN_STAT	(0x1 << 7)
+#define MAX77759_USB_POWER_STATUS_MASK_REG_MSK_TCPC_INIT_STAT	(0x1 << 6)
+#define MAX77759_USB_POWER_STATUS_MASK_REG_MSK_SRC_HI_V_STAT	(0x1 << 5)
+#define MAX77759_USB_POWER_STATUS_MASK_REG_MSK_SRC_VBUS_STAT	(0x1 << 4)
+#define MAX77759_USB_POWER_STATUS_MASK_REG_MSK_VBUS_DET_STAT	(0x1 << 3)
+#define MAX77759_USB_POWER_STATUS_MASK_REG_MSK_VBUS_PRSN_STAT	(0x1 << 2)
+#define MAX77759_USB_POWER_STATUS_MASK_REG_MSK_VCONN_PRSN_STAT	(0x1 << 1)
+#define MAX77759_USB_POWER_STATUS_MASK_REG_MSK_SNK_VBUS_STAT	(0x1 << 0)
+
+#define MAX77759_USB_POWER_STATUS_MASK_REG_MSK_DEBG_ACC_CONN_STAT_SHIFT	7
+#define MAX77759_USB_POWER_STATUS_MASK_REG_MSK_DEBG_ACC_CONN_STAT_MASK	(0x1 << 7)
+#define MAX77759_USB_POWER_STATUS_MASK_REG_MSK_DEBG_ACC_CONN_STAT_CLEAR	(~(0x1 << 7))
+#define MAX77759_USB_POWER_STATUS_MASK_REG_MSK_TCPC_INIT_STAT_SHIFT	6
+#define MAX77759_USB_POWER_STATUS_MASK_REG_MSK_TCPC_INIT_STAT_MASK	(0x1 << 6)
+#define MAX77759_USB_POWER_STATUS_MASK_REG_MSK_TCPC_INIT_STAT_CLEAR	(~(0x1 << 6))
+#define MAX77759_USB_POWER_STATUS_MASK_REG_MSK_SRC_HI_V_STAT_SHIFT	5
+#define MAX77759_USB_POWER_STATUS_MASK_REG_MSK_SRC_HI_V_STAT_MASK	(0x1 << 5)
+#define MAX77759_USB_POWER_STATUS_MASK_REG_MSK_SRC_HI_V_STAT_CLEAR	(~(0x1 << 5))
+#define MAX77759_USB_POWER_STATUS_MASK_REG_MSK_SRC_VBUS_STAT_SHIFT	4
+#define MAX77759_USB_POWER_STATUS_MASK_REG_MSK_SRC_VBUS_STAT_MASK	(0x1 << 4)
+#define MAX77759_USB_POWER_STATUS_MASK_REG_MSK_SRC_VBUS_STAT_CLEAR	(~(0x1 << 4))
+#define MAX77759_USB_POWER_STATUS_MASK_REG_MSK_VBUS_DET_STAT_SHIFT	3
+#define MAX77759_USB_POWER_STATUS_MASK_REG_MSK_VBUS_DET_STAT_MASK	(0x1 << 3)
+#define MAX77759_USB_POWER_STATUS_MASK_REG_MSK_VBUS_DET_STAT_CLEAR	(~(0x1 << 3))
+#define MAX77759_USB_POWER_STATUS_MASK_REG_MSK_VBUS_PRSN_STAT_SHIFT	2
+#define MAX77759_USB_POWER_STATUS_MASK_REG_MSK_VBUS_PRSN_STAT_MASK	(0x1 << 2)
+#define MAX77759_USB_POWER_STATUS_MASK_REG_MSK_VBUS_PRSN_STAT_CLEAR	(~(0x1 << 2))
+#define MAX77759_USB_POWER_STATUS_MASK_REG_MSK_VCONN_PRSN_STAT_SHIFT	1
+#define MAX77759_USB_POWER_STATUS_MASK_REG_MSK_VCONN_PRSN_STAT_MASK	(0x1 << 1)
+#define MAX77759_USB_POWER_STATUS_MASK_REG_MSK_VCONN_PRSN_STAT_CLEAR	(~(0x1 << 1))
+#define MAX77759_USB_POWER_STATUS_MASK_REG_MSK_SNK_VBUS_STAT_SHIFT	0
+#define MAX77759_USB_POWER_STATUS_MASK_REG_MSK_SNK_VBUS_STAT_MASK	(0x1 << 0)
+#define MAX77759_USB_POWER_STATUS_MASK_REG_MSK_SNK_VBUS_STAT_CLEAR	(~(0x1 << 0))
+
+MAX77759_BFF(usb_power_status_mask_reg_msk_debg_acc_conn_stat,7,7)
+MAX77759_BFF(usb_power_status_mask_reg_msk_tcpc_init_stat,6,6)
+MAX77759_BFF(usb_power_status_mask_reg_msk_src_hi_v_stat,5,5)
+MAX77759_BFF(usb_power_status_mask_reg_msk_src_vbus_stat,4,4)
+MAX77759_BFF(usb_power_status_mask_reg_msk_vbus_det_stat,3,3)
+MAX77759_BFF(usb_power_status_mask_reg_msk_vbus_prsn_stat,2,2)
+MAX77759_BFF(usb_power_status_mask_reg_msk_vconn_prsn_stat,1,1)
+MAX77759_BFF(usb_power_status_mask_reg_msk_snk_vbus_stat,0,0)
+static inline const char *
+max77759_usb_power_status_mask_reg_cstr(char *buff, size_t len, int val)
+{
+#ifdef SCNPRINTF
+	int i = 0;
+
+	i += SCNPRINTF(&buff[i], len - i, " MSK_DEBG_ACC_CONN_STAT=%x",
+		FIELD2VALUE(MAX77759_USB_POWER_STATUS_MASK_REG_MSK_DEBG_ACC_CONN_STAT, val));
+	i += SCNPRINTF(&buff[i], len - i, " MSK_TCPC_INIT_STAT=%x",
+		FIELD2VALUE(MAX77759_USB_POWER_STATUS_MASK_REG_MSK_TCPC_INIT_STAT, val));
+	i += SCNPRINTF(&buff[i], len - i, " MSK_SRC_HI_V_STAT=%x",
+		FIELD2VALUE(MAX77759_USB_POWER_STATUS_MASK_REG_MSK_SRC_HI_V_STAT, val));
+	i += SCNPRINTF(&buff[i], len - i, " MSK_SRC_VBUS_STAT=%x",
+		FIELD2VALUE(MAX77759_USB_POWER_STATUS_MASK_REG_MSK_SRC_VBUS_STAT, val));
+	i += SCNPRINTF(&buff[i], len - i, " MSK_VBUS_DET_STAT=%x",
+		FIELD2VALUE(MAX77759_USB_POWER_STATUS_MASK_REG_MSK_VBUS_DET_STAT, val));
+	i += SCNPRINTF(&buff[i], len - i, " MSK_VBUS_PRSN_STAT=%x",
+		FIELD2VALUE(MAX77759_USB_POWER_STATUS_MASK_REG_MSK_VBUS_PRSN_STAT, val));
+	i += SCNPRINTF(&buff[i], len - i, " MSK_VCONN_PRSN_STAT=%x",
+		FIELD2VALUE(MAX77759_USB_POWER_STATUS_MASK_REG_MSK_VCONN_PRSN_STAT, val));
+	i += SCNPRINTF(&buff[i], len - i, " MSK_SNK_VBUS_STAT=%x",
+		FIELD2VALUE(MAX77759_USB_POWER_STATUS_MASK_REG_MSK_SNK_VBUS_STAT, val));
+#else
+	buff[0] = 0;
+#endif
+	return buff;
+}
+
+/*
+ * FAULT_STATUS_MASK_REG,0x15,0b11111111,0xff
+ * MSK_All_REG_RST,MSK_FORC_VBUS,MSK_AUTO_DISCH_FAIL,MSK_FORC_DISCH_FAIL,MSK_VBUS_OCP,MSK_VBUS_OVP,MSK_VCONN_OCP
+ */
+#define MAX77759_USB_FAULT_STATUS_MASK_REG	0x15
+#define MAX77759_USB_FAULT_STATUS_MASK_REG_MSK_ALL_REG_RST	(0x1 << 7)
+#define MAX77759_USB_FAULT_STATUS_MASK_REG_MSK_FORC_VBUS	(0x1 << 6)
+#define MAX77759_USB_FAULT_STATUS_MASK_REG_MSK_AUTO_DISCH_FAIL	(0x1 << 5)
+#define MAX77759_USB_FAULT_STATUS_MASK_REG_MSK_FORC_DISCH_FAIL	(0x1 << 4)
+#define MAX77759_USB_FAULT_STATUS_MASK_REG_MSK_VBUS_OCP	(0x1 << 3)
+#define MAX77759_USB_FAULT_STATUS_MASK_REG_MSK_VBUS_OVP	(0x1 << 2)
+#define MAX77759_USB_FAULT_STATUS_MASK_REG_MSK_VCONN_OCP	(0x1 << 1)
+#define MAX77759_USB_FAULT_STATUS_MASK_REG_MSK_I2C_ERR	(0x1 << 0)
+
+#define MAX77759_USB_FAULT_STATUS_MASK_REG_MSK_ALL_REG_RST_SHIFT	7
+#define MAX77759_USB_FAULT_STATUS_MASK_REG_MSK_ALL_REG_RST_MASK	(0x1 << 7)
+#define MAX77759_USB_FAULT_STATUS_MASK_REG_MSK_ALL_REG_RST_CLEAR	(~(0x1 << 7))
+#define MAX77759_USB_FAULT_STATUS_MASK_REG_MSK_FORC_VBUS_SHIFT	6
+#define MAX77759_USB_FAULT_STATUS_MASK_REG_MSK_FORC_VBUS_MASK	(0x1 << 6)
+#define MAX77759_USB_FAULT_STATUS_MASK_REG_MSK_FORC_VBUS_CLEAR	(~(0x1 << 6))
+#define MAX77759_USB_FAULT_STATUS_MASK_REG_MSK_AUTO_DISCH_FAIL_SHIFT	5
+#define MAX77759_USB_FAULT_STATUS_MASK_REG_MSK_AUTO_DISCH_FAIL_MASK	(0x1 << 5)
+#define MAX77759_USB_FAULT_STATUS_MASK_REG_MSK_AUTO_DISCH_FAIL_CLEAR	(~(0x1 << 5))
+#define MAX77759_USB_FAULT_STATUS_MASK_REG_MSK_FORC_DISCH_FAIL_SHIFT	4
+#define MAX77759_USB_FAULT_STATUS_MASK_REG_MSK_FORC_DISCH_FAIL_MASK	(0x1 << 4)
+#define MAX77759_USB_FAULT_STATUS_MASK_REG_MSK_FORC_DISCH_FAIL_CLEAR	(~(0x1 << 4))
+#define MAX77759_USB_FAULT_STATUS_MASK_REG_MSK_VBUS_OCP_SHIFT	3
+#define MAX77759_USB_FAULT_STATUS_MASK_REG_MSK_VBUS_OCP_MASK	(0x1 << 3)
+#define MAX77759_USB_FAULT_STATUS_MASK_REG_MSK_VBUS_OCP_CLEAR	(~(0x1 << 3))
+#define MAX77759_USB_FAULT_STATUS_MASK_REG_MSK_VBUS_OVP_SHIFT	2
+#define MAX77759_USB_FAULT_STATUS_MASK_REG_MSK_VBUS_OVP_MASK	(0x1 << 2)
+#define MAX77759_USB_FAULT_STATUS_MASK_REG_MSK_VBUS_OVP_CLEAR	(~(0x1 << 2))
+#define MAX77759_USB_FAULT_STATUS_MASK_REG_MSK_VCONN_OCP_SHIFT	1
+#define MAX77759_USB_FAULT_STATUS_MASK_REG_MSK_VCONN_OCP_MASK	(0x1 << 1)
+#define MAX77759_USB_FAULT_STATUS_MASK_REG_MSK_VCONN_OCP_CLEAR	(~(0x1 << 1))
+#define MAX77759_USB_FAULT_STATUS_MASK_REG_MSK_I2C_ERR_SHIFT	0
+#define MAX77759_USB_FAULT_STATUS_MASK_REG_MSK_I2C_ERR_MASK	(0x1 << 0)
+#define MAX77759_USB_FAULT_STATUS_MASK_REG_MSK_I2C_ERR_CLEAR	(~(0x1 << 0))
+
+MAX77759_BFF(usb_fault_status_mask_reg_msk_all_reg_rst,7,7)
+MAX77759_BFF(usb_fault_status_mask_reg_msk_forc_vbus,6,6)
+MAX77759_BFF(usb_fault_status_mask_reg_msk_auto_disch_fail,5,5)
+MAX77759_BFF(usb_fault_status_mask_reg_msk_forc_disch_fail,4,4)
+MAX77759_BFF(usb_fault_status_mask_reg_msk_vbus_ocp,3,3)
+MAX77759_BFF(usb_fault_status_mask_reg_msk_vbus_ovp,2,2)
+MAX77759_BFF(usb_fault_status_mask_reg_msk_vconn_ocp,1,1)
+MAX77759_BFF(usb_fault_status_mask_reg_msk_i2c_err,0,0)
+static inline const char *
+max77759_usb_fault_status_mask_reg_cstr(char *buff, size_t len, int val)
+{
+#ifdef SCNPRINTF
+	int i = 0;
+
+	i += SCNPRINTF(&buff[i], len - i, " MSK_ALL_REG_RST=%x",
+		FIELD2VALUE(MAX77759_USB_FAULT_STATUS_MASK_REG_MSK_ALL_REG_RST, val));
+	i += SCNPRINTF(&buff[i], len - i, " MSK_FORC_VBUS=%x",
+		FIELD2VALUE(MAX77759_USB_FAULT_STATUS_MASK_REG_MSK_FORC_VBUS, val));
+	i += SCNPRINTF(&buff[i], len - i, " MSK_AUTO_DISCH_FAIL=%x",
+		FIELD2VALUE(MAX77759_USB_FAULT_STATUS_MASK_REG_MSK_AUTO_DISCH_FAIL, val));
+	i += SCNPRINTF(&buff[i], len - i, " MSK_FORC_DISCH_FAIL=%x",
+		FIELD2VALUE(MAX77759_USB_FAULT_STATUS_MASK_REG_MSK_FORC_DISCH_FAIL, val));
+	i += SCNPRINTF(&buff[i], len - i, " MSK_VBUS_OCP=%x",
+		FIELD2VALUE(MAX77759_USB_FAULT_STATUS_MASK_REG_MSK_VBUS_OCP, val));
+	i += SCNPRINTF(&buff[i], len - i, " MSK_VBUS_OVP=%x",
+		FIELD2VALUE(MAX77759_USB_FAULT_STATUS_MASK_REG_MSK_VBUS_OVP, val));
+	i += SCNPRINTF(&buff[i], len - i, " MSK_VCONN_OCP=%x",
+		FIELD2VALUE(MAX77759_USB_FAULT_STATUS_MASK_REG_MSK_VCONN_OCP, val));
+	i += SCNPRINTF(&buff[i], len - i, " MSK_I2C_ERR=%x",
+		FIELD2VALUE(MAX77759_USB_FAULT_STATUS_MASK_REG_MSK_I2C_ERR, val));
+#else
+	buff[0] = 0;
+#endif
+	return buff;
+}
+
+/*
+ * EXTENDED_STATUS_MASK_REG,0x16,0b00000001,0x01
+ * RSVD_7_1[6:0],,,,,,
+ */
+#define MAX77759_USB_EXTENDED_STATUS_MASK_REG	0x16
+#define MAX77759_USB_EXTENDED_STATUS_MASK_REG_MSK_VSAFE0V	(0x1 << 0)
+
+#define MAX77759_USB_EXTENDED_STATUS_MASK_REG_RSVD_7_1_SHIFT	1
+#define MAX77759_USB_EXTENDED_STATUS_MASK_REG_RSVD_7_1_MASK	(0x7f << 1)
+#define MAX77759_USB_EXTENDED_STATUS_MASK_REG_RSVD_7_1_CLEAR	(~(0x7f << 1))
+#define MAX77759_USB_EXTENDED_STATUS_MASK_REG_MSK_VSAFE0V_SHIFT	0
+#define MAX77759_USB_EXTENDED_STATUS_MASK_REG_MSK_VSAFE0V_MASK	(0x1 << 0)
+#define MAX77759_USB_EXTENDED_STATUS_MASK_REG_MSK_VSAFE0V_CLEAR	(~(0x1 << 0))
+
+MAX77759_BFF(usb_extended_status_mask_reg_rsvd_7_1,7,1)
+MAX77759_BFF(usb_extended_status_mask_reg_msk_vsafe0v,0,0)
+static inline const char *
+max77759_usb_extended_status_mask_reg_cstr(char *buff, size_t len, int val)
+{
+#ifdef SCNPRINTF
+	int i = 0;
+
+	i += SCNPRINTF(&buff[i], len - i, " RSVD_7_1=%x",
+		FIELD2VALUE(MAX77759_USB_EXTENDED_STATUS_MASK_REG_RSVD_7_1, val));
+	i += SCNPRINTF(&buff[i], len - i, " MSK_VSAFE0V=%x",
+		FIELD2VALUE(MAX77759_USB_EXTENDED_STATUS_MASK_REG_MSK_VSAFE0V, val));
+#else
+	buff[0] = 0;
+#endif
+	return buff;
+}
+
+/*
+ * ALERT_EXTENDED_MASK,0x17,0b00000001,0x01
+ * RSVD_7_1[6:0],,,,,,
+ */
+#define MAX77759_USB_ALERT_EXTENDED_MASK	0x17
+#define MAX77759_USB_ALERT_EXTENDED_MASK_MSK_SNK_FRS	(0x1 << 0)
+
+#define MAX77759_USB_ALERT_EXTENDED_MASK_RSVD_7_1_SHIFT	1
+#define MAX77759_USB_ALERT_EXTENDED_MASK_RSVD_7_1_MASK	(0x7f << 1)
+#define MAX77759_USB_ALERT_EXTENDED_MASK_RSVD_7_1_CLEAR	(~(0x7f << 1))
+#define MAX77759_USB_ALERT_EXTENDED_MASK_MSK_SNK_FRS_SHIFT	0
+#define MAX77759_USB_ALERT_EXTENDED_MASK_MSK_SNK_FRS_MASK	(0x1 << 0)
+#define MAX77759_USB_ALERT_EXTENDED_MASK_MSK_SNK_FRS_CLEAR	(~(0x1 << 0))
+
+MAX77759_BFF(usb_alert_extended_mask_rsvd_7_1,7,1)
+MAX77759_BFF(usb_alert_extended_mask_msk_snk_frs,0,0)
+static inline const char *
+max77759_usb_alert_extended_mask_cstr(char *buff, size_t len, int val)
+{
+#ifdef SCNPRINTF
+	int i = 0;
+
+	i += SCNPRINTF(&buff[i], len - i, " RSVD_7_1=%x",
+		FIELD2VALUE(MAX77759_USB_ALERT_EXTENDED_MASK_RSVD_7_1, val));
+	i += SCNPRINTF(&buff[i], len - i, " MSK_SNK_FRS=%x",
+		FIELD2VALUE(MAX77759_USB_ALERT_EXTENDED_MASK_MSK_SNK_FRS, val));
+#else
+	buff[0] = 0;
+#endif
+	return buff;
+}
+
+/*
+ * CONFIG_STANDARD_OUTPUT,0x18,0b01000000,0x40
+ * RSVD_7,DbgAccConn,RSVD_5,RSVD_4_3[1:0],,RSVD_2,RSVD_1
+ */
+#define MAX77759_USB_CONFIG_STANDARD_OUTPUT	0x18
+#define MAX77759_USB_CONFIG_STANDARD_OUTPUT_RSVD_7	(0x1 << 7)
+#define MAX77759_USB_CONFIG_STANDARD_OUTPUT_DBGACCCONN	(0x1 << 6)
+#define MAX77759_USB_CONFIG_STANDARD_OUTPUT_RSVD_5	(0x1 << 5)
+#define MAX77759_USB_CONFIG_STANDARD_OUTPUT_RSVD_2	(0x1 << 2)
+#define MAX77759_USB_CONFIG_STANDARD_OUTPUT_RSVD_1	(0x1 << 1)
+#define MAX77759_USB_CONFIG_STANDARD_OUTPUT_RSVD_0	(0x1 << 0)
+
+#define MAX77759_USB_CONFIG_STANDARD_OUTPUT_RSVD_7_SHIFT	7
+#define MAX77759_USB_CONFIG_STANDARD_OUTPUT_RSVD_7_MASK	(0x1 << 7)
+#define MAX77759_USB_CONFIG_STANDARD_OUTPUT_RSVD_7_CLEAR	(~(0x1 << 7))
+#define MAX77759_USB_CONFIG_STANDARD_OUTPUT_DBGACCCONN_SHIFT	6
+#define MAX77759_USB_CONFIG_STANDARD_OUTPUT_DBGACCCONN_MASK	(0x1 << 6)
+#define MAX77759_USB_CONFIG_STANDARD_OUTPUT_DBGACCCONN_CLEAR	(~(0x1 << 6))
+#define MAX77759_USB_CONFIG_STANDARD_OUTPUT_RSVD_5_SHIFT	5
+#define MAX77759_USB_CONFIG_STANDARD_OUTPUT_RSVD_5_MASK	(0x1 << 5)
+#define MAX77759_USB_CONFIG_STANDARD_OUTPUT_RSVD_5_CLEAR	(~(0x1 << 5))
+#define MAX77759_USB_CONFIG_STANDARD_OUTPUT_RSVD_4_3_SHIFT	3
+#define MAX77759_USB_CONFIG_STANDARD_OUTPUT_RSVD_4_3_MASK	(0x3 << 3)
+#define MAX77759_USB_CONFIG_STANDARD_OUTPUT_RSVD_4_3_CLEAR	(~(0x3 << 3))
+#define MAX77759_USB_CONFIG_STANDARD_OUTPUT_RSVD_2_SHIFT	2
+#define MAX77759_USB_CONFIG_STANDARD_OUTPUT_RSVD_2_MASK	(0x1 << 2)
+#define MAX77759_USB_CONFIG_STANDARD_OUTPUT_RSVD_2_CLEAR	(~(0x1 << 2))
+#define MAX77759_USB_CONFIG_STANDARD_OUTPUT_RSVD_1_SHIFT	1
+#define MAX77759_USB_CONFIG_STANDARD_OUTPUT_RSVD_1_MASK	(0x1 << 1)
+#define MAX77759_USB_CONFIG_STANDARD_OUTPUT_RSVD_1_CLEAR	(~(0x1 << 1))
+#define MAX77759_USB_CONFIG_STANDARD_OUTPUT_RSVD_0_SHIFT	0
+#define MAX77759_USB_CONFIG_STANDARD_OUTPUT_RSVD_0_MASK	(0x1 << 0)
+#define MAX77759_USB_CONFIG_STANDARD_OUTPUT_RSVD_0_CLEAR	(~(0x1 << 0))
+
+MAX77759_BFF(usb_config_standard_output_rsvd_7,7,7)
+MAX77759_BFF(usb_config_standard_output_dbgaccconn,6,6)
+MAX77759_BFF(usb_config_standard_output_rsvd_5,5,5)
+MAX77759_BFF(usb_config_standard_output_rsvd_4_3,4,3)
+MAX77759_BFF(usb_config_standard_output_rsvd_2,2,2)
+MAX77759_BFF(usb_config_standard_output_rsvd_1,1,1)
+MAX77759_BFF(usb_config_standard_output_rsvd_0,0,0)
+static inline const char *
+max77759_usb_config_standard_output_cstr(char *buff, size_t len, int val)
+{
+#ifdef SCNPRINTF
+	int i = 0;
+
+	i += SCNPRINTF(&buff[i], len - i, " RSVD_7=%x",
+		FIELD2VALUE(MAX77759_USB_CONFIG_STANDARD_OUTPUT_RSVD_7, val));
+	i += SCNPRINTF(&buff[i], len - i, " DBGACCCONN=%x",
+		FIELD2VALUE(MAX77759_USB_CONFIG_STANDARD_OUTPUT_DBGACCCONN, val));
+	i += SCNPRINTF(&buff[i], len - i, " RSVD_5=%x",
+		FIELD2VALUE(MAX77759_USB_CONFIG_STANDARD_OUTPUT_RSVD_5, val));
+	i += SCNPRINTF(&buff[i], len - i, " RSVD_4_3=%x",
+		FIELD2VALUE(MAX77759_USB_CONFIG_STANDARD_OUTPUT_RSVD_4_3, val));
+	i += SCNPRINTF(&buff[i], len - i, " RSVD_2=%x",
+		FIELD2VALUE(MAX77759_USB_CONFIG_STANDARD_OUTPUT_RSVD_2, val));
+	i += SCNPRINTF(&buff[i], len - i, " RSVD_1=%x",
+		FIELD2VALUE(MAX77759_USB_CONFIG_STANDARD_OUTPUT_RSVD_1, val));
+	i += SCNPRINTF(&buff[i], len - i, " RSVD_0=%x",
+		FIELD2VALUE(MAX77759_USB_CONFIG_STANDARD_OUTPUT_RSVD_0, val));
+#else
+	buff[0] = 0;
+#endif
+	return buff;
+}
+
+/*
+ * TCPC_CONTROL_REG,0x19,0b00000000,0x00
+ * RSVD_7,EN_LK4CONN_ALRT,EN_WD_TMR,DBG_ACC_CNTRL,RSVD_3_2[1:0],,BIST_TM
+ */
+#define MAX77759_USB_TCPC_CONTROL_REG	0x19
+#define MAX77759_USB_TCPC_CONTROL_REG_RSVD_7	(0x1 << 7)
+#define MAX77759_USB_TCPC_CONTROL_REG_EN_LK4CONN_ALRT	(0x1 << 6)
+#define MAX77759_USB_TCPC_CONTROL_REG_EN_WD_TMR	(0x1 << 5)
+#define MAX77759_USB_TCPC_CONTROL_REG_DBG_ACC_CNTRL	(0x1 << 4)
+#define MAX77759_USB_TCPC_CONTROL_REG_BIST_TM	(0x1 << 1)
+#define MAX77759_USB_TCPC_CONTROL_REG_PLUG_ORNT	(0x1 << 0)
+
+#define MAX77759_USB_TCPC_CONTROL_REG_RSVD_7_SHIFT	7
+#define MAX77759_USB_TCPC_CONTROL_REG_RSVD_7_MASK	(0x1 << 7)
+#define MAX77759_USB_TCPC_CONTROL_REG_RSVD_7_CLEAR	(~(0x1 << 7))
+#define MAX77759_USB_TCPC_CONTROL_REG_EN_LK4CONN_ALRT_SHIFT	6
+#define MAX77759_USB_TCPC_CONTROL_REG_EN_LK4CONN_ALRT_MASK	(0x1 << 6)
+#define MAX77759_USB_TCPC_CONTROL_REG_EN_LK4CONN_ALRT_CLEAR	(~(0x1 << 6))
+#define MAX77759_USB_TCPC_CONTROL_REG_EN_WD_TMR_SHIFT	5
+#define MAX77759_USB_TCPC_CONTROL_REG_EN_WD_TMR_MASK	(0x1 << 5)
+#define MAX77759_USB_TCPC_CONTROL_REG_EN_WD_TMR_CLEAR	(~(0x1 << 5))
+#define MAX77759_USB_TCPC_CONTROL_REG_DBG_ACC_CNTRL_SHIFT	4
+#define MAX77759_USB_TCPC_CONTROL_REG_DBG_ACC_CNTRL_MASK	(0x1 << 4)
+#define MAX77759_USB_TCPC_CONTROL_REG_DBG_ACC_CNTRL_CLEAR	(~(0x1 << 4))
+#define MAX77759_USB_TCPC_CONTROL_REG_RSVD_3_2_SHIFT	2
+#define MAX77759_USB_TCPC_CONTROL_REG_RSVD_3_2_MASK	(0x3 << 2)
+#define MAX77759_USB_TCPC_CONTROL_REG_RSVD_3_2_CLEAR	(~(0x3 << 2))
+#define MAX77759_USB_TCPC_CONTROL_REG_BIST_TM_SHIFT	1
+#define MAX77759_USB_TCPC_CONTROL_REG_BIST_TM_MASK	(0x1 << 1)
+#define MAX77759_USB_TCPC_CONTROL_REG_BIST_TM_CLEAR	(~(0x1 << 1))
+#define MAX77759_USB_TCPC_CONTROL_REG_PLUG_ORNT_SHIFT	0
+#define MAX77759_USB_TCPC_CONTROL_REG_PLUG_ORNT_MASK	(0x1 << 0)
+#define MAX77759_USB_TCPC_CONTROL_REG_PLUG_ORNT_CLEAR	(~(0x1 << 0))
+
+MAX77759_BFF(usb_tcpc_control_reg_rsvd_7,7,7)
+MAX77759_BFF(usb_tcpc_control_reg_en_lk4conn_alrt,6,6)
+MAX77759_BFF(usb_tcpc_control_reg_en_wd_tmr,5,5)
+MAX77759_BFF(usb_tcpc_control_reg_dbg_acc_cntrl,4,4)
+MAX77759_BFF(usb_tcpc_control_reg_rsvd_3_2,3,2)
+MAX77759_BFF(usb_tcpc_control_reg_bist_tm,1,1)
+MAX77759_BFF(usb_tcpc_control_reg_plug_ornt,0,0)
+static inline const char *
+max77759_usb_tcpc_control_reg_cstr(char *buff, size_t len, int val)
+{
+#ifdef SCNPRINTF
+	int i = 0;
+
+	i += SCNPRINTF(&buff[i], len - i, " RSVD_7=%x",
+		FIELD2VALUE(MAX77759_USB_TCPC_CONTROL_REG_RSVD_7, val));
+	i += SCNPRINTF(&buff[i], len - i, " EN_LK4CONN_ALRT=%x",
+		FIELD2VALUE(MAX77759_USB_TCPC_CONTROL_REG_EN_LK4CONN_ALRT, val));
+	i += SCNPRINTF(&buff[i], len - i, " EN_WD_TMR=%x",
+		FIELD2VALUE(MAX77759_USB_TCPC_CONTROL_REG_EN_WD_TMR, val));
+	i += SCNPRINTF(&buff[i], len - i, " DBG_ACC_CNTRL=%x",
+		FIELD2VALUE(MAX77759_USB_TCPC_CONTROL_REG_DBG_ACC_CNTRL, val));
+	i += SCNPRINTF(&buff[i], len - i, " RSVD_3_2=%x",
+		FIELD2VALUE(MAX77759_USB_TCPC_CONTROL_REG_RSVD_3_2, val));
+	i += SCNPRINTF(&buff[i], len - i, " BIST_TM=%x",
+		FIELD2VALUE(MAX77759_USB_TCPC_CONTROL_REG_BIST_TM, val));
+	i += SCNPRINTF(&buff[i], len - i, " PLUG_ORNT=%x",
+		FIELD2VALUE(MAX77759_USB_TCPC_CONTROL_REG_PLUG_ORNT, val));
+#else
+	buff[0] = 0;
+#endif
+	return buff;
+}
+
+/*
+ * ROLE_CONTROL_REG,0x1A,0b00001010,0x0a
+ * RSVD_7,DRP,RP_VAL[1:0],,CC2[1:0],,CC1[1:0]
+ */
+#define MAX77759_USB_ROLE_CONTROL_REG	0x1A
+#define MAX77759_USB_ROLE_CONTROL_REG_RSVD_7	(0x1 << 7)
+#define MAX77759_USB_ROLE_CONTROL_REG_DRP	(0x1 << 6)
+
+#define MAX77759_USB_ROLE_CONTROL_REG_RSVD_7_SHIFT	7
+#define MAX77759_USB_ROLE_CONTROL_REG_RSVD_7_MASK	(0x1 << 7)
+#define MAX77759_USB_ROLE_CONTROL_REG_RSVD_7_CLEAR	(~(0x1 << 7))
+#define MAX77759_USB_ROLE_CONTROL_REG_DRP_SHIFT	6
+#define MAX77759_USB_ROLE_CONTROL_REG_DRP_MASK	(0x1 << 6)
+#define MAX77759_USB_ROLE_CONTROL_REG_DRP_CLEAR	(~(0x1 << 6))
+#define MAX77759_USB_ROLE_CONTROL_REG_RP_VAL_SHIFT	4
+#define MAX77759_USB_ROLE_CONTROL_REG_RP_VAL_MASK	(0x3 << 4)
+#define MAX77759_USB_ROLE_CONTROL_REG_RP_VAL_CLEAR	(~(0x3 << 4))
+#define MAX77759_USB_ROLE_CONTROL_REG_CC2_SHIFT	2
+#define MAX77759_USB_ROLE_CONTROL_REG_CC2_MASK	(0x3 << 2)
+#define MAX77759_USB_ROLE_CONTROL_REG_CC2_CLEAR	(~(0x3 << 2))
+#define MAX77759_USB_ROLE_CONTROL_REG_CC1_SHIFT	0
+#define MAX77759_USB_ROLE_CONTROL_REG_CC1_MASK	(0x3 << 0)
+#define MAX77759_USB_ROLE_CONTROL_REG_CC1_CLEAR	(~(0x3 << 0))
+
+MAX77759_BFF(usb_role_control_reg_rsvd_7,7,7)
+MAX77759_BFF(usb_role_control_reg_drp,6,6)
+MAX77759_BFF(usb_role_control_reg_rp_val,5,4)
+MAX77759_BFF(usb_role_control_reg_cc2,3,2)
+MAX77759_BFF(usb_role_control_reg_cc1,1,0)
+static inline const char *
+max77759_usb_role_control_reg_cstr(char *buff, size_t len, int val)
+{
+#ifdef SCNPRINTF
+	int i = 0;
+
+	i += SCNPRINTF(&buff[i], len - i, " RSVD_7=%x",
+		FIELD2VALUE(MAX77759_USB_ROLE_CONTROL_REG_RSVD_7, val));
+	i += SCNPRINTF(&buff[i], len - i, " DRP=%x",
+		FIELD2VALUE(MAX77759_USB_ROLE_CONTROL_REG_DRP, val));
+	i += SCNPRINTF(&buff[i], len - i, " RP_VAL=%x",
+		FIELD2VALUE(MAX77759_USB_ROLE_CONTROL_REG_RP_VAL, val));
+	i += SCNPRINTF(&buff[i], len - i, " CC2=%x",
+		FIELD2VALUE(MAX77759_USB_ROLE_CONTROL_REG_CC2, val));
+	i += SCNPRINTF(&buff[i], len - i, " CC1=%x",
+		FIELD2VALUE(MAX77759_USB_ROLE_CONTROL_REG_CC1, val));
+#else
+	buff[0] = 0;
+#endif
+	return buff;
+}
+
+/*
+ * FAULT_CONTROL_REG,0x1B,0b00000000,0x00
+ * RSVD_7_5[2:0],,,RSVD_4,VBUS_DISCH_FAIL_DIS,RSVD_2,RSVD_1
+ */
+#define MAX77759_USB_FAULT_CONTROL_REG	0x1B
+#define MAX77759_USB_FAULT_CONTROL_REG_RSVD_4	(0x1 << 4)
+#define MAX77759_USB_FAULT_CONTROL_REG_VBUS_DISCH_FAIL_DIS	(0x1 << 3)
+#define MAX77759_USB_FAULT_CONTROL_REG_RSVD_2	(0x1 << 2)
+#define MAX77759_USB_FAULT_CONTROL_REG_RSVD_1	(0x1 << 1)
+#define MAX77759_USB_FAULT_CONTROL_REG_VCONN_OCP_FAULT_DIS	(0x1 << 0)
+
+#define MAX77759_USB_FAULT_CONTROL_REG_RSVD_7_5_SHIFT	5
+#define MAX77759_USB_FAULT_CONTROL_REG_RSVD_7_5_MASK	(0x7 << 5)
+#define MAX77759_USB_FAULT_CONTROL_REG_RSVD_7_5_CLEAR	(~(0x7 << 5))
+#define MAX77759_USB_FAULT_CONTROL_REG_RSVD_4_SHIFT	4
+#define MAX77759_USB_FAULT_CONTROL_REG_RSVD_4_MASK	(0x1 << 4)
+#define MAX77759_USB_FAULT_CONTROL_REG_RSVD_4_CLEAR	(~(0x1 << 4))
+#define MAX77759_USB_FAULT_CONTROL_REG_VBUS_DISCH_FAIL_DIS_SHIFT	3
+#define MAX77759_USB_FAULT_CONTROL_REG_VBUS_DISCH_FAIL_DIS_MASK	(0x1 << 3)
+#define MAX77759_USB_FAULT_CONTROL_REG_VBUS_DISCH_FAIL_DIS_CLEAR	(~(0x1 << 3))
+#define MAX77759_USB_FAULT_CONTROL_REG_RSVD_2_SHIFT	2
+#define MAX77759_USB_FAULT_CONTROL_REG_RSVD_2_MASK	(0x1 << 2)
+#define MAX77759_USB_FAULT_CONTROL_REG_RSVD_2_CLEAR	(~(0x1 << 2))
+#define MAX77759_USB_FAULT_CONTROL_REG_RSVD_1_SHIFT	1
+#define MAX77759_USB_FAULT_CONTROL_REG_RSVD_1_MASK	(0x1 << 1)
+#define MAX77759_USB_FAULT_CONTROL_REG_RSVD_1_CLEAR	(~(0x1 << 1))
+#define MAX77759_USB_FAULT_CONTROL_REG_VCONN_OCP_FAULT_DIS_SHIFT	0
+#define MAX77759_USB_FAULT_CONTROL_REG_VCONN_OCP_FAULT_DIS_MASK	(0x1 << 0)
+#define MAX77759_USB_FAULT_CONTROL_REG_VCONN_OCP_FAULT_DIS_CLEAR	(~(0x1 << 0))
+
+MAX77759_BFF(usb_fault_control_reg_rsvd_7_5,7,5)
+MAX77759_BFF(usb_fault_control_reg_rsvd_4,4,4)
+MAX77759_BFF(usb_fault_control_reg_vbus_disch_fail_dis,3,3)
+MAX77759_BFF(usb_fault_control_reg_rsvd_2,2,2)
+MAX77759_BFF(usb_fault_control_reg_rsvd_1,1,1)
+MAX77759_BFF(usb_fault_control_reg_vconn_ocp_fault_dis,0,0)
+static inline const char *
+max77759_usb_fault_control_reg_cstr(char *buff, size_t len, int val)
+{
+#ifdef SCNPRINTF
+	int i = 0;
+
+	i += SCNPRINTF(&buff[i], len - i, " RSVD_7_5=%x",
+		FIELD2VALUE(MAX77759_USB_FAULT_CONTROL_REG_RSVD_7_5, val));
+	i += SCNPRINTF(&buff[i], len - i, " RSVD_4=%x",
+		FIELD2VALUE(MAX77759_USB_FAULT_CONTROL_REG_RSVD_4, val));
+	i += SCNPRINTF(&buff[i], len - i, " VBUS_DISCH_FAIL_DIS=%x",
+		FIELD2VALUE(MAX77759_USB_FAULT_CONTROL_REG_VBUS_DISCH_FAIL_DIS, val));
+	i += SCNPRINTF(&buff[i], len - i, " RSVD_2=%x",
+		FIELD2VALUE(MAX77759_USB_FAULT_CONTROL_REG_RSVD_2, val));
+	i += SCNPRINTF(&buff[i], len - i, " RSVD_1=%x",
+		FIELD2VALUE(MAX77759_USB_FAULT_CONTROL_REG_RSVD_1, val));
+	i += SCNPRINTF(&buff[i], len - i, " VCONN_OCP_FAULT_DIS=%x",
+		FIELD2VALUE(MAX77759_USB_FAULT_CONTROL_REG_VCONN_OCP_FAULT_DIS, val));
+#else
+	buff[0] = 0;
+#endif
+	return buff;
+}
+
+/*
+ * POWER_CONTROL_REG,0x1C,0b01100000,0x60
+ * FAST_RSWP_EN,VBUS_VOLT_MON,DIS_VOLT_ALRM,AUTO_DISCH_DISC,EN_BLEED_DISCH,FORC_DISCH,RSVD_1
+ */
+#define MAX77759_USB_POWER_CONTROL_REG	0x1C
+#define MAX77759_USB_POWER_CONTROL_REG_FAST_RSWP_EN	(0x1 << 7)
+#define MAX77759_USB_POWER_CONTROL_REG_VBUS_VOLT_MON	(0x1 << 6)
+#define MAX77759_USB_POWER_CONTROL_REG_DIS_VOLT_ALRM	(0x1 << 5)
+#define MAX77759_USB_POWER_CONTROL_REG_AUTO_DISCH_DISC	(0x1 << 4)
+#define MAX77759_USB_POWER_CONTROL_REG_EN_BLEED_DISCH	(0x1 << 3)
+#define MAX77759_USB_POWER_CONTROL_REG_FORC_DISCH	(0x1 << 2)
+#define MAX77759_USB_POWER_CONTROL_REG_RSVD_1	(0x1 << 1)
+#define MAX77759_USB_POWER_CONTROL_REG_EN_VCONN	(0x1 << 0)
+
+#define MAX77759_USB_POWER_CONTROL_REG_FAST_RSWP_EN_SHIFT	7
+#define MAX77759_USB_POWER_CONTROL_REG_FAST_RSWP_EN_MASK	(0x1 << 7)
+#define MAX77759_USB_POWER_CONTROL_REG_FAST_RSWP_EN_CLEAR	(~(0x1 << 7))
+#define MAX77759_USB_POWER_CONTROL_REG_VBUS_VOLT_MON_SHIFT	6
+#define MAX77759_USB_POWER_CONTROL_REG_VBUS_VOLT_MON_MASK	(0x1 << 6)
+#define MAX77759_USB_POWER_CONTROL_REG_VBUS_VOLT_MON_CLEAR	(~(0x1 << 6))
+#define MAX77759_USB_POWER_CONTROL_REG_DIS_VOLT_ALRM_SHIFT	5
+#define MAX77759_USB_POWER_CONTROL_REG_DIS_VOLT_ALRM_MASK	(0x1 << 5)
+#define MAX77759_USB_POWER_CONTROL_REG_DIS_VOLT_ALRM_CLEAR	(~(0x1 << 5))
+#define MAX77759_USB_POWER_CONTROL_REG_AUTO_DISCH_DISC_SHIFT	4
+#define MAX77759_USB_POWER_CONTROL_REG_AUTO_DISCH_DISC_MASK	(0x1 << 4)
+#define MAX77759_USB_POWER_CONTROL_REG_AUTO_DISCH_DISC_CLEAR	(~(0x1 << 4))
+#define MAX77759_USB_POWER_CONTROL_REG_EN_BLEED_DISCH_SHIFT	3
+#define MAX77759_USB_POWER_CONTROL_REG_EN_BLEED_DISCH_MASK	(0x1 << 3)
+#define MAX77759_USB_POWER_CONTROL_REG_EN_BLEED_DISCH_CLEAR	(~(0x1 << 3))
+#define MAX77759_USB_POWER_CONTROL_REG_FORC_DISCH_SHIFT	2
+#define MAX77759_USB_POWER_CONTROL_REG_FORC_DISCH_MASK	(0x1 << 2)
+#define MAX77759_USB_POWER_CONTROL_REG_FORC_DISCH_CLEAR	(~(0x1 << 2))
+#define MAX77759_USB_POWER_CONTROL_REG_RSVD_1_SHIFT	1
+#define MAX77759_USB_POWER_CONTROL_REG_RSVD_1_MASK	(0x1 << 1)
+#define MAX77759_USB_POWER_CONTROL_REG_RSVD_1_CLEAR	(~(0x1 << 1))
+#define MAX77759_USB_POWER_CONTROL_REG_EN_VCONN_SHIFT	0
+#define MAX77759_USB_POWER_CONTROL_REG_EN_VCONN_MASK	(0x1 << 0)
+#define MAX77759_USB_POWER_CONTROL_REG_EN_VCONN_CLEAR	(~(0x1 << 0))
+
+MAX77759_BFF(usb_power_control_reg_fast_rswp_en,7,7)
+MAX77759_BFF(usb_power_control_reg_vbus_volt_mon,6,6)
+MAX77759_BFF(usb_power_control_reg_dis_volt_alrm,5,5)
+MAX77759_BFF(usb_power_control_reg_auto_disch_disc,4,4)
+MAX77759_BFF(usb_power_control_reg_en_bleed_disch,3,3)
+MAX77759_BFF(usb_power_control_reg_forc_disch,2,2)
+MAX77759_BFF(usb_power_control_reg_rsvd_1,1,1)
+MAX77759_BFF(usb_power_control_reg_en_vconn,0,0)
+static inline const char *
+max77759_usb_power_control_reg_cstr(char *buff, size_t len, int val)
+{
+#ifdef SCNPRINTF
+	int i = 0;
+
+	i += SCNPRINTF(&buff[i], len - i, " FAST_RSWP_EN=%x",
+		FIELD2VALUE(MAX77759_USB_POWER_CONTROL_REG_FAST_RSWP_EN, val));
+	i += SCNPRINTF(&buff[i], len - i, " VBUS_VOLT_MON=%x",
+		FIELD2VALUE(MAX77759_USB_POWER_CONTROL_REG_VBUS_VOLT_MON, val));
+	i += SCNPRINTF(&buff[i], len - i, " DIS_VOLT_ALRM=%x",
+		FIELD2VALUE(MAX77759_USB_POWER_CONTROL_REG_DIS_VOLT_ALRM, val));
+	i += SCNPRINTF(&buff[i], len - i, " AUTO_DISCH_DISC=%x",
+		FIELD2VALUE(MAX77759_USB_POWER_CONTROL_REG_AUTO_DISCH_DISC, val));
+	i += SCNPRINTF(&buff[i], len - i, " EN_BLEED_DISCH=%x",
+		FIELD2VALUE(MAX77759_USB_POWER_CONTROL_REG_EN_BLEED_DISCH, val));
+	i += SCNPRINTF(&buff[i], len - i, " FORC_DISCH=%x",
+		FIELD2VALUE(MAX77759_USB_POWER_CONTROL_REG_FORC_DISCH, val));
+	i += SCNPRINTF(&buff[i], len - i, " RSVD_1=%x",
+		FIELD2VALUE(MAX77759_USB_POWER_CONTROL_REG_RSVD_1, val));
+	i += SCNPRINTF(&buff[i], len - i, " EN_VCONN=%x",
+		FIELD2VALUE(MAX77759_USB_POWER_CONTROL_REG_EN_VCONN, val));
+#else
+	buff[0] = 0;
+#endif
+	return buff;
+}
+
+/*
+ * CC_STATUS_REG,0x1D,0b00000000,0x00
+ * RSVD_7_6[1:0],,LOOKING4CONN,CONN_RSLT,CC2_STATE[1:0],,CC1_STATE[1:0]
+ */
+#define MAX77759_USB_CC_STATUS_REG	0x1D
+#define MAX77759_USB_CC_STATUS_REG_LOOKING4CONN	(0x1 << 5)
+#define MAX77759_USB_CC_STATUS_REG_CONN_RSLT	(0x1 << 4)
+
+#define MAX77759_USB_CC_STATUS_REG_RSVD_7_6_SHIFT	6
+#define MAX77759_USB_CC_STATUS_REG_RSVD_7_6_MASK	(0x3 << 6)
+#define MAX77759_USB_CC_STATUS_REG_RSVD_7_6_CLEAR	(~(0x3 << 6))
+#define MAX77759_USB_CC_STATUS_REG_LOOKING4CONN_SHIFT	5
+#define MAX77759_USB_CC_STATUS_REG_LOOKING4CONN_MASK	(0x1 << 5)
+#define MAX77759_USB_CC_STATUS_REG_LOOKING4CONN_CLEAR	(~(0x1 << 5))
+#define MAX77759_USB_CC_STATUS_REG_CONN_RSLT_SHIFT	4
+#define MAX77759_USB_CC_STATUS_REG_CONN_RSLT_MASK	(0x1 << 4)
+#define MAX77759_USB_CC_STATUS_REG_CONN_RSLT_CLEAR	(~(0x1 << 4))
+#define MAX77759_USB_CC_STATUS_REG_CC2_STATE_SHIFT	2
+#define MAX77759_USB_CC_STATUS_REG_CC2_STATE_MASK	(0x3 << 2)
+#define MAX77759_USB_CC_STATUS_REG_CC2_STATE_CLEAR	(~(0x3 << 2))
+#define MAX77759_USB_CC_STATUS_REG_CC1_STATE_SHIFT	0
+#define MAX77759_USB_CC_STATUS_REG_CC1_STATE_MASK	(0x3 << 0)
+#define MAX77759_USB_CC_STATUS_REG_CC1_STATE_CLEAR	(~(0x3 << 0))
+
+MAX77759_BFF(usb_cc_status_reg_rsvd_7_6,7,6)
+MAX77759_BFF(usb_cc_status_reg_looking4conn,5,5)
+MAX77759_BFF(usb_cc_status_reg_conn_rslt,4,4)
+MAX77759_BFF(usb_cc_status_reg_cc2_state,3,2)
+MAX77759_BFF(usb_cc_status_reg_cc1_state,1,0)
+static inline const char *
+max77759_usb_cc_status_reg_cstr(char *buff, size_t len, int val)
+{
+#ifdef SCNPRINTF
+	int i = 0;
+
+	i += SCNPRINTF(&buff[i], len - i, " RSVD_7_6=%x",
+		FIELD2VALUE(MAX77759_USB_CC_STATUS_REG_RSVD_7_6, val));
+	i += SCNPRINTF(&buff[i], len - i, " LOOKING4CONN=%x",
+		FIELD2VALUE(MAX77759_USB_CC_STATUS_REG_LOOKING4CONN, val));
+	i += SCNPRINTF(&buff[i], len - i, " CONN_RSLT=%x",
+		FIELD2VALUE(MAX77759_USB_CC_STATUS_REG_CONN_RSLT, val));
+	i += SCNPRINTF(&buff[i], len - i, " CC2_STATE=%x",
+		FIELD2VALUE(MAX77759_USB_CC_STATUS_REG_CC2_STATE, val));
+	i += SCNPRINTF(&buff[i], len - i, " CC1_STATE=%x",
+		FIELD2VALUE(MAX77759_USB_CC_STATUS_REG_CC1_STATE, val));
+#else
+	buff[0] = 0;
+#endif
+	return buff;
+}
+
+/*
+ * POWER_STATUS_REG,0x1E,0b00001000,0x08
+ * DBG_ACC_CONN,TCPC_INIT_STAT,SRC_HI_VOLT,SRC_VBUS,VBUS_DET_EN,VBUS_PRESENT,VCONN_PRESENT
+ */
+#define MAX77759_USB_POWER_STATUS_REG	0x1E
+#define MAX77759_USB_POWER_STATUS_REG_DBG_ACC_CONN	(0x1 << 7)
+#define MAX77759_USB_POWER_STATUS_REG_TCPC_INIT_STAT	(0x1 << 6)
+#define MAX77759_USB_POWER_STATUS_REG_SRC_HI_VOLT	(0x1 << 5)
+#define MAX77759_USB_POWER_STATUS_REG_SRC_VBUS	(0x1 << 4)
+#define MAX77759_USB_POWER_STATUS_REG_VBUS_DET_EN	(0x1 << 3)
+#define MAX77759_USB_POWER_STATUS_REG_VBUS_PRESENT	(0x1 << 2)
+#define MAX77759_USB_POWER_STATUS_REG_VCONN_PRESENT	(0x1 << 1)
+#define MAX77759_USB_POWER_STATUS_REG_SNK_VBUS	(0x1 << 0)
+
+#define MAX77759_USB_POWER_STATUS_REG_DBG_ACC_CONN_SHIFT	7
+#define MAX77759_USB_POWER_STATUS_REG_DBG_ACC_CONN_MASK	(0x1 << 7)
+#define MAX77759_USB_POWER_STATUS_REG_DBG_ACC_CONN_CLEAR	(~(0x1 << 7))
+#define MAX77759_USB_POWER_STATUS_REG_TCPC_INIT_STAT_SHIFT	6
+#define MAX77759_USB_POWER_STATUS_REG_TCPC_INIT_STAT_MASK	(0x1 << 6)
+#define MAX77759_USB_POWER_STATUS_REG_TCPC_INIT_STAT_CLEAR	(~(0x1 << 6))
+#define MAX77759_USB_POWER_STATUS_REG_SRC_HI_VOLT_SHIFT	5
+#define MAX77759_USB_POWER_STATUS_REG_SRC_HI_VOLT_MASK	(0x1 << 5)
+#define MAX77759_USB_POWER_STATUS_REG_SRC_HI_VOLT_CLEAR	(~(0x1 << 5))
+#define MAX77759_USB_POWER_STATUS_REG_SRC_VBUS_SHIFT	4
+#define MAX77759_USB_POWER_STATUS_REG_SRC_VBUS_MASK	(0x1 << 4)
+#define MAX77759_USB_POWER_STATUS_REG_SRC_VBUS_CLEAR	(~(0x1 << 4))
+#define MAX77759_USB_POWER_STATUS_REG_VBUS_DET_EN_SHIFT	3
+#define MAX77759_USB_POWER_STATUS_REG_VBUS_DET_EN_MASK	(0x1 << 3)
+#define MAX77759_USB_POWER_STATUS_REG_VBUS_DET_EN_CLEAR	(~(0x1 << 3))
+#define MAX77759_USB_POWER_STATUS_REG_VBUS_PRESENT_SHIFT	2
+#define MAX77759_USB_POWER_STATUS_REG_VBUS_PRESENT_MASK	(0x1 << 2)
+#define MAX77759_USB_POWER_STATUS_REG_VBUS_PRESENT_CLEAR	(~(0x1 << 2))
+#define MAX77759_USB_POWER_STATUS_REG_VCONN_PRESENT_SHIFT	1
+#define MAX77759_USB_POWER_STATUS_REG_VCONN_PRESENT_MASK	(0x1 << 1)
+#define MAX77759_USB_POWER_STATUS_REG_VCONN_PRESENT_CLEAR	(~(0x1 << 1))
+#define MAX77759_USB_POWER_STATUS_REG_SNK_VBUS_SHIFT	0
+#define MAX77759_USB_POWER_STATUS_REG_SNK_VBUS_MASK	(0x1 << 0)
+#define MAX77759_USB_POWER_STATUS_REG_SNK_VBUS_CLEAR	(~(0x1 << 0))
+
+MAX77759_BFF(usb_power_status_reg_dbg_acc_conn,7,7)
+MAX77759_BFF(usb_power_status_reg_tcpc_init_stat,6,6)
+MAX77759_BFF(usb_power_status_reg_src_hi_volt,5,5)
+MAX77759_BFF(usb_power_status_reg_src_vbus,4,4)
+MAX77759_BFF(usb_power_status_reg_vbus_det_en,3,3)
+MAX77759_BFF(usb_power_status_reg_vbus_present,2,2)
+MAX77759_BFF(usb_power_status_reg_vconn_present,1,1)
+MAX77759_BFF(usb_power_status_reg_snk_vbus,0,0)
+static inline const char *
+max77759_usb_power_status_reg_cstr(char *buff, size_t len, int val)
+{
+#ifdef SCNPRINTF
+	int i = 0;
+
+	i += SCNPRINTF(&buff[i], len - i, " DBG_ACC_CONN=%x",
+		FIELD2VALUE(MAX77759_USB_POWER_STATUS_REG_DBG_ACC_CONN, val));
+	i += SCNPRINTF(&buff[i], len - i, " TCPC_INIT_STAT=%x",
+		FIELD2VALUE(MAX77759_USB_POWER_STATUS_REG_TCPC_INIT_STAT, val));
+	i += SCNPRINTF(&buff[i], len - i, " SRC_HI_VOLT=%x",
+		FIELD2VALUE(MAX77759_USB_POWER_STATUS_REG_SRC_HI_VOLT, val));
+	i += SCNPRINTF(&buff[i], len - i, " SRC_VBUS=%x",
+		FIELD2VALUE(MAX77759_USB_POWER_STATUS_REG_SRC_VBUS, val));
+	i += SCNPRINTF(&buff[i], len - i, " VBUS_DET_EN=%x",
+		FIELD2VALUE(MAX77759_USB_POWER_STATUS_REG_VBUS_DET_EN, val));
+	i += SCNPRINTF(&buff[i], len - i, " VBUS_PRESENT=%x",
+		FIELD2VALUE(MAX77759_USB_POWER_STATUS_REG_VBUS_PRESENT, val));
+	i += SCNPRINTF(&buff[i], len - i, " VCONN_PRESENT=%x",
+		FIELD2VALUE(MAX77759_USB_POWER_STATUS_REG_VCONN_PRESENT, val));
+	i += SCNPRINTF(&buff[i], len - i, " SNK_VBUS=%x",
+		FIELD2VALUE(MAX77759_USB_POWER_STATUS_REG_SNK_VBUS, val));
+#else
+	buff[0] = 0;
+#endif
+	return buff;
+}
+
+/*
+ * FAULT_STATUS_REG,0x1F,0b10000000,0x80
+ * ALL_REG_RST,RSVD_6,AUTO_DISCH_FAIL,FORCE_DISCH_FAIL,RSVD_3,RSVD_2,VCONN_OCP_FAULT
+ */
+#define MAX77759_USB_FAULT_STATUS_REG	0x1F
+#define MAX77759_USB_FAULT_STATUS_REG_ALL_REG_RST	(0x1 << 7)
+#define MAX77759_USB_FAULT_STATUS_REG_RSVD_6	(0x1 << 6)
+#define MAX77759_USB_FAULT_STATUS_REG_AUTO_DISCH_FAIL	(0x1 << 5)
+#define MAX77759_USB_FAULT_STATUS_REG_FORCE_DISCH_FAIL	(0x1 << 4)
+#define MAX77759_USB_FAULT_STATUS_REG_RSVD_3	(0x1 << 3)
+#define MAX77759_USB_FAULT_STATUS_REG_RSVD_2	(0x1 << 2)
+#define MAX77759_USB_FAULT_STATUS_REG_VCONN_OCP_FAULT	(0x1 << 1)
+#define MAX77759_USB_FAULT_STATUS_REG_I2C_ERR	(0x1 << 0)
+
+#define MAX77759_USB_FAULT_STATUS_REG_ALL_REG_RST_SHIFT	7
+#define MAX77759_USB_FAULT_STATUS_REG_ALL_REG_RST_MASK	(0x1 << 7)
+#define MAX77759_USB_FAULT_STATUS_REG_ALL_REG_RST_CLEAR	(~(0x1 << 7))
+#define MAX77759_USB_FAULT_STATUS_REG_RSVD_6_SHIFT	6
+#define MAX77759_USB_FAULT_STATUS_REG_RSVD_6_MASK	(0x1 << 6)
+#define MAX77759_USB_FAULT_STATUS_REG_RSVD_6_CLEAR	(~(0x1 << 6))
+#define MAX77759_USB_FAULT_STATUS_REG_AUTO_DISCH_FAIL_SHIFT	5
+#define MAX77759_USB_FAULT_STATUS_REG_AUTO_DISCH_FAIL_MASK	(0x1 << 5)
+#define MAX77759_USB_FAULT_STATUS_REG_AUTO_DISCH_FAIL_CLEAR	(~(0x1 << 5))
+#define MAX77759_USB_FAULT_STATUS_REG_FORCE_DISCH_FAIL_SHIFT	4
+#define MAX77759_USB_FAULT_STATUS_REG_FORCE_DISCH_FAIL_MASK	(0x1 << 4)
+#define MAX77759_USB_FAULT_STATUS_REG_FORCE_DISCH_FAIL_CLEAR	(~(0x1 << 4))
+#define MAX77759_USB_FAULT_STATUS_REG_RSVD_3_SHIFT	3
+#define MAX77759_USB_FAULT_STATUS_REG_RSVD_3_MASK	(0x1 << 3)
+#define MAX77759_USB_FAULT_STATUS_REG_RSVD_3_CLEAR	(~(0x1 << 3))
+#define MAX77759_USB_FAULT_STATUS_REG_RSVD_2_SHIFT	2
+#define MAX77759_USB_FAULT_STATUS_REG_RSVD_2_MASK	(0x1 << 2)
+#define MAX77759_USB_FAULT_STATUS_REG_RSVD_2_CLEAR	(~(0x1 << 2))
+#define MAX77759_USB_FAULT_STATUS_REG_VCONN_OCP_FAULT_SHIFT	1
+#define MAX77759_USB_FAULT_STATUS_REG_VCONN_OCP_FAULT_MASK	(0x1 << 1)
+#define MAX77759_USB_FAULT_STATUS_REG_VCONN_OCP_FAULT_CLEAR	(~(0x1 << 1))
+#define MAX77759_USB_FAULT_STATUS_REG_I2C_ERR_SHIFT	0
+#define MAX77759_USB_FAULT_STATUS_REG_I2C_ERR_MASK	(0x1 << 0)
+#define MAX77759_USB_FAULT_STATUS_REG_I2C_ERR_CLEAR	(~(0x1 << 0))
+
+MAX77759_BFF(usb_fault_status_reg_all_reg_rst,7,7)
+MAX77759_BFF(usb_fault_status_reg_rsvd_6,6,6)
+MAX77759_BFF(usb_fault_status_reg_auto_disch_fail,5,5)
+MAX77759_BFF(usb_fault_status_reg_force_disch_fail,4,4)
+MAX77759_BFF(usb_fault_status_reg_rsvd_3,3,3)
+MAX77759_BFF(usb_fault_status_reg_rsvd_2,2,2)
+MAX77759_BFF(usb_fault_status_reg_vconn_ocp_fault,1,1)
+MAX77759_BFF(usb_fault_status_reg_i2c_err,0,0)
+static inline const char *
+max77759_usb_fault_status_reg_cstr(char *buff, size_t len, int val)
+{
+#ifdef SCNPRINTF
+	int i = 0;
+
+	i += SCNPRINTF(&buff[i], len - i, " ALL_REG_RST=%x",
+		FIELD2VALUE(MAX77759_USB_FAULT_STATUS_REG_ALL_REG_RST, val));
+	i += SCNPRINTF(&buff[i], len - i, " RSVD_6=%x",
+		FIELD2VALUE(MAX77759_USB_FAULT_STATUS_REG_RSVD_6, val));
+	i += SCNPRINTF(&buff[i], len - i, " AUTO_DISCH_FAIL=%x",
+		FIELD2VALUE(MAX77759_USB_FAULT_STATUS_REG_AUTO_DISCH_FAIL, val));
+	i += SCNPRINTF(&buff[i], len - i, " FORCE_DISCH_FAIL=%x",
+		FIELD2VALUE(MAX77759_USB_FAULT_STATUS_REG_FORCE_DISCH_FAIL, val));
+	i += SCNPRINTF(&buff[i], len - i, " RSVD_3=%x",
+		FIELD2VALUE(MAX77759_USB_FAULT_STATUS_REG_RSVD_3, val));
+	i += SCNPRINTF(&buff[i], len - i, " RSVD_2=%x",
+		FIELD2VALUE(MAX77759_USB_FAULT_STATUS_REG_RSVD_2, val));
+	i += SCNPRINTF(&buff[i], len - i, " VCONN_OCP_FAULT=%x",
+		FIELD2VALUE(MAX77759_USB_FAULT_STATUS_REG_VCONN_OCP_FAULT, val));
+	i += SCNPRINTF(&buff[i], len - i, " I2C_ERR=%x",
+		FIELD2VALUE(MAX77759_USB_FAULT_STATUS_REG_I2C_ERR, val));
+#else
+	buff[0] = 0;
+#endif
+	return buff;
+}
+
+/*
+ * EXTENDED_STATUS_REG,0x20,0b00000000,0x00
+ * RSVD_7_1[6:0],,,,,,
+ */
+#define MAX77759_USB_EXTENDED_STATUS_REG	0x20
+#define MAX77759_USB_EXTENDED_STATUS_REG_VSAFE0V	(0x1 << 0)
+
+#define MAX77759_USB_EXTENDED_STATUS_REG_RSVD_7_1_SHIFT	1
+#define MAX77759_USB_EXTENDED_STATUS_REG_RSVD_7_1_MASK	(0x7f << 1)
+#define MAX77759_USB_EXTENDED_STATUS_REG_RSVD_7_1_CLEAR	(~(0x7f << 1))
+#define MAX77759_USB_EXTENDED_STATUS_REG_VSAFE0V_SHIFT	0
+#define MAX77759_USB_EXTENDED_STATUS_REG_VSAFE0V_MASK	(0x1 << 0)
+#define MAX77759_USB_EXTENDED_STATUS_REG_VSAFE0V_CLEAR	(~(0x1 << 0))
+
+MAX77759_BFF(usb_extended_status_reg_rsvd_7_1,7,1)
+MAX77759_BFF(usb_extended_status_reg_vsafe0v,0,0)
+static inline const char *
+max77759_usb_extended_status_reg_cstr(char *buff, size_t len, int val)
+{
+#ifdef SCNPRINTF
+	int i = 0;
+
+	i += SCNPRINTF(&buff[i], len - i, " RSVD_7_1=%x",
+		FIELD2VALUE(MAX77759_USB_EXTENDED_STATUS_REG_RSVD_7_1, val));
+	i += SCNPRINTF(&buff[i], len - i, " VSAFE0V=%x",
+		FIELD2VALUE(MAX77759_USB_EXTENDED_STATUS_REG_VSAFE0V, val));
+#else
+	buff[0] = 0;
+#endif
+	return buff;
+}
+
+/*
+ * ALERT_EXTENDED,0x21,0b00000000,0x00
+ * RSVD_7_3[4:0],,,,,RSVD_2,RSVD_1
+ */
+#define MAX77759_USB_ALERT_EXTENDED	0x21
+#define MAX77759_USB_ALERT_EXTENDED_RSVD_2	(0x1 << 2)
+#define MAX77759_USB_ALERT_EXTENDED_RSVD_1	(0x1 << 1)
+#define MAX77759_USB_ALERT_EXTENDED_SNK_FRS	(0x1 << 0)
+
+#define MAX77759_USB_ALERT_EXTENDED_RSVD_7_3_SHIFT	3
+#define MAX77759_USB_ALERT_EXTENDED_RSVD_7_3_MASK	(0x1f << 3)
+#define MAX77759_USB_ALERT_EXTENDED_RSVD_7_3_CLEAR	(~(0x1f << 3))
+#define MAX77759_USB_ALERT_EXTENDED_RSVD_2_SHIFT	2
+#define MAX77759_USB_ALERT_EXTENDED_RSVD_2_MASK	(0x1 << 2)
+#define MAX77759_USB_ALERT_EXTENDED_RSVD_2_CLEAR	(~(0x1 << 2))
+#define MAX77759_USB_ALERT_EXTENDED_RSVD_1_SHIFT	1
+#define MAX77759_USB_ALERT_EXTENDED_RSVD_1_MASK	(0x1 << 1)
+#define MAX77759_USB_ALERT_EXTENDED_RSVD_1_CLEAR	(~(0x1 << 1))
+#define MAX77759_USB_ALERT_EXTENDED_SNK_FRS_SHIFT	0
+#define MAX77759_USB_ALERT_EXTENDED_SNK_FRS_MASK	(0x1 << 0)
+#define MAX77759_USB_ALERT_EXTENDED_SNK_FRS_CLEAR	(~(0x1 << 0))
+
+MAX77759_BFF(usb_alert_extended_rsvd_7_3,7,3)
+MAX77759_BFF(usb_alert_extended_rsvd_2,2,2)
+MAX77759_BFF(usb_alert_extended_rsvd_1,1,1)
+MAX77759_BFF(usb_alert_extended_snk_frs,0,0)
+static inline const char *
+max77759_usb_alert_extended_cstr(char *buff, size_t len, int val)
+{
+#ifdef SCNPRINTF
+	int i = 0;
+
+	i += SCNPRINTF(&buff[i], len - i, " RSVD_7_3=%x",
+		FIELD2VALUE(MAX77759_USB_ALERT_EXTENDED_RSVD_7_3, val));
+	i += SCNPRINTF(&buff[i], len - i, " RSVD_2=%x",
+		FIELD2VALUE(MAX77759_USB_ALERT_EXTENDED_RSVD_2, val));
+	i += SCNPRINTF(&buff[i], len - i, " RSVD_1=%x",
+		FIELD2VALUE(MAX77759_USB_ALERT_EXTENDED_RSVD_1, val));
+	i += SCNPRINTF(&buff[i], len - i, " SNK_FRS=%x",
+		FIELD2VALUE(MAX77759_USB_ALERT_EXTENDED_SNK_FRS, val));
+#else
+	buff[0] = 0;
+#endif
+	return buff;
+}
+
+/*
+ * COMMAND_REG,0x23,0b00000000,0x00
+ * COMMAND[7:0],,,,,,
+ */
+#define MAX77759_USB_COMMAND_REG	0x23
+
+/*
+ * DEVICE_CAPABILITIES_1_L,0x24,0b11011000,0xd8
+ * PWR_ROLE_CAP[2:0],,,SOP_DBG_CAP,SRC_VCONN_CAP,SNK_VBUS_CAP,SRC_HI_VBUS_CAP
+ */
+#define MAX77759_USB_DEVICE_CAPABILITIES_1_L	0x24
+#define MAX77759_USB_DEVICE_CAPABILITIES_1_L_SOP_DBG_CAP	(0x1 << 4)
+#define MAX77759_USB_DEVICE_CAPABILITIES_1_L_SRC_VCONN_CAP	(0x1 << 3)
+#define MAX77759_USB_DEVICE_CAPABILITIES_1_L_SNK_VBUS_CAP	(0x1 << 2)
+#define MAX77759_USB_DEVICE_CAPABILITIES_1_L_SRC_HI_VBUS_CAP	(0x1 << 1)
+#define MAX77759_USB_DEVICE_CAPABILITIES_1_L_SRC_VBUS_CAP	(0x1 << 0)
+
+#define MAX77759_USB_DEVICE_CAPABILITIES_1_L_PWR_ROLE_CAP_SHIFT	5
+#define MAX77759_USB_DEVICE_CAPABILITIES_1_L_PWR_ROLE_CAP_MASK	(0x7 << 5)
+#define MAX77759_USB_DEVICE_CAPABILITIES_1_L_PWR_ROLE_CAP_CLEAR	(~(0x7 << 5))
+#define MAX77759_USB_DEVICE_CAPABILITIES_1_L_SOP_DBG_CAP_SHIFT	4
+#define MAX77759_USB_DEVICE_CAPABILITIES_1_L_SOP_DBG_CAP_MASK	(0x1 << 4)
+#define MAX77759_USB_DEVICE_CAPABILITIES_1_L_SOP_DBG_CAP_CLEAR	(~(0x1 << 4))
+#define MAX77759_USB_DEVICE_CAPABILITIES_1_L_SRC_VCONN_CAP_SHIFT	3
+#define MAX77759_USB_DEVICE_CAPABILITIES_1_L_SRC_VCONN_CAP_MASK	(0x1 << 3)
+#define MAX77759_USB_DEVICE_CAPABILITIES_1_L_SRC_VCONN_CAP_CLEAR	(~(0x1 << 3))
+#define MAX77759_USB_DEVICE_CAPABILITIES_1_L_SNK_VBUS_CAP_SHIFT	2
+#define MAX77759_USB_DEVICE_CAPABILITIES_1_L_SNK_VBUS_CAP_MASK	(0x1 << 2)
+#define MAX77759_USB_DEVICE_CAPABILITIES_1_L_SNK_VBUS_CAP_CLEAR	(~(0x1 << 2))
+#define MAX77759_USB_DEVICE_CAPABILITIES_1_L_SRC_HI_VBUS_CAP_SHIFT	1
+#define MAX77759_USB_DEVICE_CAPABILITIES_1_L_SRC_HI_VBUS_CAP_MASK	(0x1 << 1)
+#define MAX77759_USB_DEVICE_CAPABILITIES_1_L_SRC_HI_VBUS_CAP_CLEAR	(~(0x1 << 1))
+#define MAX77759_USB_DEVICE_CAPABILITIES_1_L_SRC_VBUS_CAP_SHIFT	0
+#define MAX77759_USB_DEVICE_CAPABILITIES_1_L_SRC_VBUS_CAP_MASK	(0x1 << 0)
+#define MAX77759_USB_DEVICE_CAPABILITIES_1_L_SRC_VBUS_CAP_CLEAR	(~(0x1 << 0))
+
+MAX77759_BFF(usb_device_capabilities_1_l_pwr_role_cap,7,5)
+MAX77759_BFF(usb_device_capabilities_1_l_sop_dbg_cap,4,4)
+MAX77759_BFF(usb_device_capabilities_1_l_src_vconn_cap,3,3)
+MAX77759_BFF(usb_device_capabilities_1_l_snk_vbus_cap,2,2)
+MAX77759_BFF(usb_device_capabilities_1_l_src_hi_vbus_cap,1,1)
+MAX77759_BFF(usb_device_capabilities_1_l_src_vbus_cap,0,0)
+static inline const char *
+max77759_usb_device_capabilities_1_l_cstr(char *buff, size_t len, int val)
+{
+#ifdef SCNPRINTF
+	int i = 0;
+
+	i += SCNPRINTF(&buff[i], len - i, " PWR_ROLE_CAP=%x",
+		FIELD2VALUE(MAX77759_USB_DEVICE_CAPABILITIES_1_L_PWR_ROLE_CAP, val));
+	i += SCNPRINTF(&buff[i], len - i, " SOP_DBG_CAP=%x",
+		FIELD2VALUE(MAX77759_USB_DEVICE_CAPABILITIES_1_L_SOP_DBG_CAP, val));
+	i += SCNPRINTF(&buff[i], len - i, " SRC_VCONN_CAP=%x",
+		FIELD2VALUE(MAX77759_USB_DEVICE_CAPABILITIES_1_L_SRC_VCONN_CAP, val));
+	i += SCNPRINTF(&buff[i], len - i, " SNK_VBUS_CAP=%x",
+		FIELD2VALUE(MAX77759_USB_DEVICE_CAPABILITIES_1_L_SNK_VBUS_CAP, val));
+	i += SCNPRINTF(&buff[i], len - i, " SRC_HI_VBUS_CAP=%x",
+		FIELD2VALUE(MAX77759_USB_DEVICE_CAPABILITIES_1_L_SRC_HI_VBUS_CAP, val));
+	i += SCNPRINTF(&buff[i], len - i, " SRC_VBUS_CAP=%x",
+		FIELD2VALUE(MAX77759_USB_DEVICE_CAPABILITIES_1_L_SRC_VBUS_CAP, val));
+#else
+	buff[0] = 0;
+#endif
+	return buff;
+}
+
+/*
+ * DEVICE_CAPABILITIES_1_H,0x25,0b00011110,0x1e
+ * VBUS_HI_VOLT_TRGT_CAP,VBUS_OCP_RPT_CAP,VBUS_OVP_RPT_CAP,BLEED_DISCH_CAP,FORCE_DISCH_CAP,VBUS_MEAS_ALRM_CAP,SRC_RES_SUP_CAP[1:0]
+ */
+#define MAX77759_USB_DEVICE_CAPABILITIES_1_H	0x25
+#define MAX77759_USB_DEVICE_CAPABILITIES_1_H_VBUS_HI_VOLT_TRGT_CAP	(0x1 << 7)
+#define MAX77759_USB_DEVICE_CAPABILITIES_1_H_VBUS_OCP_RPT_CAP	(0x1 << 6)
+#define MAX77759_USB_DEVICE_CAPABILITIES_1_H_VBUS_OVP_RPT_CAP	(0x1 << 5)
+#define MAX77759_USB_DEVICE_CAPABILITIES_1_H_BLEED_DISCH_CAP	(0x1 << 4)
+#define MAX77759_USB_DEVICE_CAPABILITIES_1_H_FORCE_DISCH_CAP	(0x1 << 3)
+#define MAX77759_USB_DEVICE_CAPABILITIES_1_H_VBUS_MEAS_ALRM_CAP	(0x1 << 2)
+
+#define MAX77759_USB_DEVICE_CAPABILITIES_1_H_VBUS_HI_VOLT_TRGT_CAP_SHIFT	7
+#define MAX77759_USB_DEVICE_CAPABILITIES_1_H_VBUS_HI_VOLT_TRGT_CAP_MASK	(0x1 << 7)
+#define MAX77759_USB_DEVICE_CAPABILITIES_1_H_VBUS_HI_VOLT_TRGT_CAP_CLEAR	(~(0x1 << 7))
+#define MAX77759_USB_DEVICE_CAPABILITIES_1_H_VBUS_OCP_RPT_CAP_SHIFT	6
+#define MAX77759_USB_DEVICE_CAPABILITIES_1_H_VBUS_OCP_RPT_CAP_MASK	(0x1 << 6)
+#define MAX77759_USB_DEVICE_CAPABILITIES_1_H_VBUS_OCP_RPT_CAP_CLEAR	(~(0x1 << 6))
+#define MAX77759_USB_DEVICE_CAPABILITIES_1_H_VBUS_OVP_RPT_CAP_SHIFT	5
+#define MAX77759_USB_DEVICE_CAPABILITIES_1_H_VBUS_OVP_RPT_CAP_MASK	(0x1 << 5)
+#define MAX77759_USB_DEVICE_CAPABILITIES_1_H_VBUS_OVP_RPT_CAP_CLEAR	(~(0x1 << 5))
+#define MAX77759_USB_DEVICE_CAPABILITIES_1_H_BLEED_DISCH_CAP_SHIFT	4
+#define MAX77759_USB_DEVICE_CAPABILITIES_1_H_BLEED_DISCH_CAP_MASK	(0x1 << 4)
+#define MAX77759_USB_DEVICE_CAPABILITIES_1_H_BLEED_DISCH_CAP_CLEAR	(~(0x1 << 4))
+#define MAX77759_USB_DEVICE_CAPABILITIES_1_H_FORCE_DISCH_CAP_SHIFT	3
+#define MAX77759_USB_DEVICE_CAPABILITIES_1_H_FORCE_DISCH_CAP_MASK	(0x1 << 3)
+#define MAX77759_USB_DEVICE_CAPABILITIES_1_H_FORCE_DISCH_CAP_CLEAR	(~(0x1 << 3))
+#define MAX77759_USB_DEVICE_CAPABILITIES_1_H_VBUS_MEAS_ALRM_CAP_SHIFT	2
+#define MAX77759_USB_DEVICE_CAPABILITIES_1_H_VBUS_MEAS_ALRM_CAP_MASK	(0x1 << 2)
+#define MAX77759_USB_DEVICE_CAPABILITIES_1_H_VBUS_MEAS_ALRM_CAP_CLEAR	(~(0x1 << 2))
+#define MAX77759_USB_DEVICE_CAPABILITIES_1_H_SRC_RES_SUP_CAP_SHIFT	0
+#define MAX77759_USB_DEVICE_CAPABILITIES_1_H_SRC_RES_SUP_CAP_MASK	(0x3 << 0)
+#define MAX77759_USB_DEVICE_CAPABILITIES_1_H_SRC_RES_SUP_CAP_CLEAR	(~(0x3 << 0))
+
+MAX77759_BFF(usb_device_capabilities_1_h_vbus_hi_volt_trgt_cap,7,7)
+MAX77759_BFF(usb_device_capabilities_1_h_vbus_ocp_rpt_cap,6,6)
+MAX77759_BFF(usb_device_capabilities_1_h_vbus_ovp_rpt_cap,5,5)
+MAX77759_BFF(usb_device_capabilities_1_h_bleed_disch_cap,4,4)
+MAX77759_BFF(usb_device_capabilities_1_h_force_disch_cap,3,3)
+MAX77759_BFF(usb_device_capabilities_1_h_vbus_meas_alrm_cap,2,2)
+MAX77759_BFF(usb_device_capabilities_1_h_src_res_sup_cap,1,0)
+static inline const char *
+max77759_usb_device_capabilities_1_h_cstr(char *buff, size_t len, int val)
+{
+#ifdef SCNPRINTF
+	int i = 0;
+
+	i += SCNPRINTF(&buff[i], len - i, " VBUS_HI_VOLT_TRGT_CAP=%x",
+		FIELD2VALUE(MAX77759_USB_DEVICE_CAPABILITIES_1_H_VBUS_HI_VOLT_TRGT_CAP, val));
+	i += SCNPRINTF(&buff[i], len - i, " VBUS_OCP_RPT_CAP=%x",
+		FIELD2VALUE(MAX77759_USB_DEVICE_CAPABILITIES_1_H_VBUS_OCP_RPT_CAP, val));
+	i += SCNPRINTF(&buff[i], len - i, " VBUS_OVP_RPT_CAP=%x",
+		FIELD2VALUE(MAX77759_USB_DEVICE_CAPABILITIES_1_H_VBUS_OVP_RPT_CAP, val));
+	i += SCNPRINTF(&buff[i], len - i, " BLEED_DISCH_CAP=%x",
+		FIELD2VALUE(MAX77759_USB_DEVICE_CAPABILITIES_1_H_BLEED_DISCH_CAP, val));
+	i += SCNPRINTF(&buff[i], len - i, " FORCE_DISCH_CAP=%x",
+		FIELD2VALUE(MAX77759_USB_DEVICE_CAPABILITIES_1_H_FORCE_DISCH_CAP, val));
+	i += SCNPRINTF(&buff[i], len - i, " VBUS_MEAS_ALRM_CAP=%x",
+		FIELD2VALUE(MAX77759_USB_DEVICE_CAPABILITIES_1_H_VBUS_MEAS_ALRM_CAP, val));
+	i += SCNPRINTF(&buff[i], len - i, " SRC_RES_SUP_CAP=%x",
+		FIELD2VALUE(MAX77759_USB_DEVICE_CAPABILITIES_1_H_SRC_RES_SUP_CAP, val));
+#else
+	buff[0] = 0;
+#endif
+	return buff;
+}
+
+/*
+ * DEVICE_CAPABILITIES_2_L,0x26,0b11000001,0xc1
+ * SNK_DISC_DET_CAP,STP_DISCH_THR_CAP,VBUS_VOLT_ALRM_LSB_CAP[1:0],,VCONN_PWR_CAP[2:0],,
+ */
+#define MAX77759_USB_DEVICE_CAPABILITIES_2_L	0x26
+#define MAX77759_USB_DEVICE_CAPABILITIES_2_L_SNK_DISC_DET_CAP	(0x1 << 7)
+#define MAX77759_USB_DEVICE_CAPABILITIES_2_L_STP_DISCH_THR_CAP	(0x1 << 6)
+#define MAX77759_USB_DEVICE_CAPABILITIES_2_L_VCONN_OCP_CAP	(0x1 << 0)
+
+#define MAX77759_USB_DEVICE_CAPABILITIES_2_L_SNK_DISC_DET_CAP_SHIFT	7
+#define MAX77759_USB_DEVICE_CAPABILITIES_2_L_SNK_DISC_DET_CAP_MASK	(0x1 << 7)
+#define MAX77759_USB_DEVICE_CAPABILITIES_2_L_SNK_DISC_DET_CAP_CLEAR	(~(0x1 << 7))
+#define MAX77759_USB_DEVICE_CAPABILITIES_2_L_STP_DISCH_THR_CAP_SHIFT	6
+#define MAX77759_USB_DEVICE_CAPABILITIES_2_L_STP_DISCH_THR_CAP_MASK	(0x1 << 6)
+#define MAX77759_USB_DEVICE_CAPABILITIES_2_L_STP_DISCH_THR_CAP_CLEAR	(~(0x1 << 6))
+#define MAX77759_USB_DEVICE_CAPABILITIES_2_L_VBUS_VOLT_ALRM_LSB_CAP_SHIFT	4
+#define MAX77759_USB_DEVICE_CAPABILITIES_2_L_VBUS_VOLT_ALRM_LSB_CAP_MASK	(0x3 << 4)
+#define MAX77759_USB_DEVICE_CAPABILITIES_2_L_VBUS_VOLT_ALRM_LSB_CAP_CLEAR	(~(0x3 << 4))
+#define MAX77759_USB_DEVICE_CAPABILITIES_2_L_VCONN_PWR_CAP_SHIFT	1
+#define MAX77759_USB_DEVICE_CAPABILITIES_2_L_VCONN_PWR_CAP_MASK	(0x7 << 1)
+#define MAX77759_USB_DEVICE_CAPABILITIES_2_L_VCONN_PWR_CAP_CLEAR	(~(0x7 << 1))
+#define MAX77759_USB_DEVICE_CAPABILITIES_2_L_VCONN_OCP_CAP_SHIFT	0
+#define MAX77759_USB_DEVICE_CAPABILITIES_2_L_VCONN_OCP_CAP_MASK	(0x1 << 0)
+#define MAX77759_USB_DEVICE_CAPABILITIES_2_L_VCONN_OCP_CAP_CLEAR	(~(0x1 << 0))
+
+MAX77759_BFF(usb_device_capabilities_2_l_snk_disc_det_cap,7,7)
+MAX77759_BFF(usb_device_capabilities_2_l_stp_disch_thr_cap,6,6)
+MAX77759_BFF(usb_device_capabilities_2_l_vbus_volt_alrm_lsb_cap,5,4)
+MAX77759_BFF(usb_device_capabilities_2_l_vconn_pwr_cap,3,1)
+MAX77759_BFF(usb_device_capabilities_2_l_vconn_ocp_cap,0,0)
+static inline const char *
+max77759_usb_device_capabilities_2_l_cstr(char *buff, size_t len, int val)
+{
+#ifdef SCNPRINTF
+	int i = 0;
+
+	i += SCNPRINTF(&buff[i], len - i, " SNK_DISC_DET_CAP=%x",
+		FIELD2VALUE(MAX77759_USB_DEVICE_CAPABILITIES_2_L_SNK_DISC_DET_CAP, val));
+	i += SCNPRINTF(&buff[i], len - i, " STP_DISCH_THR_CAP=%x",
+		FIELD2VALUE(MAX77759_USB_DEVICE_CAPABILITIES_2_L_STP_DISCH_THR_CAP, val));
+	i += SCNPRINTF(&buff[i], len - i, " VBUS_VOLT_ALRM_LSB_CAP=%x",
+		FIELD2VALUE(MAX77759_USB_DEVICE_CAPABILITIES_2_L_VBUS_VOLT_ALRM_LSB_CAP, val));
+	i += SCNPRINTF(&buff[i], len - i, " VCONN_PWR_CAP=%x",
+		FIELD2VALUE(MAX77759_USB_DEVICE_CAPABILITIES_2_L_VCONN_PWR_CAP, val));
+	i += SCNPRINTF(&buff[i], len - i, " VCONN_OCP_CAP=%x",
+		FIELD2VALUE(MAX77759_USB_DEVICE_CAPABILITIES_2_L_VCONN_OCP_CAP, val));
+#else
+	buff[0] = 0;
+#endif
+	return buff;
+}
+
+/*
+ * DEVICE_CAPABILITIES_2_H,0x27,0b00000011,0x03
+ * RSVD_7,MSGDisDisc,GENERIC_TMR_CAP,LONG_MSG_CAP,SMB_PEC_CAP,SRC_FRS_CAP,SNK_FRS_CAP
+ */
+#define MAX77759_USB_DEVICE_CAPABILITIES_2_H	0x27
+#define MAX77759_USB_DEVICE_CAPABILITIES_2_H_RSVD_7	(0x1 << 7)
+#define MAX77759_USB_DEVICE_CAPABILITIES_2_H_MSGDISDISC	(0x1 << 6)
+#define MAX77759_USB_DEVICE_CAPABILITIES_2_H_GENERIC_TMR_CAP	(0x1 << 5)
+#define MAX77759_USB_DEVICE_CAPABILITIES_2_H_LONG_MSG_CAP	(0x1 << 4)
+#define MAX77759_USB_DEVICE_CAPABILITIES_2_H_SMB_PEC_CAP	(0x1 << 3)
+#define MAX77759_USB_DEVICE_CAPABILITIES_2_H_SRC_FRS_CAP	(0x1 << 2)
+#define MAX77759_USB_DEVICE_CAPABILITIES_2_H_SNK_FRS_CAP	(0x1 << 1)
+#define MAX77759_USB_DEVICE_CAPABILITIES_2_H_WDOG_TMR_CAP	(0x1 << 0)
+
+#define MAX77759_USB_DEVICE_CAPABILITIES_2_H_RSVD_7_SHIFT	7
+#define MAX77759_USB_DEVICE_CAPABILITIES_2_H_RSVD_7_MASK	(0x1 << 7)
+#define MAX77759_USB_DEVICE_CAPABILITIES_2_H_RSVD_7_CLEAR	(~(0x1 << 7))
+#define MAX77759_USB_DEVICE_CAPABILITIES_2_H_MSGDISDISC_SHIFT	6
+#define MAX77759_USB_DEVICE_CAPABILITIES_2_H_MSGDISDISC_MASK	(0x1 << 6)
+#define MAX77759_USB_DEVICE_CAPABILITIES_2_H_MSGDISDISC_CLEAR	(~(0x1 << 6))
+#define MAX77759_USB_DEVICE_CAPABILITIES_2_H_GENERIC_TMR_CAP_SHIFT	5
+#define MAX77759_USB_DEVICE_CAPABILITIES_2_H_GENERIC_TMR_CAP_MASK	(0x1 << 5)
+#define MAX77759_USB_DEVICE_CAPABILITIES_2_H_GENERIC_TMR_CAP_CLEAR	(~(0x1 << 5))
+#define MAX77759_USB_DEVICE_CAPABILITIES_2_H_LONG_MSG_CAP_SHIFT	4
+#define MAX77759_USB_DEVICE_CAPABILITIES_2_H_LONG_MSG_CAP_MASK	(0x1 << 4)
+#define MAX77759_USB_DEVICE_CAPABILITIES_2_H_LONG_MSG_CAP_CLEAR	(~(0x1 << 4))
+#define MAX77759_USB_DEVICE_CAPABILITIES_2_H_SMB_PEC_CAP_SHIFT	3
+#define MAX77759_USB_DEVICE_CAPABILITIES_2_H_SMB_PEC_CAP_MASK	(0x1 << 3)
+#define MAX77759_USB_DEVICE_CAPABILITIES_2_H_SMB_PEC_CAP_CLEAR	(~(0x1 << 3))
+#define MAX77759_USB_DEVICE_CAPABILITIES_2_H_SRC_FRS_CAP_SHIFT	2
+#define MAX77759_USB_DEVICE_CAPABILITIES_2_H_SRC_FRS_CAP_MASK	(0x1 << 2)
+#define MAX77759_USB_DEVICE_CAPABILITIES_2_H_SRC_FRS_CAP_CLEAR	(~(0x1 << 2))
+#define MAX77759_USB_DEVICE_CAPABILITIES_2_H_SNK_FRS_CAP_SHIFT	1
+#define MAX77759_USB_DEVICE_CAPABILITIES_2_H_SNK_FRS_CAP_MASK	(0x1 << 1)
+#define MAX77759_USB_DEVICE_CAPABILITIES_2_H_SNK_FRS_CAP_CLEAR	(~(0x1 << 1))
+#define MAX77759_USB_DEVICE_CAPABILITIES_2_H_WDOG_TMR_CAP_SHIFT	0
+#define MAX77759_USB_DEVICE_CAPABILITIES_2_H_WDOG_TMR_CAP_MASK	(0x1 << 0)
+#define MAX77759_USB_DEVICE_CAPABILITIES_2_H_WDOG_TMR_CAP_CLEAR	(~(0x1 << 0))
+
+MAX77759_BFF(usb_device_capabilities_2_h_rsvd_7,7,7)
+MAX77759_BFF(usb_device_capabilities_2_h_msgdisdisc,6,6)
+MAX77759_BFF(usb_device_capabilities_2_h_generic_tmr_cap,5,5)
+MAX77759_BFF(usb_device_capabilities_2_h_long_msg_cap,4,4)
+MAX77759_BFF(usb_device_capabilities_2_h_smb_pec_cap,3,3)
+MAX77759_BFF(usb_device_capabilities_2_h_src_frs_cap,2,2)
+MAX77759_BFF(usb_device_capabilities_2_h_snk_frs_cap,1,1)
+MAX77759_BFF(usb_device_capabilities_2_h_wdog_tmr_cap,0,0)
+static inline const char *
+max77759_usb_device_capabilities_2_h_cstr(char *buff, size_t len, int val)
+{
+#ifdef SCNPRINTF
+	int i = 0;
+
+	i += SCNPRINTF(&buff[i], len - i, " RSVD_7=%x",
+		FIELD2VALUE(MAX77759_USB_DEVICE_CAPABILITIES_2_H_RSVD_7, val));
+	i += SCNPRINTF(&buff[i], len - i, " MSGDISDISC=%x",
+		FIELD2VALUE(MAX77759_USB_DEVICE_CAPABILITIES_2_H_MSGDISDISC, val));
+	i += SCNPRINTF(&buff[i], len - i, " GENERIC_TMR_CAP=%x",
+		FIELD2VALUE(MAX77759_USB_DEVICE_CAPABILITIES_2_H_GENERIC_TMR_CAP, val));
+	i += SCNPRINTF(&buff[i], len - i, " LONG_MSG_CAP=%x",
+		FIELD2VALUE(MAX77759_USB_DEVICE_CAPABILITIES_2_H_LONG_MSG_CAP, val));
+	i += SCNPRINTF(&buff[i], len - i, " SMB_PEC_CAP=%x",
+		FIELD2VALUE(MAX77759_USB_DEVICE_CAPABILITIES_2_H_SMB_PEC_CAP, val));
+	i += SCNPRINTF(&buff[i], len - i, " SRC_FRS_CAP=%x",
+		FIELD2VALUE(MAX77759_USB_DEVICE_CAPABILITIES_2_H_SRC_FRS_CAP, val));
+	i += SCNPRINTF(&buff[i], len - i, " SNK_FRS_CAP=%x",
+		FIELD2VALUE(MAX77759_USB_DEVICE_CAPABILITIES_2_H_SNK_FRS_CAP, val));
+	i += SCNPRINTF(&buff[i], len - i, " WDOG_TMR_CAP=%x",
+		FIELD2VALUE(MAX77759_USB_DEVICE_CAPABILITIES_2_H_WDOG_TMR_CAP, val));
+#else
+	buff[0] = 0;
+#endif
+	return buff;
+}
+
+/*
+ * STANDARD_INPUT_CAPABILITIES_REG,0x28,0b00000000,0x00
+ * RSVD_7_5[2:0],,,SRC_FRS_INP_CAP[1:0],,VBUS_EXT_OVP_CAP,VBUS_EXT_OCP_CAP
+ */
+#define MAX77759_USB_STANDARD_INPUT_CAPABILITIES_REG	0x28
+#define MAX77759_USB_STANDARD_INPUT_CAPABILITIES_REG_VBUS_EXT_OVP_CAP	(0x1 << 2)
+#define MAX77759_USB_STANDARD_INPUT_CAPABILITIES_REG_VBUS_EXT_OCP_CAP	(0x1 << 1)
+#define MAX77759_USB_STANDARD_INPUT_CAPABILITIES_REG_FRC_OFF_VBUS_CAP	(0x1 << 0)
+
+#define MAX77759_USB_STANDARD_INPUT_CAPABILITIES_REG_RSVD_7_5_SHIFT	5
+#define MAX77759_USB_STANDARD_INPUT_CAPABILITIES_REG_RSVD_7_5_MASK	(0x7 << 5)
+#define MAX77759_USB_STANDARD_INPUT_CAPABILITIES_REG_RSVD_7_5_CLEAR	(~(0x7 << 5))
+#define MAX77759_USB_STANDARD_INPUT_CAPABILITIES_REG_SRC_FRS_INP_CAP_SHIFT	3
+#define MAX77759_USB_STANDARD_INPUT_CAPABILITIES_REG_SRC_FRS_INP_CAP_MASK	(0x3 << 3)
+#define MAX77759_USB_STANDARD_INPUT_CAPABILITIES_REG_SRC_FRS_INP_CAP_CLEAR	(~(0x3 << 3))
+#define MAX77759_USB_STANDARD_INPUT_CAPABILITIES_REG_VBUS_EXT_OVP_CAP_SHIFT	2
+#define MAX77759_USB_STANDARD_INPUT_CAPABILITIES_REG_VBUS_EXT_OVP_CAP_MASK	(0x1 << 2)
+#define MAX77759_USB_STANDARD_INPUT_CAPABILITIES_REG_VBUS_EXT_OVP_CAP_CLEAR	(~(0x1 << 2))
+#define MAX77759_USB_STANDARD_INPUT_CAPABILITIES_REG_VBUS_EXT_OCP_CAP_SHIFT	1
+#define MAX77759_USB_STANDARD_INPUT_CAPABILITIES_REG_VBUS_EXT_OCP_CAP_MASK	(0x1 << 1)
+#define MAX77759_USB_STANDARD_INPUT_CAPABILITIES_REG_VBUS_EXT_OCP_CAP_CLEAR	(~(0x1 << 1))
+#define MAX77759_USB_STANDARD_INPUT_CAPABILITIES_REG_FRC_OFF_VBUS_CAP_SHIFT	0
+#define MAX77759_USB_STANDARD_INPUT_CAPABILITIES_REG_FRC_OFF_VBUS_CAP_MASK	(0x1 << 0)
+#define MAX77759_USB_STANDARD_INPUT_CAPABILITIES_REG_FRC_OFF_VBUS_CAP_CLEAR	(~(0x1 << 0))
+
+MAX77759_BFF(usb_standard_input_capabilities_reg_rsvd_7_5,7,5)
+MAX77759_BFF(usb_standard_input_capabilities_reg_src_frs_inp_cap,4,3)
+MAX77759_BFF(usb_standard_input_capabilities_reg_vbus_ext_ovp_cap,2,2)
+MAX77759_BFF(usb_standard_input_capabilities_reg_vbus_ext_ocp_cap,1,1)
+MAX77759_BFF(usb_standard_input_capabilities_reg_frc_off_vbus_cap,0,0)
+static inline const char *
+max77759_usb_standard_input_capabilities_reg_cstr(char *buff, size_t len, int val)
+{
+#ifdef SCNPRINTF
+	int i = 0;
+
+	i += SCNPRINTF(&buff[i], len - i, " RSVD_7_5=%x",
+		FIELD2VALUE(MAX77759_USB_STANDARD_INPUT_CAPABILITIES_REG_RSVD_7_5, val));
+	i += SCNPRINTF(&buff[i], len - i, " SRC_FRS_INP_CAP=%x",
+		FIELD2VALUE(MAX77759_USB_STANDARD_INPUT_CAPABILITIES_REG_SRC_FRS_INP_CAP, val));
+	i += SCNPRINTF(&buff[i], len - i, " VBUS_EXT_OVP_CAP=%x",
+		FIELD2VALUE(MAX77759_USB_STANDARD_INPUT_CAPABILITIES_REG_VBUS_EXT_OVP_CAP, val));
+	i += SCNPRINTF(&buff[i], len - i, " VBUS_EXT_OCP_CAP=%x",
+		FIELD2VALUE(MAX77759_USB_STANDARD_INPUT_CAPABILITIES_REG_VBUS_EXT_OCP_CAP, val));
+	i += SCNPRINTF(&buff[i], len - i, " FRC_OFF_VBUS_CAP=%x",
+		FIELD2VALUE(MAX77759_USB_STANDARD_INPUT_CAPABILITIES_REG_FRC_OFF_VBUS_CAP, val));
+#else
+	buff[0] = 0;
+#endif
+	return buff;
+}
+
+/*
+ * STANDARD_OUTPUT_CAPABILITIES_REG,0x29,0b01000000,0x40
+ * VBUS_SNK_DIS_DET_CAP,DBG_ACC_CAP,VBUS_PRESENT_CAP,AUD_ACC_CAP,ACT_CBL_CAP,MUX_CONFG_CAP,CONN_PRESENT_CAP
+ */
+#define MAX77759_USB_STANDARD_OUTPUT_CAPABILITIES_REG	0x29
+#define MAX77759_USB_STANDARD_OUTPUT_CAPABILITIES_REG_VBUS_SNK_DIS_DET_CAP	(0x1 << 7)
+#define MAX77759_USB_STANDARD_OUTPUT_CAPABILITIES_REG_DBG_ACC_CAP	(0x1 << 6)
+#define MAX77759_USB_STANDARD_OUTPUT_CAPABILITIES_REG_VBUS_PRESENT_CAP	(0x1 << 5)
+#define MAX77759_USB_STANDARD_OUTPUT_CAPABILITIES_REG_AUD_ACC_CAP	(0x1 << 4)
+#define MAX77759_USB_STANDARD_OUTPUT_CAPABILITIES_REG_ACT_CBL_CAP	(0x1 << 3)
+#define MAX77759_USB_STANDARD_OUTPUT_CAPABILITIES_REG_MUX_CONFG_CAP	(0x1 << 2)
+#define MAX77759_USB_STANDARD_OUTPUT_CAPABILITIES_REG_CONN_PRESENT_CAP	(0x1 << 1)
+#define MAX77759_USB_STANDARD_OUTPUT_CAPABILITIES_REG_CONN_ORIENT_CAP	(0x1 << 0)
+
+#define MAX77759_USB_STANDARD_OUTPUT_CAPABILITIES_REG_VBUS_SNK_DIS_DET_CAP_SHIFT	7
+#define MAX77759_USB_STANDARD_OUTPUT_CAPABILITIES_REG_VBUS_SNK_DIS_DET_CAP_MASK	(0x1 << 7)
+#define MAX77759_USB_STANDARD_OUTPUT_CAPABILITIES_REG_VBUS_SNK_DIS_DET_CAP_CLEAR	(~(0x1 << 7))
+#define MAX77759_USB_STANDARD_OUTPUT_CAPABILITIES_REG_DBG_ACC_CAP_SHIFT	6
+#define MAX77759_USB_STANDARD_OUTPUT_CAPABILITIES_REG_DBG_ACC_CAP_MASK	(0x1 << 6)
+#define MAX77759_USB_STANDARD_OUTPUT_CAPABILITIES_REG_DBG_ACC_CAP_CLEAR	(~(0x1 << 6))
+#define MAX77759_USB_STANDARD_OUTPUT_CAPABILITIES_REG_VBUS_PRESENT_CAP_SHIFT	5
+#define MAX77759_USB_STANDARD_OUTPUT_CAPABILITIES_REG_VBUS_PRESENT_CAP_MASK	(0x1 << 5)
+#define MAX77759_USB_STANDARD_OUTPUT_CAPABILITIES_REG_VBUS_PRESENT_CAP_CLEAR	(~(0x1 << 5))
+#define MAX77759_USB_STANDARD_OUTPUT_CAPABILITIES_REG_AUD_ACC_CAP_SHIFT	4
+#define MAX77759_USB_STANDARD_OUTPUT_CAPABILITIES_REG_AUD_ACC_CAP_MASK	(0x1 << 4)
+#define MAX77759_USB_STANDARD_OUTPUT_CAPABILITIES_REG_AUD_ACC_CAP_CLEAR	(~(0x1 << 4))
+#define MAX77759_USB_STANDARD_OUTPUT_CAPABILITIES_REG_ACT_CBL_CAP_SHIFT	3
+#define MAX77759_USB_STANDARD_OUTPUT_CAPABILITIES_REG_ACT_CBL_CAP_MASK	(0x1 << 3)
+#define MAX77759_USB_STANDARD_OUTPUT_CAPABILITIES_REG_ACT_CBL_CAP_CLEAR	(~(0x1 << 3))
+#define MAX77759_USB_STANDARD_OUTPUT_CAPABILITIES_REG_MUX_CONFG_CAP_SHIFT	2
+#define MAX77759_USB_STANDARD_OUTPUT_CAPABILITIES_REG_MUX_CONFG_CAP_MASK	(0x1 << 2)
+#define MAX77759_USB_STANDARD_OUTPUT_CAPABILITIES_REG_MUX_CONFG_CAP_CLEAR	(~(0x1 << 2))
+#define MAX77759_USB_STANDARD_OUTPUT_CAPABILITIES_REG_CONN_PRESENT_CAP_SHIFT	1
+#define MAX77759_USB_STANDARD_OUTPUT_CAPABILITIES_REG_CONN_PRESENT_CAP_MASK	(0x1 << 1)
+#define MAX77759_USB_STANDARD_OUTPUT_CAPABILITIES_REG_CONN_PRESENT_CAP_CLEAR	(~(0x1 << 1))
+#define MAX77759_USB_STANDARD_OUTPUT_CAPABILITIES_REG_CONN_ORIENT_CAP_SHIFT	0
+#define MAX77759_USB_STANDARD_OUTPUT_CAPABILITIES_REG_CONN_ORIENT_CAP_MASK	(0x1 << 0)
+#define MAX77759_USB_STANDARD_OUTPUT_CAPABILITIES_REG_CONN_ORIENT_CAP_CLEAR	(~(0x1 << 0))
+
+MAX77759_BFF(usb_standard_output_capabilities_reg_vbus_snk_dis_det_cap,7,7)
+MAX77759_BFF(usb_standard_output_capabilities_reg_dbg_acc_cap,6,6)
+MAX77759_BFF(usb_standard_output_capabilities_reg_vbus_present_cap,5,5)
+MAX77759_BFF(usb_standard_output_capabilities_reg_aud_acc_cap,4,4)
+MAX77759_BFF(usb_standard_output_capabilities_reg_act_cbl_cap,3,3)
+MAX77759_BFF(usb_standard_output_capabilities_reg_mux_confg_cap,2,2)
+MAX77759_BFF(usb_standard_output_capabilities_reg_conn_present_cap,1,1)
+MAX77759_BFF(usb_standard_output_capabilities_reg_conn_orient_cap,0,0)
+static inline const char *
+max77759_usb_standard_output_capabilities_reg_cstr(char *buff, size_t len, int val)
+{
+#ifdef SCNPRINTF
+	int i = 0;
+
+	i += SCNPRINTF(&buff[i], len - i, " VBUS_SNK_DIS_DET_CAP=%x",
+		FIELD2VALUE(MAX77759_USB_STANDARD_OUTPUT_CAPABILITIES_REG_VBUS_SNK_DIS_DET_CAP, val));
+	i += SCNPRINTF(&buff[i], len - i, " DBG_ACC_CAP=%x",
+		FIELD2VALUE(MAX77759_USB_STANDARD_OUTPUT_CAPABILITIES_REG_DBG_ACC_CAP, val));
+	i += SCNPRINTF(&buff[i], len - i, " VBUS_PRESENT_CAP=%x",
+		FIELD2VALUE(MAX77759_USB_STANDARD_OUTPUT_CAPABILITIES_REG_VBUS_PRESENT_CAP, val));
+	i += SCNPRINTF(&buff[i], len - i, " AUD_ACC_CAP=%x",
+		FIELD2VALUE(MAX77759_USB_STANDARD_OUTPUT_CAPABILITIES_REG_AUD_ACC_CAP, val));
+	i += SCNPRINTF(&buff[i], len - i, " ACT_CBL_CAP=%x",
+		FIELD2VALUE(MAX77759_USB_STANDARD_OUTPUT_CAPABILITIES_REG_ACT_CBL_CAP, val));
+	i += SCNPRINTF(&buff[i], len - i, " MUX_CONFG_CAP=%x",
+		FIELD2VALUE(MAX77759_USB_STANDARD_OUTPUT_CAPABILITIES_REG_MUX_CONFG_CAP, val));
+	i += SCNPRINTF(&buff[i], len - i, " CONN_PRESENT_CAP=%x",
+		FIELD2VALUE(MAX77759_USB_STANDARD_OUTPUT_CAPABILITIES_REG_CONN_PRESENT_CAP, val));
+	i += SCNPRINTF(&buff[i], len - i, " CONN_ORIENT_CAP=%x",
+		FIELD2VALUE(MAX77759_USB_STANDARD_OUTPUT_CAPABILITIES_REG_CONN_ORIENT_CAP, val));
+#else
+	buff[0] = 0;
+#endif
+	return buff;
+}
+
+/*
+ * CONFIG_EXTENDED1_REG,0x2A,0b00000000,0x00
+ * RSVD_7_2[5:0],,,,,,RSVD_1
+ */
+#define MAX77759_USB_CONFIG_EXTENDED1_REG	0x2A
+#define MAX77759_USB_CONFIG_EXTENDED1_REG_RSVD_1	(0x1 << 1)
+#define MAX77759_USB_CONFIG_EXTENDED1_REG_RSVD_0	(0x1 << 0)
+
+#define MAX77759_USB_CONFIG_EXTENDED1_REG_RSVD_7_2_SHIFT	2
+#define MAX77759_USB_CONFIG_EXTENDED1_REG_RSVD_7_2_MASK	(0x3f << 2)
+#define MAX77759_USB_CONFIG_EXTENDED1_REG_RSVD_7_2_CLEAR	(~(0x3f << 2))
+#define MAX77759_USB_CONFIG_EXTENDED1_REG_RSVD_1_SHIFT	1
+#define MAX77759_USB_CONFIG_EXTENDED1_REG_RSVD_1_MASK	(0x1 << 1)
+#define MAX77759_USB_CONFIG_EXTENDED1_REG_RSVD_1_CLEAR	(~(0x1 << 1))
+#define MAX77759_USB_CONFIG_EXTENDED1_REG_RSVD_0_SHIFT	0
+#define MAX77759_USB_CONFIG_EXTENDED1_REG_RSVD_0_MASK	(0x1 << 0)
+#define MAX77759_USB_CONFIG_EXTENDED1_REG_RSVD_0_CLEAR	(~(0x1 << 0))
+
+MAX77759_BFF(usb_config_extended1_reg_rsvd_7_2,7,2)
+MAX77759_BFF(usb_config_extended1_reg_rsvd_1,1,1)
+MAX77759_BFF(usb_config_extended1_reg_rsvd_0,0,0)
+static inline const char *
+max77759_usb_config_extended1_reg_cstr(char *buff, size_t len, int val)
+{
+#ifdef SCNPRINTF
+	int i = 0;
+
+	i += SCNPRINTF(&buff[i], len - i, " RSVD_7_2=%x",
+		FIELD2VALUE(MAX77759_USB_CONFIG_EXTENDED1_REG_RSVD_7_2, val));
+	i += SCNPRINTF(&buff[i], len - i, " RSVD_1=%x",
+		FIELD2VALUE(MAX77759_USB_CONFIG_EXTENDED1_REG_RSVD_1, val));
+	i += SCNPRINTF(&buff[i], len - i, " RSVD_0=%x",
+		FIELD2VALUE(MAX77759_USB_CONFIG_EXTENDED1_REG_RSVD_0, val));
+#else
+	buff[0] = 0;
+#endif
+	return buff;
+}
+
+/*
+ * MESSAGE_HEADER_INFO_REG,0x2E,0b00000100,0x04
+ * RSVD_7_5[2:0],,,CBL_PLG,DATA_ROLE,USB_PD[1:0],
+ */
+#define MAX77759_USB_MESSAGE_HEADER_INFO_REG	0x2E
+#define MAX77759_USB_MESSAGE_HEADER_INFO_REG_CBL_PLG	(0x1 << 4)
+#define MAX77759_USB_MESSAGE_HEADER_INFO_REG_DATA_ROLE	(0x1 << 3)
+#define MAX77759_USB_MESSAGE_HEADER_INFO_REG_PWR_ROLE	(0x1 << 0)
+
+#define MAX77759_USB_MESSAGE_HEADER_INFO_REG_RSVD_7_5_SHIFT	5
+#define MAX77759_USB_MESSAGE_HEADER_INFO_REG_RSVD_7_5_MASK	(0x7 << 5)
+#define MAX77759_USB_MESSAGE_HEADER_INFO_REG_RSVD_7_5_CLEAR	(~(0x7 << 5))
+#define MAX77759_USB_MESSAGE_HEADER_INFO_REG_CBL_PLG_SHIFT	4
+#define MAX77759_USB_MESSAGE_HEADER_INFO_REG_CBL_PLG_MASK	(0x1 << 4)
+#define MAX77759_USB_MESSAGE_HEADER_INFO_REG_CBL_PLG_CLEAR	(~(0x1 << 4))
+#define MAX77759_USB_MESSAGE_HEADER_INFO_REG_DATA_ROLE_SHIFT	3
+#define MAX77759_USB_MESSAGE_HEADER_INFO_REG_DATA_ROLE_MASK	(0x1 << 3)
+#define MAX77759_USB_MESSAGE_HEADER_INFO_REG_DATA_ROLE_CLEAR	(~(0x1 << 3))
+#define MAX77759_USB_MESSAGE_HEADER_INFO_REG_USB_PD_SHIFT	1
+#define MAX77759_USB_MESSAGE_HEADER_INFO_REG_USB_PD_MASK	(0x3 << 1)
+#define MAX77759_USB_MESSAGE_HEADER_INFO_REG_USB_PD_CLEAR	(~(0x3 << 1))
+#define MAX77759_USB_MESSAGE_HEADER_INFO_REG_PWR_ROLE_SHIFT	0
+#define MAX77759_USB_MESSAGE_HEADER_INFO_REG_PWR_ROLE_MASK	(0x1 << 0)
+#define MAX77759_USB_MESSAGE_HEADER_INFO_REG_PWR_ROLE_CLEAR	(~(0x1 << 0))
+
+MAX77759_BFF(usb_message_header_info_reg_rsvd_7_5,7,5)
+MAX77759_BFF(usb_message_header_info_reg_cbl_plg,4,4)
+MAX77759_BFF(usb_message_header_info_reg_data_role,3,3)
+MAX77759_BFF(usb_message_header_info_reg_usb_pd,2,1)
+MAX77759_BFF(usb_message_header_info_reg_pwr_role,0,0)
+static inline const char *
+max77759_usb_message_header_info_reg_cstr(char *buff, size_t len, int val)
+{
+#ifdef SCNPRINTF
+	int i = 0;
+
+	i += SCNPRINTF(&buff[i], len - i, " RSVD_7_5=%x",
+		FIELD2VALUE(MAX77759_USB_MESSAGE_HEADER_INFO_REG_RSVD_7_5, val));
+	i += SCNPRINTF(&buff[i], len - i, " CBL_PLG=%x",
+		FIELD2VALUE(MAX77759_USB_MESSAGE_HEADER_INFO_REG_CBL_PLG, val));
+	i += SCNPRINTF(&buff[i], len - i, " DATA_ROLE=%x",
+		FIELD2VALUE(MAX77759_USB_MESSAGE_HEADER_INFO_REG_DATA_ROLE, val));
+	i += SCNPRINTF(&buff[i], len - i, " USB_PD=%x",
+		FIELD2VALUE(MAX77759_USB_MESSAGE_HEADER_INFO_REG_USB_PD, val));
+	i += SCNPRINTF(&buff[i], len - i, " PWR_ROLE=%x",
+		FIELD2VALUE(MAX77759_USB_MESSAGE_HEADER_INFO_REG_PWR_ROLE, val));
+#else
+	buff[0] = 0;
+#endif
+	return buff;
+}
+
+/*
+ * RECEIVE_DETECT_REG,0x2F,0b00000000,0x00
+ * RSVD_7,EN_CBL_RST,EN_HRD_RST,EN_SOP_DBG2,EN_SOP_DBG1,EN_SOP2,EN_SOP1
+ */
+#define MAX77759_USB_RECEIVE_DETECT_REG	0x2F
+#define MAX77759_USB_RECEIVE_DETECT_REG_RSVD_7	(0x1 << 7)
+#define MAX77759_USB_RECEIVE_DETECT_REG_EN_CBL_RST	(0x1 << 6)
+#define MAX77759_USB_RECEIVE_DETECT_REG_EN_HRD_RST	(0x1 << 5)
+#define MAX77759_USB_RECEIVE_DETECT_REG_EN_SOP_DBG2	(0x1 << 4)
+#define MAX77759_USB_RECEIVE_DETECT_REG_EN_SOP_DBG1	(0x1 << 3)
+#define MAX77759_USB_RECEIVE_DETECT_REG_EN_SOP2	(0x1 << 2)
+#define MAX77759_USB_RECEIVE_DETECT_REG_EN_SOP1	(0x1 << 1)
+#define MAX77759_USB_RECEIVE_DETECT_REG_EN_SOP	(0x1 << 0)
+
+#define MAX77759_USB_RECEIVE_DETECT_REG_RSVD_7_SHIFT	7
+#define MAX77759_USB_RECEIVE_DETECT_REG_RSVD_7_MASK	(0x1 << 7)
+#define MAX77759_USB_RECEIVE_DETECT_REG_RSVD_7_CLEAR	(~(0x1 << 7))
+#define MAX77759_USB_RECEIVE_DETECT_REG_EN_CBL_RST_SHIFT	6
+#define MAX77759_USB_RECEIVE_DETECT_REG_EN_CBL_RST_MASK	(0x1 << 6)
+#define MAX77759_USB_RECEIVE_DETECT_REG_EN_CBL_RST_CLEAR	(~(0x1 << 6))
+#define MAX77759_USB_RECEIVE_DETECT_REG_EN_HRD_RST_SHIFT	5
+#define MAX77759_USB_RECEIVE_DETECT_REG_EN_HRD_RST_MASK	(0x1 << 5)
+#define MAX77759_USB_RECEIVE_DETECT_REG_EN_HRD_RST_CLEAR	(~(0x1 << 5))
+#define MAX77759_USB_RECEIVE_DETECT_REG_EN_SOP_DBG2_SHIFT	4
+#define MAX77759_USB_RECEIVE_DETECT_REG_EN_SOP_DBG2_MASK	(0x1 << 4)
+#define MAX77759_USB_RECEIVE_DETECT_REG_EN_SOP_DBG2_CLEAR	(~(0x1 << 4))
+#define MAX77759_USB_RECEIVE_DETECT_REG_EN_SOP_DBG1_SHIFT	3
+#define MAX77759_USB_RECEIVE_DETECT_REG_EN_SOP_DBG1_MASK	(0x1 << 3)
+#define MAX77759_USB_RECEIVE_DETECT_REG_EN_SOP_DBG1_CLEAR	(~(0x1 << 3))
+#define MAX77759_USB_RECEIVE_DETECT_REG_EN_SOP2_SHIFT	2
+#define MAX77759_USB_RECEIVE_DETECT_REG_EN_SOP2_MASK	(0x1 << 2)
+#define MAX77759_USB_RECEIVE_DETECT_REG_EN_SOP2_CLEAR	(~(0x1 << 2))
+#define MAX77759_USB_RECEIVE_DETECT_REG_EN_SOP1_SHIFT	1
+#define MAX77759_USB_RECEIVE_DETECT_REG_EN_SOP1_MASK	(0x1 << 1)
+#define MAX77759_USB_RECEIVE_DETECT_REG_EN_SOP1_CLEAR	(~(0x1 << 1))
+#define MAX77759_USB_RECEIVE_DETECT_REG_EN_SOP_SHIFT	0
+#define MAX77759_USB_RECEIVE_DETECT_REG_EN_SOP_MASK	(0x1 << 0)
+#define MAX77759_USB_RECEIVE_DETECT_REG_EN_SOP_CLEAR	(~(0x1 << 0))
+
+MAX77759_BFF(usb_receive_detect_reg_rsvd_7,7,7)
+MAX77759_BFF(usb_receive_detect_reg_en_cbl_rst,6,6)
+MAX77759_BFF(usb_receive_detect_reg_en_hrd_rst,5,5)
+MAX77759_BFF(usb_receive_detect_reg_en_sop_dbg2,4,4)
+MAX77759_BFF(usb_receive_detect_reg_en_sop_dbg1,3,3)
+MAX77759_BFF(usb_receive_detect_reg_en_sop2,2,2)
+MAX77759_BFF(usb_receive_detect_reg_en_sop1,1,1)
+MAX77759_BFF(usb_receive_detect_reg_en_sop,0,0)
+static inline const char *
+max77759_usb_receive_detect_reg_cstr(char *buff, size_t len, int val)
+{
+#ifdef SCNPRINTF
+	int i = 0;
+
+	i += SCNPRINTF(&buff[i], len - i, " RSVD_7=%x",
+		FIELD2VALUE(MAX77759_USB_RECEIVE_DETECT_REG_RSVD_7, val));
+	i += SCNPRINTF(&buff[i], len - i, " EN_CBL_RST=%x",
+		FIELD2VALUE(MAX77759_USB_RECEIVE_DETECT_REG_EN_CBL_RST, val));
+	i += SCNPRINTF(&buff[i], len - i, " EN_HRD_RST=%x",
+		FIELD2VALUE(MAX77759_USB_RECEIVE_DETECT_REG_EN_HRD_RST, val));
+	i += SCNPRINTF(&buff[i], len - i, " EN_SOP_DBG2=%x",
+		FIELD2VALUE(MAX77759_USB_RECEIVE_DETECT_REG_EN_SOP_DBG2, val));
+	i += SCNPRINTF(&buff[i], len - i, " EN_SOP_DBG1=%x",
+		FIELD2VALUE(MAX77759_USB_RECEIVE_DETECT_REG_EN_SOP_DBG1, val));
+	i += SCNPRINTF(&buff[i], len - i, " EN_SOP2=%x",
+		FIELD2VALUE(MAX77759_USB_RECEIVE_DETECT_REG_EN_SOP2, val));
+	i += SCNPRINTF(&buff[i], len - i, " EN_SOP1=%x",
+		FIELD2VALUE(MAX77759_USB_RECEIVE_DETECT_REG_EN_SOP1, val));
+	i += SCNPRINTF(&buff[i], len - i, " EN_SOP=%x",
+		FIELD2VALUE(MAX77759_USB_RECEIVE_DETECT_REG_EN_SOP, val));
+#else
+	buff[0] = 0;
+#endif
+	return buff;
+}
+
+/*
+ * RECEIVE_BUFFER_REG,0x30,0b00000000,0x00
+ * RECEIVE_BUFFER[7:0],,,,,,
+ */
+#define MAX77759_USB_RECEIVE_BUFFER_REG	0x30
+
+/*
+ * TRANSMIT_REG,0x50,0b00000000,0x00
+ * RSVD_7_6[1:0],,RETRY_COUNTER[1:0],,RSVD_3,TX_SOP_MESSAGE[2:0],
+ */
+#define MAX77759_USB_TRANSMIT_REG	0x50
+#define MAX77759_USB_TRANSMIT_REG_RSVD_3	(0x1 << 3)
+
+#define MAX77759_USB_TRANSMIT_REG_RSVD_7_6_SHIFT	6
+#define MAX77759_USB_TRANSMIT_REG_RSVD_7_6_MASK	(0x3 << 6)
+#define MAX77759_USB_TRANSMIT_REG_RSVD_7_6_CLEAR	(~(0x3 << 6))
+#define MAX77759_USB_TRANSMIT_REG_RETRY_COUNTER_SHIFT	4
+#define MAX77759_USB_TRANSMIT_REG_RETRY_COUNTER_MASK	(0x3 << 4)
+#define MAX77759_USB_TRANSMIT_REG_RETRY_COUNTER_CLEAR	(~(0x3 << 4))
+#define MAX77759_USB_TRANSMIT_REG_RSVD_3_SHIFT	3
+#define MAX77759_USB_TRANSMIT_REG_RSVD_3_MASK	(0x1 << 3)
+#define MAX77759_USB_TRANSMIT_REG_RSVD_3_CLEAR	(~(0x1 << 3))
+#define MAX77759_USB_TRANSMIT_REG_TX_SOP_MESSAGE_SHIFT	0
+#define MAX77759_USB_TRANSMIT_REG_TX_SOP_MESSAGE_MASK	(0x7 << 0)
+#define MAX77759_USB_TRANSMIT_REG_TX_SOP_MESSAGE_CLEAR	(~(0x7 << 0))
+
+MAX77759_BFF(usb_transmit_reg_rsvd_7_6,7,6)
+MAX77759_BFF(usb_transmit_reg_retry_counter,5,4)
+MAX77759_BFF(usb_transmit_reg_rsvd_3,3,3)
+MAX77759_BFF(usb_transmit_reg_tx_sop_message,2,0)
+static inline const char *
+max77759_usb_transmit_reg_cstr(char *buff, size_t len, int val)
+{
+#ifdef SCNPRINTF
+	int i = 0;
+
+	i += SCNPRINTF(&buff[i], len - i, " RSVD_7_6=%x",
+		FIELD2VALUE(MAX77759_USB_TRANSMIT_REG_RSVD_7_6, val));
+	i += SCNPRINTF(&buff[i], len - i, " RETRY_COUNTER=%x",
+		FIELD2VALUE(MAX77759_USB_TRANSMIT_REG_RETRY_COUNTER, val));
+	i += SCNPRINTF(&buff[i], len - i, " RSVD_3=%x",
+		FIELD2VALUE(MAX77759_USB_TRANSMIT_REG_RSVD_3, val));
+	i += SCNPRINTF(&buff[i], len - i, " TX_SOP_MESSAGE=%x",
+		FIELD2VALUE(MAX77759_USB_TRANSMIT_REG_TX_SOP_MESSAGE, val));
+#else
+	buff[0] = 0;
+#endif
+	return buff;
+}
+
+/*
+ * TRANSMIT_BUFFER_REG,0x51,0b00000000,0x00
+ * TRANSMIT_BUFFER[7:0],,,,,,
+ */
+#define MAX77759_USB_TRANSMIT_BUFFER_REG	0x51
+
+/*
+ * VBUS_VOLTAGE_L,0x70,0b00000000,0x00
+ * VBUS_VOLTAGE7_0[7:0],,,,,,
+ */
+#define MAX77759_USB_VBUS_VOLTAGE_L	0x70
+
+/*
+ * VBUS_VOLTAGE_H,0x71,0b00000000,0x00
+ * RSVD_7_4[3:0],,,,SCALE_FACTOR[1:0],,VBUS_VOLTAGE9_8[1:0]
+ */
+#define MAX77759_USB_VBUS_VOLTAGE_H	0x71
+
+#define MAX77759_USB_VBUS_VOLTAGE_H_RSVD_7_4_SHIFT	4
+#define MAX77759_USB_VBUS_VOLTAGE_H_RSVD_7_4_MASK	(0xf << 4)
+#define MAX77759_USB_VBUS_VOLTAGE_H_RSVD_7_4_CLEAR	(~(0xf << 4))
+#define MAX77759_USB_VBUS_VOLTAGE_H_SCALE_FACTOR_SHIFT	2
+#define MAX77759_USB_VBUS_VOLTAGE_H_SCALE_FACTOR_MASK	(0x3 << 2)
+#define MAX77759_USB_VBUS_VOLTAGE_H_SCALE_FACTOR_CLEAR	(~(0x3 << 2))
+#define MAX77759_USB_VBUS_VOLTAGE_H_VBUS_VOLTAGE9_8_SHIFT	0
+#define MAX77759_USB_VBUS_VOLTAGE_H_VBUS_VOLTAGE9_8_MASK	(0x3 << 0)
+#define MAX77759_USB_VBUS_VOLTAGE_H_VBUS_VOLTAGE9_8_CLEAR	(~(0x3 << 0))
+
+MAX77759_BFF(usb_vbus_voltage_h_rsvd_7_4,7,4)
+MAX77759_BFF(usb_vbus_voltage_h_scale_factor,3,2)
+MAX77759_BFF(usb_vbus_voltage_h_vbus_voltage9_8,1,0)
+static inline const char *
+max77759_usb_vbus_voltage_h_cstr(char *buff, size_t len, int val)
+{
+#ifdef SCNPRINTF
+	int i = 0;
+
+	i += SCNPRINTF(&buff[i], len - i, " RSVD_7_4=%x",
+		FIELD2VALUE(MAX77759_USB_VBUS_VOLTAGE_H_RSVD_7_4, val));
+	i += SCNPRINTF(&buff[i], len - i, " SCALE_FACTOR=%x",
+		FIELD2VALUE(MAX77759_USB_VBUS_VOLTAGE_H_SCALE_FACTOR, val));
+	i += SCNPRINTF(&buff[i], len - i, " VBUS_VOLTAGE9_8=%x",
+		FIELD2VALUE(MAX77759_USB_VBUS_VOLTAGE_H_VBUS_VOLTAGE9_8, val));
+#else
+	buff[0] = 0;
+#endif
+	return buff;
+}
+
+/*
+ * VBUS_SNK_DISC_L,0x72,0b10001100,0x8c
+ * VBUS_SNK_DISC7_0[7:0],,,,,,
+ */
+#define MAX77759_USB_VBUS_SNK_DISC_L	0x72
+
+/*
+ * VBUS_SNK_DISC_H,0x73,0b00000000,0x00
+ * RSVD_7_2[5:0],,,,,,VBUS_SNK_DISC9_8[1:0]
+ */
+#define MAX77759_USB_VBUS_SNK_DISC_H	0x73
+
+#define MAX77759_USB_VBUS_SNK_DISC_H_RSVD_7_2_SHIFT	2
+#define MAX77759_USB_VBUS_SNK_DISC_H_RSVD_7_2_MASK	(0x3f << 2)
+#define MAX77759_USB_VBUS_SNK_DISC_H_RSVD_7_2_CLEAR	(~(0x3f << 2))
+#define MAX77759_USB_VBUS_SNK_DISC_H_VBUS_SNK_DISC9_8_SHIFT	0
+#define MAX77759_USB_VBUS_SNK_DISC_H_VBUS_SNK_DISC9_8_MASK	(0x3 << 0)
+#define MAX77759_USB_VBUS_SNK_DISC_H_VBUS_SNK_DISC9_8_CLEAR	(~(0x3 << 0))
+
+MAX77759_BFF(usb_vbus_snk_disc_h_rsvd_7_2,7,2)
+MAX77759_BFF(usb_vbus_snk_disc_h_vbus_snk_disc9_8,1,0)
+static inline const char *
+max77759_usb_vbus_snk_disc_h_cstr(char *buff, size_t len, int val)
+{
+#ifdef SCNPRINTF
+	int i = 0;
+
+	i += SCNPRINTF(&buff[i], len - i, " RSVD_7_2=%x",
+		FIELD2VALUE(MAX77759_USB_VBUS_SNK_DISC_H_RSVD_7_2, val));
+	i += SCNPRINTF(&buff[i], len - i, " VBUS_SNK_DISC9_8=%x",
+		FIELD2VALUE(MAX77759_USB_VBUS_SNK_DISC_H_VBUS_SNK_DISC9_8, val));
+#else
+	buff[0] = 0;
+#endif
+	return buff;
+}
+
+/*
+ * VBUS_STOP_DISCHARGE_THRESHOLD_L,0x74,0b00100000,0x20
+ * VBUS_STOP_DISCH_THRESHOLD7_0[7:0],,,,,,
+ */
+#define MAX77759_USB_VBUS_STOP_DISCHARGE_THRESHOLD_L	0x74
+
+/*
+ * VBUS_STOP_DISCHARGE_THRESHOLD_H,0x75,0b00000000,0x00
+ * RSVD_7_2[5:0],,,,,,VBUS_STOP_DISCH_THRESHOLD9_8[1:0]
+ */
+#define MAX77759_USB_VBUS_STOP_DISCHARGE_THRESHOLD_H	0x75
+
+#define MAX77759_USB_VBUS_STOP_DISCHARGE_THRESHOLD_H_RSVD_7_2_SHIFT	2
+#define MAX77759_USB_VBUS_STOP_DISCHARGE_THRESHOLD_H_RSVD_7_2_MASK	(0x3f << 2)
+#define MAX77759_USB_VBUS_STOP_DISCHARGE_THRESHOLD_H_RSVD_7_2_CLEAR	(~(0x3f << 2))
+#define MAX77759_USB_VBUS_STOP_DISCHARGE_THRESHOLD_H_VBUS_STOP_DISCH_THRESHOLD9_8_SHIFT	0
+#define MAX77759_USB_VBUS_STOP_DISCHARGE_THRESHOLD_H_VBUS_STOP_DISCH_THRESHOLD9_8_MASK	(0x3 << 0)
+#define MAX77759_USB_VBUS_STOP_DISCHARGE_THRESHOLD_H_VBUS_STOP_DISCH_THRESHOLD9_8_CLEAR	(~(0x3 << 0))
+
+MAX77759_BFF(usb_vbus_stop_discharge_threshold_h_rsvd_7_2,7,2)
+MAX77759_BFF(usb_vbus_stop_discharge_threshold_h_vbus_stop_disch_threshold9_8,1,0)
+static inline const char *
+max77759_usb_vbus_stop_discharge_threshold_h_cstr(char *buff, size_t len, int val)
+{
+#ifdef SCNPRINTF
+	int i = 0;
+
+	i += SCNPRINTF(&buff[i], len - i, " RSVD_7_2=%x",
+		FIELD2VALUE(MAX77759_USB_VBUS_STOP_DISCHARGE_THRESHOLD_H_RSVD_7_2, val));
+	i += SCNPRINTF(&buff[i], len - i, " VBUS_STOP_DISCH_THRESHOLD9_8=%x",
+		FIELD2VALUE(MAX77759_USB_VBUS_STOP_DISCHARGE_THRESHOLD_H_VBUS_STOP_DISCH_THRESHOLD9_8, val));
+#else
+	buff[0] = 0;
+#endif
+	return buff;
+}
+
+/*
+ * VBUS_VOLTAGE_ALARM_HI_CFG_L,0x76,0b00000000,0x00
+ * VBUS_ALARM_HI_CFG7_0[7:0],,,,,,
+ */
+#define MAX77759_USB_VBUS_VOLTAGE_ALARM_HI_CFG_L	0x76
+
+/*
+ * VBUS_VOLTAGE_ALARM_HI_CFG_H,0x77,0b00000000,0x00
+ * RSVD_7_2[5:0],,,,,,VBUS_ALARM_HI_CFG9_8[1:0]
+ */
+#define MAX77759_USB_VBUS_VOLTAGE_ALARM_HI_CFG_H	0x77
+
+#define MAX77759_USB_VBUS_VOLTAGE_ALARM_HI_CFG_H_RSVD_7_2_SHIFT	2
+#define MAX77759_USB_VBUS_VOLTAGE_ALARM_HI_CFG_H_RSVD_7_2_MASK	(0x3f << 2)
+#define MAX77759_USB_VBUS_VOLTAGE_ALARM_HI_CFG_H_RSVD_7_2_CLEAR	(~(0x3f << 2))
+#define MAX77759_USB_VBUS_VOLTAGE_ALARM_HI_CFG_H_VBUS_ALARM_HI_CFG9_8_SHIFT	0
+#define MAX77759_USB_VBUS_VOLTAGE_ALARM_HI_CFG_H_VBUS_ALARM_HI_CFG9_8_MASK	(0x3 << 0)
+#define MAX77759_USB_VBUS_VOLTAGE_ALARM_HI_CFG_H_VBUS_ALARM_HI_CFG9_8_CLEAR	(~(0x3 << 0))
+
+MAX77759_BFF(usb_vbus_voltage_alarm_hi_cfg_h_rsvd_7_2,7,2)
+MAX77759_BFF(usb_vbus_voltage_alarm_hi_cfg_h_vbus_alarm_hi_cfg9_8,1,0)
+static inline const char *
+max77759_usb_vbus_voltage_alarm_hi_cfg_h_cstr(char *buff, size_t len, int val)
+{
+#ifdef SCNPRINTF
+	int i = 0;
+
+	i += SCNPRINTF(&buff[i], len - i, " RSVD_7_2=%x",
+		FIELD2VALUE(MAX77759_USB_VBUS_VOLTAGE_ALARM_HI_CFG_H_RSVD_7_2, val));
+	i += SCNPRINTF(&buff[i], len - i, " VBUS_ALARM_HI_CFG9_8=%x",
+		FIELD2VALUE(MAX77759_USB_VBUS_VOLTAGE_ALARM_HI_CFG_H_VBUS_ALARM_HI_CFG9_8, val));
+#else
+	buff[0] = 0;
+#endif
+	return buff;
+}
+
+/*
+ * VBUS_VOLTAGE_ALARM_LO_CFG_L,0x78,0b00000000,0x00
+ * VBUS_ALARM_LO_CFG_7_0[7:0],,,,,,
+ */
+#define MAX77759_USB_VBUS_VOLTAGE_ALARM_LO_CFG_L	0x78
+
+/*
+ * VBUS_VOLTAGE_ALARM_LO_CFG_H,0x79,0b00000000,0x00
+ * RSVD_7_2[5:0],,,,,,VBUS_ALARM_LO_CFG9_8[1:0]
+ */
+#define MAX77759_USB_VBUS_VOLTAGE_ALARM_LO_CFG_H	0x79
+
+#define MAX77759_USB_VBUS_VOLTAGE_ALARM_LO_CFG_H_RSVD_7_2_SHIFT	2
+#define MAX77759_USB_VBUS_VOLTAGE_ALARM_LO_CFG_H_RSVD_7_2_MASK	(0x3f << 2)
+#define MAX77759_USB_VBUS_VOLTAGE_ALARM_LO_CFG_H_RSVD_7_2_CLEAR	(~(0x3f << 2))
+#define MAX77759_USB_VBUS_VOLTAGE_ALARM_LO_CFG_H_VBUS_ALARM_LO_CFG9_8_SHIFT	0
+#define MAX77759_USB_VBUS_VOLTAGE_ALARM_LO_CFG_H_VBUS_ALARM_LO_CFG9_8_MASK	(0x3 << 0)
+#define MAX77759_USB_VBUS_VOLTAGE_ALARM_LO_CFG_H_VBUS_ALARM_LO_CFG9_8_CLEAR	(~(0x3 << 0))
+
+MAX77759_BFF(usb_vbus_voltage_alarm_lo_cfg_h_rsvd_7_2,7,2)
+MAX77759_BFF(usb_vbus_voltage_alarm_lo_cfg_h_vbus_alarm_lo_cfg9_8,1,0)
+static inline const char *
+max77759_usb_vbus_voltage_alarm_lo_cfg_h_cstr(char *buff, size_t len, int val)
+{
+#ifdef SCNPRINTF
+	int i = 0;
+
+	i += SCNPRINTF(&buff[i], len - i, " RSVD_7_2=%x",
+		FIELD2VALUE(MAX77759_USB_VBUS_VOLTAGE_ALARM_LO_CFG_H_RSVD_7_2, val));
+	i += SCNPRINTF(&buff[i], len - i, " VBUS_ALARM_LO_CFG9_8=%x",
+		FIELD2VALUE(MAX77759_USB_VBUS_VOLTAGE_ALARM_LO_CFG_H_VBUS_ALARM_LO_CFG9_8, val));
+#else
+	buff[0] = 0;
+#endif
+	return buff;
+}
+
+/*
+ * VENDOR_ALERT1,0x80,0b00000000,0x00
+ * SPR_7_6[1:0],,dnVdatRefInt,chgTypRunFInt,chgTypRunRInt,prChgTypInt,dcdTmoInt
+ */
+#define MAX77759_USB_VENDOR_ALERT1	0x80
+#define MAX77759_USB_VENDOR_ALERT1_DNVDATREFINT	(0x1 << 5)
+#define MAX77759_USB_VENDOR_ALERT1_CHGTYPRUNFINT	(0x1 << 4)
+#define MAX77759_USB_VENDOR_ALERT1_CHGTYPRUNRINT	(0x1 << 3)
+#define MAX77759_USB_VENDOR_ALERT1_PRCHGTYPINT	(0x1 << 2)
+#define MAX77759_USB_VENDOR_ALERT1_DCDTMOINT	(0x1 << 1)
+#define MAX77759_USB_VENDOR_ALERT1_CHGTYPINT	(0x1 << 0)
+
+#define MAX77759_USB_VENDOR_ALERT1_SPR_7_6_SHIFT	6
+#define MAX77759_USB_VENDOR_ALERT1_SPR_7_6_MASK	(0x3 << 6)
+#define MAX77759_USB_VENDOR_ALERT1_SPR_7_6_CLEAR	(~(0x3 << 6))
+#define MAX77759_USB_VENDOR_ALERT1_DNVDATREFINT_SHIFT	5
+#define MAX77759_USB_VENDOR_ALERT1_DNVDATREFINT_MASK	(0x1 << 5)
+#define MAX77759_USB_VENDOR_ALERT1_DNVDATREFINT_CLEAR	(~(0x1 << 5))
+#define MAX77759_USB_VENDOR_ALERT1_CHGTYPRUNFINT_SHIFT	4
+#define MAX77759_USB_VENDOR_ALERT1_CHGTYPRUNFINT_MASK	(0x1 << 4)
+#define MAX77759_USB_VENDOR_ALERT1_CHGTYPRUNFINT_CLEAR	(~(0x1 << 4))
+#define MAX77759_USB_VENDOR_ALERT1_CHGTYPRUNRINT_SHIFT	3
+#define MAX77759_USB_VENDOR_ALERT1_CHGTYPRUNRINT_MASK	(0x1 << 3)
+#define MAX77759_USB_VENDOR_ALERT1_CHGTYPRUNRINT_CLEAR	(~(0x1 << 3))
+#define MAX77759_USB_VENDOR_ALERT1_PRCHGTYPINT_SHIFT	2
+#define MAX77759_USB_VENDOR_ALERT1_PRCHGTYPINT_MASK	(0x1 << 2)
+#define MAX77759_USB_VENDOR_ALERT1_PRCHGTYPINT_CLEAR	(~(0x1 << 2))
+#define MAX77759_USB_VENDOR_ALERT1_DCDTMOINT_SHIFT	1
+#define MAX77759_USB_VENDOR_ALERT1_DCDTMOINT_MASK	(0x1 << 1)
+#define MAX77759_USB_VENDOR_ALERT1_DCDTMOINT_CLEAR	(~(0x1 << 1))
+#define MAX77759_USB_VENDOR_ALERT1_CHGTYPINT_SHIFT	0
+#define MAX77759_USB_VENDOR_ALERT1_CHGTYPINT_MASK	(0x1 << 0)
+#define MAX77759_USB_VENDOR_ALERT1_CHGTYPINT_CLEAR	(~(0x1 << 0))
+
+MAX77759_BFF(usb_vendor_alert1_spr_7_6,7,6)
+MAX77759_BFF(usb_vendor_alert1_dnvdatrefint,5,5)
+MAX77759_BFF(usb_vendor_alert1_chgtyprunfint,4,4)
+MAX77759_BFF(usb_vendor_alert1_chgtyprunrint,3,3)
+MAX77759_BFF(usb_vendor_alert1_prchgtypint,2,2)
+MAX77759_BFF(usb_vendor_alert1_dcdtmoint,1,1)
+MAX77759_BFF(usb_vendor_alert1_chgtypint,0,0)
+static inline const char *
+max77759_usb_vendor_alert1_cstr(char *buff, size_t len, int val)
+{
+#ifdef SCNPRINTF
+	int i = 0;
+
+	i += SCNPRINTF(&buff[i], len - i, " SPR_7_6=%x",
+		FIELD2VALUE(MAX77759_USB_VENDOR_ALERT1_SPR_7_6, val));
+	i += SCNPRINTF(&buff[i], len - i, " DNVDATREFINT=%x",
+		FIELD2VALUE(MAX77759_USB_VENDOR_ALERT1_DNVDATREFINT, val));
+	i += SCNPRINTF(&buff[i], len - i, " CHGTYPRUNFINT=%x",
+		FIELD2VALUE(MAX77759_USB_VENDOR_ALERT1_CHGTYPRUNFINT, val));
+	i += SCNPRINTF(&buff[i], len - i, " CHGTYPRUNRINT=%x",
+		FIELD2VALUE(MAX77759_USB_VENDOR_ALERT1_CHGTYPRUNRINT, val));
+	i += SCNPRINTF(&buff[i], len - i, " PRCHGTYPINT=%x",
+		FIELD2VALUE(MAX77759_USB_VENDOR_ALERT1_PRCHGTYPINT, val));
+	i += SCNPRINTF(&buff[i], len - i, " DCDTMOINT=%x",
+		FIELD2VALUE(MAX77759_USB_VENDOR_ALERT1_DCDTMOINT, val));
+	i += SCNPRINTF(&buff[i], len - i, " CHGTYPINT=%x",
+		FIELD2VALUE(MAX77759_USB_VENDOR_ALERT1_CHGTYPINT, val));
+#else
+	buff[0] = 0;
+#endif
+	return buff;
+}
+
+/*
+ * VENDOR_ALERT2,0x81,0b00000000,0x00
+ * SBU_OVPint,USB_OVPint,CC_OVPint,SPR_4_3[1:0],,CCVCNSCInt,FLASH_ADCInt
+ */
+#define MAX77759_USB_VENDOR_ALERT2	0x81
+#define MAX77759_USB_VENDOR_ALERT2_SBU_OVPINT	(0x1 << 7)
+#define MAX77759_USB_VENDOR_ALERT2_USB_OVPINT	(0x1 << 6)
+#define MAX77759_USB_VENDOR_ALERT2_CC_OVPINT	(0x1 << 5)
+#define MAX77759_USB_VENDOR_ALERT2_CCVCNSCINT	(0x1 << 2)
+#define MAX77759_USB_VENDOR_ALERT2_FLASH_ADCINT	(0x1 << 1)
+#define MAX77759_USB_VENDOR_ALERT2_SPR_0	(0x1 << 0)
+
+#define MAX77759_USB_VENDOR_ALERT2_SBU_OVPINT_SHIFT	7
+#define MAX77759_USB_VENDOR_ALERT2_SBU_OVPINT_MASK	(0x1 << 7)
+#define MAX77759_USB_VENDOR_ALERT2_SBU_OVPINT_CLEAR	(~(0x1 << 7))
+#define MAX77759_USB_VENDOR_ALERT2_USB_OVPINT_SHIFT	6
+#define MAX77759_USB_VENDOR_ALERT2_USB_OVPINT_MASK	(0x1 << 6)
+#define MAX77759_USB_VENDOR_ALERT2_USB_OVPINT_CLEAR	(~(0x1 << 6))
+#define MAX77759_USB_VENDOR_ALERT2_CC_OVPINT_SHIFT	5
+#define MAX77759_USB_VENDOR_ALERT2_CC_OVPINT_MASK	(0x1 << 5)
+#define MAX77759_USB_VENDOR_ALERT2_CC_OVPINT_CLEAR	(~(0x1 << 5))
+#define MAX77759_USB_VENDOR_ALERT2_SPR_4_3_SHIFT	3
+#define MAX77759_USB_VENDOR_ALERT2_SPR_4_3_MASK	(0x3 << 3)
+#define MAX77759_USB_VENDOR_ALERT2_SPR_4_3_CLEAR	(~(0x3 << 3))
+#define MAX77759_USB_VENDOR_ALERT2_CCVCNSCINT_SHIFT	2
+#define MAX77759_USB_VENDOR_ALERT2_CCVCNSCINT_MASK	(0x1 << 2)
+#define MAX77759_USB_VENDOR_ALERT2_CCVCNSCINT_CLEAR	(~(0x1 << 2))
+#define MAX77759_USB_VENDOR_ALERT2_FLASH_ADCINT_SHIFT	1
+#define MAX77759_USB_VENDOR_ALERT2_FLASH_ADCINT_MASK	(0x1 << 1)
+#define MAX77759_USB_VENDOR_ALERT2_FLASH_ADCINT_CLEAR	(~(0x1 << 1))
+#define MAX77759_USB_VENDOR_ALERT2_SPR_0_SHIFT	0
+#define MAX77759_USB_VENDOR_ALERT2_SPR_0_MASK	(0x1 << 0)
+#define MAX77759_USB_VENDOR_ALERT2_SPR_0_CLEAR	(~(0x1 << 0))
+
+MAX77759_BFF(usb_vendor_alert2_sbu_ovpint,7,7)
+MAX77759_BFF(usb_vendor_alert2_usb_ovpint,6,6)
+MAX77759_BFF(usb_vendor_alert2_cc_ovpint,5,5)
+MAX77759_BFF(usb_vendor_alert2_spr_4_3,4,3)
+MAX77759_BFF(usb_vendor_alert2_ccvcnscint,2,2)
+MAX77759_BFF(usb_vendor_alert2_flash_adcint,1,1)
+MAX77759_BFF(usb_vendor_alert2_spr_0,0,0)
+static inline const char *
+max77759_usb_vendor_alert2_cstr(char *buff, size_t len, int val)
+{
+#ifdef SCNPRINTF
+	int i = 0;
+
+	i += SCNPRINTF(&buff[i], len - i, " SBU_OVPINT=%x",
+		FIELD2VALUE(MAX77759_USB_VENDOR_ALERT2_SBU_OVPINT, val));
+	i += SCNPRINTF(&buff[i], len - i, " USB_OVPINT=%x",
+		FIELD2VALUE(MAX77759_USB_VENDOR_ALERT2_USB_OVPINT, val));
+	i += SCNPRINTF(&buff[i], len - i, " CC_OVPINT=%x",
+		FIELD2VALUE(MAX77759_USB_VENDOR_ALERT2_CC_OVPINT, val));
+	i += SCNPRINTF(&buff[i], len - i, " SPR_4_3=%x",
+		FIELD2VALUE(MAX77759_USB_VENDOR_ALERT2_SPR_4_3, val));
+	i += SCNPRINTF(&buff[i], len - i, " CCVCNSCINT=%x",
+		FIELD2VALUE(MAX77759_USB_VENDOR_ALERT2_CCVCNSCINT, val));
+	i += SCNPRINTF(&buff[i], len - i, " FLASH_ADCINT=%x",
+		FIELD2VALUE(MAX77759_USB_VENDOR_ALERT2_FLASH_ADCINT, val));
+	i += SCNPRINTF(&buff[i], len - i, " SPR_0=%x",
+		FIELD2VALUE(MAX77759_USB_VENDOR_ALERT2_SPR_0, val));
+#else
+	buff[0] = 0;
+#endif
+	return buff;
+}
+
+/*
+ * VENDOR_ALERT_MASK1,0x82,0b11111111,0xff
+ * SPR_7_6[1:0],,MSK_dnVDatRef,MSK_chgTypRunF,MSK_chgTypRunR,MSK_PrchgTyp,MSK_dcdTmo
+ */
+#define MAX77759_USB_VENDOR_ALERT_MASK1	0x82
+#define MAX77759_USB_VENDOR_ALERT_MASK1_MSK_DNVDATREF	(0x1 << 5)
+#define MAX77759_USB_VENDOR_ALERT_MASK1_MSK_CHGTYPRUNF	(0x1 << 4)
+#define MAX77759_USB_VENDOR_ALERT_MASK1_MSK_CHGTYPRUNR	(0x1 << 3)
+#define MAX77759_USB_VENDOR_ALERT_MASK1_MSK_PRCHGTYP	(0x1 << 2)
+#define MAX77759_USB_VENDOR_ALERT_MASK1_MSK_DCDTMO	(0x1 << 1)
+#define MAX77759_USB_VENDOR_ALERT_MASK1_MSK_CHGTYP	(0x1 << 0)
+
+#define MAX77759_USB_VENDOR_ALERT_MASK1_SPR_7_6_SHIFT	6
+#define MAX77759_USB_VENDOR_ALERT_MASK1_SPR_7_6_MASK	(0x3 << 6)
+#define MAX77759_USB_VENDOR_ALERT_MASK1_SPR_7_6_CLEAR	(~(0x3 << 6))
+#define MAX77759_USB_VENDOR_ALERT_MASK1_MSK_DNVDATREF_SHIFT	5
+#define MAX77759_USB_VENDOR_ALERT_MASK1_MSK_DNVDATREF_MASK	(0x1 << 5)
+#define MAX77759_USB_VENDOR_ALERT_MASK1_MSK_DNVDATREF_CLEAR	(~(0x1 << 5))
+#define MAX77759_USB_VENDOR_ALERT_MASK1_MSK_CHGTYPRUNF_SHIFT	4
+#define MAX77759_USB_VENDOR_ALERT_MASK1_MSK_CHGTYPRUNF_MASK	(0x1 << 4)
+#define MAX77759_USB_VENDOR_ALERT_MASK1_MSK_CHGTYPRUNF_CLEAR	(~(0x1 << 4))
+#define MAX77759_USB_VENDOR_ALERT_MASK1_MSK_CHGTYPRUNR_SHIFT	3
+#define MAX77759_USB_VENDOR_ALERT_MASK1_MSK_CHGTYPRUNR_MASK	(0x1 << 3)
+#define MAX77759_USB_VENDOR_ALERT_MASK1_MSK_CHGTYPRUNR_CLEAR	(~(0x1 << 3))
+#define MAX77759_USB_VENDOR_ALERT_MASK1_MSK_PRCHGTYP_SHIFT	2
+#define MAX77759_USB_VENDOR_ALERT_MASK1_MSK_PRCHGTYP_MASK	(0x1 << 2)
+#define MAX77759_USB_VENDOR_ALERT_MASK1_MSK_PRCHGTYP_CLEAR	(~(0x1 << 2))
+#define MAX77759_USB_VENDOR_ALERT_MASK1_MSK_DCDTMO_SHIFT	1
+#define MAX77759_USB_VENDOR_ALERT_MASK1_MSK_DCDTMO_MASK	(0x1 << 1)
+#define MAX77759_USB_VENDOR_ALERT_MASK1_MSK_DCDTMO_CLEAR	(~(0x1 << 1))
+#define MAX77759_USB_VENDOR_ALERT_MASK1_MSK_CHGTYP_SHIFT	0
+#define MAX77759_USB_VENDOR_ALERT_MASK1_MSK_CHGTYP_MASK	(0x1 << 0)
+#define MAX77759_USB_VENDOR_ALERT_MASK1_MSK_CHGTYP_CLEAR	(~(0x1 << 0))
+
+MAX77759_BFF(usb_vendor_alert_mask1_spr_7_6,7,6)
+MAX77759_BFF(usb_vendor_alert_mask1_msk_dnvdatref,5,5)
+MAX77759_BFF(usb_vendor_alert_mask1_msk_chgtyprunf,4,4)
+MAX77759_BFF(usb_vendor_alert_mask1_msk_chgtyprunr,3,3)
+MAX77759_BFF(usb_vendor_alert_mask1_msk_prchgtyp,2,2)
+MAX77759_BFF(usb_vendor_alert_mask1_msk_dcdtmo,1,1)
+MAX77759_BFF(usb_vendor_alert_mask1_msk_chgtyp,0,0)
+static inline const char *
+max77759_usb_vendor_alert_mask1_cstr(char *buff, size_t len, int val)
+{
+#ifdef SCNPRINTF
+	int i = 0;
+
+	i += SCNPRINTF(&buff[i], len - i, " SPR_7_6=%x",
+		FIELD2VALUE(MAX77759_USB_VENDOR_ALERT_MASK1_SPR_7_6, val));
+	i += SCNPRINTF(&buff[i], len - i, " MSK_DNVDATREF=%x",
+		FIELD2VALUE(MAX77759_USB_VENDOR_ALERT_MASK1_MSK_DNVDATREF, val));
+	i += SCNPRINTF(&buff[i], len - i, " MSK_CHGTYPRUNF=%x",
+		FIELD2VALUE(MAX77759_USB_VENDOR_ALERT_MASK1_MSK_CHGTYPRUNF, val));
+	i += SCNPRINTF(&buff[i], len - i, " MSK_CHGTYPRUNR=%x",
+		FIELD2VALUE(MAX77759_USB_VENDOR_ALERT_MASK1_MSK_CHGTYPRUNR, val));
+	i += SCNPRINTF(&buff[i], len - i, " MSK_PRCHGTYP=%x",
+		FIELD2VALUE(MAX77759_USB_VENDOR_ALERT_MASK1_MSK_PRCHGTYP, val));
+	i += SCNPRINTF(&buff[i], len - i, " MSK_DCDTMO=%x",
+		FIELD2VALUE(MAX77759_USB_VENDOR_ALERT_MASK1_MSK_DCDTMO, val));
+	i += SCNPRINTF(&buff[i], len - i, " MSK_CHGTYP=%x",
+		FIELD2VALUE(MAX77759_USB_VENDOR_ALERT_MASK1_MSK_CHGTYP, val));
+#else
+	buff[0] = 0;
+#endif
+	return buff;
+}
+
+/*
+ * VENDOR_ALERT_MASK2,0x83,0b11111111,0xff
+ * MSK_SBU_OVP,MSK_USB_OVP,MSK_CC_OVP,SPR_4_3[1:0],,MSK_CCVCNSCInt,MSK_FLASH_ADCInt
+ */
+#define MAX77759_USB_VENDOR_ALERT_MASK2	0x83
+#define MAX77759_USB_VENDOR_ALERT_MASK2_MSK_SBU_OVP	(0x1 << 7)
+#define MAX77759_USB_VENDOR_ALERT_MASK2_MSK_USB_OVP	(0x1 << 6)
+#define MAX77759_USB_VENDOR_ALERT_MASK2_MSK_CC_OVP	(0x1 << 5)
+#define MAX77759_USB_VENDOR_ALERT_MASK2_MSK_CCVCNSCINT	(0x1 << 2)
+#define MAX77759_USB_VENDOR_ALERT_MASK2_MSK_FLASH_ADCINT	(0x1 << 1)
+#define MAX77759_USB_VENDOR_ALERT_MASK2_SPR_0	(0x1 << 0)
+
+#define MAX77759_USB_VENDOR_ALERT_MASK2_MSK_SBU_OVP_SHIFT	7
+#define MAX77759_USB_VENDOR_ALERT_MASK2_MSK_SBU_OVP_MASK	(0x1 << 7)
+#define MAX77759_USB_VENDOR_ALERT_MASK2_MSK_SBU_OVP_CLEAR	(~(0x1 << 7))
+#define MAX77759_USB_VENDOR_ALERT_MASK2_MSK_USB_OVP_SHIFT	6
+#define MAX77759_USB_VENDOR_ALERT_MASK2_MSK_USB_OVP_MASK	(0x1 << 6)
+#define MAX77759_USB_VENDOR_ALERT_MASK2_MSK_USB_OVP_CLEAR	(~(0x1 << 6))
+#define MAX77759_USB_VENDOR_ALERT_MASK2_MSK_CC_OVP_SHIFT	5
+#define MAX77759_USB_VENDOR_ALERT_MASK2_MSK_CC_OVP_MASK	(0x1 << 5)
+#define MAX77759_USB_VENDOR_ALERT_MASK2_MSK_CC_OVP_CLEAR	(~(0x1 << 5))
+#define MAX77759_USB_VENDOR_ALERT_MASK2_SPR_4_3_SHIFT	3
+#define MAX77759_USB_VENDOR_ALERT_MASK2_SPR_4_3_MASK	(0x3 << 3)
+#define MAX77759_USB_VENDOR_ALERT_MASK2_SPR_4_3_CLEAR	(~(0x3 << 3))
+#define MAX77759_USB_VENDOR_ALERT_MASK2_MSK_CCVCNSCINT_SHIFT	2
+#define MAX77759_USB_VENDOR_ALERT_MASK2_MSK_CCVCNSCINT_MASK	(0x1 << 2)
+#define MAX77759_USB_VENDOR_ALERT_MASK2_MSK_CCVCNSCINT_CLEAR	(~(0x1 << 2))
+#define MAX77759_USB_VENDOR_ALERT_MASK2_MSK_FLASH_ADCINT_SHIFT	1
+#define MAX77759_USB_VENDOR_ALERT_MASK2_MSK_FLASH_ADCINT_MASK	(0x1 << 1)
+#define MAX77759_USB_VENDOR_ALERT_MASK2_MSK_FLASH_ADCINT_CLEAR	(~(0x1 << 1))
+#define MAX77759_USB_VENDOR_ALERT_MASK2_SPR_0_SHIFT	0
+#define MAX77759_USB_VENDOR_ALERT_MASK2_SPR_0_MASK	(0x1 << 0)
+#define MAX77759_USB_VENDOR_ALERT_MASK2_SPR_0_CLEAR	(~(0x1 << 0))
+
+MAX77759_BFF(usb_vendor_alert_mask2_msk_sbu_ovp,7,7)
+MAX77759_BFF(usb_vendor_alert_mask2_msk_usb_ovp,6,6)
+MAX77759_BFF(usb_vendor_alert_mask2_msk_cc_ovp,5,5)
+MAX77759_BFF(usb_vendor_alert_mask2_spr_4_3,4,3)
+MAX77759_BFF(usb_vendor_alert_mask2_msk_ccvcnscint,2,2)
+MAX77759_BFF(usb_vendor_alert_mask2_msk_flash_adcint,1,1)
+MAX77759_BFF(usb_vendor_alert_mask2_spr_0,0,0)
+static inline const char *
+max77759_usb_vendor_alert_mask2_cstr(char *buff, size_t len, int val)
+{
+#ifdef SCNPRINTF
+	int i = 0;
+
+	i += SCNPRINTF(&buff[i], len - i, " MSK_SBU_OVP=%x",
+		FIELD2VALUE(MAX77759_USB_VENDOR_ALERT_MASK2_MSK_SBU_OVP, val));
+	i += SCNPRINTF(&buff[i], len - i, " MSK_USB_OVP=%x",
+		FIELD2VALUE(MAX77759_USB_VENDOR_ALERT_MASK2_MSK_USB_OVP, val));
+	i += SCNPRINTF(&buff[i], len - i, " MSK_CC_OVP=%x",
+		FIELD2VALUE(MAX77759_USB_VENDOR_ALERT_MASK2_MSK_CC_OVP, val));
+	i += SCNPRINTF(&buff[i], len - i, " SPR_4_3=%x",
+		FIELD2VALUE(MAX77759_USB_VENDOR_ALERT_MASK2_SPR_4_3, val));
+	i += SCNPRINTF(&buff[i], len - i, " MSK_CCVCNSCINT=%x",
+		FIELD2VALUE(MAX77759_USB_VENDOR_ALERT_MASK2_MSK_CCVCNSCINT, val));
+	i += SCNPRINTF(&buff[i], len - i, " MSK_FLASH_ADCINT=%x",
+		FIELD2VALUE(MAX77759_USB_VENDOR_ALERT_MASK2_MSK_FLASH_ADCINT, val));
+	i += SCNPRINTF(&buff[i], len - i, " SPR_0=%x",
+		FIELD2VALUE(MAX77759_USB_VENDOR_ALERT_MASK2_SPR_0, val));
+#else
+	buff[0] = 0;
+#endif
+	return buff;
+}
+
+/*
+ * VENDOR_CC_STATUS1,0x84,0b00000000,0x00
+ * SBU2_OVP,SBU1_OVP,USBDP_OVP,USBDN_OVP,CC2_OVP,CC1_OVP,SPR_1_0[1:0]
+ */
+#define MAX77759_USB_VENDOR_CC_STATUS1	0x84
+#define MAX77759_USB_VENDOR_CC_STATUS1_SBU2_OVP	(0x1 << 7)
+#define MAX77759_USB_VENDOR_CC_STATUS1_SBU1_OVP	(0x1 << 6)
+#define MAX77759_USB_VENDOR_CC_STATUS1_USBDP_OVP	(0x1 << 5)
+#define MAX77759_USB_VENDOR_CC_STATUS1_USBDN_OVP	(0x1 << 4)
+#define MAX77759_USB_VENDOR_CC_STATUS1_CC2_OVP	(0x1 << 3)
+#define MAX77759_USB_VENDOR_CC_STATUS1_CC1_OVP	(0x1 << 2)
+
+#define MAX77759_USB_VENDOR_CC_STATUS1_SBU2_OVP_SHIFT	7
+#define MAX77759_USB_VENDOR_CC_STATUS1_SBU2_OVP_MASK	(0x1 << 7)
+#define MAX77759_USB_VENDOR_CC_STATUS1_SBU2_OVP_CLEAR	(~(0x1 << 7))
+#define MAX77759_USB_VENDOR_CC_STATUS1_SBU1_OVP_SHIFT	6
+#define MAX77759_USB_VENDOR_CC_STATUS1_SBU1_OVP_MASK	(0x1 << 6)
+#define MAX77759_USB_VENDOR_CC_STATUS1_SBU1_OVP_CLEAR	(~(0x1 << 6))
+#define MAX77759_USB_VENDOR_CC_STATUS1_USBDP_OVP_SHIFT	5
+#define MAX77759_USB_VENDOR_CC_STATUS1_USBDP_OVP_MASK	(0x1 << 5)
+#define MAX77759_USB_VENDOR_CC_STATUS1_USBDP_OVP_CLEAR	(~(0x1 << 5))
+#define MAX77759_USB_VENDOR_CC_STATUS1_USBDN_OVP_SHIFT	4
+#define MAX77759_USB_VENDOR_CC_STATUS1_USBDN_OVP_MASK	(0x1 << 4)
+#define MAX77759_USB_VENDOR_CC_STATUS1_USBDN_OVP_CLEAR	(~(0x1 << 4))
+#define MAX77759_USB_VENDOR_CC_STATUS1_CC2_OVP_SHIFT	3
+#define MAX77759_USB_VENDOR_CC_STATUS1_CC2_OVP_MASK	(0x1 << 3)
+#define MAX77759_USB_VENDOR_CC_STATUS1_CC2_OVP_CLEAR	(~(0x1 << 3))
+#define MAX77759_USB_VENDOR_CC_STATUS1_CC1_OVP_SHIFT	2
+#define MAX77759_USB_VENDOR_CC_STATUS1_CC1_OVP_MASK	(0x1 << 2)
+#define MAX77759_USB_VENDOR_CC_STATUS1_CC1_OVP_CLEAR	(~(0x1 << 2))
+#define MAX77759_USB_VENDOR_CC_STATUS1_SPR_1_0_SHIFT	0
+#define MAX77759_USB_VENDOR_CC_STATUS1_SPR_1_0_MASK	(0x3 << 0)
+#define MAX77759_USB_VENDOR_CC_STATUS1_SPR_1_0_CLEAR	(~(0x3 << 0))
+
+MAX77759_BFF(usb_vendor_cc_status1_sbu2_ovp,7,7)
+MAX77759_BFF(usb_vendor_cc_status1_sbu1_ovp,6,6)
+MAX77759_BFF(usb_vendor_cc_status1_usbdp_ovp,5,5)
+MAX77759_BFF(usb_vendor_cc_status1_usbdn_ovp,4,4)
+MAX77759_BFF(usb_vendor_cc_status1_cc2_ovp,3,3)
+MAX77759_BFF(usb_vendor_cc_status1_cc1_ovp,2,2)
+MAX77759_BFF(usb_vendor_cc_status1_spr_1_0,1,0)
+static inline const char *
+max77759_usb_vendor_cc_status1_cstr(char *buff, size_t len, int val)
+{
+#ifdef SCNPRINTF
+	int i = 0;
+
+	i += SCNPRINTF(&buff[i], len - i, " SBU2_OVP=%x",
+		FIELD2VALUE(MAX77759_USB_VENDOR_CC_STATUS1_SBU2_OVP, val));
+	i += SCNPRINTF(&buff[i], len - i, " SBU1_OVP=%x",
+		FIELD2VALUE(MAX77759_USB_VENDOR_CC_STATUS1_SBU1_OVP, val));
+	i += SCNPRINTF(&buff[i], len - i, " USBDP_OVP=%x",
+		FIELD2VALUE(MAX77759_USB_VENDOR_CC_STATUS1_USBDP_OVP, val));
+	i += SCNPRINTF(&buff[i], len - i, " USBDN_OVP=%x",
+		FIELD2VALUE(MAX77759_USB_VENDOR_CC_STATUS1_USBDN_OVP, val));
+	i += SCNPRINTF(&buff[i], len - i, " CC2_OVP=%x",
+		FIELD2VALUE(MAX77759_USB_VENDOR_CC_STATUS1_CC2_OVP, val));
+	i += SCNPRINTF(&buff[i], len - i, " CC1_OVP=%x",
+		FIELD2VALUE(MAX77759_USB_VENDOR_CC_STATUS1_CC1_OVP, val));
+	i += SCNPRINTF(&buff[i], len - i, " SPR_1_0=%x",
+		FIELD2VALUE(MAX77759_USB_VENDOR_CC_STATUS1_SPR_1_0, val));
+#else
+	buff[0] = 0;
+#endif
+	return buff;
+}
+
+/*
+ * VENDOR_CC_STATUS2,0x85,0b00000000,0x00
+ * CC2_VDFP_OPEN,CC2_VUFP_RD1P5,CC2_VUFP_RD0P5,CC2_VRA_RD0P5,CC1_VDFP_OPEN,CC1_VUFP_RD1P5,CC1_VUFP_RD0P5
+ */
+#define MAX77759_USB_VENDOR_CC_STATUS2	0x85
+#define MAX77759_USB_VENDOR_CC_STATUS2_CC2_VDFP_OPEN	(0x1 << 7)
+#define MAX77759_USB_VENDOR_CC_STATUS2_CC2_VUFP_RD1P5	(0x1 << 6)
+#define MAX77759_USB_VENDOR_CC_STATUS2_CC2_VUFP_RD0P5	(0x1 << 5)
+#define MAX77759_USB_VENDOR_CC_STATUS2_CC2_VRA_RD0P5	(0x1 << 4)
+#define MAX77759_USB_VENDOR_CC_STATUS2_CC1_VDFP_OPEN	(0x1 << 3)
+#define MAX77759_USB_VENDOR_CC_STATUS2_CC1_VUFP_RD1P5	(0x1 << 2)
+#define MAX77759_USB_VENDOR_CC_STATUS2_CC1_VUFP_RD0P5	(0x1 << 1)
+#define MAX77759_USB_VENDOR_CC_STATUS2_CC1_VRA_RD0P5	(0x1 << 0)
+
+#define MAX77759_USB_VENDOR_CC_STATUS2_CC2_VDFP_OPEN_SHIFT	7
+#define MAX77759_USB_VENDOR_CC_STATUS2_CC2_VDFP_OPEN_MASK	(0x1 << 7)
+#define MAX77759_USB_VENDOR_CC_STATUS2_CC2_VDFP_OPEN_CLEAR	(~(0x1 << 7))
+#define MAX77759_USB_VENDOR_CC_STATUS2_CC2_VUFP_RD1P5_SHIFT	6
+#define MAX77759_USB_VENDOR_CC_STATUS2_CC2_VUFP_RD1P5_MASK	(0x1 << 6)
+#define MAX77759_USB_VENDOR_CC_STATUS2_CC2_VUFP_RD1P5_CLEAR	(~(0x1 << 6))
+#define MAX77759_USB_VENDOR_CC_STATUS2_CC2_VUFP_RD0P5_SHIFT	5
+#define MAX77759_USB_VENDOR_CC_STATUS2_CC2_VUFP_RD0P5_MASK	(0x1 << 5)
+#define MAX77759_USB_VENDOR_CC_STATUS2_CC2_VUFP_RD0P5_CLEAR	(~(0x1 << 5))
+#define MAX77759_USB_VENDOR_CC_STATUS2_CC2_VRA_RD0P5_SHIFT	4
+#define MAX77759_USB_VENDOR_CC_STATUS2_CC2_VRA_RD0P5_MASK	(0x1 << 4)
+#define MAX77759_USB_VENDOR_CC_STATUS2_CC2_VRA_RD0P5_CLEAR	(~(0x1 << 4))
+#define MAX77759_USB_VENDOR_CC_STATUS2_CC1_VDFP_OPEN_SHIFT	3
+#define MAX77759_USB_VENDOR_CC_STATUS2_CC1_VDFP_OPEN_MASK	(0x1 << 3)
+#define MAX77759_USB_VENDOR_CC_STATUS2_CC1_VDFP_OPEN_CLEAR	(~(0x1 << 3))
+#define MAX77759_USB_VENDOR_CC_STATUS2_CC1_VUFP_RD1P5_SHIFT	2
+#define MAX77759_USB_VENDOR_CC_STATUS2_CC1_VUFP_RD1P5_MASK	(0x1 << 2)
+#define MAX77759_USB_VENDOR_CC_STATUS2_CC1_VUFP_RD1P5_CLEAR	(~(0x1 << 2))
+#define MAX77759_USB_VENDOR_CC_STATUS2_CC1_VUFP_RD0P5_SHIFT	1
+#define MAX77759_USB_VENDOR_CC_STATUS2_CC1_VUFP_RD0P5_MASK	(0x1 << 1)
+#define MAX77759_USB_VENDOR_CC_STATUS2_CC1_VUFP_RD0P5_CLEAR	(~(0x1 << 1))
+#define MAX77759_USB_VENDOR_CC_STATUS2_CC1_VRA_RD0P5_SHIFT	0
+#define MAX77759_USB_VENDOR_CC_STATUS2_CC1_VRA_RD0P5_MASK	(0x1 << 0)
+#define MAX77759_USB_VENDOR_CC_STATUS2_CC1_VRA_RD0P5_CLEAR	(~(0x1 << 0))
+
+MAX77759_BFF(usb_vendor_cc_status2_cc2_vdfp_open,7,7)
+MAX77759_BFF(usb_vendor_cc_status2_cc2_vufp_rd1p5,6,6)
+MAX77759_BFF(usb_vendor_cc_status2_cc2_vufp_rd0p5,5,5)
+MAX77759_BFF(usb_vendor_cc_status2_cc2_vra_rd0p5,4,4)
+MAX77759_BFF(usb_vendor_cc_status2_cc1_vdfp_open,3,3)
+MAX77759_BFF(usb_vendor_cc_status2_cc1_vufp_rd1p5,2,2)
+MAX77759_BFF(usb_vendor_cc_status2_cc1_vufp_rd0p5,1,1)
+MAX77759_BFF(usb_vendor_cc_status2_cc1_vra_rd0p5,0,0)
+static inline const char *
+max77759_usb_vendor_cc_status2_cstr(char *buff, size_t len, int val)
+{
+#ifdef SCNPRINTF
+	int i = 0;
+
+	i += SCNPRINTF(&buff[i], len - i, " CC2_VDFP_OPEN=%x",
+		FIELD2VALUE(MAX77759_USB_VENDOR_CC_STATUS2_CC2_VDFP_OPEN, val));
+	i += SCNPRINTF(&buff[i], len - i, " CC2_VUFP_RD1P5=%x",
+		FIELD2VALUE(MAX77759_USB_VENDOR_CC_STATUS2_CC2_VUFP_RD1P5, val));
+	i += SCNPRINTF(&buff[i], len - i, " CC2_VUFP_RD0P5=%x",
+		FIELD2VALUE(MAX77759_USB_VENDOR_CC_STATUS2_CC2_VUFP_RD0P5, val));
+	i += SCNPRINTF(&buff[i], len - i, " CC2_VRA_RD0P5=%x",
+		FIELD2VALUE(MAX77759_USB_VENDOR_CC_STATUS2_CC2_VRA_RD0P5, val));
+	i += SCNPRINTF(&buff[i], len - i, " CC1_VDFP_OPEN=%x",
+		FIELD2VALUE(MAX77759_USB_VENDOR_CC_STATUS2_CC1_VDFP_OPEN, val));
+	i += SCNPRINTF(&buff[i], len - i, " CC1_VUFP_RD1P5=%x",
+		FIELD2VALUE(MAX77759_USB_VENDOR_CC_STATUS2_CC1_VUFP_RD1P5, val));
+	i += SCNPRINTF(&buff[i], len - i, " CC1_VUFP_RD0P5=%x",
+		FIELD2VALUE(MAX77759_USB_VENDOR_CC_STATUS2_CC1_VUFP_RD0P5, val));
+	i += SCNPRINTF(&buff[i], len - i, " CC1_VRA_RD0P5=%x",
+		FIELD2VALUE(MAX77759_USB_VENDOR_CC_STATUS2_CC1_VRA_RD0P5, val));
+#else
+	buff[0] = 0;
+#endif
+	return buff;
+}
+
+/*
+ * VENDOR_CC_STATUS3,0x86,0b00000000,0x00
+ * ccVcnSc,ccVcnOCP,SPR_5_1[4:0],,,,
+ */
+#define MAX77759_USB_VENDOR_CC_STATUS3	0x86
+#define MAX77759_USB_VENDOR_CC_STATUS3_CCVCNSC	(0x1 << 7)
+#define MAX77759_USB_VENDOR_CC_STATUS3_CCVCNOCP	(0x1 << 6)
+#define MAX77759_USB_VENDOR_CC_STATUS3_CCVCNSTAT	(0x1 << 0)
+
+#define MAX77759_USB_VENDOR_CC_STATUS3_CCVCNSC_SHIFT	7
+#define MAX77759_USB_VENDOR_CC_STATUS3_CCVCNSC_MASK	(0x1 << 7)
+#define MAX77759_USB_VENDOR_CC_STATUS3_CCVCNSC_CLEAR	(~(0x1 << 7))
+#define MAX77759_USB_VENDOR_CC_STATUS3_CCVCNOCP_SHIFT	6
+#define MAX77759_USB_VENDOR_CC_STATUS3_CCVCNOCP_MASK	(0x1 << 6)
+#define MAX77759_USB_VENDOR_CC_STATUS3_CCVCNOCP_CLEAR	(~(0x1 << 6))
+#define MAX77759_USB_VENDOR_CC_STATUS3_SPR_5_1_SHIFT	1
+#define MAX77759_USB_VENDOR_CC_STATUS3_SPR_5_1_MASK	(0x1f << 1)
+#define MAX77759_USB_VENDOR_CC_STATUS3_SPR_5_1_CLEAR	(~(0x1f << 1))
+#define MAX77759_USB_VENDOR_CC_STATUS3_CCVCNSTAT_SHIFT	0
+#define MAX77759_USB_VENDOR_CC_STATUS3_CCVCNSTAT_MASK	(0x1 << 0)
+#define MAX77759_USB_VENDOR_CC_STATUS3_CCVCNSTAT_CLEAR	(~(0x1 << 0))
+
+MAX77759_BFF(usb_vendor_cc_status3_ccvcnsc,7,7)
+MAX77759_BFF(usb_vendor_cc_status3_ccvcnocp,6,6)
+MAX77759_BFF(usb_vendor_cc_status3_spr_5_1,5,1)
+MAX77759_BFF(usb_vendor_cc_status3_ccvcnstat,0,0)
+static inline const char *
+max77759_usb_vendor_cc_status3_cstr(char *buff, size_t len, int val)
+{
+#ifdef SCNPRINTF
+	int i = 0;
+
+	i += SCNPRINTF(&buff[i], len - i, " CCVCNSC=%x",
+		FIELD2VALUE(MAX77759_USB_VENDOR_CC_STATUS3_CCVCNSC, val));
+	i += SCNPRINTF(&buff[i], len - i, " CCVCNOCP=%x",
+		FIELD2VALUE(MAX77759_USB_VENDOR_CC_STATUS3_CCVCNOCP, val));
+	i += SCNPRINTF(&buff[i], len - i, " SPR_5_1=%x",
+		FIELD2VALUE(MAX77759_USB_VENDOR_CC_STATUS3_SPR_5_1, val));
+	i += SCNPRINTF(&buff[i], len - i, " CCVCNSTAT=%x",
+		FIELD2VALUE(MAX77759_USB_VENDOR_CC_STATUS3_CCVCNSTAT, val));
+#else
+	buff[0] = 0;
+#endif
+	return buff;
+}
+
+/*
+ * VENDOR_BC_STATUS1,0x87,0b00000000,0x00
+ * SPR_7,ChgTypRun,PrChgTyp[2:0],,,DCDTmo,ChgTyp[1:0]
+ */
+#define MAX77759_USB_VENDOR_BC_STATUS1	0x87
+#define MAX77759_USB_VENDOR_BC_STATUS1_SPR_7	(0x1 << 7)
+#define MAX77759_USB_VENDOR_BC_STATUS1_CHGTYPRUN	(0x1 << 6)
+#define MAX77759_USB_VENDOR_BC_STATUS1_DCDTMO	(0x1 << 2)
+
+#define MAX77759_USB_VENDOR_BC_STATUS1_SPR_7_SHIFT	7
+#define MAX77759_USB_VENDOR_BC_STATUS1_SPR_7_MASK	(0x1 << 7)
+#define MAX77759_USB_VENDOR_BC_STATUS1_SPR_7_CLEAR	(~(0x1 << 7))
+#define MAX77759_USB_VENDOR_BC_STATUS1_CHGTYPRUN_SHIFT	6
+#define MAX77759_USB_VENDOR_BC_STATUS1_CHGTYPRUN_MASK	(0x1 << 6)
+#define MAX77759_USB_VENDOR_BC_STATUS1_CHGTYPRUN_CLEAR	(~(0x1 << 6))
+#define MAX77759_USB_VENDOR_BC_STATUS1_PRCHGTYP_SHIFT	3
+#define MAX77759_USB_VENDOR_BC_STATUS1_PRCHGTYP_MASK	(0x7 << 3)
+#define MAX77759_USB_VENDOR_BC_STATUS1_PRCHGTYP_CLEAR	(~(0x7 << 3))
+#define MAX77759_USB_VENDOR_BC_STATUS1_DCDTMO_SHIFT	2
+#define MAX77759_USB_VENDOR_BC_STATUS1_DCDTMO_MASK	(0x1 << 2)
+#define MAX77759_USB_VENDOR_BC_STATUS1_DCDTMO_CLEAR	(~(0x1 << 2))
+#define MAX77759_USB_VENDOR_BC_STATUS1_CHGTYP_SHIFT	0
+#define MAX77759_USB_VENDOR_BC_STATUS1_CHGTYP_MASK	(0x3 << 0)
+#define MAX77759_USB_VENDOR_BC_STATUS1_CHGTYP_CLEAR	(~(0x3 << 0))
+
+MAX77759_BFF(usb_vendor_bc_status1_spr_7,7,7)
+MAX77759_BFF(usb_vendor_bc_status1_chgtyprun,6,6)
+MAX77759_BFF(usb_vendor_bc_status1_prchgtyp,5,3)
+MAX77759_BFF(usb_vendor_bc_status1_dcdtmo,2,2)
+MAX77759_BFF(usb_vendor_bc_status1_chgtyp,1,0)
+static inline const char *
+max77759_usb_vendor_bc_status1_cstr(char *buff, size_t len, int val)
+{
+#ifdef SCNPRINTF
+	int i = 0;
+
+	i += SCNPRINTF(&buff[i], len - i, " SPR_7=%x",
+		FIELD2VALUE(MAX77759_USB_VENDOR_BC_STATUS1_SPR_7, val));
+	i += SCNPRINTF(&buff[i], len - i, " CHGTYPRUN=%x",
+		FIELD2VALUE(MAX77759_USB_VENDOR_BC_STATUS1_CHGTYPRUN, val));
+	i += SCNPRINTF(&buff[i], len - i, " PRCHGTYP=%x",
+		FIELD2VALUE(MAX77759_USB_VENDOR_BC_STATUS1_PRCHGTYP, val));
+	i += SCNPRINTF(&buff[i], len - i, " DCDTMO=%x",
+		FIELD2VALUE(MAX77759_USB_VENDOR_BC_STATUS1_DCDTMO, val));
+	i += SCNPRINTF(&buff[i], len - i, " CHGTYP=%x",
+		FIELD2VALUE(MAX77759_USB_VENDOR_BC_STATUS1_CHGTYP, val));
+#else
+	buff[0] = 0;
+#endif
+	return buff;
+}
+
+/*
+ * VENDOR_BC_STATUS2,0x88,0b00000000,0x00
+ * dnDebOk,SPR_6,dnVlgc,dnVdatRef,dpDebOk,SPR_2,dpVlgc
+ */
+#define MAX77759_USB_VENDOR_BC_STATUS2	0x88
+#define MAX77759_USB_VENDOR_BC_STATUS2_DNDEBOK	(0x1 << 7)
+#define MAX77759_USB_VENDOR_BC_STATUS2_SPR_6	(0x1 << 6)
+#define MAX77759_USB_VENDOR_BC_STATUS2_DNVLGC	(0x1 << 5)
+#define MAX77759_USB_VENDOR_BC_STATUS2_DNVDATREF	(0x1 << 4)
+#define MAX77759_USB_VENDOR_BC_STATUS2_DPDEBOK	(0x1 << 3)
+#define MAX77759_USB_VENDOR_BC_STATUS2_SPR_2	(0x1 << 2)
+#define MAX77759_USB_VENDOR_BC_STATUS2_DPVLGC	(0x1 << 1)
+#define MAX77759_USB_VENDOR_BC_STATUS2_DPVDATREF	(0x1 << 0)
+
+#define MAX77759_USB_VENDOR_BC_STATUS2_DNDEBOK_SHIFT	7
+#define MAX77759_USB_VENDOR_BC_STATUS2_DNDEBOK_MASK	(0x1 << 7)
+#define MAX77759_USB_VENDOR_BC_STATUS2_DNDEBOK_CLEAR	(~(0x1 << 7))
+#define MAX77759_USB_VENDOR_BC_STATUS2_SPR_6_SHIFT	6
+#define MAX77759_USB_VENDOR_BC_STATUS2_SPR_6_MASK	(0x1 << 6)
+#define MAX77759_USB_VENDOR_BC_STATUS2_SPR_6_CLEAR	(~(0x1 << 6))
+#define MAX77759_USB_VENDOR_BC_STATUS2_DNVLGC_SHIFT	5
+#define MAX77759_USB_VENDOR_BC_STATUS2_DNVLGC_MASK	(0x1 << 5)
+#define MAX77759_USB_VENDOR_BC_STATUS2_DNVLGC_CLEAR	(~(0x1 << 5))
+#define MAX77759_USB_VENDOR_BC_STATUS2_DNVDATREF_SHIFT	4
+#define MAX77759_USB_VENDOR_BC_STATUS2_DNVDATREF_MASK	(0x1 << 4)
+#define MAX77759_USB_VENDOR_BC_STATUS2_DNVDATREF_CLEAR	(~(0x1 << 4))
+#define MAX77759_USB_VENDOR_BC_STATUS2_DPDEBOK_SHIFT	3
+#define MAX77759_USB_VENDOR_BC_STATUS2_DPDEBOK_MASK	(0x1 << 3)
+#define MAX77759_USB_VENDOR_BC_STATUS2_DPDEBOK_CLEAR	(~(0x1 << 3))
+#define MAX77759_USB_VENDOR_BC_STATUS2_SPR_2_SHIFT	2
+#define MAX77759_USB_VENDOR_BC_STATUS2_SPR_2_MASK	(0x1 << 2)
+#define MAX77759_USB_VENDOR_BC_STATUS2_SPR_2_CLEAR	(~(0x1 << 2))
+#define MAX77759_USB_VENDOR_BC_STATUS2_DPVLGC_SHIFT	1
+#define MAX77759_USB_VENDOR_BC_STATUS2_DPVLGC_MASK	(0x1 << 1)
+#define MAX77759_USB_VENDOR_BC_STATUS2_DPVLGC_CLEAR	(~(0x1 << 1))
+#define MAX77759_USB_VENDOR_BC_STATUS2_DPVDATREF_SHIFT	0
+#define MAX77759_USB_VENDOR_BC_STATUS2_DPVDATREF_MASK	(0x1 << 0)
+#define MAX77759_USB_VENDOR_BC_STATUS2_DPVDATREF_CLEAR	(~(0x1 << 0))
+
+MAX77759_BFF(usb_vendor_bc_status2_dndebok,7,7)
+MAX77759_BFF(usb_vendor_bc_status2_spr_6,6,6)
+MAX77759_BFF(usb_vendor_bc_status2_dnvlgc,5,5)
+MAX77759_BFF(usb_vendor_bc_status2_dnvdatref,4,4)
+MAX77759_BFF(usb_vendor_bc_status2_dpdebok,3,3)
+MAX77759_BFF(usb_vendor_bc_status2_spr_2,2,2)
+MAX77759_BFF(usb_vendor_bc_status2_dpvlgc,1,1)
+MAX77759_BFF(usb_vendor_bc_status2_dpvdatref,0,0)
+static inline const char *
+max77759_usb_vendor_bc_status2_cstr(char *buff, size_t len, int val)
+{
+#ifdef SCNPRINTF
+	int i = 0;
+
+	i += SCNPRINTF(&buff[i], len - i, " DNDEBOK=%x",
+		FIELD2VALUE(MAX77759_USB_VENDOR_BC_STATUS2_DNDEBOK, val));
+	i += SCNPRINTF(&buff[i], len - i, " SPR_6=%x",
+		FIELD2VALUE(MAX77759_USB_VENDOR_BC_STATUS2_SPR_6, val));
+	i += SCNPRINTF(&buff[i], len - i, " DNVLGC=%x",
+		FIELD2VALUE(MAX77759_USB_VENDOR_BC_STATUS2_DNVLGC, val));
+	i += SCNPRINTF(&buff[i], len - i, " DNVDATREF=%x",
+		FIELD2VALUE(MAX77759_USB_VENDOR_BC_STATUS2_DNVDATREF, val));
+	i += SCNPRINTF(&buff[i], len - i, " DPDEBOK=%x",
+		FIELD2VALUE(MAX77759_USB_VENDOR_BC_STATUS2_DPDEBOK, val));
+	i += SCNPRINTF(&buff[i], len - i, " SPR_2=%x",
+		FIELD2VALUE(MAX77759_USB_VENDOR_BC_STATUS2_SPR_2, val));
+	i += SCNPRINTF(&buff[i], len - i, " DPVLGC=%x",
+		FIELD2VALUE(MAX77759_USB_VENDOR_BC_STATUS2_DPVLGC, val));
+	i += SCNPRINTF(&buff[i], len - i, " DPVDATREF=%x",
+		FIELD2VALUE(MAX77759_USB_VENDOR_BC_STATUS2_DPVDATREF, val));
+#else
+	buff[0] = 0;
+#endif
+	return buff;
+}
+
+/*
+ * VENDOR_FLADC_STATUS,0x89,0b00000000,0x00
+ * ADC_VAL[7:0],,,,,,
+ */
+#define MAX77759_USB_VENDOR_FLADC_STATUS	0x89
+
+/*
+ * VENDOR_WDG_CTRL,0x8A,0b00000000,0x00
+ * RSVD_7_2[5:0],,,,,,WD_TIMEOUT[1:0]
+ */
+#define MAX77759_USB_VENDOR_WDG_CTRL	0x8A
+
+#define MAX77759_USB_VENDOR_WDG_CTRL_RSVD_7_2_SHIFT	2
+#define MAX77759_USB_VENDOR_WDG_CTRL_RSVD_7_2_MASK	(0x3f << 2)
+#define MAX77759_USB_VENDOR_WDG_CTRL_RSVD_7_2_CLEAR	(~(0x3f << 2))
+#define MAX77759_USB_VENDOR_WDG_CTRL_WD_TIMEOUT_SHIFT	0
+#define MAX77759_USB_VENDOR_WDG_CTRL_WD_TIMEOUT_MASK	(0x3 << 0)
+#define MAX77759_USB_VENDOR_WDG_CTRL_WD_TIMEOUT_CLEAR	(~(0x3 << 0))
+
+MAX77759_BFF(usb_vendor_wdg_ctrl_rsvd_7_2,7,2)
+MAX77759_BFF(usb_vendor_wdg_ctrl_wd_timeout,1,0)
+static inline const char *
+max77759_usb_vendor_wdg_ctrl_cstr(char *buff, size_t len, int val)
+{
+#ifdef SCNPRINTF
+	int i = 0;
+
+	i += SCNPRINTF(&buff[i], len - i, " RSVD_7_2=%x",
+		FIELD2VALUE(MAX77759_USB_VENDOR_WDG_CTRL_RSVD_7_2, val));
+	i += SCNPRINTF(&buff[i], len - i, " WD_TIMEOUT=%x",
+		FIELD2VALUE(MAX77759_USB_VENDOR_WDG_CTRL_WD_TIMEOUT, val));
+#else
+	buff[0] = 0;
+#endif
+	return buff;
+}
+
+/*
+ * VENDOR_VCON_CTRL,0x8B,0b10000001,0x81
+ * VcnOcpEn,SPR_6_5[1:0],,VcnSoftStartDis,VcnSc_Deb,VcnIlim[2:0],
+ */
+#define MAX77759_USB_VENDOR_VCON_CTRL	0x8B
+#define MAX77759_USB_VENDOR_VCON_CTRL_VCNOCPEN	(0x1 << 7)
+#define MAX77759_USB_VENDOR_VCON_CTRL_VCNSOFTSTARTDIS	(0x1 << 4)
+#define MAX77759_USB_VENDOR_VCON_CTRL_VCNSC_DEB	(0x1 << 3)
+
+#define MAX77759_USB_VENDOR_VCON_CTRL_VCNOCPEN_SHIFT	7
+#define MAX77759_USB_VENDOR_VCON_CTRL_VCNOCPEN_MASK	(0x1 << 7)
+#define MAX77759_USB_VENDOR_VCON_CTRL_VCNOCPEN_CLEAR	(~(0x1 << 7))
+#define MAX77759_USB_VENDOR_VCON_CTRL_SPR_6_5_SHIFT	5
+#define MAX77759_USB_VENDOR_VCON_CTRL_SPR_6_5_MASK	(0x3 << 5)
+#define MAX77759_USB_VENDOR_VCON_CTRL_SPR_6_5_CLEAR	(~(0x3 << 5))
+#define MAX77759_USB_VENDOR_VCON_CTRL_VCNSOFTSTARTDIS_SHIFT	4
+#define MAX77759_USB_VENDOR_VCON_CTRL_VCNSOFTSTARTDIS_MASK	(0x1 << 4)
+#define MAX77759_USB_VENDOR_VCON_CTRL_VCNSOFTSTARTDIS_CLEAR	(~(0x1 << 4))
+#define MAX77759_USB_VENDOR_VCON_CTRL_VCNSC_DEB_SHIFT	3
+#define MAX77759_USB_VENDOR_VCON_CTRL_VCNSC_DEB_MASK	(0x1 << 3)
+#define MAX77759_USB_VENDOR_VCON_CTRL_VCNSC_DEB_CLEAR	(~(0x1 << 3))
+#define MAX77759_USB_VENDOR_VCON_CTRL_VCNILIM_SHIFT	0
+#define MAX77759_USB_VENDOR_VCON_CTRL_VCNILIM_MASK	(0x7 << 0)
+#define MAX77759_USB_VENDOR_VCON_CTRL_VCNILIM_CLEAR	(~(0x7 << 0))
+
+MAX77759_BFF(usb_vendor_vcon_ctrl_vcnocpen,7,7)
+MAX77759_BFF(usb_vendor_vcon_ctrl_spr_6_5,6,5)
+MAX77759_BFF(usb_vendor_vcon_ctrl_vcnsoftstartdis,4,4)
+MAX77759_BFF(usb_vendor_vcon_ctrl_vcnsc_deb,3,3)
+MAX77759_BFF(usb_vendor_vcon_ctrl_vcnilim,2,0)
+static inline const char *
+max77759_usb_vendor_vcon_ctrl_cstr(char *buff, size_t len, int val)
+{
+#ifdef SCNPRINTF
+	int i = 0;
+
+	i += SCNPRINTF(&buff[i], len - i, " VCNOCPEN=%x",
+		FIELD2VALUE(MAX77759_USB_VENDOR_VCON_CTRL_VCNOCPEN, val));
+	i += SCNPRINTF(&buff[i], len - i, " SPR_6_5=%x",
+		FIELD2VALUE(MAX77759_USB_VENDOR_VCON_CTRL_SPR_6_5, val));
+	i += SCNPRINTF(&buff[i], len - i, " VCNSOFTSTARTDIS=%x",
+		FIELD2VALUE(MAX77759_USB_VENDOR_VCON_CTRL_VCNSOFTSTARTDIS, val));
+	i += SCNPRINTF(&buff[i], len - i, " VCNSC_DEB=%x",
+		FIELD2VALUE(MAX77759_USB_VENDOR_VCON_CTRL_VCNSC_DEB, val));
+	i += SCNPRINTF(&buff[i], len - i, " VCNILIM=%x",
+		FIELD2VALUE(MAX77759_USB_VENDOR_VCON_CTRL_VCNILIM, val));
+#else
+	buff[0] = 0;
+#endif
+	return buff;
+}
+
+/*
+ * VENDOR_CC_CTRL1,0x8C,0b00000010,0x02
+ * ccConnDry,RdOpenDis,ccCompEn,ccSnkExitEn,ccLpDrpCycle[1:0],,ccDrpPhase[1:0]
+ */
+#define MAX77759_USB_VENDOR_CC_CTRL1	0x8C
+#define MAX77759_USB_VENDOR_CC_CTRL1_CCCONNDRY	(0x1 << 7)
+#define MAX77759_USB_VENDOR_CC_CTRL1_RDOPENDIS	(0x1 << 6)
+#define MAX77759_USB_VENDOR_CC_CTRL1_CCCOMPEN	(0x1 << 5)
+#define MAX77759_USB_VENDOR_CC_CTRL1_CCSNKEXITEN	(0x1 << 4)
+
+#define MAX77759_USB_VENDOR_CC_CTRL1_CCCONNDRY_SHIFT	7
+#define MAX77759_USB_VENDOR_CC_CTRL1_CCCONNDRY_MASK	(0x1 << 7)
+#define MAX77759_USB_VENDOR_CC_CTRL1_CCCONNDRY_CLEAR	(~(0x1 << 7))
+#define MAX77759_USB_VENDOR_CC_CTRL1_RDOPENDIS_SHIFT	6
+#define MAX77759_USB_VENDOR_CC_CTRL1_RDOPENDIS_MASK	(0x1 << 6)
+#define MAX77759_USB_VENDOR_CC_CTRL1_RDOPENDIS_CLEAR	(~(0x1 << 6))
+#define MAX77759_USB_VENDOR_CC_CTRL1_CCCOMPEN_SHIFT	5
+#define MAX77759_USB_VENDOR_CC_CTRL1_CCCOMPEN_MASK	(0x1 << 5)
+#define MAX77759_USB_VENDOR_CC_CTRL1_CCCOMPEN_CLEAR	(~(0x1 << 5))
+#define MAX77759_USB_VENDOR_CC_CTRL1_CCSNKEXITEN_SHIFT	4
+#define MAX77759_USB_VENDOR_CC_CTRL1_CCSNKEXITEN_MASK	(0x1 << 4)
+#define MAX77759_USB_VENDOR_CC_CTRL1_CCSNKEXITEN_CLEAR	(~(0x1 << 4))
+#define MAX77759_USB_VENDOR_CC_CTRL1_CCLPDRPCYCLE_SHIFT	2
+#define MAX77759_USB_VENDOR_CC_CTRL1_CCLPDRPCYCLE_MASK	(0x3 << 2)
+#define MAX77759_USB_VENDOR_CC_CTRL1_CCLPDRPCYCLE_CLEAR	(~(0x3 << 2))
+#define MAX77759_USB_VENDOR_CC_CTRL1_CCDRPPHASE_SHIFT	0
+#define MAX77759_USB_VENDOR_CC_CTRL1_CCDRPPHASE_MASK	(0x3 << 0)
+#define MAX77759_USB_VENDOR_CC_CTRL1_CCDRPPHASE_CLEAR	(~(0x3 << 0))
+
+MAX77759_BFF(usb_vendor_cc_ctrl1_ccconndry,7,7)
+MAX77759_BFF(usb_vendor_cc_ctrl1_rdopendis,6,6)
+MAX77759_BFF(usb_vendor_cc_ctrl1_cccompen,5,5)
+MAX77759_BFF(usb_vendor_cc_ctrl1_ccsnkexiten,4,4)
+MAX77759_BFF(usb_vendor_cc_ctrl1_cclpdrpcycle,3,2)
+MAX77759_BFF(usb_vendor_cc_ctrl1_ccdrpphase,1,0)
+static inline const char *
+max77759_usb_vendor_cc_ctrl1_cstr(char *buff, size_t len, int val)
+{
+#ifdef SCNPRINTF
+	int i = 0;
+
+	i += SCNPRINTF(&buff[i], len - i, " CCCONNDRY=%x",
+		FIELD2VALUE(MAX77759_USB_VENDOR_CC_CTRL1_CCCONNDRY, val));
+	i += SCNPRINTF(&buff[i], len - i, " RDOPENDIS=%x",
+		FIELD2VALUE(MAX77759_USB_VENDOR_CC_CTRL1_RDOPENDIS, val));
+	i += SCNPRINTF(&buff[i], len - i, " CCCOMPEN=%x",
+		FIELD2VALUE(MAX77759_USB_VENDOR_CC_CTRL1_CCCOMPEN, val));
+	i += SCNPRINTF(&buff[i], len - i, " CCSNKEXITEN=%x",
+		FIELD2VALUE(MAX77759_USB_VENDOR_CC_CTRL1_CCSNKEXITEN, val));
+	i += SCNPRINTF(&buff[i], len - i, " CCLPDRPCYCLE=%x",
+		FIELD2VALUE(MAX77759_USB_VENDOR_CC_CTRL1_CCLPDRPCYCLE, val));
+	i += SCNPRINTF(&buff[i], len - i, " CCDRPPHASE=%x",
+		FIELD2VALUE(MAX77759_USB_VENDOR_CC_CTRL1_CCDRPPHASE, val));
+#else
+	buff[0] = 0;
+#endif
+	return buff;
+}
+
+/*
+ * VENDOR_CC_CTRL2,0x8D,0b00000000,0x00
+ * sbuOvpDis,ccOvpDis,sbuRpCtrl,ccLpModeSel[1:0],,ccRpCtrl[2:0],
+ */
+#define MAX77759_USB_VENDOR_CC_CTRL2	0x8D
+#define MAX77759_USB_VENDOR_CC_CTRL2_SBUOVPDIS	(0x1 << 7)
+#define MAX77759_USB_VENDOR_CC_CTRL2_CCOVPDIS	(0x1 << 6)
+#define MAX77759_USB_VENDOR_CC_CTRL2_SBURPCTRL	(0x1 << 5)
+
+#define MAX77759_USB_VENDOR_CC_CTRL2_SBUOVPDIS_SHIFT	7
+#define MAX77759_USB_VENDOR_CC_CTRL2_SBUOVPDIS_MASK	(0x1 << 7)
+#define MAX77759_USB_VENDOR_CC_CTRL2_SBUOVPDIS_CLEAR	(~(0x1 << 7))
+#define MAX77759_USB_VENDOR_CC_CTRL2_CCOVPDIS_SHIFT	6
+#define MAX77759_USB_VENDOR_CC_CTRL2_CCOVPDIS_MASK	(0x1 << 6)
+#define MAX77759_USB_VENDOR_CC_CTRL2_CCOVPDIS_CLEAR	(~(0x1 << 6))
+#define MAX77759_USB_VENDOR_CC_CTRL2_SBURPCTRL_SHIFT	5
+#define MAX77759_USB_VENDOR_CC_CTRL2_SBURPCTRL_MASK	(0x1 << 5)
+#define MAX77759_USB_VENDOR_CC_CTRL2_SBURPCTRL_CLEAR	(~(0x1 << 5))
+#define MAX77759_USB_VENDOR_CC_CTRL2_CCLPMODESEL_SHIFT	3
+#define MAX77759_USB_VENDOR_CC_CTRL2_CCLPMODESEL_MASK	(0x3 << 3)
+#define MAX77759_USB_VENDOR_CC_CTRL2_CCLPMODESEL_CLEAR	(~(0x3 << 3))
+#define MAX77759_USB_VENDOR_CC_CTRL2_CCRPCTRL_SHIFT	0
+#define MAX77759_USB_VENDOR_CC_CTRL2_CCRPCTRL_MASK	(0x7 << 0)
+#define MAX77759_USB_VENDOR_CC_CTRL2_CCRPCTRL_CLEAR	(~(0x7 << 0))
+
+MAX77759_BFF(usb_vendor_cc_ctrl2_sbuovpdis,7,7)
+MAX77759_BFF(usb_vendor_cc_ctrl2_ccovpdis,6,6)
+MAX77759_BFF(usb_vendor_cc_ctrl2_sburpctrl,5,5)
+MAX77759_BFF(usb_vendor_cc_ctrl2_cclpmodesel,4,3)
+MAX77759_BFF(usb_vendor_cc_ctrl2_ccrpctrl,2,0)
+static inline const char *
+max77759_usb_vendor_cc_ctrl2_cstr(char *buff, size_t len, int val)
+{
+#ifdef SCNPRINTF
+	int i = 0;
+
+	i += SCNPRINTF(&buff[i], len - i, " SBUOVPDIS=%x",
+		FIELD2VALUE(MAX77759_USB_VENDOR_CC_CTRL2_SBUOVPDIS, val));
+	i += SCNPRINTF(&buff[i], len - i, " CCOVPDIS=%x",
+		FIELD2VALUE(MAX77759_USB_VENDOR_CC_CTRL2_CCOVPDIS, val));
+	i += SCNPRINTF(&buff[i], len - i, " SBURPCTRL=%x",
+		FIELD2VALUE(MAX77759_USB_VENDOR_CC_CTRL2_SBURPCTRL, val));
+	i += SCNPRINTF(&buff[i], len - i, " CCLPMODESEL=%x",
+		FIELD2VALUE(MAX77759_USB_VENDOR_CC_CTRL2_CCLPMODESEL, val));
+	i += SCNPRINTF(&buff[i], len - i, " CCRPCTRL=%x",
+		FIELD2VALUE(MAX77759_USB_VENDOR_CC_CTRL2_CCRPCTRL, val));
+#else
+	buff[0] = 0;
+#endif
+	return buff;
+}
+
+/*
+ * VENDOR_CC_CTRL3,0x8E,0b00100000,0x20
+ * ccWtrDeb[1:0],,ccWtrSel[2:0],,,ccLadderDis,SPR_1
+ */
+#define MAX77759_USB_VENDOR_CC_CTRL3	0x8E
+#define MAX77759_USB_VENDOR_CC_CTRL3_CCLADDERDIS	(0x1 << 2)
+#define MAX77759_USB_VENDOR_CC_CTRL3_SPR_1	(0x1 << 1)
+#define MAX77759_USB_VENDOR_CC_CTRL3_WTRCYCLE	(0x1 << 0)
+
+#define MAX77759_USB_VENDOR_CC_CTRL3_CCWTRDEB_SHIFT	6
+#define MAX77759_USB_VENDOR_CC_CTRL3_CCWTRDEB_MASK	(0x3 << 6)
+#define MAX77759_USB_VENDOR_CC_CTRL3_CCWTRDEB_CLEAR	(~(0x3 << 6))
+#define MAX77759_USB_VENDOR_CC_CTRL3_CCWTRSEL_SHIFT	3
+#define MAX77759_USB_VENDOR_CC_CTRL3_CCWTRSEL_MASK	(0x7 << 3)
+#define MAX77759_USB_VENDOR_CC_CTRL3_CCWTRSEL_CLEAR	(~(0x7 << 3))
+#define MAX77759_USB_VENDOR_CC_CTRL3_CCLADDERDIS_SHIFT	2
+#define MAX77759_USB_VENDOR_CC_CTRL3_CCLADDERDIS_MASK	(0x1 << 2)
+#define MAX77759_USB_VENDOR_CC_CTRL3_CCLADDERDIS_CLEAR	(~(0x1 << 2))
+#define MAX77759_USB_VENDOR_CC_CTRL3_SPR_1_SHIFT	1
+#define MAX77759_USB_VENDOR_CC_CTRL3_SPR_1_MASK	(0x1 << 1)
+#define MAX77759_USB_VENDOR_CC_CTRL3_SPR_1_CLEAR	(~(0x1 << 1))
+#define MAX77759_USB_VENDOR_CC_CTRL3_WTRCYCLE_SHIFT	0
+#define MAX77759_USB_VENDOR_CC_CTRL3_WTRCYCLE_MASK	(0x1 << 0)
+#define MAX77759_USB_VENDOR_CC_CTRL3_WTRCYCLE_CLEAR	(~(0x1 << 0))
+
+MAX77759_BFF(usb_vendor_cc_ctrl3_ccwtrdeb,7,6)
+MAX77759_BFF(usb_vendor_cc_ctrl3_ccwtrsel,5,3)
+MAX77759_BFF(usb_vendor_cc_ctrl3_ccladderdis,2,2)
+MAX77759_BFF(usb_vendor_cc_ctrl3_spr_1,1,1)
+MAX77759_BFF(usb_vendor_cc_ctrl3_wtrcycle,0,0)
+static inline const char *
+max77759_usb_vendor_cc_ctrl3_cstr(char *buff, size_t len, int val)
+{
+#ifdef SCNPRINTF
+	int i = 0;
+
+	i += SCNPRINTF(&buff[i], len - i, " CCWTRDEB=%x",
+		FIELD2VALUE(MAX77759_USB_VENDOR_CC_CTRL3_CCWTRDEB, val));
+	i += SCNPRINTF(&buff[i], len - i, " CCWTRSEL=%x",
+		FIELD2VALUE(MAX77759_USB_VENDOR_CC_CTRL3_CCWTRSEL, val));
+	i += SCNPRINTF(&buff[i], len - i, " CCLADDERDIS=%x",
+		FIELD2VALUE(MAX77759_USB_VENDOR_CC_CTRL3_CCLADDERDIS, val));
+	i += SCNPRINTF(&buff[i], len - i, " SPR_1=%x",
+		FIELD2VALUE(MAX77759_USB_VENDOR_CC_CTRL3_SPR_1, val));
+	i += SCNPRINTF(&buff[i], len - i, " WTRCYCLE=%x",
+		FIELD2VALUE(MAX77759_USB_VENDOR_CC_CTRL3_WTRCYCLE, val));
+#else
+	buff[0] = 0;
+#endif
+	return buff;
+}
+
+/*
+ * VENDOR_BC_CTRL1,0x8F,0b10100001,0xa1
+ * dcdCpl,SPR_6,noBcComp,SPR_4_2[2:0],,,chgDetMan
+ */
+#define MAX77759_USB_VENDOR_BC_CTRL1	0x8F
+#define MAX77759_USB_VENDOR_BC_CTRL1_DCDCPL	(0x1 << 7)
+#define MAX77759_USB_VENDOR_BC_CTRL1_SPR_6	(0x1 << 6)
+#define MAX77759_USB_VENDOR_BC_CTRL1_NOBCCOMP	(0x1 << 5)
+#define MAX77759_USB_VENDOR_BC_CTRL1_CHGDETMAN	(0x1 << 1)
+#define MAX77759_USB_VENDOR_BC_CTRL1_CHGDETEN	(0x1 << 0)
+
+#define MAX77759_USB_VENDOR_BC_CTRL1_DCDCPL_SHIFT	7
+#define MAX77759_USB_VENDOR_BC_CTRL1_DCDCPL_MASK	(0x1 << 7)
+#define MAX77759_USB_VENDOR_BC_CTRL1_DCDCPL_CLEAR	(~(0x1 << 7))
+#define MAX77759_USB_VENDOR_BC_CTRL1_SPR_6_SHIFT	6
+#define MAX77759_USB_VENDOR_BC_CTRL1_SPR_6_MASK	(0x1 << 6)
+#define MAX77759_USB_VENDOR_BC_CTRL1_SPR_6_CLEAR	(~(0x1 << 6))
+#define MAX77759_USB_VENDOR_BC_CTRL1_NOBCCOMP_SHIFT	5
+#define MAX77759_USB_VENDOR_BC_CTRL1_NOBCCOMP_MASK	(0x1 << 5)
+#define MAX77759_USB_VENDOR_BC_CTRL1_NOBCCOMP_CLEAR	(~(0x1 << 5))
+#define MAX77759_USB_VENDOR_BC_CTRL1_SPR_4_2_SHIFT	2
+#define MAX77759_USB_VENDOR_BC_CTRL1_SPR_4_2_MASK	(0x7 << 2)
+#define MAX77759_USB_VENDOR_BC_CTRL1_SPR_4_2_CLEAR	(~(0x7 << 2))
+#define MAX77759_USB_VENDOR_BC_CTRL1_CHGDETMAN_SHIFT	1
+#define MAX77759_USB_VENDOR_BC_CTRL1_CHGDETMAN_MASK	(0x1 << 1)
+#define MAX77759_USB_VENDOR_BC_CTRL1_CHGDETMAN_CLEAR	(~(0x1 << 1))
+#define MAX77759_USB_VENDOR_BC_CTRL1_CHGDETEN_SHIFT	0
+#define MAX77759_USB_VENDOR_BC_CTRL1_CHGDETEN_MASK	(0x1 << 0)
+#define MAX77759_USB_VENDOR_BC_CTRL1_CHGDETEN_CLEAR	(~(0x1 << 0))
+
+MAX77759_BFF(usb_vendor_bc_ctrl1_dcdcpl,7,7)
+MAX77759_BFF(usb_vendor_bc_ctrl1_spr_6,6,6)
+MAX77759_BFF(usb_vendor_bc_ctrl1_nobccomp,5,5)
+MAX77759_BFF(usb_vendor_bc_ctrl1_spr_4_2,4,2)
+MAX77759_BFF(usb_vendor_bc_ctrl1_chgdetman,1,1)
+MAX77759_BFF(usb_vendor_bc_ctrl1_chgdeten,0,0)
+static inline const char *
+max77759_usb_vendor_bc_ctrl1_cstr(char *buff, size_t len, int val)
+{
+#ifdef SCNPRINTF
+	int i = 0;
+
+	i += SCNPRINTF(&buff[i], len - i, " DCDCPL=%x",
+		FIELD2VALUE(MAX77759_USB_VENDOR_BC_CTRL1_DCDCPL, val));
+	i += SCNPRINTF(&buff[i], len - i, " SPR_6=%x",
+		FIELD2VALUE(MAX77759_USB_VENDOR_BC_CTRL1_SPR_6, val));
+	i += SCNPRINTF(&buff[i], len - i, " NOBCCOMP=%x",
+		FIELD2VALUE(MAX77759_USB_VENDOR_BC_CTRL1_NOBCCOMP, val));
+	i += SCNPRINTF(&buff[i], len - i, " SPR_4_2=%x",
+		FIELD2VALUE(MAX77759_USB_VENDOR_BC_CTRL1_SPR_4_2, val));
+	i += SCNPRINTF(&buff[i], len - i, " CHGDETMAN=%x",
+		FIELD2VALUE(MAX77759_USB_VENDOR_BC_CTRL1_CHGDETMAN, val));
+	i += SCNPRINTF(&buff[i], len - i, " CHGDETEN=%x",
+		FIELD2VALUE(MAX77759_USB_VENDOR_BC_CTRL1_CHGDETEN, val));
+#else
+	buff[0] = 0;
+#endif
+	return buff;
+}
+
+/*
+ * VENDOR_BC_CTRL2,0x90,0b00000000,0x00
+ * dpMonEn,SPR_6,dnMonEn,dpDnMan,dpDrv[1:0],,dnDrv[1:0]
+ */
+#define MAX77759_USB_VENDOR_BC_CTRL2	0x90
+#define MAX77759_USB_VENDOR_BC_CTRL2_DPMONEN	(0x1 << 7)
+#define MAX77759_USB_VENDOR_BC_CTRL2_SPR_6	(0x1 << 6)
+#define MAX77759_USB_VENDOR_BC_CTRL2_DNMONEN	(0x1 << 5)
+#define MAX77759_USB_VENDOR_BC_CTRL2_DPDNMAN	(0x1 << 4)
+
+#define MAX77759_USB_VENDOR_BC_CTRL2_DPMONEN_SHIFT	7
+#define MAX77759_USB_VENDOR_BC_CTRL2_DPMONEN_MASK	(0x1 << 7)
+#define MAX77759_USB_VENDOR_BC_CTRL2_DPMONEN_CLEAR	(~(0x1 << 7))
+#define MAX77759_USB_VENDOR_BC_CTRL2_SPR_6_SHIFT	6
+#define MAX77759_USB_VENDOR_BC_CTRL2_SPR_6_MASK	(0x1 << 6)
+#define MAX77759_USB_VENDOR_BC_CTRL2_SPR_6_CLEAR	(~(0x1 << 6))
+#define MAX77759_USB_VENDOR_BC_CTRL2_DNMONEN_SHIFT	5
+#define MAX77759_USB_VENDOR_BC_CTRL2_DNMONEN_MASK	(0x1 << 5)
+#define MAX77759_USB_VENDOR_BC_CTRL2_DNMONEN_CLEAR	(~(0x1 << 5))
+#define MAX77759_USB_VENDOR_BC_CTRL2_DPDNMAN_SHIFT	4
+#define MAX77759_USB_VENDOR_BC_CTRL2_DPDNMAN_MASK	(0x1 << 4)
+#define MAX77759_USB_VENDOR_BC_CTRL2_DPDNMAN_CLEAR	(~(0x1 << 4))
+#define MAX77759_USB_VENDOR_BC_CTRL2_DPDRV_SHIFT	2
+#define MAX77759_USB_VENDOR_BC_CTRL2_DPDRV_MASK	(0x3 << 2)
+#define MAX77759_USB_VENDOR_BC_CTRL2_DPDRV_CLEAR	(~(0x3 << 2))
+#define MAX77759_USB_VENDOR_BC_CTRL2_DNDRV_SHIFT	0
+#define MAX77759_USB_VENDOR_BC_CTRL2_DNDRV_MASK	(0x3 << 0)
+#define MAX77759_USB_VENDOR_BC_CTRL2_DNDRV_CLEAR	(~(0x3 << 0))
+
+MAX77759_BFF(usb_vendor_bc_ctrl2_dpmonen,7,7)
+MAX77759_BFF(usb_vendor_bc_ctrl2_spr_6,6,6)
+MAX77759_BFF(usb_vendor_bc_ctrl2_dnmonen,5,5)
+MAX77759_BFF(usb_vendor_bc_ctrl2_dpdnman,4,4)
+MAX77759_BFF(usb_vendor_bc_ctrl2_dpdrv,3,2)
+MAX77759_BFF(usb_vendor_bc_ctrl2_dndrv,1,0)
+static inline const char *
+max77759_usb_vendor_bc_ctrl2_cstr(char *buff, size_t len, int val)
+{
+#ifdef SCNPRINTF
+	int i = 0;
+
+	i += SCNPRINTF(&buff[i], len - i, " DPMONEN=%x",
+		FIELD2VALUE(MAX77759_USB_VENDOR_BC_CTRL2_DPMONEN, val));
+	i += SCNPRINTF(&buff[i], len - i, " SPR_6=%x",
+		FIELD2VALUE(MAX77759_USB_VENDOR_BC_CTRL2_SPR_6, val));
+	i += SCNPRINTF(&buff[i], len - i, " DNMONEN=%x",
+		FIELD2VALUE(MAX77759_USB_VENDOR_BC_CTRL2_DNMONEN, val));
+	i += SCNPRINTF(&buff[i], len - i, " DPDNMAN=%x",
+		FIELD2VALUE(MAX77759_USB_VENDOR_BC_CTRL2_DPDNMAN, val));
+	i += SCNPRINTF(&buff[i], len - i, " DPDRV=%x",
+		FIELD2VALUE(MAX77759_USB_VENDOR_BC_CTRL2_DPDRV, val));
+	i += SCNPRINTF(&buff[i], len - i, " DNDRV=%x",
+		FIELD2VALUE(MAX77759_USB_VENDOR_BC_CTRL2_DNDRV, val));
+#else
+	buff[0] = 0;
+#endif
+	return buff;
+}
+
+/*
+ * VENDOR_ADC_CTRL1,0x91,0b00000000,0x00
+ * adcinSel[2:0],,,SPR_4_1[3:0],,,
+ */
+#define MAX77759_USB_VENDOR_ADC_CTRL1	0x91
+#define MAX77759_USB_VENDOR_ADC_CTRL1_ADCEN	(0x1 << 0)
+
+#define MAX77759_USB_VENDOR_ADC_CTRL1_ADCINSEL_SHIFT	5
+#define MAX77759_USB_VENDOR_ADC_CTRL1_ADCINSEL_MASK	(0x7 << 5)
+#define MAX77759_USB_VENDOR_ADC_CTRL1_ADCINSEL_CLEAR	(~(0x7 << 5))
+#define MAX77759_USB_VENDOR_ADC_CTRL1_SPR_4_1_SHIFT	1
+#define MAX77759_USB_VENDOR_ADC_CTRL1_SPR_4_1_MASK	(0xf << 1)
+#define MAX77759_USB_VENDOR_ADC_CTRL1_SPR_4_1_CLEAR	(~(0xf << 1))
+#define MAX77759_USB_VENDOR_ADC_CTRL1_ADCEN_SHIFT	0
+#define MAX77759_USB_VENDOR_ADC_CTRL1_ADCEN_MASK	(0x1 << 0)
+#define MAX77759_USB_VENDOR_ADC_CTRL1_ADCEN_CLEAR	(~(0x1 << 0))
+
+MAX77759_BFF(usb_vendor_adc_ctrl1_adcinsel,7,5)
+MAX77759_BFF(usb_vendor_adc_ctrl1_spr_4_1,4,1)
+MAX77759_BFF(usb_vendor_adc_ctrl1_adcen,0,0)
+static inline const char *
+max77759_usb_vendor_adc_ctrl1_cstr(char *buff, size_t len, int val)
+{
+#ifdef SCNPRINTF
+	int i = 0;
+
+	i += SCNPRINTF(&buff[i], len - i, " ADCINSEL=%x",
+		FIELD2VALUE(MAX77759_USB_VENDOR_ADC_CTRL1_ADCINSEL, val));
+	i += SCNPRINTF(&buff[i], len - i, " SPR_4_1=%x",
+		FIELD2VALUE(MAX77759_USB_VENDOR_ADC_CTRL1_SPR_4_1, val));
+	i += SCNPRINTF(&buff[i], len - i, " ADCEN=%x",
+		FIELD2VALUE(MAX77759_USB_VENDOR_ADC_CTRL1_ADCEN, val));
+#else
+	buff[0] = 0;
+#endif
+	return buff;
+}
+
+/*
+ * VENDOR_EXTBST_CTRL,0x92,0b00000000,0x00
+ * SPR_7_1[6:0],,,,,,
+ */
+#define MAX77759_USB_VENDOR_EXTBST_CTRL	0x92
+#define MAX77759_USB_VENDOR_EXTBST_CTRL_EXT_BST_EN	(0x1 << 0)
+
+#define MAX77759_USB_VENDOR_EXTBST_CTRL_SPR_7_1_SHIFT	1
+#define MAX77759_USB_VENDOR_EXTBST_CTRL_SPR_7_1_MASK	(0x7f << 1)
+#define MAX77759_USB_VENDOR_EXTBST_CTRL_SPR_7_1_CLEAR	(~(0x7f << 1))
+#define MAX77759_USB_VENDOR_EXTBST_CTRL_EXT_BST_EN_SHIFT	0
+#define MAX77759_USB_VENDOR_EXTBST_CTRL_EXT_BST_EN_MASK	(0x1 << 0)
+#define MAX77759_USB_VENDOR_EXTBST_CTRL_EXT_BST_EN_CLEAR	(~(0x1 << 0))
+
+MAX77759_BFF(usb_vendor_extbst_ctrl_spr_7_1,7,1)
+MAX77759_BFF(usb_vendor_extbst_ctrl_ext_bst_en,0,0)
+static inline const char *
+max77759_usb_vendor_extbst_ctrl_cstr(char *buff, size_t len, int val)
+{
+#ifdef SCNPRINTF
+	int i = 0;
+
+	i += SCNPRINTF(&buff[i], len - i, " SPR_7_1=%x",
+		FIELD2VALUE(MAX77759_USB_VENDOR_EXTBST_CTRL_SPR_7_1, val));
+	i += SCNPRINTF(&buff[i], len - i, " EXT_BST_EN=%x",
+		FIELD2VALUE(MAX77759_USB_VENDOR_EXTBST_CTRL_EXT_BST_EN, val));
+#else
+	buff[0] = 0;
+#endif
+	return buff;
+}
+
+/*
+ * VENDOR_USBSW_CTRL,0x93,0b00000000,0x00
+ * SPR_7_6[1:0],,DPSw[2:0],,,DNSw[2:0],
+ */
+#define MAX77759_USB_VENDOR_USBSW_CTRL	0x93
+
+#define MAX77759_USB_VENDOR_USBSW_CTRL_SPR_7_6_SHIFT	6
+#define MAX77759_USB_VENDOR_USBSW_CTRL_SPR_7_6_MASK	(0x3 << 6)
+#define MAX77759_USB_VENDOR_USBSW_CTRL_SPR_7_6_CLEAR	(~(0x3 << 6))
+#define MAX77759_USB_VENDOR_USBSW_CTRL_DPSW_SHIFT	3
+#define MAX77759_USB_VENDOR_USBSW_CTRL_DPSW_MASK	(0x7 << 3)
+#define MAX77759_USB_VENDOR_USBSW_CTRL_DPSW_CLEAR	(~(0x7 << 3))
+#define MAX77759_USB_VENDOR_USBSW_CTRL_DNSW_SHIFT	0
+#define MAX77759_USB_VENDOR_USBSW_CTRL_DNSW_MASK	(0x7 << 0)
+#define MAX77759_USB_VENDOR_USBSW_CTRL_DNSW_CLEAR	(~(0x7 << 0))
+
+MAX77759_BFF(usb_vendor_usbsw_ctrl_spr_7_6,7,6)
+MAX77759_BFF(usb_vendor_usbsw_ctrl_dpsw,5,3)
+MAX77759_BFF(usb_vendor_usbsw_ctrl_dnsw,2,0)
+static inline const char *
+max77759_usb_vendor_usbsw_ctrl_cstr(char *buff, size_t len, int val)
+{
+#ifdef SCNPRINTF
+	int i = 0;
+
+	i += SCNPRINTF(&buff[i], len - i, " SPR_7_6=%x",
+		FIELD2VALUE(MAX77759_USB_VENDOR_USBSW_CTRL_SPR_7_6, val));
+	i += SCNPRINTF(&buff[i], len - i, " DPSW=%x",
+		FIELD2VALUE(MAX77759_USB_VENDOR_USBSW_CTRL_DPSW, val));
+	i += SCNPRINTF(&buff[i], len - i, " DNSW=%x",
+		FIELD2VALUE(MAX77759_USB_VENDOR_USBSW_CTRL_DNSW, val));
+#else
+	buff[0] = 0;
+#endif
+	return buff;
+}
+
+/*
+ * VENDOR_SBUSW_CTRL,0x94,0b00000000,0x00
+ * SPR_7_6[1:0],,SBU2Sw[2:0],,,SBU1Sw[2:0],
+ */
+#define MAX77759_USB_VENDOR_SBUSW_CTRL	0x94
+
+#define MAX77759_USB_VENDOR_SBUSW_CTRL_SPR_7_6_SHIFT	6
+#define MAX77759_USB_VENDOR_SBUSW_CTRL_SPR_7_6_MASK	(0x3 << 6)
+#define MAX77759_USB_VENDOR_SBUSW_CTRL_SPR_7_6_CLEAR	(~(0x3 << 6))
+#define MAX77759_USB_VENDOR_SBUSW_CTRL_SBU2SW_SHIFT	3
+#define MAX77759_USB_VENDOR_SBUSW_CTRL_SBU2SW_MASK	(0x7 << 3)
+#define MAX77759_USB_VENDOR_SBUSW_CTRL_SBU2SW_CLEAR	(~(0x7 << 3))
+#define MAX77759_USB_VENDOR_SBUSW_CTRL_SBU1SW_SHIFT	0
+#define MAX77759_USB_VENDOR_SBUSW_CTRL_SBU1SW_MASK	(0x7 << 0)
+#define MAX77759_USB_VENDOR_SBUSW_CTRL_SBU1SW_CLEAR	(~(0x7 << 0))
+
+MAX77759_BFF(usb_vendor_sbusw_ctrl_spr_7_6,7,6)
+MAX77759_BFF(usb_vendor_sbusw_ctrl_sbu2sw,5,3)
+MAX77759_BFF(usb_vendor_sbusw_ctrl_sbu1sw,2,0)
+static inline const char *
+max77759_usb_vendor_sbusw_ctrl_cstr(char *buff, size_t len, int val)
+{
+#ifdef SCNPRINTF
+	int i = 0;
+
+	i += SCNPRINTF(&buff[i], len - i, " SPR_7_6=%x",
+		FIELD2VALUE(MAX77759_USB_VENDOR_SBUSW_CTRL_SPR_7_6, val));
+	i += SCNPRINTF(&buff[i], len - i, " SBU2SW=%x",
+		FIELD2VALUE(MAX77759_USB_VENDOR_SBUSW_CTRL_SBU2SW, val));
+	i += SCNPRINTF(&buff[i], len - i, " SBU1SW=%x",
+		FIELD2VALUE(MAX77759_USB_VENDOR_SBUSW_CTRL_SBU1SW, val));
+#else
+	buff[0] = 0;
+#endif
+	return buff;
+}
+
+/*
+ * VENDOR_SW_CTRL,0x95,0b00000000,0x00
+ * SPR_7_1[6:0],,,,,,
+ */
+#define MAX77759_USB_VENDOR_SW_CTRL	0x95
+
+#endif /* MAX77759_REG_v0p65_121919_H_ */
diff --git a/drivers/soc/qcom/max_m5.h b/drivers/soc/qcom/max_m5.h
new file mode 100644
index 000000000000..02d5b91df307
--- /dev/null
+++ b/drivers/soc/qcom/max_m5.h
@@ -0,0 +1,251 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Copyright 2019 Google, LLC
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#ifndef MAX_M5_H_
+#define MAX_M5_H_
+
+#include "max1720x_battery.h"
+#include "max_m5_reg.h"
+
+#define MAX_M5_I2C_ADDR 0x6C
+
+
+/* change to 1 or 0 to load FG model with default parameters on startup */
+#define MAX_M5_LOAD_MODEL_DISABLED	-1
+#define MAX_M5_LOAD_MODEL_IDLE		0
+#define MAX_M5_LOAD_MODEL_REQUEST	5
+
+#define MAX_M5_FG_MODEL_START		0x80
+#define MAX_M5_FG_MODEL_SIZE		48
+
+#define MAX_M5_UNLOCK_EXTRA_CONFIG	0x60
+#define MAX_M5_UNLOCK_EXTRA_CONFIG_UNLOCK_CODE	0x80
+#define MAX_M5_UNLOCK_EXTRA_CONFIG_LOCK_CODE	0x00
+
+#define MAX_M5_UNLOCK_MODEL_ACCESS	0x62
+#define MAX_M5_MODEL_ACCESS_UNLOCK_CODE	0xc459
+#define MAX_M5_MODEL_ACCESS_LOCK_CODE	0x0000
+#define MAX_M5_MODEL_ACCESS_LOCK_OK	0xFFFF
+
+#define MAX_M5_TCURVE	0xB9
+#define MAX_M5_VFSOC	0xFF
+
+/* model version */
+#define MAX_M5_INVALID_VERSION	-1
+
+
+/** ------------------------------------------------------------------------ */
+
+/*
+ * Custom parameters are updated while the device is runnig.
+ * NOTE: a subset (model_state_save) is saved to permanent storage every "n"
+ * cycles and restored when the model is reloaded (usually on POR).
+ * TODO: handle switching between RC1 and RC2 model types.
+ */
+struct max_m5_custom_parameters {
+	u16 iavg_empty; /* WV */
+	u16 relaxcfg;
+	u16 learncfg;
+	u16 config;
+	u16 config2;
+	u16 fullsocthr;
+	u16 fullcaprep; /* WV */
+	u16 designcap;
+	u16 dpacc;	/* WV */
+	u16 dqacc;	/* WV */
+	u16 fullcapnom;	/* WV */
+	u16 v_empty;
+	u16 qresidual00;	/* WV */
+	u16 qresidual10;	/* WV */
+	u16 qresidual20;	/* WV */
+	u16 qresidual30;	/* WV */
+	u16 rcomp0;	/* WV */
+	u16 tempco;	/* WV */
+	u16 ichgterm;
+	u16 tgain;
+	u16 toff;
+	u16 tcurve; 	/* write to 0x00B9 */
+	u16 misccfg;	/* 0x9d0 for internal current sense, 0x8d0 external */
+
+	u16 atrate;
+	u16 convgcfg;
+	u16 filtercfg; 	/* write to 0x0029 */
+	u16 taskperiod;
+	u16 cgain;
+} __attribute__((packed));
+
+/* this is what is saved and restored to/from GMSR */
+struct model_state_save {
+	u16 rcomp0;
+	u16 tempco;
+	u16 fullcaprep;
+	u16 cycles;
+	u16 fullcapnom;
+	u16 qresidual00;
+	u16 qresidual10;
+	u16 qresidual20;
+	u16 qresidual30;
+	u16 cv_mixcap;
+	u16 halftime;
+	u8 crc;
+} __attribute__((packed));
+
+struct max_m5_data {
+	struct device *dev;
+	struct max17x0x_regmap *regmap;
+	int cap_lsb;	/* b/177099997 */
+
+	/* initial parameters are in device tree they are also learned */
+	struct max_m5_custom_parameters parameters;
+	u16 cycles;
+	u16 cv_mixcap;
+	u16 halftime;
+
+	int custom_model_size;
+	u16 *custom_model;
+	u32 model_version;
+	bool force_reset_model_data;
+
+	/* to/from GMSR */
+	struct model_state_save model_save;
+};
+
+/** ------------------------------------------------------------------------ */
+
+int max_m5_model_read_version(const struct max_m5_data *m5_data);
+int max_m5_model_get_cap_lsb(const struct max_m5_data *m5_data);
+int max_m5_reset_state_data(struct max_m5_data *m5_data);
+int max_m5_needs_reset_model_data(const struct max_m5_data *m5_data);
+
+/*
+ * max_m5 might use the low 8 bits of devname to keep the model version number
+ * - 0 not M5, !=0 M5
+ */
+static inline int max_m5_check_devname(u16 devname)
+{
+	const u16 radix = devname >> 8;
+
+	return radix == 0x62 || radix == 0x63;
+}
+
+/* b/177099997, handle TaskConfig = 351 */
+static inline int max_m5_cap_lsb(const struct max_m5_data *m5_data)
+{
+	return m5_data ? (1 << m5_data->cap_lsb) : 1;
+}
+
+static inline int max_m5_fg_model_version(const struct max_m5_data *m5_data)
+{
+	return m5_data ? m5_data->model_version : MAX_M5_INVALID_VERSION;
+}
+
+/*
+ * 0 reload, != 0 no reload
+ * always reload when the model version is not specified
+ */
+static inline int max_m5_fg_model_check_version(const struct max_m5_data *m5_data)
+{
+	if (!m5_data)
+		return 1;
+	if (m5_data->model_version == MAX_M5_INVALID_VERSION)
+		return 0;
+
+	return max_m5_model_read_version(m5_data) == m5_data->model_version;
+}
+
+/** ------------------------------------------------------------------------ */
+
+int max_m5_regmap_init(struct max17x0x_regmap *regmap,
+		       struct i2c_client *primary);
+
+void *max_m5_init_data(struct device *dev, struct device_node *batt_node,
+		       struct max17x0x_regmap *regmap);
+void max_m5_free_data(void *data);
+
+int max_m5_load_state_data(struct max_m5_data *m5_data);
+int max_m5_save_state_data(struct max_m5_data *m5_data);
+
+/* read state from the gauge */
+int max_m5_model_read_state(struct max_m5_data *m5_data);
+int max_m5_model_check_state(struct max_m5_data *m5_data);
+
+/* load model to gauge */
+int max_m5_load_gauge_model(struct max_m5_data *m5_data);
+
+int max_m5_fixup_outliers(struct max1720x_drift_data *ddata,
+			  struct max_m5_data *m5_data);
+
+ssize_t max_m5_model_state_cstr(char *buf, int max,
+				struct max_m5_data *m5_data);
+int max_m5_model_state_sscan(struct max_m5_data *m5_data, const char *buf,
+			     int max);
+int max_m5_fg_model_sscan(struct max_m5_data *m5_data, const char *buf,
+			  int max);
+int max_m5_fg_model_cstr(char *buf, int max, const struct max_m5_data *m5_data);
+
+/* read saved value */
+ssize_t max_m5_gmsr_state_cstr(char *buf, int max);
+
+/** ------------------------------------------------------------------------ */
+
+/*
+ *
+ */
+#if IS_ENABLED(CONFIG_MAX_M5)
+
+extern int max_m5_read_actual_input_current_ua(struct i2c_client *client,
+					       int *iic);
+extern int max_m5_read_vbypass(struct i2c_client *client,
+					       int *volt);
+
+extern int max_m5_reg_read(struct i2c_client *client, unsigned int reg,
+		    unsigned int *val);
+extern int max_m5_reg_write(struct i2c_client *client, unsigned int reg,
+		     unsigned int val);
+#else
+static inline int
+max_m5_read_actual_input_current_ua(struct i2c_client *client, int *iic)
+{
+	return -ENODEV;
+}
+
+static inline int
+max_m5_read_vbypass(struct i2c_client *client, int *volt)
+{
+	return -ENODEV;
+}
+
+static inline int
+max_m5_reg_read(struct i2c_client *client, unsigned int reg, unsigned int *val)
+{
+	return -ENODEV;
+}
+
+static inline int max_m5_reg_write(struct i2c_client *client, unsigned int reg,
+				   unsigned int val)
+{
+	return -ENODEV;
+}
+
+
+#endif
+
+
+
+/* reach back into max1720x battery */
+void *max1720x_get_model_data(struct i2c_client *client);
+
+
+#endif
diff --git a/drivers/soc/qcom/max_m5_reg.h b/drivers/soc/qcom/max_m5_reg.h
new file mode 100644
index 000000000000..e302dc62f386
--- /dev/null
+++ b/drivers/soc/qcom/max_m5_reg.h
@@ -0,0 +1,1618 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/* machine generated DO NOT MODIFY
+ * source MW_regmap_ds_v0p54_091819.csv
+ * 2019-11-04
+ */
+
+#ifndef MAX_M5_REG_H_
+#define MAX_M5_REG_H_
+
+/* Status,0x0,0b00000010,0x02
+ * Br,Smx,Tmx,Vmx,Bi,Smn,Tmn
+ */
+#define MAX_M5_STATUS	0x0
+#define MAX_M5_STATUS_BR	(0x1 << 15)
+#define MAX_M5_STATUS_SMX	(0x1 << 14)
+#define MAX_M5_STATUS_TMX	(0x1 << 13)
+#define MAX_M5_STATUS_VMX	(0x1 << 12)
+#define MAX_M5_STATUS_BI	(0x1 << 11)
+#define MAX_M5_STATUS_SMN	(0x1 << 10)
+#define MAX_M5_STATUS_TMN	(0x1 << 9)
+#define MAX_M5_STATUS_VMN	(0x1 << 8)
+#define MAX_M5_STATUS_DSOCI	(0x1 << 7)
+#define MAX_M5_STATUS_THMHOT	(0x1 << 6)
+#define MAX_M5_STATUS_SPR_5	(0x1 << 5)
+#define MAX_M5_STATUS_ISYSMX	(0x1 << 4)
+#define MAX_M5_STATUS_BST	(0x1 << 3)
+#define MAX_M5_STATUS_SPR_2	(0x1 << 2)
+#define MAX_M5_STATUS_POR	(0x1 << 1)
+#define MAX_M5_STATUS_IMN	(0x1 << 0)
+
+#define MAX_M5_STATUS_BR_MASK	0x1
+#define MAX_M5_STATUS_BR_SHIFT	15
+#define MAX_M5_STATUS_BR_CLEAR	(~(0x1 << 15))
+#define MAX_M5_STATUS_BR_CLR(v)	((v) & MAX_M5_STATUS_BR_CLEAR)
+#define MAX_M5_STATUS_BR_SET(v) \
+			(MAX_M5_STATUS_BR_CLR(v) | MAX_M5_STATUS_BR)
+#define MAX_M5_STATUS_SMX_MASK	0x1
+#define MAX_M5_STATUS_SMX_SHIFT	14
+#define MAX_M5_STATUS_SMX_CLEAR	(~(0x1 << 14))
+#define MAX_M5_STATUS_SMX_CLR(v)	((v) & MAX_M5_STATUS_SMX_CLEAR)
+#define MAX_M5_STATUS_SMX_SET(v) \
+			(MAX_M5_STATUS_SMX_CLR(v) | MAX_M5_STATUS_SMX)
+#define MAX_M5_STATUS_TMX_MASK	0x1
+#define MAX_M5_STATUS_TMX_SHIFT	13
+#define MAX_M5_STATUS_TMX_CLEAR	(~(0x1 << 13))
+#define MAX_M5_STATUS_TMX_CLR(v)	((v) & MAX_M5_STATUS_TMX_CLEAR)
+#define MAX_M5_STATUS_TMX_SET(v) \
+			(MAX_M5_STATUS_TMX_CLR(v) | MAX_M5_STATUS_TMX)
+#define MAX_M5_STATUS_VMX_MASK	0x1
+#define MAX_M5_STATUS_VMX_SHIFT	12
+#define MAX_M5_STATUS_VMX_CLEAR	(~(0x1 << 12))
+#define MAX_M5_STATUS_VMX_CLR(v)	((v) & MAX_M5_STATUS_VMX_CLEAR)
+#define MAX_M5_STATUS_VMX_SET(v) \
+			(MAX_M5_STATUS_VMX_CLR(v) | MAX_M5_STATUS_VMX)
+#define MAX_M5_STATUS_BI_MASK	0x1
+#define MAX_M5_STATUS_BI_SHIFT	11
+#define MAX_M5_STATUS_BI_CLEAR	(~(0x1 << 11))
+#define MAX_M5_STATUS_BI_CLR(v)	((v) & MAX_M5_STATUS_BI_CLEAR)
+#define MAX_M5_STATUS_BI_SET(v) \
+			(MAX_M5_STATUS_BI_CLR(v) | MAX_M5_STATUS_BI)
+#define MAX_M5_STATUS_SMN_MASK	0x1
+#define MAX_M5_STATUS_SMN_SHIFT	10
+#define MAX_M5_STATUS_SMN_CLEAR	(~(0x1 << 10))
+#define MAX_M5_STATUS_SMN_CLR(v)	((v) & MAX_M5_STATUS_SMN_CLEAR)
+#define MAX_M5_STATUS_SMN_SET(v) \
+			(MAX_M5_STATUS_SMN_CLR(v) | MAX_M5_STATUS_SMN)
+#define MAX_M5_STATUS_TMN_MASK	0x1
+#define MAX_M5_STATUS_TMN_SHIFT	9
+#define MAX_M5_STATUS_TMN_CLEAR	(~(0x1 << 9))
+#define MAX_M5_STATUS_TMN_CLR(v)	((v) & MAX_M5_STATUS_TMN_CLEAR)
+#define MAX_M5_STATUS_TMN_SET(v) \
+			(MAX_M5_STATUS_TMN_CLR(v) | MAX_M5_STATUS_TMN)
+#define MAX_M5_STATUS_VMN_MASK	0x1
+#define MAX_M5_STATUS_VMN_SHIFT	8
+#define MAX_M5_STATUS_VMN_CLEAR	(~(0x1 << 8))
+#define MAX_M5_STATUS_VMN_CLR(v)	((v) & MAX_M5_STATUS_VMN_CLEAR)
+#define MAX_M5_STATUS_VMN_SET(v) \
+			(MAX_M5_STATUS_VMN_CLR(v) | MAX_M5_STATUS_VMN)
+#define MAX_M5_STATUS_DSOCI_MASK	0x1
+#define MAX_M5_STATUS_DSOCI_SHIFT	7
+#define MAX_M5_STATUS_DSOCI_CLEAR	(~(0x1 << 7))
+#define MAX_M5_STATUS_DSOCI_CLR(v)	((v) & MAX_M5_STATUS_DSOCI_CLEAR)
+#define MAX_M5_STATUS_DSOCI_SET(v) \
+			(MAX_M5_STATUS_DSOCI_CLR(v) | MAX_M5_STATUS_DSOCI)
+#define MAX_M5_STATUS_THMHOT_MASK	0x1
+#define MAX_M5_STATUS_THMHOT_SHIFT	6
+#define MAX_M5_STATUS_THMHOT_CLEAR	(~(0x1 << 6))
+#define MAX_M5_STATUS_THMHOT_CLR(v) \
+			((v) & MAX_M5_STATUS_THMHOT_CLEAR)
+#define MAX_M5_STATUS_THMHOT_SET(v) \
+			(MAX_M5_STATUS_THMHOT_CLR(v) | MAX_M5_STATUS_THMHOT)
+#define MAX_M5_STATUS_SPR_5_MASK	0x1
+#define MAX_M5_STATUS_SPR_5_SHIFT	5
+#define MAX_M5_STATUS_SPR_5_CLEAR	(~(0x1 << 5))
+#define MAX_M5_STATUS_SPR_5_CLR(v)	((v) & MAX_M5_STATUS_SPR_5_CLEAR)
+#define MAX_M5_STATUS_SPR_5_SET(v) \
+			(MAX_M5_STATUS_SPR_5_CLR(v) | MAX_M5_STATUS_SPR_5)
+#define MAX_M5_STATUS_ISYSMX_MASK	0x1
+#define MAX_M5_STATUS_ISYSMX_SHIFT	4
+#define MAX_M5_STATUS_ISYSMX_CLEAR	(~(0x1 << 4))
+#define MAX_M5_STATUS_ISYSMX_CLR(v) \
+			((v) & MAX_M5_STATUS_ISYSMX_CLEAR)
+#define MAX_M5_STATUS_ISYSMX_SET(v) \
+			(MAX_M5_STATUS_ISYSMX_CLR(v) | MAX_M5_STATUS_ISYSMX)
+#define MAX_M5_STATUS_BST_MASK	0x1
+#define MAX_M5_STATUS_BST_SHIFT	3
+#define MAX_M5_STATUS_BST_CLEAR	(~(0x1 << 3))
+#define MAX_M5_STATUS_BST_CLR(v)	((v) & MAX_M5_STATUS_BST_CLEAR)
+#define MAX_M5_STATUS_BST_SET(v) \
+			(MAX_M5_STATUS_BST_CLR(v) | MAX_M5_STATUS_BST)
+#define MAX_M5_STATUS_SPR_2_MASK	0x1
+#define MAX_M5_STATUS_SPR_2_SHIFT	2
+#define MAX_M5_STATUS_SPR_2_CLEAR	(~(0x1 << 2))
+#define MAX_M5_STATUS_SPR_2_CLR(v)	((v) & MAX_M5_STATUS_SPR_2_CLEAR)
+#define MAX_M5_STATUS_SPR_2_SET(v) \
+			(MAX_M5_STATUS_SPR_2_CLR(v) | MAX_M5_STATUS_SPR_2)
+#define MAX_M5_STATUS_POR_MASK	0x1
+#define MAX_M5_STATUS_POR_SHIFT	1
+#define MAX_M5_STATUS_POR_CLEAR	(~(0x1 << 1))
+#define MAX_M5_STATUS_POR_CLR(v)	((v) & MAX_M5_STATUS_POR_CLEAR)
+#define MAX_M5_STATUS_POR_SET(v) \
+			(MAX_M5_STATUS_POR_CLR(v) | MAX_M5_STATUS_POR)
+#define MAX_M5_STATUS_IMN_MASK	0x1
+#define MAX_M5_STATUS_IMN_SHIFT	0
+#define MAX_M5_STATUS_IMN_CLEAR	(~(0x1 << 0))
+#define MAX_M5_STATUS_IMN_CLR(v)	((v) & MAX_M5_STATUS_IMN_CLEAR)
+#define MAX_M5_STATUS_IMN_SET(v) \
+			(MAX_M5_STATUS_IMN_CLR(v) | MAX_M5_STATUS_IMN)
+
+/* VAlrtTh,0x1,0b1111111100000000,0xff00
+ * MaxVoltageAlrt[7:0],,,,,,
+ */
+#define MAX_M5_VALRTTH	0x1
+#define MAX_M5_VALRTTH_MAXVOLTAGEALRT	(0xff << 8)
+#define MAX_M5_VALRTTH_MINVOLTAGEALRT	(0xff << 0)
+
+#define MAX_M5_VALRTTH_MAXVOLTAGEALRT_MASK	0xff
+#define MAX_M5_VALRTTH_MAXVOLTAGEALRT_SHIFT	8
+#define MAX_M5_VALRTTH_MAXVOLTAGEALRT_CLEAR	(~(0xff << 8))
+#define MAX_M5_VALRTTH_MAXVOLTAGEALRT_CLR(v) \
+			((v) & MAX_M5_VALRTTH_MAXVOLTAGEALRT_CLEAR)
+#define MAX_M5_VALRTTH_MAXVOLTAGEALRT_SET(v) \
+	(MAX_M5_VALRTTH_MAXVOLTAGEALRT_CLR(v) | MAX_M5_VALRTTH_MAXVOLTAGEALRT)
+#define MAX_M5_VALRTTH_MINVOLTAGEALRT_MASK	0xff
+#define MAX_M5_VALRTTH_MINVOLTAGEALRT_SHIFT	0
+#define MAX_M5_VALRTTH_MINVOLTAGEALRT_CLEAR	(~(0xff << 0))
+#define MAX_M5_VALRTTH_MINVOLTAGEALRT_CLR(v) \
+			((v) & MAX_M5_VALRTTH_MINVOLTAGEALRT_CLEAR)
+#define MAX_M5_VALRTTH_MINVOLTAGEALRT_SET(v) \
+	(MAX_M5_VALRTTH_MINVOLTAGEALRT_CLR(v) | MAX_M5_VALRTTH_MINVOLTAGEALRT)
+
+/* TAlrtTh,0x2,0b111111110000000,0x7f80
+ * MaxTempAlrt[7:0],,,,,,
+ */
+#define MAX_M5_TALRTTH	0x2
+#define MAX_M5_TALRTTH_MAXTEMPALRT	(0xff << 8)
+#define MAX_M5_TALRTTH_MINTEMPALRT	(0xff << 0)
+
+#define MAX_M5_TALRTTH_MAXTEMPALRT_MASK	0xff
+#define MAX_M5_TALRTTH_MAXTEMPALRT_SHIFT	8
+#define MAX_M5_TALRTTH_MAXTEMPALRT_CLEAR	(~(0xff << 8))
+#define MAX_M5_TALRTTH_MAXTEMPALRT_CLR(v) \
+			((v) & MAX_M5_TALRTTH_MAXTEMPALRT_CLEAR)
+#define MAX_M5_TALRTTH_MAXTEMPALRT_SET(v) \
+		(MAX_M5_TALRTTH_MAXTEMPALRT_CLR(v) | MAX_M5_TALRTTH_MAXTEMPALRT)
+#define MAX_M5_TALRTTH_MINTEMPALRT_MASK	0xff
+#define MAX_M5_TALRTTH_MINTEMPALRT_SHIFT	0
+#define MAX_M5_TALRTTH_MINTEMPALRT_CLEAR	(~(0xff << 0))
+#define MAX_M5_TALRTTH_MINTEMPALRT_CLR(v) \
+			((v) & MAX_M5_TALRTTH_MINTEMPALRT_CLEAR)
+#define MAX_M5_TALRTTH_MINTEMPALRT_SET(v) \
+		(MAX_M5_TALRTTH_MINTEMPALRT_CLR(v) | MAX_M5_TALRTTH_MINTEMPALRT)
+
+/* SAlrtTh,0x3,0b1111111100000000,0xff00
+ * MaxSocAlrt[7:0],,,,,,
+ */
+#define MAX_M5_SALRTTH	0x3
+#define MAX_M5_SALRTTH_MAXSOCALRT	(0xff << 8)
+#define MAX_M5_SALRTTH_MINSOCALRT	(0xff << 0)
+
+#define MAX_M5_SALRTTH_MAXSOCALRT_MASK	0xff
+#define MAX_M5_SALRTTH_MAXSOCALRT_SHIFT	8
+#define MAX_M5_SALRTTH_MAXSOCALRT_CLEAR	(~(0xff << 8))
+#define MAX_M5_SALRTTH_MAXSOCALRT_CLR(v) \
+			((v) & MAX_M5_SALRTTH_MAXSOCALRT_CLEAR)
+#define MAX_M5_SALRTTH_MAXSOCALRT_SET(v) \
+		(MAX_M5_SALRTTH_MAXSOCALRT_CLR(v) | MAX_M5_SALRTTH_MAXSOCALRT)
+#define MAX_M5_SALRTTH_MINSOCALRT_MASK	0xff
+#define MAX_M5_SALRTTH_MINSOCALRT_SHIFT	0
+#define MAX_M5_SALRTTH_MINSOCALRT_CLEAR	(~(0xff << 0))
+#define MAX_M5_SALRTTH_MINSOCALRT_CLR(v) \
+			((v) & MAX_M5_SALRTTH_MINSOCALRT_CLEAR)
+#define MAX_M5_SALRTTH_MINSOCALRT_SET(v) \
+		(MAX_M5_SALRTTH_MINSOCALRT_CLR(v) | MAX_M5_SALRTTH_MINSOCALRT)
+
+/* AtRate,0x4,0b00000000,0x00
+ * AtRate[15:8],,,,,,
+ */
+#define MAX_M5_ATRATE	0x4
+
+/* RepCap,0x5,0b10111011100,0x5dc
+ * RepCap[15:8],,,,,,
+ */
+#define MAX_M5_REPCAP	0x5
+
+/* RepSOC,0x6,0b11001000000000,0x3200
+ * RepSOC[15:8],,,,,,
+ */
+#define MAX_M5_REPSOC	0x6
+
+/* Age,0x7,0b110010000000000,0x6400
+ * Age[15:8],,,,,,
+ */
+#define MAX_M5_AGE	0x7
+
+/* Temp,0x8,0b1011000000000,0x1600
+ * TEMP[15:8],,,,,,
+ */
+#define MAX_M5_TEMP	0x8
+
+/* Vcell,0x9,0b1011010000000000,0xb400
+ * VCELL[15:8],,,,,,
+ */
+#define MAX_M5_VCELL	0x9
+
+/* Current,0xA,0b00000000,0x00
+ * Current[15:8],,,,,,
+ */
+#define MAX_M5_CURRENT	0xA
+
+/* AvgCurrent,0xB,0b00000000,0x00
+ * AvgCurrent[15:8],,,,,,
+ */
+#define MAX_M5_AVGCURRENT	0xB
+
+/* QResidual,0xC,0b00000000,0x00
+ * Qresidual[15:8],,,,,,
+ */
+#define MAX_M5_QRESIDUAL	0xC
+
+/* MixSOC,0xD,0b11001000000000,0x3200
+ * MixSOC[15:8],,,,,,
+ */
+#define MAX_M5_MIXSOC	0xD
+
+/* AvSOC,0xE,0b11001000000000,0x3200
+ * AvSOC[15:8],,,,,,
+ */
+#define MAX_M5_AVSOC	0xE
+
+/* MixCap,0xF,0b10111011100,0x5dc
+ * MixCapH[15:8],,,,,,
+ */
+#define MAX_M5_MIXCAP	0xF
+
+/* FullCap,0x10,0b101110111000,0xbb8
+ * FullCAP[15:8],,,,,,
+ */
+#define MAX_M5_FULLCAP	0x10
+
+/* TTE,0x11,0b00000000,0x00
+ * hr[5:0],,,,,,mn[5:4]
+ */
+#define MAX_M5_TTE	0x11
+#define MAX_M5_TTE_HR	(0x3f << 10)
+#define MAX_M5_TTE_MN	(0x3f << 4)
+#define MAX_M5_TTE_SEC	(0xf << 0)
+
+#define MAX_M5_TTE_HR_MASK	0x3f
+#define MAX_M5_TTE_HR_SHIFT	10
+#define MAX_M5_TTE_HR_CLEAR	(~(0x3f << 10))
+#define MAX_M5_TTE_HR_CLR(v)	((v) & MAX_M5_TTE_HR_CLEAR)
+#define MAX_M5_TTE_HR_SET(v)	(MAX_M5_TTE_HR_CLR(v) | MAX_M5_TTE_HR)
+#define MAX_M5_TTE_MN_MASK	0x3f
+#define MAX_M5_TTE_MN_SHIFT	4
+#define MAX_M5_TTE_MN_CLEAR	(~(0x3f << 4))
+#define MAX_M5_TTE_MN_CLR(v)	((v) & MAX_M5_TTE_MN_CLEAR)
+#define MAX_M5_TTE_MN_SET(v)	(MAX_M5_TTE_MN_CLR(v) | MAX_M5_TTE_MN)
+#define MAX_M5_TTE_SEC_MASK	0xf
+#define MAX_M5_TTE_SEC_SHIFT	0
+#define MAX_M5_TTE_SEC_CLEAR	(~(0xf << 0))
+#define MAX_M5_TTE_SEC_CLR(v)	((v) & MAX_M5_TTE_SEC_CLEAR)
+#define MAX_M5_TTE_SEC_SET(v) \
+			(MAX_M5_TTE_SEC_CLR(v) | MAX_M5_TTE_SEC)
+
+/* QRTable00,0x12,0b11110000000000,0x3c00
+ * QRTable00[15:8],,,,,,
+ */
+#define MAX_M5_QRTABLE00	0x12
+
+/* FullSocThr,0x13,0b101000000000000,0x5000
+ * FullSOCThr[15:8],,,,,,
+ */
+#define MAX_M5_FULLSOCTHR	0x13
+
+/* Rslow,0x14,0b1010010000,0x290
+ * RSLOW[15:8],,,,,,
+ */
+#define MAX_M5_RSLOW	0x14
+
+/* RFast,0x15,0b101001000,0x148
+ * RFAST[15:8],,,,,,
+ */
+#define MAX_M5_RFAST	0x15
+
+/* AvgTA,0x16,0b1011000000000,0x1600
+ * AvgTA[15:8],,,,,,
+ */
+#define MAX_M5_AVGTA	0x16
+
+/* Cycles,0x17,0b00000000,0x00
+ * Cycles[15:8],,,,,,
+ */
+#define MAX_M5_CYCLES	0x17
+
+/* DesignCap,0x18,0b101110111000,0xbb8
+ * DesignCap[15:8],,,,,,
+ */
+#define MAX_M5_DESIGNCAP	0x18
+
+/* AvgVCell,0x19,0b1011010000000000,0xb400
+ * AvgVCELL[15:8],,,,,,
+ */
+#define MAX_M5_AVGVCELL	0x19
+
+/* MaxMinTemp,0x1A,0b1000000001111111,0x807f
+ * MaxTemperature[7:0],,,,,,
+ */
+#define MAX_M5_MAXMINTEMP	0x1A
+#define MAX_M5_MAXMINTEMP_MAXTEMPERATURE	(0xff << 8)
+#define MAX_M5_MAXMINTEMP_MINTEMPERATURE	(0xff << 0)
+
+#define MAX_M5_MAXMINTEMP_MAXTEMPERATURE_MASK	0xff
+#define MAX_M5_MAXMINTEMP_MAXTEMPERATURE_SHIFT	8
+#define MAX_M5_MAXMINTEMP_MAXTEMPERATURE_CLEAR	(~(0xff << 8))
+#define MAX_M5_MAXMINTEMP_MAXTEMPERATURE_CLR(v) \
+			((v) & MAX_M5_MAXMINTEMP_MAXTEMPERATURE_CLEAR)
+#define MAX_M5_MAXMINTEMP_MAXTEMPERATURE_SET(v) \
+(MAX_M5_MAXMINTEMP_MAXTEMPERATURE_CLR(v) | MAX_M5_MAXMINTEMP_MAXTEMPERATURE)
+#define MAX_M5_MAXMINTEMP_MINTEMPERATURE_MASK	0xff
+#define MAX_M5_MAXMINTEMP_MINTEMPERATURE_SHIFT	0
+#define MAX_M5_MAXMINTEMP_MINTEMPERATURE_CLEAR	(~(0xff << 0))
+#define MAX_M5_MAXMINTEMP_MINTEMPERATURE_CLR(v) \
+			((v) & MAX_M5_MAXMINTEMP_MINTEMPERATURE_CLEAR)
+#define MAX_M5_MAXMINTEMP_MINTEMPERATURE_SET(v) \
+(MAX_M5_MAXMINTEMP_MINTEMPERATURE_CLR(v) | MAX_M5_MAXMINTEMP_MINTEMPERATURE)
+
+/* MaxMinVolt,0x1B,0b11111111,0xff
+ * MaxVoltage[7:0],,,,,,
+ */
+#define MAX_M5_MAXMINVOLT	0x1B
+#define MAX_M5_MAXMINVOLT_MAXVOLTAGE	(0xff << 8)
+#define MAX_M5_MAXMINVOLT_MINVOLTAGE	(0xff << 0)
+
+#define MAX_M5_MAXMINVOLT_MAXVOLTAGE_MASK	0xff
+#define MAX_M5_MAXMINVOLT_MAXVOLTAGE_SHIFT	8
+#define MAX_M5_MAXMINVOLT_MAXVOLTAGE_CLEAR	(~(0xff << 8))
+#define MAX_M5_MAXMINVOLT_MAXVOLTAGE_CLR(v) \
+			((v) & MAX_M5_MAXMINVOLT_MAXVOLTAGE_CLEAR)
+#define MAX_M5_MAXMINVOLT_MAXVOLTAGE_SET(v) \
+	(MAX_M5_MAXMINVOLT_MAXVOLTAGE_CLR(v) | MAX_M5_MAXMINVOLT_MAXVOLTAGE)
+#define MAX_M5_MAXMINVOLT_MINVOLTAGE_MASK	0xff
+#define MAX_M5_MAXMINVOLT_MINVOLTAGE_SHIFT	0
+#define MAX_M5_MAXMINVOLT_MINVOLTAGE_CLEAR	(~(0xff << 0))
+#define MAX_M5_MAXMINVOLT_MINVOLTAGE_CLR(v) \
+			((v) & MAX_M5_MAXMINVOLT_MINVOLTAGE_CLEAR)
+#define MAX_M5_MAXMINVOLT_MINVOLTAGE_SET(v) \
+	(MAX_M5_MAXMINVOLT_MINVOLTAGE_CLR(v) | MAX_M5_MAXMINVOLT_MINVOLTAGE)
+
+/* MaxMinCurr,0x1C,0b1000000001111111,0x807f
+ * MaxChargeCurrent[7:0],,,,,,
+ */
+#define MAX_M5_MAXMINCURR	0x1C
+#define MAX_M5_MAXMINCURR_MAXCHARGECURRENT	(0xff << 8)
+#define MAX_M5_MAXMINCURR_MAXDISCURRENT	(0xff << 0)
+
+#define MAX_M5_MAXMINCURR_MAXCHARGECURRENT_MASK	0xff
+#define MAX_M5_MAXMINCURR_MAXCHARGECURRENT_SHIFT	8
+#define MAX_M5_MAXMINCURR_MAXCHARGECURRENT_CLEAR	(~(0xff << 8))
+#define MAX_M5_MAXMINCURR_MAXCHARGECURRENT_CLR(v) \
+			((v) & MAX_M5_MAXMINCURR_MAXCHARGECURRENT_CLEAR)
+#define MAX_M5_MAXMINCURR_MAXCHARGECURRENT_SET(v) \
+(MAX_M5_MAXMINCURR_MAXCHARGECURRENT_CLR(v) | MAX_M5_MAXMINCURR_MAXCHARGECURRENT)
+#define MAX_M5_MAXMINCURR_MAXDISCURRENT_MASK	0xff
+#define MAX_M5_MAXMINCURR_MAXDISCURRENT_SHIFT	0
+#define MAX_M5_MAXMINCURR_MAXDISCURRENT_CLEAR	(~(0xff << 0))
+#define MAX_M5_MAXMINCURR_MAXDISCURRENT_CLR(v) \
+			((v) & MAX_M5_MAXMINCURR_MAXDISCURRENT_CLEAR)
+#define MAX_M5_MAXMINCURR_MAXDISCURRENT_SET(v) \
+(MAX_M5_MAXMINCURR_MAXDISCURRENT_CLR(v) | MAX_M5_MAXMINCURR_MAXDISCURRENT)
+
+/* Config,0x1D,0b10001101010000,0x2350
+ * FCFE,Ss,Ts,Vs,FGCC,AINSH,Ten
+ */
+#define MAX_M5_CONFIG	0x1D
+#define MAX_M5_CONFIG_FCFE	(0x1 << 15)
+#define MAX_M5_CONFIG_SS	(0x1 << 14)
+#define MAX_M5_CONFIG_TS	(0x1 << 13)
+#define MAX_M5_CONFIG_VS	(0x1 << 12)
+#define MAX_M5_CONFIG_FGCC	(0x1 << 11)
+#define MAX_M5_CONFIG_AINSH	(0x1 << 10)
+#define MAX_M5_CONFIG_TEN	(0x1 << 9)
+#define MAX_M5_CONFIG_TEX	(0x1 << 8)
+#define MAX_M5_CONFIG_SHDN	(0x1 << 7)
+#define MAX_M5_CONFIG_I2CSH	(0x1 << 6)
+#define MAX_M5_CONFIG_ICFE	(0x1 << 5)
+#define MAX_M5_CONFIG_ETHRM	(0x1 << 4)
+#define MAX_M5_CONFIG_FTHRM	(0x1 << 3)
+#define MAX_M5_CONFIG_AEN	(0x1 << 2)
+#define MAX_M5_CONFIG_BEI	(0x1 << 1)
+#define MAX_M5_CONFIG_BER	(0x1 << 0)
+
+#define MAX_M5_CONFIG_FCFE_MASK	0x1
+#define MAX_M5_CONFIG_FCFE_SHIFT	15
+#define MAX_M5_CONFIG_FCFE_CLEAR	(~(0x1 << 15))
+#define MAX_M5_CONFIG_FCFE_CLR(v)	((v) & MAX_M5_CONFIG_FCFE_CLEAR)
+#define MAX_M5_CONFIG_FCFE_SET(v) \
+			(MAX_M5_CONFIG_FCFE_CLR(v) | MAX_M5_CONFIG_FCFE)
+#define MAX_M5_CONFIG_SS_MASK	0x1
+#define MAX_M5_CONFIG_SS_SHIFT	14
+#define MAX_M5_CONFIG_SS_CLEAR	(~(0x1 << 14))
+#define MAX_M5_CONFIG_SS_CLR(v)	((v) & MAX_M5_CONFIG_SS_CLEAR)
+#define MAX_M5_CONFIG_SS_SET(v) \
+			(MAX_M5_CONFIG_SS_CLR(v) | MAX_M5_CONFIG_SS)
+#define MAX_M5_CONFIG_TS_MASK	0x1
+#define MAX_M5_CONFIG_TS_SHIFT	13
+#define MAX_M5_CONFIG_TS_CLEAR	(~(0x1 << 13))
+#define MAX_M5_CONFIG_TS_CLR(v)	((v) & MAX_M5_CONFIG_TS_CLEAR)
+#define MAX_M5_CONFIG_TS_SET(v) \
+			(MAX_M5_CONFIG_TS_CLR(v) | MAX_M5_CONFIG_TS)
+#define MAX_M5_CONFIG_VS_MASK	0x1
+#define MAX_M5_CONFIG_VS_SHIFT	12
+#define MAX_M5_CONFIG_VS_CLEAR	(~(0x1 << 12))
+#define MAX_M5_CONFIG_VS_CLR(v)	((v) & MAX_M5_CONFIG_VS_CLEAR)
+#define MAX_M5_CONFIG_VS_SET(v) \
+			(MAX_M5_CONFIG_VS_CLR(v) | MAX_M5_CONFIG_VS)
+#define MAX_M5_CONFIG_FGCC_MASK	0x1
+#define MAX_M5_CONFIG_FGCC_SHIFT	11
+#define MAX_M5_CONFIG_FGCC_CLEAR	(~(0x1 << 11))
+#define MAX_M5_CONFIG_FGCC_CLR(v)	((v) & MAX_M5_CONFIG_FGCC_CLEAR)
+#define MAX_M5_CONFIG_FGCC_SET(v) \
+			(MAX_M5_CONFIG_FGCC_CLR(v) | MAX_M5_CONFIG_FGCC)
+#define MAX_M5_CONFIG_AINSH_MASK	0x1
+#define MAX_M5_CONFIG_AINSH_SHIFT	10
+#define MAX_M5_CONFIG_AINSH_CLEAR	(~(0x1 << 10))
+#define MAX_M5_CONFIG_AINSH_CLR(v)	((v) & MAX_M5_CONFIG_AINSH_CLEAR)
+#define MAX_M5_CONFIG_AINSH_SET(v) \
+			(MAX_M5_CONFIG_AINSH_CLR(v) | MAX_M5_CONFIG_AINSH)
+#define MAX_M5_CONFIG_TEN_MASK	0x1
+#define MAX_M5_CONFIG_TEN_SHIFT	9
+#define MAX_M5_CONFIG_TEN_CLEAR	(~(0x1 << 9))
+#define MAX_M5_CONFIG_TEN_CLR(v)	((v) & MAX_M5_CONFIG_TEN_CLEAR)
+#define MAX_M5_CONFIG_TEN_SET(v) \
+			(MAX_M5_CONFIG_TEN_CLR(v) | MAX_M5_CONFIG_TEN)
+#define MAX_M5_CONFIG_TEX_MASK	0x1
+#define MAX_M5_CONFIG_TEX_SHIFT	8
+#define MAX_M5_CONFIG_TEX_CLEAR	(~(0x1 << 8))
+#define MAX_M5_CONFIG_TEX_CLR(v)	((v) & MAX_M5_CONFIG_TEX_CLEAR)
+#define MAX_M5_CONFIG_TEX_SET(v) \
+			(MAX_M5_CONFIG_TEX_CLR(v) | MAX_M5_CONFIG_TEX)
+#define MAX_M5_CONFIG_SHDN_MASK	0x1
+#define MAX_M5_CONFIG_SHDN_SHIFT	7
+#define MAX_M5_CONFIG_SHDN_CLEAR	(~(0x1 << 7))
+#define MAX_M5_CONFIG_SHDN_CLR(v)	((v) & MAX_M5_CONFIG_SHDN_CLEAR)
+#define MAX_M5_CONFIG_SHDN_SET(v) \
+			(MAX_M5_CONFIG_SHDN_CLR(v) | MAX_M5_CONFIG_SHDN)
+#define MAX_M5_CONFIG_I2CSH_MASK	0x1
+#define MAX_M5_CONFIG_I2CSH_SHIFT	6
+#define MAX_M5_CONFIG_I2CSH_CLEAR	(~(0x1 << 6))
+#define MAX_M5_CONFIG_I2CSH_CLR(v)	((v) & MAX_M5_CONFIG_I2CSH_CLEAR)
+#define MAX_M5_CONFIG_I2CSH_SET(v) \
+			(MAX_M5_CONFIG_I2CSH_CLR(v) | MAX_M5_CONFIG_I2CSH)
+#define MAX_M5_CONFIG_ICFE_MASK	0x1
+#define MAX_M5_CONFIG_ICFE_SHIFT	5
+#define MAX_M5_CONFIG_ICFE_CLEAR	(~(0x1 << 5))
+#define MAX_M5_CONFIG_ICFE_CLR(v)	((v) & MAX_M5_CONFIG_ICFE_CLEAR)
+#define MAX_M5_CONFIG_ICFE_SET(v) \
+			(MAX_M5_CONFIG_ICFE_CLR(v) | MAX_M5_CONFIG_ICFE)
+#define MAX_M5_CONFIG_ETHRM_MASK	0x1
+#define MAX_M5_CONFIG_ETHRM_SHIFT	4
+#define MAX_M5_CONFIG_ETHRM_CLEAR	(~(0x1 << 4))
+#define MAX_M5_CONFIG_ETHRM_CLR(v)	((v) & MAX_M5_CONFIG_ETHRM_CLEAR)
+#define MAX_M5_CONFIG_ETHRM_SET(v) \
+			(MAX_M5_CONFIG_ETHRM_CLR(v) | MAX_M5_CONFIG_ETHRM)
+#define MAX_M5_CONFIG_FTHRM_MASK	0x1
+#define MAX_M5_CONFIG_FTHRM_SHIFT	3
+#define MAX_M5_CONFIG_FTHRM_CLEAR	(~(0x1 << 3))
+#define MAX_M5_CONFIG_FTHRM_CLR(v)	((v) & MAX_M5_CONFIG_FTHRM_CLEAR)
+#define MAX_M5_CONFIG_FTHRM_SET(v) \
+			(MAX_M5_CONFIG_FTHRM_CLR(v) | MAX_M5_CONFIG_FTHRM)
+#define MAX_M5_CONFIG_AEN_MASK	0x1
+#define MAX_M5_CONFIG_AEN_SHIFT	2
+#define MAX_M5_CONFIG_AEN_CLEAR	(~(0x1 << 2))
+#define MAX_M5_CONFIG_AEN_CLR(v)	((v) & MAX_M5_CONFIG_AEN_CLEAR)
+#define MAX_M5_CONFIG_AEN_SET(v) \
+			(MAX_M5_CONFIG_AEN_CLR(v) | MAX_M5_CONFIG_AEN)
+#define MAX_M5_CONFIG_BEI_MASK	0x1
+#define MAX_M5_CONFIG_BEI_SHIFT	1
+#define MAX_M5_CONFIG_BEI_CLEAR	(~(0x1 << 1))
+#define MAX_M5_CONFIG_BEI_CLR(v)	((v) & MAX_M5_CONFIG_BEI_CLEAR)
+#define MAX_M5_CONFIG_BEI_SET(v) \
+			(MAX_M5_CONFIG_BEI_CLR(v) | MAX_M5_CONFIG_BEI)
+#define MAX_M5_CONFIG_BER_MASK	0x1
+#define MAX_M5_CONFIG_BER_SHIFT	0
+#define MAX_M5_CONFIG_BER_CLEAR	(~(0x1 << 0))
+#define MAX_M5_CONFIG_BER_CLR(v)	((v) & MAX_M5_CONFIG_BER_CLEAR)
+#define MAX_M5_CONFIG_BER_SET(v) \
+			(MAX_M5_CONFIG_BER_CLR(v) | MAX_M5_CONFIG_BER)
+
+/* IChgTerm,0x1E,0b1111000000,0x3c0
+ * ICHGTerm[15:8],,,,,,
+ */
+#define MAX_M5_ICHGTERM	0x1E
+
+/* AvCap,0x1F,0b10111011100,0x5dc
+ * AvCap[15:8],,,,,,
+ */
+#define MAX_M5_AVCAP	0x1F
+
+/* TTF,0x20,0b1111111111111111,0xffff
+ * hr[5:0],,,,,,mn[5:4]
+ */
+#define MAX_M5_TTF	0x20
+#define MAX_M5_TTF_HR	(0x3f << 10)
+#define MAX_M5_TTF_MN	(0x3f << 4)
+#define MAX_M5_TTF_SEC	(0xf << 0)
+
+#define MAX_M5_TTF_HR_MASK	0x3f
+#define MAX_M5_TTF_HR_SHIFT	10
+#define MAX_M5_TTF_HR_CLEAR	(~(0x3f << 10))
+#define MAX_M5_TTF_HR_CLR(v)	((v) & MAX_M5_TTF_HR_CLEAR)
+#define MAX_M5_TTF_HR_SET(v)	(MAX_M5_TTF_HR_CLR(v) | MAX_M5_TTF_HR)
+#define MAX_M5_TTF_MN_MASK	0x3f
+#define MAX_M5_TTF_MN_SHIFT	4
+#define MAX_M5_TTF_MN_CLEAR	(~(0x3f << 4))
+#define MAX_M5_TTF_MN_CLR(v)	((v) & MAX_M5_TTF_MN_CLEAR)
+#define MAX_M5_TTF_MN_SET(v)	(MAX_M5_TTF_MN_CLR(v) | MAX_M5_TTF_MN)
+#define MAX_M5_TTF_SEC_MASK	0xf
+#define MAX_M5_TTF_SEC_SHIFT	0
+#define MAX_M5_TTF_SEC_CLEAR	(~(0xf << 0))
+#define MAX_M5_TTF_SEC_CLR(v)	((v) & MAX_M5_TTF_SEC_CLEAR)
+#define MAX_M5_TTF_SEC_SET(v) \
+			(MAX_M5_TTF_SEC_CLR(v) | MAX_M5_TTF_SEC)
+
+/* DevName,0x21,0b110001000000000,0x6200
+ * DevName[15:8],,,,,,
+ */
+#define MAX_M5_DEVNAME	0x21
+
+/* QRTable10,0x22,0b1101110000000,0x1b80
+ * QRTable10[15:8],,,,,,
+ */
+#define MAX_M5_QRTABLE10	0x22
+
+/* FullCapNom,0x23,0b101110111000,0xbb8
+ * FullCapNom[15:8],,,,,,
+ */
+#define MAX_M5_FULLCAPNOM	0x23
+
+/* TempNom,0x24,0b1010000000000,0x1400
+ * TempNom[9:2],,,,,,
+ */
+#define MAX_M5_TEMPNOM	0x24
+#define MAX_M5_TEMPNOM_TEMPNOM	(0x3ff << 6)
+#define MAX_M5_TEMPNOM_SPR_5_0	(0x3f << 0)
+
+#define MAX_M5_TEMPNOM_TEMPNOM_MASK	0x3ff
+#define MAX_M5_TEMPNOM_TEMPNOM_SHIFT	6
+#define MAX_M5_TEMPNOM_TEMPNOM_CLEAR	(~(0x3ff << 6))
+#define MAX_M5_TEMPNOM_TEMPNOM_CLR(v) \
+			((v) & MAX_M5_TEMPNOM_TEMPNOM_CLEAR)
+#define MAX_M5_TEMPNOM_TEMPNOM_SET(v) \
+			(MAX_M5_TEMPNOM_TEMPNOM_CLR(v) | MAX_M5_TEMPNOM_TEMPNOM)
+#define MAX_M5_TEMPNOM_SPR_5_0_MASK	0x3f
+#define MAX_M5_TEMPNOM_SPR_5_0_SHIFT	0
+#define MAX_M5_TEMPNOM_SPR_5_0_CLEAR	(~(0x3f << 0))
+#define MAX_M5_TEMPNOM_SPR_5_0_CLR(v) \
+			((v) & MAX_M5_TEMPNOM_SPR_5_0_CLEAR)
+#define MAX_M5_TEMPNOM_SPR_5_0_SET(v) \
+			(MAX_M5_TEMPNOM_SPR_5_0_CLR(v) | MAX_M5_TEMPNOM_SPR_5_0)
+
+/* TempLim,0x25,0b10001100000101,0x2305
+ * TempHot[7:0],,,,,,
+ */
+#define MAX_M5_TEMPLIM	0x25
+#define MAX_M5_TEMPLIM_TEMPHOT	(0xff << 8)
+#define MAX_M5_TEMPLIM_TEMPCOLD	(0xff << 0)
+
+#define MAX_M5_TEMPLIM_TEMPHOT_MASK	0xff
+#define MAX_M5_TEMPLIM_TEMPHOT_SHIFT	8
+#define MAX_M5_TEMPLIM_TEMPHOT_CLEAR	(~(0xff << 8))
+#define MAX_M5_TEMPLIM_TEMPHOT_CLR(v) \
+			((v) & MAX_M5_TEMPLIM_TEMPHOT_CLEAR)
+#define MAX_M5_TEMPLIM_TEMPHOT_SET(v) \
+			(MAX_M5_TEMPLIM_TEMPHOT_CLR(v) | MAX_M5_TEMPLIM_TEMPHOT)
+#define MAX_M5_TEMPLIM_TEMPCOLD_MASK	0xff
+#define MAX_M5_TEMPLIM_TEMPCOLD_SHIFT	0
+#define MAX_M5_TEMPLIM_TEMPCOLD_CLEAR	(~(0xff << 0))
+#define MAX_M5_TEMPLIM_TEMPCOLD_CLR(v) \
+			((v) & MAX_M5_TEMPLIM_TEMPCOLD_CLEAR)
+#define MAX_M5_TEMPLIM_TEMPCOLD_SET(v) \
+		(MAX_M5_TEMPLIM_TEMPCOLD_CLR(v) | MAX_M5_TEMPLIM_TEMPCOLD)
+
+/* AvgTA0,0x26,0b1011000000000,0x1600
+ * AvgTA0[15:8],,,,,,
+ */
+#define MAX_M5_AVGTA0	0x26
+
+/* AIN0,0x27,0b1000100011010000,0x88d0
+ * AIN0[15:8],,,,,,
+ */
+#define MAX_M5_AIN0	0x27
+
+/* LearnCfg,0x28,0b10011000000011,0x2603
+ * LearnRCOMP[2:0],,,LearnTCO[2:0],,,FCLm[1:0]
+ */
+#define MAX_M5_LEARNCFG	0x28
+#define MAX_M5_LEARNCFG_LEARNRCOMP	(0x7 << 13)
+#define MAX_M5_LEARNCFG_LEARNTCO	(0x7 << 10)
+#define MAX_M5_LEARNCFG_FCLM	(0x3 << 8)
+#define MAX_M5_LEARNCFG_FCX	(0x1 << 7)
+#define MAX_M5_LEARNCFG_FCLRNSTAGE	(0x7 << 4)
+#define MAX_M5_LEARNCFG_SPR_3	(0x1 << 3)
+#define MAX_M5_LEARNCFG_FILLEMPTY	(0x1 << 2)
+#define MAX_M5_LEARNCFG_MIXEN	(0x1 << 1)
+#define MAX_M5_LEARNCFG_SPR_0	(0x1 << 0)
+
+#define MAX_M5_LEARNCFG_LEARNRCOMP_MASK	0x7
+#define MAX_M5_LEARNCFG_LEARNRCOMP_SHIFT	13
+#define MAX_M5_LEARNCFG_LEARNRCOMP_CLEAR	(~(0x7 << 13))
+#define MAX_M5_LEARNCFG_LEARNRCOMP_CLR(v) \
+			((v) & MAX_M5_LEARNCFG_LEARNRCOMP_CLEAR)
+#define MAX_M5_LEARNCFG_LEARNRCOMP_SET(v) \
+		(MAX_M5_LEARNCFG_LEARNRCOMP_CLR(v) | MAX_M5_LEARNCFG_LEARNRCOMP)
+#define MAX_M5_LEARNCFG_LEARNTCO_MASK	0x7
+#define MAX_M5_LEARNCFG_LEARNTCO_SHIFT	10
+#define MAX_M5_LEARNCFG_LEARNTCO_CLEAR	(~(0x7 << 10))
+#define MAX_M5_LEARNCFG_LEARNTCO_CLR(v) \
+			((v) & MAX_M5_LEARNCFG_LEARNTCO_CLEAR)
+#define MAX_M5_LEARNCFG_LEARNTCO_SET(v) \
+		(MAX_M5_LEARNCFG_LEARNTCO_CLR(v) | MAX_M5_LEARNCFG_LEARNTCO)
+#define MAX_M5_LEARNCFG_FCLM_MASK	0x3
+#define MAX_M5_LEARNCFG_FCLM_SHIFT	8
+#define MAX_M5_LEARNCFG_FCLM_CLEAR	(~(0x3 << 8))
+#define MAX_M5_LEARNCFG_FCLM_CLR(v) \
+			((v) & MAX_M5_LEARNCFG_FCLM_CLEAR)
+#define MAX_M5_LEARNCFG_FCLM_SET(v) \
+			(MAX_M5_LEARNCFG_FCLM_CLR(v) | MAX_M5_LEARNCFG_FCLM)
+#define MAX_M5_LEARNCFG_FCX_MASK	0x1
+#define MAX_M5_LEARNCFG_FCX_SHIFT	7
+#define MAX_M5_LEARNCFG_FCX_CLEAR	(~(0x1 << 7))
+#define MAX_M5_LEARNCFG_FCX_CLR(v)	((v) & MAX_M5_LEARNCFG_FCX_CLEAR)
+#define MAX_M5_LEARNCFG_FCX_SET(v) \
+			(MAX_M5_LEARNCFG_FCX_CLR(v) | MAX_M5_LEARNCFG_FCX)
+#define MAX_M5_LEARNCFG_FCLRNSTAGE_MASK	0x7
+#define MAX_M5_LEARNCFG_FCLRNSTAGE_SHIFT	4
+#define MAX_M5_LEARNCFG_FCLRNSTAGE_CLEAR	(~(0x7 << 4))
+#define MAX_M5_LEARNCFG_FCLRNSTAGE_CLR(v) \
+			((v) & MAX_M5_LEARNCFG_FCLRNSTAGE_CLEAR)
+#define MAX_M5_LEARNCFG_FCLRNSTAGE_SET(v) \
+		(MAX_M5_LEARNCFG_FCLRNSTAGE_CLR(v) | MAX_M5_LEARNCFG_FCLRNSTAGE)
+#define MAX_M5_LEARNCFG_SPR_3_MASK	0x1
+#define MAX_M5_LEARNCFG_SPR_3_SHIFT	3
+#define MAX_M5_LEARNCFG_SPR_3_CLEAR	(~(0x1 << 3))
+#define MAX_M5_LEARNCFG_SPR_3_CLR(v) \
+			((v) & MAX_M5_LEARNCFG_SPR_3_CLEAR)
+#define MAX_M5_LEARNCFG_SPR_3_SET(v) \
+			(MAX_M5_LEARNCFG_SPR_3_CLR(v) | MAX_M5_LEARNCFG_SPR_3)
+#define MAX_M5_LEARNCFG_FILLEMPTY_MASK	0x1
+#define MAX_M5_LEARNCFG_FILLEMPTY_SHIFT	2
+#define MAX_M5_LEARNCFG_FILLEMPTY_CLEAR	(~(0x1 << 2))
+#define MAX_M5_LEARNCFG_FILLEMPTY_CLR(v) \
+			((v) & MAX_M5_LEARNCFG_FILLEMPTY_CLEAR)
+#define MAX_M5_LEARNCFG_FILLEMPTY_SET(v) \
+		(MAX_M5_LEARNCFG_FILLEMPTY_CLR(v) | MAX_M5_LEARNCFG_FILLEMPTY)
+#define MAX_M5_LEARNCFG_MIXEN_MASK	0x1
+#define MAX_M5_LEARNCFG_MIXEN_SHIFT	1
+#define MAX_M5_LEARNCFG_MIXEN_CLEAR	(~(0x1 << 1))
+#define MAX_M5_LEARNCFG_MIXEN_CLR(v) \
+			((v) & MAX_M5_LEARNCFG_MIXEN_CLEAR)
+#define MAX_M5_LEARNCFG_MIXEN_SET(v) \
+			(MAX_M5_LEARNCFG_MIXEN_CLR(v) | MAX_M5_LEARNCFG_MIXEN)
+#define MAX_M5_LEARNCFG_SPR_0_MASK	0x1
+#define MAX_M5_LEARNCFG_SPR_0_SHIFT	0
+#define MAX_M5_LEARNCFG_SPR_0_CLEAR	(~(0x1 << 0))
+#define MAX_M5_LEARNCFG_SPR_0_CLR(v) \
+			((v) & MAX_M5_LEARNCFG_SPR_0_CLEAR)
+#define MAX_M5_LEARNCFG_SPR_0_SET(v) \
+			(MAX_M5_LEARNCFG_SPR_0_CLR(v) | MAX_M5_LEARNCFG_SPR_0)
+
+/* RC is customizable in MWA1+, not in datasheet */
+#define MAX_M5_LEARNCFG_RC_VER_MASK   MAX_M5_LEARNCFG_SPR_3_MASK
+#define MAX_M5_LEARNCFG_RC_VER_SHIFT  MAX_M5_LEARNCFG_SPR_3_SHIFT
+#define MAX_M5_LEARNCFG_RC_VER_CLEAR  MAX_M5_LEARNCFG_SPR_3_CLEAR
+#define MAX_M5_LEARNCFG_RC_VER_CLR(v) MAX_M5_LEARNCFG_SPR_3_CLR(v)
+#define MAX_M5_LEARNCFG_RC_VER_SET(v) MAX_M5_LEARNCFG_SPR_3_SET(v)
+
+#define MAX_M5_LEARNCFG_RC_VER        MAX_M5_LEARNCFG_SPR_3
+#define MAX_M5_LEARNCFG_RC1           (0x0 << MAX_M5_LEARNCFG_RC_VER_SHIFT)
+#define MAX_M5_LEARNCFG_RC2           (0x1 << MAX_M5_LEARNCFG_RC_VER_SHIFT)
+
+/* FilterCfg,0x29,0b1100111010100100,0xcea4
+ * NEMPTY[1:0],,NTEMP[2:0],,,NMIX[3:1],
+ */
+#define MAX_M5_FILTERCFG	0x29
+#define MAX_M5_FILTERCFG_NEMPTY	(0x3 << 14)
+#define MAX_M5_FILTERCFG_NTEMP	(0x7 << 11)
+#define MAX_M5_FILTERCFG_NMIX	(0x7 << 8)
+#define MAX_M5_FILTERCFG_NAVGCELL	(0x7 << 5)
+#define MAX_M5_FILTERCFG_NCURR	(0xf << 1)
+
+#define MAX_M5_FILTERCFG_NEMPTY_MASK	0x3
+#define MAX_M5_FILTERCFG_NEMPTY_SHIFT	14
+#define MAX_M5_FILTERCFG_NEMPTY_CLEAR	(~(0x3 << 14))
+#define MAX_M5_FILTERCFG_NEMPTY_CLR(v) \
+			((v) & MAX_M5_FILTERCFG_NEMPTY_CLEAR)
+#define MAX_M5_FILTERCFG_NEMPTY_SET(v) \
+		(MAX_M5_FILTERCFG_NEMPTY_CLR(v) | MAX_M5_FILTERCFG_NEMPTY)
+#define MAX_M5_FILTERCFG_NTEMP_MASK	0x7
+#define MAX_M5_FILTERCFG_NTEMP_SHIFT	11
+#define MAX_M5_FILTERCFG_NTEMP_CLEAR	(~(0x7 << 11))
+#define MAX_M5_FILTERCFG_NTEMP_CLR(v) \
+			((v) & MAX_M5_FILTERCFG_NTEMP_CLEAR)
+#define MAX_M5_FILTERCFG_NTEMP_SET(v) \
+			(MAX_M5_FILTERCFG_NTEMP_CLR(v) | MAX_M5_FILTERCFG_NTEMP)
+#define MAX_M5_FILTERCFG_NMIX_MASK	0x7
+#define MAX_M5_FILTERCFG_NMIX_SHIFT	8
+#define MAX_M5_FILTERCFG_NMIX_CLEAR	(~(0x7 << 8))
+#define MAX_M5_FILTERCFG_NMIX_CLR(v) \
+			((v) & MAX_M5_FILTERCFG_NMIX_CLEAR)
+#define MAX_M5_FILTERCFG_NMIX_SET(v) \
+			(MAX_M5_FILTERCFG_NMIX_CLR(v) | MAX_M5_FILTERCFG_NMIX)
+#define MAX_M5_FILTERCFG_NAVGCELL_MASK	0x7
+#define MAX_M5_FILTERCFG_NAVGCELL_SHIFT	5
+#define MAX_M5_FILTERCFG_NAVGCELL_CLEAR	(~(0x7 << 5))
+#define MAX_M5_FILTERCFG_NAVGCELL_CLR(v) \
+			((v) & MAX_M5_FILTERCFG_NAVGCELL_CLEAR)
+#define MAX_M5_FILTERCFG_NAVGCELL_SET(v) \
+		(MAX_M5_FILTERCFG_NAVGCELL_CLR(v) | MAX_M5_FILTERCFG_NAVGCELL)
+#define MAX_M5_FILTERCFG_NCURR_MASK	0xf
+#define MAX_M5_FILTERCFG_NCURR_SHIFT	1
+#define MAX_M5_FILTERCFG_NCURR_CLEAR	(~(0xf << 1))
+#define MAX_M5_FILTERCFG_NCURR_CLR(v) \
+			((v) & MAX_M5_FILTERCFG_NCURR_CLEAR)
+#define MAX_M5_FILTERCFG_NCURR_SET(v) \
+			(MAX_M5_FILTERCFG_NCURR_CLR(v) | MAX_M5_FILTERCFG_NCURR)
+
+/* RelaxCfg,0x2A,0b10000011001001,0x20c9
+ * LoadThr[6:0],,,,,,
+ */
+#define MAX_M5_RELAXCFG	0x2A
+#define MAX_M5_RELAXCFG_LOADTHR	(0x7f << 9)
+#define MAX_M5_RELAXCFG_DVTHR	(0xf << 4)
+#define MAX_M5_RELAXCFG_DTTHR	(0xf << 0)
+
+#define MAX_M5_RELAXCFG_LOADTHR_MASK	0x7f
+#define MAX_M5_RELAXCFG_LOADTHR_SHIFT	9
+#define MAX_M5_RELAXCFG_LOADTHR_CLEAR	(~(0x7f << 9))
+#define MAX_M5_RELAXCFG_LOADTHR_CLR(v) \
+			((v) & MAX_M5_RELAXCFG_LOADTHR_CLEAR)
+#define MAX_M5_RELAXCFG_LOADTHR_SET(v) \
+		(MAX_M5_RELAXCFG_LOADTHR_CLR(v) | MAX_M5_RELAXCFG_LOADTHR)
+#define MAX_M5_RELAXCFG_DVTHR_MASK	0xf
+#define MAX_M5_RELAXCFG_DVTHR_SHIFT	4
+#define MAX_M5_RELAXCFG_DVTHR_CLEAR	(~(0xf << 4))
+#define MAX_M5_RELAXCFG_DVTHR_CLR(v) \
+			((v) & MAX_M5_RELAXCFG_DVTHR_CLEAR)
+#define MAX_M5_RELAXCFG_DVTHR_SET(v) \
+			(MAX_M5_RELAXCFG_DVTHR_CLR(v) | MAX_M5_RELAXCFG_DVTHR)
+#define MAX_M5_RELAXCFG_DTTHR_MASK	0xf
+#define MAX_M5_RELAXCFG_DTTHR_SHIFT	0
+#define MAX_M5_RELAXCFG_DTTHR_CLEAR	(~(0xf << 0))
+#define MAX_M5_RELAXCFG_DTTHR_CLR(v) \
+			((v) & MAX_M5_RELAXCFG_DTTHR_CLEAR)
+#define MAX_M5_RELAXCFG_DTTHR_SET(v) \
+			(MAX_M5_RELAXCFG_DTTHR_CLR(v) | MAX_M5_RELAXCFG_DTTHR)
+
+/* MiscCfg,0x2B,0b100111010000,0x9d0
+ * OopsFilter[3:0],,,,EnBi1,InitVFG,MixRate[4:3]
+ */
+#define MAX_M5_MISCCFG	0x2B
+#define MAX_M5_MISCCFG_OOPSFILTER	(0xf << 12)
+#define MAX_M5_MISCCFG_ENBI1	(0x1 << 11)
+#define MAX_M5_MISCCFG_INITVFG	(0x1 << 10)
+#define MAX_M5_MISCCFG_MIXRATE	(0x1f << 5)
+#define MAX_M5_MISCCFG_RDFCLRN	(0x1 << 4)
+#define MAX_M5_MISCCFG_VTTL	(0x1 << 3)
+#define MAX_M5_MISCCFG_VEX	(0x1 << 2)
+#define MAX_M5_MISCCFG_SACFG	(0x3 << 0)
+
+#define MAX_M5_MISCCFG_OOPSFILTER_MASK	0xf
+#define MAX_M5_MISCCFG_OOPSFILTER_SHIFT	12
+#define MAX_M5_MISCCFG_OOPSFILTER_CLEAR	(~(0xf << 12))
+#define MAX_M5_MISCCFG_OOPSFILTER_CLR(v) \
+			((v) & MAX_M5_MISCCFG_OOPSFILTER_CLEAR)
+#define MAX_M5_MISCCFG_OOPSFILTER_SET(v) \
+		(MAX_M5_MISCCFG_OOPSFILTER_CLR(v) | MAX_M5_MISCCFG_OOPSFILTER)
+#define MAX_M5_MISCCFG_ENBI1_MASK	0x1
+#define MAX_M5_MISCCFG_ENBI1_SHIFT	11
+#define MAX_M5_MISCCFG_ENBI1_CLEAR	(~(0x1 << 11))
+#define MAX_M5_MISCCFG_ENBI1_CLR(v) \
+			((v) & MAX_M5_MISCCFG_ENBI1_CLEAR)
+#define MAX_M5_MISCCFG_ENBI1_SET(v) \
+			(MAX_M5_MISCCFG_ENBI1_CLR(v) | MAX_M5_MISCCFG_ENBI1)
+#define MAX_M5_MISCCFG_INITVFG_MASK	0x1
+#define MAX_M5_MISCCFG_INITVFG_SHIFT	10
+#define MAX_M5_MISCCFG_INITVFG_CLEAR	(~(0x1 << 10))
+#define MAX_M5_MISCCFG_INITVFG_CLR(v) \
+			((v) & MAX_M5_MISCCFG_INITVFG_CLEAR)
+#define MAX_M5_MISCCFG_INITVFG_SET(v) \
+			(MAX_M5_MISCCFG_INITVFG_CLR(v) | MAX_M5_MISCCFG_INITVFG)
+#define MAX_M5_MISCCFG_MIXRATE_MASK	0x1f
+#define MAX_M5_MISCCFG_MIXRATE_SHIFT	5
+#define MAX_M5_MISCCFG_MIXRATE_CLEAR	(~(0x1f << 5))
+#define MAX_M5_MISCCFG_MIXRATE_CLR(v) \
+			((v) & MAX_M5_MISCCFG_MIXRATE_CLEAR)
+#define MAX_M5_MISCCFG_MIXRATE_SET(v) \
+			(MAX_M5_MISCCFG_MIXRATE_CLR(v) | MAX_M5_MISCCFG_MIXRATE)
+#define MAX_M5_MISCCFG_RDFCLRN_MASK	0x1
+#define MAX_M5_MISCCFG_RDFCLRN_SHIFT	4
+#define MAX_M5_MISCCFG_RDFCLRN_CLEAR	(~(0x1 << 4))
+#define MAX_M5_MISCCFG_RDFCLRN_CLR(v) \
+			((v) & MAX_M5_MISCCFG_RDFCLRN_CLEAR)
+#define MAX_M5_MISCCFG_RDFCLRN_SET(v) \
+			(MAX_M5_MISCCFG_RDFCLRN_CLR(v) | MAX_M5_MISCCFG_RDFCLRN)
+#define MAX_M5_MISCCFG_VTTL_MASK	0x1
+#define MAX_M5_MISCCFG_VTTL_SHIFT	3
+#define MAX_M5_MISCCFG_VTTL_CLEAR	(~(0x1 << 3))
+#define MAX_M5_MISCCFG_VTTL_CLR(v)	((v) & MAX_M5_MISCCFG_VTTL_CLEAR)
+#define MAX_M5_MISCCFG_VTTL_SET(v) \
+			(MAX_M5_MISCCFG_VTTL_CLR(v) | MAX_M5_MISCCFG_VTTL)
+#define MAX_M5_MISCCFG_VEX_MASK	0x1
+#define MAX_M5_MISCCFG_VEX_SHIFT	2
+#define MAX_M5_MISCCFG_VEX_CLEAR	(~(0x1 << 2))
+#define MAX_M5_MISCCFG_VEX_CLR(v)	((v) & MAX_M5_MISCCFG_VEX_CLEAR)
+#define MAX_M5_MISCCFG_VEX_SET(v) \
+			(MAX_M5_MISCCFG_VEX_CLR(v) | MAX_M5_MISCCFG_VEX)
+#define MAX_M5_MISCCFG_SACFG_MASK	0x3
+#define MAX_M5_MISCCFG_SACFG_SHIFT	0
+#define MAX_M5_MISCCFG_SACFG_CLEAR	(~(0x3 << 0))
+#define MAX_M5_MISCCFG_SACFG_CLR(v) \
+			((v) & MAX_M5_MISCCFG_SACFG_CLEAR)
+#define MAX_M5_MISCCFG_SACFG_SET(v) \
+			(MAX_M5_MISCCFG_SACFG_CLR(v) | MAX_M5_MISCCFG_SACFG)
+
+/* TGain,0x2C,0b1110101110001101,0xeb8d
+ * TGAIN[15:8],,,,,,
+ */
+#define MAX_M5_TGAIN	0x2C
+
+/* TOff,0x2D,0b10000010101010,0x20aa
+ * TOFF[15:8],,,,,,
+ */
+#define MAX_M5_TOFF	0x2D
+
+/* CGain,0x2E,0b10000000000,0x400
+ * CGAIN[15:8],,,,,,
+ */
+#define MAX_M5_CGAIN	0x2E
+
+/* COff,0x2F,0b00000000,0x00
+ * COFF[15:8],,,,,,
+ */
+#define MAX_M5_COFF	0x2F
+
+/* dV_acc,0x30,0b10000000000,0x400
+ * dV_acc[15:8],,,,,,
+ */
+#define MAX_M5_DV_ACC	0x30
+
+/* dI_acc,0x31,0b11001000000,0x640
+ * dI_acc[15:8],,,,,,
+ */
+#define MAX_M5_DI_ACC	0x31
+
+/* QRTable20,0x32,0b101100000100,0xb04
+ * QRTable20[15:8],,,,,,
+ */
+#define MAX_M5_QRTABLE20	0x32
+
+/* AtTTF,0x33,0b1111111111111111,0xffff
+ * AtTTF[15:8],,,,,,
+ */
+#define MAX_M5_ATTTF	0x33
+
+/* TConvert,0x34,0b1011000000000,0x1600
+ * TConvert[15:8],,,,,,
+ */
+#define MAX_M5_TCONVERT	0x34
+
+/* FullCapRep,0x35,0b101110111000,0xbb8
+ * FullCapRep[15:8],,,,,,
+ */
+#define MAX_M5_FULLCAPREP	0x35
+
+/* IAvgEmpty,0x36,0b1111010001001000,0xf448
+ * Iavg_empty[15:8],,,,,,
+ */
+#define MAX_M5_IAVGEMPTY	0x36
+
+/* FCTC,0x37,0b10111100000,0x5e0
+ * FCTC[15:8],,,,,,
+ */
+#define MAX_M5_FCTC	0x37
+
+/* RComp0,0x38,0b01110000,0x70
+ * SPR_15_8[7:0],,,,,,
+ */
+#define MAX_M5_RCOMP0	0x38
+#define MAX_M5_RCOMP0_SPR_15_8	(0xff << 8)
+#define MAX_M5_RCOMP0_RCOMP0	(0xff << 0)
+
+#define MAX_M5_RCOMP0_SPR_15_8_MASK	0xff
+#define MAX_M5_RCOMP0_SPR_15_8_SHIFT	8
+#define MAX_M5_RCOMP0_SPR_15_8_CLEAR	(~(0xff << 8))
+#define MAX_M5_RCOMP0_SPR_15_8_CLR(v) \
+			((v) & MAX_M5_RCOMP0_SPR_15_8_CLEAR)
+#define MAX_M5_RCOMP0_SPR_15_8_SET(v) \
+			(MAX_M5_RCOMP0_SPR_15_8_CLR(v) | MAX_M5_RCOMP0_SPR_15_8)
+#define MAX_M5_RCOMP0_RCOMP0_MASK	0xff
+#define MAX_M5_RCOMP0_RCOMP0_SHIFT	0
+#define MAX_M5_RCOMP0_RCOMP0_CLEAR	(~(0xff << 0))
+#define MAX_M5_RCOMP0_RCOMP0_CLR(v) \
+			((v) & MAX_M5_RCOMP0_RCOMP0_CLEAR)
+#define MAX_M5_RCOMP0_RCOMP0_SET(v) \
+			(MAX_M5_RCOMP0_RCOMP0_CLR(v) | MAX_M5_RCOMP0_RCOMP0)
+
+/* TempCo,0x39,0b10011000111101,0x263d
+ * TempCoHot[7:0],,,,,,
+ */
+#define MAX_M5_TEMPCO	0x39
+#define MAX_M5_TEMPCO_TEMPCOHOT	(0xff << 8)
+#define MAX_M5_TEMPCO_TEMPCOCOLD	(0xff << 0)
+
+#define MAX_M5_TEMPCO_TEMPCOHOT_MASK	0xff
+#define MAX_M5_TEMPCO_TEMPCOHOT_SHIFT	8
+#define MAX_M5_TEMPCO_TEMPCOHOT_CLEAR	(~(0xff << 8))
+#define MAX_M5_TEMPCO_TEMPCOHOT_CLR(v) \
+			((v) & MAX_M5_TEMPCO_TEMPCOHOT_CLEAR)
+#define MAX_M5_TEMPCO_TEMPCOHOT_SET(v) \
+		(MAX_M5_TEMPCO_TEMPCOHOT_CLR(v) | MAX_M5_TEMPCO_TEMPCOHOT)
+#define MAX_M5_TEMPCO_TEMPCOCOLD_MASK	0xff
+#define MAX_M5_TEMPCO_TEMPCOCOLD_SHIFT	0
+#define MAX_M5_TEMPCO_TEMPCOCOLD_CLEAR	(~(0xff << 0))
+#define MAX_M5_TEMPCO_TEMPCOCOLD_CLR(v) \
+			((v) & MAX_M5_TEMPCO_TEMPCOCOLD_CLEAR)
+#define MAX_M5_TEMPCO_TEMPCOCOLD_SET(v) \
+		(MAX_M5_TEMPCO_TEMPCOCOLD_CLR(v) | MAX_M5_TEMPCO_TEMPCOCOLD)
+
+/* VEmpty,0x3A,0b1010010101100001,0xa561
+ * V_Empty[8:1],,,,,,
+ */
+#define MAX_M5_VEMPTY	0x3A
+#define MAX_M5_VEMPTY_V_EMPTY	(0xff << 8)
+#define MAX_M5_VEMPTY_V_RECOVER	(0x7f << 1)
+
+#define MAX_M5_VEMPTY_V_EMPTY_MASK	0xff
+#define MAX_M5_VEMPTY_V_EMPTY_SHIFT	8
+#define MAX_M5_VEMPTY_V_EMPTY_CLEAR	(~(0xff << 8))
+#define MAX_M5_VEMPTY_V_EMPTY_CLR(v) \
+			((v) & MAX_M5_VEMPTY_V_EMPTY_CLEAR)
+#define MAX_M5_VEMPTY_V_EMPTY_SET(v) \
+			(MAX_M5_VEMPTY_V_EMPTY_CLR(v) | MAX_M5_VEMPTY_V_EMPTY)
+#define MAX_M5_VEMPTY_V_RECOVER_MASK	0x7f
+#define MAX_M5_VEMPTY_V_RECOVER_SHIFT	1
+#define MAX_M5_VEMPTY_V_RECOVER_CLEAR	(~(0x7f << 1))
+#define MAX_M5_VEMPTY_V_RECOVER_CLR(v) \
+			((v) & MAX_M5_VEMPTY_V_RECOVER_CLEAR)
+#define MAX_M5_VEMPTY_V_RECOVER_SET(v) \
+		(MAX_M5_VEMPTY_V_RECOVER_CLR(v) | MAX_M5_VEMPTY_V_RECOVER)
+
+/* AvgCurrent0,0x3B,0b111111111111111,0x7fff
+ * AvgCurrent0[15:8],,,,,,
+ */
+#define MAX_M5_AVGCURRENT0	0x3B
+
+/* TaskPeriod,0x3C,0b1011010000000,0x1680
+ * TaskPeriod[15:8],,,,,,
+ */
+#define MAX_M5_TASKPERIOD	0x3C
+
+/* FStat,0x3D,0b00000001,0x01
+ * xBr,RDF,tmode,DeBn,xBi,Relck,RelDt
+ */
+#define MAX_M5_FSTAT	0x3D
+#define MAX_M5_FSTAT_XBR	(0x1 << 15)
+#define MAX_M5_FSTAT_RDF	(0x1 << 14)
+#define MAX_M5_FSTAT_TMODE	(0x1 << 13)
+#define MAX_M5_FSTAT_DEBN	(0x1 << 12)
+#define MAX_M5_FSTAT_XBI	(0x1 << 11)
+#define MAX_M5_FSTAT_RELCK	(0x1 << 10)
+#define MAX_M5_FSTAT_RELDT	(0x1 << 9)
+#define MAX_M5_FSTAT_EDET	(0x1 << 8)
+#define MAX_M5_FSTAT_FQ	(0x1 << 7)
+#define MAX_M5_FSTAT_RELDT2	(0x1 << 6)
+#define MAX_M5_FSTAT_TIMER_START	(0x1 << 5)
+#define MAX_M5_FSTAT_XBST	(0x1 << 4)
+#define MAX_M5_FSTAT_ACCEN	(0x1 << 3)
+#define MAX_M5_FSTAT_WK	(0x1 << 2)
+#define MAX_M5_FSTAT_LDMDL	(0x1 << 1)
+#define MAX_M5_FSTAT_DNR	(0x1 << 0)
+
+#define MAX_M5_FSTAT_XBR_MASK	0x1
+#define MAX_M5_FSTAT_XBR_SHIFT	15
+#define MAX_M5_FSTAT_XBR_CLEAR	(~(0x1 << 15))
+#define MAX_M5_FSTAT_XBR_CLR(v)	((v) & MAX_M5_FSTAT_XBR_CLEAR)
+#define MAX_M5_FSTAT_XBR_SET(v) \
+			(MAX_M5_FSTAT_XBR_CLR(v) | MAX_M5_FSTAT_XBR)
+#define MAX_M5_FSTAT_RDF_MASK	0x1
+#define MAX_M5_FSTAT_RDF_SHIFT	14
+#define MAX_M5_FSTAT_RDF_CLEAR	(~(0x1 << 14))
+#define MAX_M5_FSTAT_RDF_CLR(v)	((v) & MAX_M5_FSTAT_RDF_CLEAR)
+#define MAX_M5_FSTAT_RDF_SET(v) \
+			(MAX_M5_FSTAT_RDF_CLR(v) | MAX_M5_FSTAT_RDF)
+#define MAX_M5_FSTAT_TMODE_MASK	0x1
+#define MAX_M5_FSTAT_TMODE_SHIFT	13
+#define MAX_M5_FSTAT_TMODE_CLEAR	(~(0x1 << 13))
+#define MAX_M5_FSTAT_TMODE_CLR(v)	((v) & MAX_M5_FSTAT_TMODE_CLEAR)
+#define MAX_M5_FSTAT_TMODE_SET(v) \
+			(MAX_M5_FSTAT_TMODE_CLR(v) | MAX_M5_FSTAT_TMODE)
+#define MAX_M5_FSTAT_DEBN_MASK	0x1
+#define MAX_M5_FSTAT_DEBN_SHIFT	12
+#define MAX_M5_FSTAT_DEBN_CLEAR	(~(0x1 << 12))
+#define MAX_M5_FSTAT_DEBN_CLR(v)	((v) & MAX_M5_FSTAT_DEBN_CLEAR)
+#define MAX_M5_FSTAT_DEBN_SET(v) \
+			(MAX_M5_FSTAT_DEBN_CLR(v) | MAX_M5_FSTAT_DEBN)
+#define MAX_M5_FSTAT_XBI_MASK	0x1
+#define MAX_M5_FSTAT_XBI_SHIFT	11
+#define MAX_M5_FSTAT_XBI_CLEAR	(~(0x1 << 11))
+#define MAX_M5_FSTAT_XBI_CLR(v)	((v) & MAX_M5_FSTAT_XBI_CLEAR)
+#define MAX_M5_FSTAT_XBI_SET(v) \
+			(MAX_M5_FSTAT_XBI_CLR(v) | MAX_M5_FSTAT_XBI)
+#define MAX_M5_FSTAT_RELCK_MASK	0x1
+#define MAX_M5_FSTAT_RELCK_SHIFT	10
+#define MAX_M5_FSTAT_RELCK_CLEAR	(~(0x1 << 10))
+#define MAX_M5_FSTAT_RELCK_CLR(v)	((v) & MAX_M5_FSTAT_RELCK_CLEAR)
+#define MAX_M5_FSTAT_RELCK_SET(v) \
+			(MAX_M5_FSTAT_RELCK_CLR(v) | MAX_M5_FSTAT_RELCK)
+#define MAX_M5_FSTAT_RELDT_MASK	0x1
+#define MAX_M5_FSTAT_RELDT_SHIFT	9
+#define MAX_M5_FSTAT_RELDT_CLEAR	(~(0x1 << 9))
+#define MAX_M5_FSTAT_RELDT_CLR(v)	((v) & MAX_M5_FSTAT_RELDT_CLEAR)
+#define MAX_M5_FSTAT_RELDT_SET(v) \
+			(MAX_M5_FSTAT_RELDT_CLR(v) | MAX_M5_FSTAT_RELDT)
+#define MAX_M5_FSTAT_EDET_MASK	0x1
+#define MAX_M5_FSTAT_EDET_SHIFT	8
+#define MAX_M5_FSTAT_EDET_CLEAR	(~(0x1 << 8))
+#define MAX_M5_FSTAT_EDET_CLR(v)	((v) & MAX_M5_FSTAT_EDET_CLEAR)
+#define MAX_M5_FSTAT_EDET_SET(v) \
+			(MAX_M5_FSTAT_EDET_CLR(v) | MAX_M5_FSTAT_EDET)
+#define MAX_M5_FSTAT_FQ_MASK	0x1
+#define MAX_M5_FSTAT_FQ_SHIFT	7
+#define MAX_M5_FSTAT_FQ_CLEAR	(~(0x1 << 7))
+#define MAX_M5_FSTAT_FQ_CLR(v)	((v) & MAX_M5_FSTAT_FQ_CLEAR)
+#define MAX_M5_FSTAT_FQ_SET(v) \
+			(MAX_M5_FSTAT_FQ_CLR(v) | MAX_M5_FSTAT_FQ)
+#define MAX_M5_FSTAT_RELDT2_MASK	0x1
+#define MAX_M5_FSTAT_RELDT2_SHIFT	6
+#define MAX_M5_FSTAT_RELDT2_CLEAR	(~(0x1 << 6))
+#define MAX_M5_FSTAT_RELDT2_CLR(v)	((v) & MAX_M5_FSTAT_RELDT2_CLEAR)
+#define MAX_M5_FSTAT_RELDT2_SET(v) \
+			(MAX_M5_FSTAT_RELDT2_CLR(v) | MAX_M5_FSTAT_RELDT2)
+#define MAX_M5_FSTAT_TIMER_START_MASK	0x1
+#define MAX_M5_FSTAT_TIMER_START_SHIFT	5
+#define MAX_M5_FSTAT_TIMER_START_CLEAR	(~(0x1 << 5))
+#define MAX_M5_FSTAT_TIMER_START_CLR(v) \
+			((v) & MAX_M5_FSTAT_TIMER_START_CLEAR)
+#define MAX_M5_FSTAT_TIMER_START_SET(v) \
+		(MAX_M5_FSTAT_TIMER_START_CLR(v) | MAX_M5_FSTAT_TIMER_START)
+#define MAX_M5_FSTAT_XBST_MASK	0x1
+#define MAX_M5_FSTAT_XBST_SHIFT	4
+#define MAX_M5_FSTAT_XBST_CLEAR	(~(0x1 << 4))
+#define MAX_M5_FSTAT_XBST_CLR(v)	((v) & MAX_M5_FSTAT_XBST_CLEAR)
+#define MAX_M5_FSTAT_XBST_SET(v) \
+			(MAX_M5_FSTAT_XBST_CLR(v) | MAX_M5_FSTAT_XBST)
+#define MAX_M5_FSTAT_ACCEN_MASK	0x1
+#define MAX_M5_FSTAT_ACCEN_SHIFT	3
+#define MAX_M5_FSTAT_ACCEN_CLEAR	(~(0x1 << 3))
+#define MAX_M5_FSTAT_ACCEN_CLR(v)	((v) & MAX_M5_FSTAT_ACCEN_CLEAR)
+#define MAX_M5_FSTAT_ACCEN_SET(v) \
+			(MAX_M5_FSTAT_ACCEN_CLR(v) | MAX_M5_FSTAT_ACCEN)
+#define MAX_M5_FSTAT_WK_MASK	0x1
+#define MAX_M5_FSTAT_WK_SHIFT	2
+#define MAX_M5_FSTAT_WK_CLEAR	(~(0x1 << 2))
+#define MAX_M5_FSTAT_WK_CLR(v)	((v) & MAX_M5_FSTAT_WK_CLEAR)
+#define MAX_M5_FSTAT_WK_SET(v) \
+			(MAX_M5_FSTAT_WK_CLR(v) | MAX_M5_FSTAT_WK)
+#define MAX_M5_FSTAT_LDMDL_MASK	0x1
+#define MAX_M5_FSTAT_LDMDL_SHIFT	1
+#define MAX_M5_FSTAT_LDMDL_CLEAR	(~(0x1 << 1))
+#define MAX_M5_FSTAT_LDMDL_CLR(v)	((v) & MAX_M5_FSTAT_LDMDL_CLEAR)
+#define MAX_M5_FSTAT_LDMDL_SET(v) \
+			(MAX_M5_FSTAT_LDMDL_CLR(v) | MAX_M5_FSTAT_LDMDL)
+#define MAX_M5_FSTAT_DNR_MASK	0x1
+#define MAX_M5_FSTAT_DNR_SHIFT	0
+#define MAX_M5_FSTAT_DNR_CLEAR	(~(0x1 << 0))
+#define MAX_M5_FSTAT_DNR_CLR(v)	((v) & MAX_M5_FSTAT_DNR_CLEAR)
+#define MAX_M5_FSTAT_DNR_SET(v) \
+			(MAX_M5_FSTAT_DNR_CLR(v) | MAX_M5_FSTAT_DNR)
+
+/* Timer,0x3E,0b00000000,0x00
+ * TIMER[15:8],,,,,,
+ */
+#define MAX_M5_TIMER	0x3E
+
+/* ShdnTimer,0x3F,0b1110000000000000,0xe000
+ * SHDN_THR[2:0],,,SHDNCTR[12:8],,,
+ */
+#define MAX_M5_SHDNTIMER	0x3F
+#define MAX_M5_SHDNTIMER_SHDN_THR	(0x7 << 13)
+#define MAX_M5_SHDNTIMER_SHDNCTR	(0x1fff << 0)
+
+#define MAX_M5_SHDNTIMER_SHDN_THR_MASK	0x7
+#define MAX_M5_SHDNTIMER_SHDN_THR_SHIFT	13
+#define MAX_M5_SHDNTIMER_SHDN_THR_CLEAR	(~(0x7 << 13))
+#define MAX_M5_SHDNTIMER_SHDN_THR_CLR(v) \
+			((v) & MAX_M5_SHDNTIMER_SHDN_THR_CLEAR)
+#define MAX_M5_SHDNTIMER_SHDN_THR_SET(v) \
+		(MAX_M5_SHDNTIMER_SHDN_THR_CLR(v) | MAX_M5_SHDNTIMER_SHDN_THR)
+#define MAX_M5_SHDNTIMER_SHDNCTR_MASK	0x1fff
+#define MAX_M5_SHDNTIMER_SHDNCTR_SHIFT	0
+#define MAX_M5_SHDNTIMER_SHDNCTR_CLEAR	(~(0x1fff << 0))
+#define MAX_M5_SHDNTIMER_SHDNCTR_CLR(v) \
+			((v) & MAX_M5_SHDNTIMER_SHDNCTR_CLEAR)
+#define MAX_M5_SHDNTIMER_SHDNCTR_SET(v) \
+		(MAX_M5_SHDNTIMER_SHDNCTR_CLR(v) | MAX_M5_SHDNTIMER_SHDNCTR)
+
+/* THMHOT,0x40,0b11111111100,0x7fc
+ * VR[4:0],,,,,Vhys[2:0],
+ */
+#define MAX_M5_THMHOT	0x40
+#define MAX_M5_THMHOT_VR	(0x1f << 11)
+#define MAX_M5_THMHOT_VHYS	(0x7 << 8)
+#define MAX_M5_THMHOT_TR	(0x1f << 3)
+#define MAX_M5_THMHOT_THYS	(0x7 << 0)
+
+#define MAX_M5_THMHOT_VR_MASK	0x1f
+#define MAX_M5_THMHOT_VR_SHIFT	11
+#define MAX_M5_THMHOT_VR_CLEAR	(~(0x1f << 11))
+#define MAX_M5_THMHOT_VR_CLR(v)	((v) & MAX_M5_THMHOT_VR_CLEAR)
+#define MAX_M5_THMHOT_VR_SET(v) \
+			(MAX_M5_THMHOT_VR_CLR(v) | MAX_M5_THMHOT_VR)
+#define MAX_M5_THMHOT_VHYS_MASK	0x7
+#define MAX_M5_THMHOT_VHYS_SHIFT	8
+#define MAX_M5_THMHOT_VHYS_CLEAR	(~(0x7 << 8))
+#define MAX_M5_THMHOT_VHYS_CLR(v)	((v) & MAX_M5_THMHOT_VHYS_CLEAR)
+#define MAX_M5_THMHOT_VHYS_SET(v) \
+			(MAX_M5_THMHOT_VHYS_CLR(v) | MAX_M5_THMHOT_VHYS)
+#define MAX_M5_THMHOT_TR_MASK	0x1f
+#define MAX_M5_THMHOT_TR_SHIFT	3
+#define MAX_M5_THMHOT_TR_CLEAR	(~(0x1f << 3))
+#define MAX_M5_THMHOT_TR_CLR(v)	((v) & MAX_M5_THMHOT_TR_CLEAR)
+#define MAX_M5_THMHOT_TR_SET(v) \
+			(MAX_M5_THMHOT_TR_CLR(v) | MAX_M5_THMHOT_TR)
+#define MAX_M5_THMHOT_THYS_MASK	0x7
+#define MAX_M5_THMHOT_THYS_SHIFT	0
+#define MAX_M5_THMHOT_THYS_CLEAR	(~(0x7 << 0))
+#define MAX_M5_THMHOT_THYS_CLR(v)	((v) & MAX_M5_THMHOT_THYS_CLEAR)
+#define MAX_M5_THMHOT_THYS_SET(v) \
+			(MAX_M5_THMHOT_THYS_CLR(v) | MAX_M5_THMHOT_THYS)
+
+/* CTESample,0x41,0b00000000,0x00
+ * CTESample[15:8],,,,,,
+ */
+#define MAX_M5_CTESAMPLE	0x41
+
+/* QRTable30,0x42,0b100010000101,0x885
+ * QRTable30[15:8],,,,,,
+ */
+#define MAX_M5_QRTABLE30	0x42
+
+/* ISys,0x43,0b00000000,0x00
+ * ISYS[15:8],,,,,,
+ */
+#define MAX_M5_ISYS	0x43
+
+/* AvgVCell0,0x44,0b1000000000000000,0x8000
+ * AvgVCELL0[15:8],,,,,,
+ */
+#define MAX_M5_AVGVCELL0	0x44
+
+/* dQAcc,0x45,0b00010111,0x17
+ * dQacc[15:8],,,,,,
+ */
+#define MAX_M5_DQACC	0x45
+
+/* dPAcc,0x46,0b110010000,0x190
+ * dPacc[15:8],,,,,,
+ */
+#define MAX_M5_DPACC	0x46
+
+/* RlxSOC,0x47,0b00000000,0x00
+ * RlxSOC[15:8],,,,,,
+ */
+#define MAX_M5_RLXSOC	0x47
+
+/* VFSOC0,0x48,0b11001000000000,0x3200
+ * VFSOC0[15:8],,,,,,
+ */
+#define MAX_M5_VFSOC0	0x48
+
+/* ConvgCfg,0x49,0b10001001000001,0x2241
+ * RepLow[3:0],,,,VoltLowOff[4:1],,
+ */
+#define MAX_M5_CONVGCFG	0x49
+#define MAX_M5_CONVGCFG_REPLOW	(0xf << 12)
+#define MAX_M5_CONVGCFG_VOLTLOWOFF	(0xf << 8)
+#define MAX_M5_CONVGCFG_MINSLOPEX	(0xf << 4)
+#define MAX_M5_CONVGCFG_REPL_PER_STAGE	(0x7 << 1)
+
+#define MAX_M5_CONVGCFG_REPLOW_MASK	0xf
+#define MAX_M5_CONVGCFG_REPLOW_SHIFT	12
+#define MAX_M5_CONVGCFG_REPLOW_CLEAR	(~(0xf << 12))
+#define MAX_M5_CONVGCFG_REPLOW_CLR(v) \
+			((v) & MAX_M5_CONVGCFG_REPLOW_CLEAR)
+#define MAX_M5_CONVGCFG_REPLOW_SET(v) \
+			(MAX_M5_CONVGCFG_REPLOW_CLR(v) | MAX_M5_CONVGCFG_REPLOW)
+#define MAX_M5_CONVGCFG_VOLTLOWOFF_MASK	0xf
+#define MAX_M5_CONVGCFG_VOLTLOWOFF_SHIFT	8
+#define MAX_M5_CONVGCFG_VOLTLOWOFF_CLEAR	(~(0xf << 8))
+#define MAX_M5_CONVGCFG_VOLTLOWOFF_CLR(v) \
+			((v) & MAX_M5_CONVGCFG_VOLTLOWOFF_CLEAR)
+#define MAX_M5_CONVGCFG_VOLTLOWOFF_SET(v) \
+		(MAX_M5_CONVGCFG_VOLTLOWOFF_CLR(v) | MAX_M5_CONVGCFG_VOLTLOWOFF)
+#define MAX_M5_CONVGCFG_MINSLOPEX_MASK	0xf
+#define MAX_M5_CONVGCFG_MINSLOPEX_SHIFT	4
+#define MAX_M5_CONVGCFG_MINSLOPEX_CLEAR	(~(0xf << 4))
+#define MAX_M5_CONVGCFG_MINSLOPEX_CLR(v) \
+			((v) & MAX_M5_CONVGCFG_MINSLOPEX_CLEAR)
+#define MAX_M5_CONVGCFG_MINSLOPEX_SET(v) \
+		(MAX_M5_CONVGCFG_MINSLOPEX_CLR(v) | MAX_M5_CONVGCFG_MINSLOPEX)
+#define MAX_M5_CONVGCFG_REPL_PER_STAGE_MASK	0x7
+#define MAX_M5_CONVGCFG_REPL_PER_STAGE_SHIFT	1
+#define MAX_M5_CONVGCFG_REPL_PER_STAGE_CLEAR	(~(0x7 << 1))
+#define MAX_M5_CONVGCFG_REPL_PER_STAGE_CLR(v) \
+			((v) & MAX_M5_CONVGCFG_REPL_PER_STAGE_CLEAR)
+#define MAX_M5_CONVGCFG_REPL_PER_STAGE_SET(v) \
+	(MAX_M5_CONVGCFG_REPL_PER_STAGE_CLR(v) | MAX_M5_CONVGCFG_REPL_PER_STAGE)
+
+/* VFRemCap,0x4A,0b10111011100,0x5dc
+ * VFRemCap[15:8],,,,,,
+ */
+#define MAX_M5_VFREMCAP	0x4A
+
+/* AvgISys,0x4B,0b00000000,0x00
+ * AVGISYS[15:8],,,,,,
+ */
+#define MAX_M5_AVGISYS	0x4B
+
+/* QH0,0x4C,0b00000000,0x00
+ * QH0[15:8],,,,,,
+ */
+#define MAX_M5_QH0	0x4C
+
+/* QH,0x4D,0b00000000,0x00
+ * QH[15:8],,,,,,
+ */
+#define MAX_M5_QH	0x4D
+
+/* QL,0x4E,0b00000000,0x00
+ * QL[15:8],,,,,,
+ */
+#define MAX_M5_QL	0x4E
+
+/* MixAtFull,0x4F,0b101110111000,0xbb8
+ * MixAtFull[15:8],,,,,,
+ */
+#define MAX_M5_MIXATFULL	0x4F
+
+/* Status2,0xB0,0b00000000,0x00
+ * SPR_15_6[9:2],,,,,,
+ */
+#define MAX_M5_STATUS2	0xB0
+#define MAX_M5_STATUS2_SPR_15_6	(0x3ff << 6)
+#define MAX_M5_STATUS2_FULLDET	(0x1 << 5)
+#define MAX_M5_STATUS2_SPR_4_2	(0x7 << 2)
+#define MAX_M5_STATUS2_HIB	(0x1 << 1)
+#define MAX_M5_STATUS2_SPR_0	(0x1 << 0)
+
+#define MAX_M5_STATUS2_SPR_15_6_MASK	0x3ff
+#define MAX_M5_STATUS2_SPR_15_6_SHIFT	6
+#define MAX_M5_STATUS2_SPR_15_6_CLEAR	(~(0x3ff << 6))
+#define MAX_M5_STATUS2_SPR_15_6_CLR(v) \
+			((v) & MAX_M5_STATUS2_SPR_15_6_CLEAR)
+#define MAX_M5_STATUS2_SPR_15_6_SET(v) \
+		(MAX_M5_STATUS2_SPR_15_6_CLR(v) | MAX_M5_STATUS2_SPR_15_6)
+#define MAX_M5_STATUS2_FULLDET_MASK	0x1
+#define MAX_M5_STATUS2_FULLDET_SHIFT	5
+#define MAX_M5_STATUS2_FULLDET_CLEAR	(~(0x1 << 5))
+#define MAX_M5_STATUS2_FULLDET_CLR(v) \
+			((v) & MAX_M5_STATUS2_FULLDET_CLEAR)
+#define MAX_M5_STATUS2_FULLDET_SET(v) \
+			(MAX_M5_STATUS2_FULLDET_CLR(v) | MAX_M5_STATUS2_FULLDET)
+#define MAX_M5_STATUS2_SPR_4_2_MASK	0x7
+#define MAX_M5_STATUS2_SPR_4_2_SHIFT	2
+#define MAX_M5_STATUS2_SPR_4_2_CLEAR	(~(0x7 << 2))
+#define MAX_M5_STATUS2_SPR_4_2_CLR(v) \
+			((v) & MAX_M5_STATUS2_SPR_4_2_CLEAR)
+#define MAX_M5_STATUS2_SPR_4_2_SET(v) \
+			(MAX_M5_STATUS2_SPR_4_2_CLR(v) | MAX_M5_STATUS2_SPR_4_2)
+#define MAX_M5_STATUS2_HIB_MASK	0x1
+#define MAX_M5_STATUS2_HIB_SHIFT	1
+#define MAX_M5_STATUS2_HIB_CLEAR	(~(0x1 << 1))
+#define MAX_M5_STATUS2_HIB_CLR(v)	((v) & MAX_M5_STATUS2_HIB_CLEAR)
+#define MAX_M5_STATUS2_HIB_SET(v) \
+			(MAX_M5_STATUS2_HIB_CLR(v) | MAX_M5_STATUS2_HIB)
+#define MAX_M5_STATUS2_SPR_0_MASK	0x1
+#define MAX_M5_STATUS2_SPR_0_SHIFT	0
+#define MAX_M5_STATUS2_SPR_0_CLEAR	(~(0x1 << 0))
+#define MAX_M5_STATUS2_SPR_0_CLR(v) \
+			((v) & MAX_M5_STATUS2_SPR_0_CLEAR)
+#define MAX_M5_STATUS2_SPR_0_SET(v) \
+			(MAX_M5_STATUS2_SPR_0_CLR(v) | MAX_M5_STATUS2_SPR_0)
+
+/* VSys,0xB1,0b00000000,0x00
+ * VSys[15:8],,,,,,
+ */
+#define MAX_M5_VSYS	0xB1
+
+/* TAlrtTh2,0xB2,0b111111110000000,0x7f80
+ * TempWarm[7:0],,,,,,
+ */
+#define MAX_M5_TALRTTH2	0xB2
+#define MAX_M5_TALRTTH2_TEMPWARM	(0xff << 8)
+#define MAX_M5_TALRTTH2_TEMPCOOL	(0xff << 0)
+
+#define MAX_M5_TALRTTH2_TEMPWARM_MASK	0xff
+#define MAX_M5_TALRTTH2_TEMPWARM_SHIFT	8
+#define MAX_M5_TALRTTH2_TEMPWARM_CLEAR	(~(0xff << 8))
+#define MAX_M5_TALRTTH2_TEMPWARM_CLR(v) \
+			((v) & MAX_M5_TALRTTH2_TEMPWARM_CLEAR)
+#define MAX_M5_TALRTTH2_TEMPWARM_SET(v) \
+		(MAX_M5_TALRTTH2_TEMPWARM_CLR(v) | MAX_M5_TALRTTH2_TEMPWARM)
+#define MAX_M5_TALRTTH2_TEMPCOOL_MASK	0xff
+#define MAX_M5_TALRTTH2_TEMPCOOL_SHIFT	0
+#define MAX_M5_TALRTTH2_TEMPCOOL_CLEAR	(~(0xff << 0))
+#define MAX_M5_TALRTTH2_TEMPCOOL_CLR(v) \
+			((v) & MAX_M5_TALRTTH2_TEMPCOOL_CLEAR)
+#define MAX_M5_TALRTTH2_TEMPCOOL_SET(v) \
+		(MAX_M5_TALRTTH2_TEMPCOOL_CLR(v) | MAX_M5_TALRTTH2_TEMPCOOL)
+
+/* VByp,0xB3,0b00000000,0x00
+ * VByp[15:8],,,,,,
+ */
+#define MAX_M5_VBYP	0xB3
+
+/* IAlrtTh,0xB4,0b111111110000000,0x7f80
+ * ISYSOCP_TH[7:0],,,,,,
+ */
+#define MAX_M5_IALRTTH	0xB4
+#define MAX_M5_IALRTTH_ISYSOCP_TH	(0xff << 8)
+#define MAX_M5_IALRTTH_IBATTMIN_TH	(0xff << 0)
+
+#define MAX_M5_IALRTTH_ISYSOCP_TH_MASK	0xff
+#define MAX_M5_IALRTTH_ISYSOCP_TH_SHIFT	8
+#define MAX_M5_IALRTTH_ISYSOCP_TH_CLEAR	(~(0xff << 8))
+#define MAX_M5_IALRTTH_ISYSOCP_TH_CLR(v) \
+			((v) & MAX_M5_IALRTTH_ISYSOCP_TH_CLEAR)
+#define MAX_M5_IALRTTH_ISYSOCP_TH_SET(v) \
+		(MAX_M5_IALRTTH_ISYSOCP_TH_CLR(v) | MAX_M5_IALRTTH_ISYSOCP_TH)
+#define MAX_M5_IALRTTH_IBATTMIN_TH_MASK	0xff
+#define MAX_M5_IALRTTH_IBATTMIN_TH_SHIFT	0
+#define MAX_M5_IALRTTH_IBATTMIN_TH_CLEAR	(~(0xff << 0))
+#define MAX_M5_IALRTTH_IBATTMIN_TH_CLR(v) \
+			((v) & MAX_M5_IALRTTH_IBATTMIN_TH_CLEAR)
+#define MAX_M5_IALRTTH_IBATTMIN_TH_SET(v) \
+		(MAX_M5_IALRTTH_IBATTMIN_TH_CLR(v) | MAX_M5_IALRTTH_IBATTMIN_TH)
+
+/* TTF_CFG,0xB5,0b00000101,0x05
+ * SPR_15_3[12:5],,,,,,
+ */
+#define MAX_M5_TTF_CFG	0xB5
+#define MAX_M5_TTF_CFG_SPR_15_3	(0x1fff << 3)
+#define MAX_M5_TTF_CFG_TTF_CFG	(0x7 << 0)
+
+#define MAX_M5_TTF_CFG_SPR_15_3_MASK	0x1fff
+#define MAX_M5_TTF_CFG_SPR_15_3_SHIFT	3
+#define MAX_M5_TTF_CFG_SPR_15_3_CLEAR	(~(0x1fff << 3))
+#define MAX_M5_TTF_CFG_SPR_15_3_CLR(v) \
+			((v) & MAX_M5_TTF_CFG_SPR_15_3_CLEAR)
+#define MAX_M5_TTF_CFG_SPR_15_3_SET(v) \
+		(MAX_M5_TTF_CFG_SPR_15_3_CLR(v) | MAX_M5_TTF_CFG_SPR_15_3)
+#define MAX_M5_TTF_CFG_TTF_CFG_MASK	0x7
+#define MAX_M5_TTF_CFG_TTF_CFG_SHIFT	0
+#define MAX_M5_TTF_CFG_TTF_CFG_CLEAR	(~(0x7 << 0))
+#define MAX_M5_TTF_CFG_TTF_CFG_CLR(v) \
+			((v) & MAX_M5_TTF_CFG_TTF_CFG_CLEAR)
+#define MAX_M5_TTF_CFG_TTF_CFG_SET(v) \
+			(MAX_M5_TTF_CFG_TTF_CFG_CLR(v) | MAX_M5_TTF_CFG_TTF_CFG)
+
+/* CV_MixCap,0xB6,0b100011001010,0x8ca
+ * CV_MixCap[15:8],,,,,,
+ */
+#define MAX_M5_CV_MIXCAP	0xB6
+
+/* CV_HalfTime,0xB7,0b101000000000,0xa00
+ * CV_Halftime[15:8],,,,,,
+ */
+#define MAX_M5_CV_HALFTIME	0xB7
+
+/* CGTempCo,0xB8,0b00000000,0x00
+ * CGTempCo[15:8],,,,,,
+ */
+#define MAX_M5_CGTEMPCO	0xB8
+
+/* Curve,0xB9,0b01101011,0x6b
+ * ECURVE[7:0],,,,,,
+ */
+#define MAX_M5_CURVE	0xB9
+#define MAX_M5_CURVE_ECURVE	(0xff << 8)
+#define MAX_M5_CURVE_TCURVE	(0xff << 0)
+
+#define MAX_M5_CURVE_ECURVE_MASK	0xff
+#define MAX_M5_CURVE_ECURVE_SHIFT	8
+#define MAX_M5_CURVE_ECURVE_CLEAR	(~(0xff << 8))
+#define MAX_M5_CURVE_ECURVE_CLR(v)	((v) & MAX_M5_CURVE_ECURVE_CLEAR)
+#define MAX_M5_CURVE_ECURVE_SET(v) \
+			(MAX_M5_CURVE_ECURVE_CLR(v) | MAX_M5_CURVE_ECURVE)
+#define MAX_M5_CURVE_TCURVE_MASK	0xff
+#define MAX_M5_CURVE_TCURVE_SHIFT	0
+#define MAX_M5_CURVE_TCURVE_CLEAR	(~(0xff << 0))
+#define MAX_M5_CURVE_TCURVE_CLR(v)	((v) & MAX_M5_CURVE_TCURVE_CLEAR)
+#define MAX_M5_CURVE_TCURVE_SET(v) \
+			(MAX_M5_CURVE_TCURVE_CLR(v) | MAX_M5_CURVE_TCURVE)
+
+/* HibCfg,0xBA,0b100100001100,0x90c
+ * EnHib,HibEnterTime[2:0],,,HibThreshold[3:0],,
+ */
+#define MAX_M5_HIBCFG	0xBA
+#define MAX_M5_HIBCFG_ENHIB	(0x1 << 15)
+#define MAX_M5_HIBCFG_HIBENTERTIME	(0x7 << 12)
+#define MAX_M5_HIBCFG_HIBTHRESHOLD	(0xf << 8)
+#define MAX_M5_HIBCFG_SPR_7_5	(0x7 << 5)
+#define MAX_M5_HIBCFG_HIBEXITTIME	(0x3 << 3)
+#define MAX_M5_HIBCFG_HIBSCALAR	(0x7 << 0)
+
+#define MAX_M5_HIBCFG_ENHIB_MASK	0x1
+#define MAX_M5_HIBCFG_ENHIB_SHIFT	15
+#define MAX_M5_HIBCFG_ENHIB_CLEAR	(~(0x1 << 15))
+#define MAX_M5_HIBCFG_ENHIB_CLR(v)	((v) & MAX_M5_HIBCFG_ENHIB_CLEAR)
+#define MAX_M5_HIBCFG_ENHIB_SET(v) \
+			(MAX_M5_HIBCFG_ENHIB_CLR(v) | MAX_M5_HIBCFG_ENHIB)
+#define MAX_M5_HIBCFG_HIBENTERTIME_MASK	0x7
+#define MAX_M5_HIBCFG_HIBENTERTIME_SHIFT	12
+#define MAX_M5_HIBCFG_HIBENTERTIME_CLEAR	(~(0x7 << 12))
+#define MAX_M5_HIBCFG_HIBENTERTIME_CLR(v) \
+			((v) & MAX_M5_HIBCFG_HIBENTERTIME_CLEAR)
+#define MAX_M5_HIBCFG_HIBENTERTIME_SET(v) \
+		(MAX_M5_HIBCFG_HIBENTERTIME_CLR(v) | MAX_M5_HIBCFG_HIBENTERTIME)
+#define MAX_M5_HIBCFG_HIBTHRESHOLD_MASK	0xf
+#define MAX_M5_HIBCFG_HIBTHRESHOLD_SHIFT	8
+#define MAX_M5_HIBCFG_HIBTHRESHOLD_CLEAR	(~(0xf << 8))
+#define MAX_M5_HIBCFG_HIBTHRESHOLD_CLR(v) \
+			((v) & MAX_M5_HIBCFG_HIBTHRESHOLD_CLEAR)
+#define MAX_M5_HIBCFG_HIBTHRESHOLD_SET(v) \
+		(MAX_M5_HIBCFG_HIBTHRESHOLD_CLR(v) | MAX_M5_HIBCFG_HIBTHRESHOLD)
+#define MAX_M5_HIBCFG_SPR_7_5_MASK	0x7
+#define MAX_M5_HIBCFG_SPR_7_5_SHIFT	5
+#define MAX_M5_HIBCFG_SPR_7_5_CLEAR	(~(0x7 << 5))
+#define MAX_M5_HIBCFG_SPR_7_5_CLR(v) \
+			((v) & MAX_M5_HIBCFG_SPR_7_5_CLEAR)
+#define MAX_M5_HIBCFG_SPR_7_5_SET(v) \
+			(MAX_M5_HIBCFG_SPR_7_5_CLR(v) | MAX_M5_HIBCFG_SPR_7_5)
+#define MAX_M5_HIBCFG_HIBEXITTIME_MASK	0x3
+#define MAX_M5_HIBCFG_HIBEXITTIME_SHIFT	3
+#define MAX_M5_HIBCFG_HIBEXITTIME_CLEAR	(~(0x3 << 3))
+#define MAX_M5_HIBCFG_HIBEXITTIME_CLR(v) \
+			((v) & MAX_M5_HIBCFG_HIBEXITTIME_CLEAR)
+#define MAX_M5_HIBCFG_HIBEXITTIME_SET(v) \
+		(MAX_M5_HIBCFG_HIBEXITTIME_CLR(v) | MAX_M5_HIBCFG_HIBEXITTIME)
+#define MAX_M5_HIBCFG_HIBSCALAR_MASK	0x7
+#define MAX_M5_HIBCFG_HIBSCALAR_SHIFT	0
+#define MAX_M5_HIBCFG_HIBSCALAR_CLEAR	(~(0x7 << 0))
+#define MAX_M5_HIBCFG_HIBSCALAR_CLR(v) \
+			((v) & MAX_M5_HIBCFG_HIBSCALAR_CLEAR)
+#define MAX_M5_HIBCFG_HIBSCALAR_SET(v) \
+		(MAX_M5_HIBCFG_HIBSCALAR_CLR(v) | MAX_M5_HIBCFG_HIBSCALAR)
+
+/* Config2,0xBB,0b01010000,0x50
+ * SPR_15_11[4:0],,,,,FCThmHot,ThmHotEn
+ */
+#define MAX_M5_CONFIG2	0xBB
+#define MAX_M5_CONFIG2_SPR_15_11	(0x1f << 11)
+#define MAX_M5_CONFIG2_FCTHMHOT	(0x1 << 10)
+#define MAX_M5_CONFIG2_THMHOTEN	(0x1 << 9)
+#define MAX_M5_CONFIG2_THMHOTALRTEN	(0x1 << 8)
+#define MAX_M5_CONFIG2_DSOCEN	(0x1 << 7)
+#define MAX_M5_CONFIG2_TALRTEN	(0x1 << 6)
+#define MAX_M5_CONFIG2_LDMDL	(0x1 << 5)
+#define MAX_M5_CONFIG2_OCVQEN	(0x1 << 4)
+#define MAX_M5_CONFIG2_ISYSNCURR	(0xf << 0)
+
+#define MAX_M5_CONFIG2_SPR_15_11_MASK	0x1f
+#define MAX_M5_CONFIG2_SPR_15_11_SHIFT	11
+#define MAX_M5_CONFIG2_SPR_15_11_CLEAR	(~(0x1f << 11))
+#define MAX_M5_CONFIG2_SPR_15_11_CLR(v) \
+			((v) & MAX_M5_CONFIG2_SPR_15_11_CLEAR)
+#define MAX_M5_CONFIG2_SPR_15_11_SET(v) \
+		(MAX_M5_CONFIG2_SPR_15_11_CLR(v) | MAX_M5_CONFIG2_SPR_15_11)
+#define MAX_M5_CONFIG2_FCTHMHOT_MASK	0x1
+#define MAX_M5_CONFIG2_FCTHMHOT_SHIFT	10
+#define MAX_M5_CONFIG2_FCTHMHOT_CLEAR	(~(0x1 << 10))
+#define MAX_M5_CONFIG2_FCTHMHOT_CLR(v) \
+			((v) & MAX_M5_CONFIG2_FCTHMHOT_CLEAR)
+#define MAX_M5_CONFIG2_FCTHMHOT_SET(v) \
+		(MAX_M5_CONFIG2_FCTHMHOT_CLR(v) | MAX_M5_CONFIG2_FCTHMHOT)
+#define MAX_M5_CONFIG2_THMHOTEN_MASK	0x1
+#define MAX_M5_CONFIG2_THMHOTEN_SHIFT	9
+#define MAX_M5_CONFIG2_THMHOTEN_CLEAR	(~(0x1 << 9))
+#define MAX_M5_CONFIG2_THMHOTEN_CLR(v) \
+			((v) & MAX_M5_CONFIG2_THMHOTEN_CLEAR)
+#define MAX_M5_CONFIG2_THMHOTEN_SET(v) \
+		(MAX_M5_CONFIG2_THMHOTEN_CLR(v) | MAX_M5_CONFIG2_THMHOTEN)
+#define MAX_M5_CONFIG2_THMHOTALRTEN_MASK	0x1
+#define MAX_M5_CONFIG2_THMHOTALRTEN_SHIFT	8
+#define MAX_M5_CONFIG2_THMHOTALRTEN_CLEAR	(~(0x1 << 8))
+#define MAX_M5_CONFIG2_THMHOTALRTEN_CLR(v) \
+			((v) & MAX_M5_CONFIG2_THMHOTALRTEN_CLEAR)
+#define MAX_M5_CONFIG2_THMHOTALRTEN_SET(v) \
+	(MAX_M5_CONFIG2_THMHOTALRTEN_CLR(v) | MAX_M5_CONFIG2_THMHOTALRTEN)
+#define MAX_M5_CONFIG2_DSOCEN_MASK	0x1
+#define MAX_M5_CONFIG2_DSOCEN_SHIFT	7
+#define MAX_M5_CONFIG2_DSOCEN_CLEAR	(~(0x1 << 7))
+#define MAX_M5_CONFIG2_DSOCEN_CLR(v) \
+			((v) & MAX_M5_CONFIG2_DSOCEN_CLEAR)
+#define MAX_M5_CONFIG2_DSOCEN_SET(v) \
+			(MAX_M5_CONFIG2_DSOCEN_CLR(v) | MAX_M5_CONFIG2_DSOCEN)
+#define MAX_M5_CONFIG2_TALRTEN_MASK	0x1
+#define MAX_M5_CONFIG2_TALRTEN_SHIFT	6
+#define MAX_M5_CONFIG2_TALRTEN_CLEAR	(~(0x1 << 6))
+#define MAX_M5_CONFIG2_TALRTEN_CLR(v) \
+			((v) & MAX_M5_CONFIG2_TALRTEN_CLEAR)
+#define MAX_M5_CONFIG2_TALRTEN_SET(v) \
+			(MAX_M5_CONFIG2_TALRTEN_CLR(v) | MAX_M5_CONFIG2_TALRTEN)
+#define MAX_M5_CONFIG2_LDMDL_MASK	0x1
+#define MAX_M5_CONFIG2_LDMDL_SHIFT	5
+#define MAX_M5_CONFIG2_LDMDL_CLEAR	(~(0x1 << 5))
+#define MAX_M5_CONFIG2_LDMDL_CLR(v) \
+			((v) & MAX_M5_CONFIG2_LDMDL_CLEAR)
+#define MAX_M5_CONFIG2_LDMDL_SET(v) \
+			(MAX_M5_CONFIG2_LDMDL_CLR(v) | MAX_M5_CONFIG2_LDMDL)
+#define MAX_M5_CONFIG2_OCVQEN_MASK	0x1
+#define MAX_M5_CONFIG2_OCVQEN_SHIFT	4
+#define MAX_M5_CONFIG2_OCVQEN_CLEAR	(~(0x1 << 4))
+#define MAX_M5_CONFIG2_OCVQEN_CLR(v) \
+			((v) & MAX_M5_CONFIG2_OCVQEN_CLEAR)
+#define MAX_M5_CONFIG2_OCVQEN_SET(v) \
+			(MAX_M5_CONFIG2_OCVQEN_CLR(v) | MAX_M5_CONFIG2_OCVQEN)
+#define MAX_M5_CONFIG2_ISYSNCURR_MASK	0xf
+#define MAX_M5_CONFIG2_ISYSNCURR_SHIFT	0
+#define MAX_M5_CONFIG2_ISYSNCURR_CLEAR	(~(0xf << 0))
+#define MAX_M5_CONFIG2_ISYSNCURR_CLR(v) \
+			((v) & MAX_M5_CONFIG2_ISYSNCURR_CLEAR)
+#define MAX_M5_CONFIG2_ISYSNCURR_SET(v) \
+		(MAX_M5_CONFIG2_ISYSNCURR_CLR(v) | MAX_M5_CONFIG2_ISYSNCURR)
+
+/* VRipple,0xBC,0b00000000,0x00
+ * Vripple[15:8],,,,,,
+ */
+#define MAX_M5_VRIPPLE	0xBC
+
+/* RippleCfg,0xBD,0b1000000100,0x204
+ * kDV[12:5],,,,,,
+ */
+#define MAX_M5_RIPPLECFG	0xBD
+#define MAX_M5_RIPPLECFG_KDV	(0x1fff << 3)
+#define MAX_M5_RIPPLECFG_NR	(0x7 << 0)
+
+#define MAX_M5_RIPPLECFG_KDV_MASK	0x1fff
+#define MAX_M5_RIPPLECFG_KDV_SHIFT	3
+#define MAX_M5_RIPPLECFG_KDV_CLEAR	(~(0x1fff << 3))
+#define MAX_M5_RIPPLECFG_KDV_CLR(v) \
+			((v) & MAX_M5_RIPPLECFG_KDV_CLEAR)
+#define MAX_M5_RIPPLECFG_KDV_SET(v) \
+			(MAX_M5_RIPPLECFG_KDV_CLR(v) | MAX_M5_RIPPLECFG_KDV)
+#define MAX_M5_RIPPLECFG_NR_MASK	0x7
+#define MAX_M5_RIPPLECFG_NR_SHIFT	0
+#define MAX_M5_RIPPLECFG_NR_CLEAR	(~(0x7 << 0))
+#define MAX_M5_RIPPLECFG_NR_CLR(v)	((v) & MAX_M5_RIPPLECFG_NR_CLEAR)
+#define MAX_M5_RIPPLECFG_NR_SET(v) \
+			(MAX_M5_RIPPLECFG_NR_CLR(v) | MAX_M5_RIPPLECFG_NR)
+
+/* TimerH,0xBE,0b00000000,0x00
+ * TIMERH[15:8],,,,,,
+ */
+#define MAX_M5_TIMERH	0xBE
+
+/* MaxError,0xBF,0b00000000,0x00
+ * MaxError[15:8],,,,,,
+ */
+#define MAX_M5_MAXERROR	0xBF
+
+/* IIn,0xD0,0b00000000,0x00
+ * IIn[15:8],,,,,,
+ */
+#define MAX_M5_IIN	0xD0
+
+/* AtQresidual,0xDC,0b00000000,0x00
+ * AtQresidual[15:8],,,,,,
+ */
+#define MAX_M5_ATQRESIDUAL	0xDC
+
+/* AtTTE,0xDD,0b00000000,0x00
+ * AtTTE[15:8],,,,,,
+ */
+#define MAX_M5_ATTTE	0xDD
+
+/* AtAvSOC,0xDE,0b00000000,0x00
+ * AtAvSOC[15:8],,,,,,
+ */
+#define MAX_M5_ATAVSOC	0xDE
+
+/* AtAvCap,0xDF,0b00000000,0x00
+ * AtAvCap[15:8],,,,,,
+ */
+#define MAX_M5_ATAVCAP	0xDF
+
+#endif /* MAX_M5_REG_H_ */
diff --git a/drivers/soc/qcom/mdt_loader.c b/drivers/soc/qcom/mdt_loader.c
index 9199387993b7..9f53d93da8de 100644
--- a/drivers/soc/qcom/mdt_loader.c
+++ b/drivers/soc/qcom/mdt_loader.c
@@ -176,7 +176,7 @@ void *qcom_mdt_read_metadata(struct device *dev, const struct firmware *fw, cons
 			goto free_metadata;
 
 		}
-		snprintf(fw_name + strlen(fw_name) - 3, 4, "b%02d", hash_index);
+		snprintf(fw_name + strlen(fw_name) - 3, 4, "b%02d", (int)hash_index);
 
 		ret = request_firmware_into_buf(&seg_fw, fw_name, dev, data + ehdr_size, hash_size);
 		kfree(fw_name);
diff --git a/drivers/soc/qcom/misc/gvotable.h b/drivers/soc/qcom/misc/gvotable.h
new file mode 100644
index 000000000000..0bd547ba4249
--- /dev/null
+++ b/drivers/soc/qcom/misc/gvotable.h
@@ -0,0 +1,121 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Copyright 2019-2022 Google LLC
+ */
+
+#ifndef __GOOGLE_GVOTABLE_H_
+#define __GOOGLE_GVOTABLE_H_
+
+#include <linux/types.h>
+#include <linux/mutex.h>
+
+#define GVOTABLE_MAX_REASON_LEN		32
+
+#define GVOTABLE_PTR_TO_INT(v)		((int)(uintptr_t)(v))
+
+struct gvotable_election;
+
+typedef int (*gvotable_cmp_fn)(void *a, void *b);
+typedef int (*gvotable_callback_fn)(struct gvotable_election *el,
+				    const char *reason,
+				    void *vote);
+
+struct gvotable_election *
+gvotable_create_election(const char *name, int vote_size,
+			 int  (*cmp_fn)(void *, void *),
+			 gvotable_callback_fn callback_fn,
+			 void *data);
+
+#define _GVOTABLE_EPC(a, ...) a ## __VA_ARGS__
+#define GVOTABLE__ELECTION_HELPER(t) \
+	_GVOTABLE_EPC(_GVOTABLE_EPC(gvotable_create_, t)_election)(name, cmp_fn, cb_fn, data)
+
+/* NOTE: cannot change the data after init to avoid adding a lock for it */
+struct gvotable_election *
+gvotable_create_int_election(const char *name, gvotable_cmp_fn cmp_fn,
+			     gvotable_callback_fn callback_fn,
+			     void *data);
+
+struct gvotable_election *
+gvotable_create_bool_election(const char *name, gvotable_callback_fn cb_fn,
+			      void *data);
+
+int gvotable_destroy_election(struct gvotable_election *el);
+
+struct gvotable_election *gvotable_election_get_handle(const char *name);
+
+/* TODO: redesign this API  */
+typedef int (*gvotable_foreach_callback_fn)(void *data, const char *reason,
+					    void *vote);
+int gvotable_election_for_each(struct gvotable_election *el,
+			       gvotable_foreach_callback_fn callback_fn,
+			       void *callback_data);
+int gvotable_election_set_result(struct gvotable_election *el,
+				 const char *reason, void *vote);
+
+void *gvotable_get_data(struct gvotable_election *el);
+
+int gvotable_get_current_reason(struct gvotable_election *el, char *reason,
+				int max_reason_len);
+
+int gvotable_set_default(struct gvotable_election *el, void *default_val);
+int gvotable_get_default(struct gvotable_election *el, void **default_val);
+
+int gvotable_election_set_name(struct gvotable_election *el, const char *name);
+
+int gvotable_use_default(struct gvotable_election *el, bool default_is_enabled);
+
+int gvotable_cast_vote(struct gvotable_election *el, const char *reason,
+		       void *vote, bool enabled);
+static inline int gvotable_cast_int_vote(struct gvotable_election *el,
+					 const char *reason, int vote,
+					 bool enabled)
+{
+	return gvotable_cast_vote(el, reason, (void *)(long)vote, enabled);
+}
+static inline int gvotable_cast_long_vote(struct gvotable_election *el,
+					  const char *reason, long vote,
+					  bool enabled)
+{
+	return gvotable_cast_vote(el, reason, (void *)vote, enabled);
+}
+static inline int gvotable_cast_bool_vote(struct gvotable_election *el,
+					  const char *reason, bool vote)
+{
+	return gvotable_cast_vote(el, reason, 0, vote);
+}
+
+int gvotable_recast_ballot(struct gvotable_election *el, const char *reason,
+			   bool enabled);
+int gvotable_run_election(struct gvotable_election *el, bool force_callback);
+
+
+int gvotable_get_vote(struct gvotable_election *el, const char *reason,
+		      void **vote);
+int gvotable_get_int_vote(struct gvotable_election *el, const char *reason);
+
+int gvotable_is_enabled(struct gvotable_election *el, const char *reason,
+			bool *enabled);
+
+int gvotable_get_current_int_vote(struct gvotable_election *el);
+int gvotable_get_current_vote(struct gvotable_election *el, const void **vote);
+int gvotable_copy_current_result(struct gvotable_election *el, void *vote,
+				 int vote_size);
+
+int gvotable_comparator_uint_max(void *a, void *b);
+int gvotable_comparator_uint_min(void *a, void *b);
+int gvotable_comparator_int_max(void *a, void *b);
+int gvotable_comparator_int_min(void *a, void *b);
+int gvotable_comparator_most_recent(void *a, void *b);
+int gvotable_comparator_least_recent(void *a, void *b);
+
+/* dump, debug */
+typedef int (*gvotable_v2sfn_t)(char *str, size_t len, const void *);
+int gvotable_v2s_int(char *str,  size_t len, const void *vote);
+int gvotable_v2s_uint(char *str, size_t len, const void *vote);
+int gvotable_v2s_uint_hex(char *str, size_t len, const void *vote);
+void gvotable_set_vote2str(struct gvotable_election *el,
+			   gvotable_v2sfn_t vote2str);
+int gvotable_disable_force_int_entry(struct gvotable_election *el);
+
+#endif /* __GOOGLE_GVOTABLE_H_*/
diff --git a/drivers/soc/qcom/misc/logbuffer.h b/drivers/soc/qcom/misc/logbuffer.h
new file mode 100644
index 000000000000..f05ec34ac5b5
--- /dev/null
+++ b/drivers/soc/qcom/misc/logbuffer.h
@@ -0,0 +1,27 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Copyright 2019-2022 Google LLC
+ */
+
+#ifndef __GOOGLE_LOGBUFFER_H_
+#define __GOOGLE_LOGBUFFER_H_
+
+#include <linux/stdarg.h>
+
+struct logbuffer;
+
+void logbuffer_log(struct logbuffer *instance, const char *fmt, ...);
+void logbuffer_logk(struct logbuffer *instance, int loglevel, const char *fmt, ...);
+void logbuffer_vlog(struct logbuffer *instance, const char *fmt,
+		    va_list args);
+/*
+ * Registers a new log buffer entry.
+ * param name: name of the file in the /d/logbuffer/ directory.
+ * returns the pointer to the logbuffer metadata.
+ */
+struct logbuffer *logbuffer_register(const char *name);
+
+void logbuffer_unregister(struct logbuffer *instance);
+
+#endif /* __GOOGLE_LOGBUFFER_H_ */
+
diff --git a/drivers/soc/qcom/p9221-dt-bindings.h b/drivers/soc/qcom/p9221-dt-bindings.h
new file mode 100644
index 000000000000..bfe59040ccc2
--- /dev/null
+++ b/drivers/soc/qcom/p9221-dt-bindings.h
@@ -0,0 +1,13 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Copyright (C) 2019 Google LLC.
+ *
+ */
+
+#ifndef _DT_BINDINGS_WC_P9221_WC_H
+#define _DT_BINDINGS_WC_P9221_WC_H
+
+#define P9221_WC_DC_RESET_VOUTCHANGED		1
+#define P9221_WC_DC_RESET_MODECHANGED		2
+
+#endif /* _DT_BINDINGS_POWER_MT7622_POWER_H */
diff --git a/drivers/soc/qcom/p9221_charger.h b/drivers/soc/qcom/p9221_charger.h
new file mode 100644
index 000000000000..8a7dd209fa10
--- /dev/null
+++ b/drivers/soc/qcom/p9221_charger.h
@@ -0,0 +1,977 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * P9221 Wireless Charger Driver
+ *
+ * Copyright (C) 2017 Google, LLC.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ */
+#ifndef __P9221_CHARGER_H__
+#define __P9221_CHARGER_H__
+
+#include <linux/gpio.h>
+#include <linux/crc8.h>
+#include <misc/gvotable.h>
+#include "gbms_power_supply.h"
+
+#define P9221_WLC_VOTER				"WLC_VOTER"
+#define P9221_USER_VOTER			"WLC_USER_VOTER"
+#define P9221_OCP_VOTER				"OCP_VOTER"
+#define DCIN_AICL_VOTER				"DCIN_AICL_VOTER"
+#define P9382A_RTX_VOTER			"RTX_VOTER"
+#define THERMAL_DAEMON_VOTER			"THERMAL_DAEMON_VOTER"
+#define HPP_DC_ICL_VOTER			"HPP_VOTER"
+#define DD_VOTER				"DD_VOTER"
+#define AUTH_DC_ICL_VOTER			"AUTH_VOTER"
+#define CPOUT_EN_VOTER				"CPOUT_EN_VOTER"
+#define LL_BPP_CEP_VOTER			"LL_BPP_CEP_VOTER"
+#define P9221_RAMP_VOTER			"WLC_RAMP_VOTER"
+#define P9221_HPP_VOTER				"EPP_HPP_VOTER"
+#define WLC_MFG_GOOGLE				0x72
+#define P9221_DC_ICL_BPP_UA			700000
+#define P9221_DC_ICL_BPP_RAMP_DEFAULT_UA	900000
+#define P9221_DC_ICL_BPP_RAMP_DELAY_DEFAULT_MS	(7 * 60 * 1000)  /* 7 mins */
+#define P9221_DC_ICL_EPP_UA			1100000
+#define P9221_DC_ICL_HPP_UA			500000
+#define P9221_DC_ICL_RTX_UA			600000
+#define P9XXX_SW_RAMP_ICL_START_UA		125000
+#define P9XXX_SW_RAMP_ICL_STEP_UA		100000
+#define P9XXX_CDMODE_ENABLE_ICL_UA		200000
+#define P9221_AUTH_DC_ICL_UA_500		500000
+#define P9221_LL_BPP_CHG_TERM_UA		200000
+#define P9221_EPP_THRESHOLD_UV			7000000
+#define P9221_MAX_VOUT_SET_MV_DEFAULT		9000
+#define P9221_VOUT_SET_MIN_MV			3500
+#define P9221_VOUT_SET_MAX_MV			29000
+#define P9221_RX_ILIM_MIN_MA			200
+#define P9221_RX_ILIM_MAX_MA			1600
+#define P9222_RX_ILIM_MIN_MA			100
+#define P9222_RX_ILIM_MAX_MA			1500
+#define P9382A_RTX_ICL_MAX_MA			1350
+#define P9221R5_OVER_CHECK_NUM			3
+
+#define P9412_VOUT_SET_MIN_MV			3520
+#define P9412_VOUT_SET_MAX_MV			20000
+#define P9412_RX_ILIM_MAX_MA			1900
+
+#define P9221_TX_TIMEOUT_MS			(20 * 1000)
+#define P9221_DCIN_TIMEOUT_MS			(1 * 1000)
+#define P9221_CHARGE_STATS_TIMEOUT_MS		(10 * 1000)
+#define P9221_VRECT_TIMEOUT_MS			(2 * 1000)
+#define P9221_ALIGN_TIMEOUT_MS			(2 * 1000)
+#define P9221_ALIGN_DELAY_MS			100
+#define P9221_NOTIFIER_DELAY_MS			100
+#define P9221_DCIN_PON_DELAY_MS			250
+#define P9221R5_ILIM_MAX_UA			(1600 * 1000)
+
+#define P9221_CHECK_NP_DELAY_MS		50
+#define P9221_NEG_POWER_5W		(5 * 2)
+#define P9221_NEG_POWER_10W		(10 * 2)
+#define P9221_PTMC_EPP_TX_1912		0x32
+#define P9221_PTMC_EPP_TX_4191		0x50
+
+#define P9222_RX_CALIBRATION_LIGHT_LOAD	0x5831
+#define P9222_LIGHT_LOAD_VALUE		0x0C
+
+#define P9221_DCIN_RETRY_DELAY_MS	50
+
+#define P9XXX_DC_ICL_EPP_1000		1000000
+#define P9XXX_DC_ICL_EPP_750		750000
+#define P9XXX_DC_ICL_EPP_100		100000
+#define P9XXX_NEG_POWER_10W		(10 * 2)
+#define P9XXX_NEG_POWER_11W		(11 * 2)
+#define P9XXX_TX_GUAR_PWR_15W		(15 * 2)
+#define P9382_RTX_TIMEOUT_MS		(2 * 1000)
+#define WLCDC_DEBOUNCE_TIME_S		400
+#define WLCDC_AUTH_CHECK_S		15
+#define WLCDC_AUTH_CHECK_INTERVAL_MS	(2 * 1000)
+#define WLCDC_AUTH_CHECK_INIT_DELAY_MS	(6 * 1000)
+
+/*
+ * P9221 common registers
+ */
+#define P9221_CHIP_ID_REG			0x00
+#define P9221_CHIP_ID				0x9220
+#define P9221_CHIP_REVISION_REG			0x02
+#define P9221_CUSTOMER_ID_REG			0x03
+#define P9221R5_CUSTOMER_ID_VAL			0x05
+#define P9221_OTP_FW_MAJOR_REV_REG		0x04
+#define P9221_OTP_FW_MINOR_REV_REG		0x06
+#define P9221_OTP_FW_DATE_REG			0x08
+#define P9221_OTP_FW_DATE_SIZE			12
+#define P9221_OTP_FW_TIME_REG			0x14
+#define P9221_OTP_FW_TIME_SIZE			8
+#define P9221_SRAM_FW_MAJOR_REV_REG		0x1C
+#define P9221_SRAM_FW_MINOR_REV_REG		0x1E
+#define P9221_SRAM_FW_DATE_REG			0x20
+#define P9221_SRAM_FW_DATE_SIZE			12
+#define P9221_SRAM_FW_TIME_REG			0x2C
+#define P9221_SRAM_FW_TIME_SIZE			8
+#define P9221_STATUS_REG			0x34
+#define P9221_INT_REG				0x36
+#define P9221_INT_MASK				0xF7
+#define P9221_INT_ENABLE_REG			0x38
+#define P9221_COM_REG				0x4E
+
+
+/*
+ * P9221R5 unique registers
+ */
+#define P9221R5_INT_CLEAR_REG			0x3A
+#define P9221R5_VOUT_SET_REG			0x3C
+#define P9221R5_ILIM_SET_REG			0x3D
+#define P9221R5_ILIM_SET_MAX			0x0E	/* 0x0E = 1.6A */
+#define P9221R5_CHARGE_STAT_REG			0x3E
+#define P9221R5_EPT_REG				0x3F
+#define P9221R5_VRECT_REG			0x40
+#define P9221R5_VOUT_REG			0x42
+#define P9221R5_IOUT_REG			0x44
+#define P9221R5_OP_FREQ_REG			0x48
+#define P9221R5_SYSTEM_MODE_REG			0x4C
+#define P9221R5_COM_CHAN_RESET_REG		0x50
+#define P9221R5_COM_CHAN_SEND_SIZE_REG		0x58
+#define P9221R5_COM_CHAN_SEND_IDX_REG		0x59
+#define P9221R5_COM_CHAN_RECV_SIZE_REG		0x5A
+#define P9221R5_COM_CHAN_RECV_IDX_REG		0x5B
+#define P9221R5_VRECT_ADC_REG			0x60
+#define P9221R5_VOUT_ADC_REG			0x62
+#define P9221R5_VOUT_ADC_MASK			0xFFF
+#define P9221R5_IOUT_ADC_REG			0x64
+#define P9221R5_IOUT_ADC_MASK			0xFFF
+#define P9221R5_DIE_TEMP_ADC_REG		0x66
+#define P9221R5_DIE_TEMP_ADC_MASK		0xFFF
+#define P9221R5_AC_PERIOD_REG			0x68
+#define P9221R5_TX_PINGFREQ_REG			0x6A
+#define P9221R5_EXT_TEMP_REG			0x6C
+#define P9221R5_EXT_TEMP_MASK			0xFFF
+#define P9221R5_FOD_REG				0x70
+#define P9221R5_NUM_FOD				16
+#define P9221R5_DEBUG_REG			0x80
+#define P9221R5_EPP_Q_FACTOR_REG		0x83
+#define P9221R5_EPP_TX_GUARANTEED_POWER_REG	0x84
+#define P9221R5_EPP_TX_POTENTIAL_POWER_REG	0x85
+#define P9221R5_EPP_TX_CAPABILITY_FLAGS_REG	0x86
+#define P9221R5_EPP_TX_CAPABILITY_FLAGS_AR	BIT(6)
+#define P9221R5_EPP_RENEGOTIATION_REG		0x87
+#define P9221R5_EPP_CUR_RPP_HEADER_REG		0x88
+#define P9221R5_EPP_CUR_NEGOTIATED_POWER_REG	0x89
+#define P9221R5_EPP_CUR_MAXIMUM_POWER_REG	0x8A
+#define P9221R5_EPP_CUR_FSK_MODULATION_REG	0x8B
+#define P9221R5_EPP_REQ_RPP_HEADER_REG		0x8C
+#define P9221R5_EPP_REQ_NEGOTIATED_POWER_REG	0x8D
+#define P9221R5_EPP_REQ_MAXIMUM_POWER_REG	0x8E
+#define P9221R5_EPP_REQ_FSK_MODULATION_REG	0x8F
+#define P9221R5_VRECT_TARGET_REG		0x90
+#define P9221R5_VRECT_KNEE_REG			0x92
+#define P9221R5_VRECT_CORRECTION_FACTOR_REG	0x93
+#define P9221R5_VRECT_MAX_CORRECTION_FACTOR_REG	0x94
+#define P9221R5_VRECT_MIN_CORRECTION_FACTOR_REG	0x96
+#define P9221R5_FOD_SECTION_REG			0x99
+#define P9221R5_VRECT_ADJ_REG			0x9E
+#define P9221R5_ALIGN_X_ADC_REG			0xA0
+#define P9221R5_ALIGN_Y_ADC_REG			0xA1
+#define P9221R5_ASK_MODULATION_DEPTH_REG	0xA2
+#define P9221R5_OVSET_REG			0xA3
+#define P9221R5_OVSET_MASK			0x7
+#define P9221R5_EPP_TX_SPEC_REV_REG		0xA9
+#define P9221R5_EPP_TX_MFG_CODE_REG		0xAA
+#define P9221R5_GP0_RESET_VOLT_REG		0xAC
+#define P9221R5_GP1_RESET_VOLT_REG		0xAE
+#define P9221R5_GP2_RESET_VOLT_REG		0xB0
+#define P9221R5_GP3_RESET_VOLT_REG		0xB2
+#define P9221R5_PROP_TX_ID_REG			0xB4
+#define P9221R5_PROP_TX_ID_SIZE			4
+#define P9221R5_DATA_SEND_BUF_START		0x100
+#define P9221R5_DATA_SEND_BUF_SIZE		0x80
+#define P9221R5_DATA_RECV_BUF_START		0x180
+#define P9221R5_DATA_RECV_BUF_SIZE		0x80
+#define P9221R5_MAX_PP_BUF_SIZE			16
+#define P9221R5_LAST_REG			0x1FF
+
+/*
+ * System Mode Mask (R5+/0x4C)
+ */
+#define P9221R5_SYSTEM_MODE_EXTENDED_MASK	(1 << 3)
+
+/*
+ * Com Channel Commands
+ */
+#define P9221R5_COM_CHAN_CCRESET		BIT(7)
+#define P9221_COM_CHAN_RETRIES			5
+
+/*
+ * End of Power packet types
+ */
+#define P9221_EOP_UNKNOWN			0x00
+#define P9221_EOP_EOC				0x01
+#define P9221_EOP_INTERNAL_FAULT		0x02
+#define P9221_EOP_OVER_TEMP			0x03
+#define P9221_EOP_OVER_VOLT			0x04
+#define P9221_EOP_OVER_CURRENT			0x05
+#define P9221_EOP_BATT_FAIL			0x06
+#define P9221_EOP_RECONFIG			0x07
+#define P9221_EOP_NO_RESPONSE			0x08
+#define P9221_EOP_NEGOTIATION_FAIL		0x0A
+#define P9221_EOP_RESTART_POWER			0x0B
+#define P9221_EOP_REVERT_TO_BPP			0xF3
+
+/*
+ * Command flags
+ */
+#define P9221R5_COM_RENEGOTIATE			P9221_COM_RENEGOTIATE
+#define P9221R5_COM_SWITCH2RAM			P9221_COM_SWITCH_TO_RAM_MASK
+#define P9221R5_COM_CLRINT			P9221_COM_CLEAR_INT_MASK
+#define P9221R5_COM_SENDCSP			P9221_COM_SEND_CHG_STAT_MASK
+#define P9221R5_COM_SENDEPT			P9221_COM_SEND_EOP_MASK
+#define P9221R5_COM_LDOTGL			P9221_COM_LDO_TOGGLE
+#define P9221R5_COM_CCACTIVATE			BIT(0)
+
+#define P9221_COM_RENEGOTIATE			BIT(7)
+#define P9221_COM_SWITCH_TO_RAM_MASK		BIT(6)
+#define P9221_COM_CLEAR_INT_MASK		BIT(5)
+#define P9221_COM_SEND_CHG_STAT_MASK		BIT(4)
+#define P9221_COM_SEND_EOP_MASK			BIT(3)
+#define P9221_COM_LDO_TOGGLE			BIT(1)
+
+/*
+ * Interrupt/Status flags for P9221
+ */
+#define P9221_STAT_VOUT				BIT(7)
+#define P9221_STAT_VRECT			BIT(6)
+#define P9221_STAT_ACMISSING			BIT(5)
+#define P9221_STAT_OV_TEMP			BIT(2)
+#define P9221_STAT_OV_VOLT			BIT(1)
+#define P9221_STAT_OV_CURRENT			BIT(0)
+#define P9221_STAT_LIMIT_MASK			(P9221_STAT_OV_TEMP | \
+						 P9221_STAT_OV_VOLT | \
+						 P9221_STAT_OV_CURRENT)
+/*
+ * Interrupt/Status flags for P9221R5
+ */
+#define P9221R5_STAT_CCRESET			BIT(12)
+#define P9221R5_STAT_CCERROR			BIT(11)
+#define P9221R5_STAT_PPRCVD			BIT(10)
+#define P9221R5_STAT_CCDATARCVD			BIT(9)
+#define P9221R5_STAT_CCSENDBUSY			BIT(8)
+#define P9221R5_STAT_VOUTCHANGED		BIT(7)
+#define P9221R5_STAT_VRECTON			BIT(6)
+#define P9221R5_STAT_MODECHANGED		BIT(5)
+#define P9221R5_STAT_UV				BIT(3)
+#define P9221R5_STAT_OVT			BIT(2)
+#define P9221R5_STAT_OVV			BIT(1)
+#define P9221R5_STAT_OVC			BIT(0)
+#define P9221R5_STAT_MASK			0x1FFF
+#define P9221R5_STAT_CC_MASK			(P9221R5_STAT_CCRESET | \
+						 P9221R5_STAT_PPRCVD | \
+						 P9221R5_STAT_CCERROR | \
+						 P9221R5_STAT_CCDATARCVD | \
+						 P9221R5_STAT_CCSENDBUSY)
+#define P9221R5_STAT_LIMIT_MASK			(P9221R5_STAT_UV | \
+						 P9221R5_STAT_OVV | \
+						 P9221R5_STAT_OVT | \
+						 P9221R5_STAT_OVC)
+
+/*
+ * P9221R5_SYSTEM_MODE_REG bits.
+ */
+#define P9221R5_MODE_RAMCODE			BIT(6)
+#define P9221R5_MODE_EEPROMCODE			BIT(5)
+#define P9221R5_MODE_EXTENDED			BIT(3)
+#define P9221R5_MODE_WPCMODE			BIT(0)
+
+/*
+ * P9222 unique registers
+ */
+#define P9222_CHIP_ID				0x9222
+#define P9222RE_SYSTEM_MODE_REG			0x3F
+#define P9222RE_CHARGE_STAT_REG			0x4E
+#define P9222RE_EPT_REG				0x4F
+#define P9222RE_VOUT_REG			0x50
+#define P9222RE_VOUT_SET_REG			0x52
+#define P9222RE_VRECT_REG			0x54
+#define P9222RE_IOUT_REG			0x58
+#define P9222RE_DIE_TEMP_REG			0x5A
+#define P9222RE_OP_FREQ_REG			0x5C
+#define P9222RE_TX_PINGFREQ_REG			0x5E
+#define P9222RE_ILIM_SET_REG			0x60
+#define P9222RE_COM_REG				0x62
+#define P9222RE_FOD_REG				0x84
+#define P9222RE_COM_CHAN_RECV_SIZE_REG		0x98
+#define P9222RE_EPP_TX_GUARANTEED_POWER_REG	0xB4
+#define P9222RE_EPP_REQ_NEGOTIATED_POWER_REG	0xBD
+#define P9222RE_EPP_REQ_MAXIMUM_POWER_REG	0xBE
+#define P9222RE_EPP_Q_FACTOR_REG		0xD2
+#define P9222RE_TX_MFG_CODE_REG			0x106
+#define P9222RE_PROP_TX_ID_REG			0x118
+#define P9222RE_DIE_TEMP_ADC_REG		0x12A
+#define P9222RE_COM_PACKET_TYPE_ADDR		0x600
+#define P9222RE_COM_CHAN_SEND_SIZE_REG		0x601
+#define P9222RE_DATA_BUF_START			0x604
+#define P9222RE_DATA_BUF_SIZE			0x100
+
+#define P9222RE_COM_CCACTIVATE			BIT(9)
+
+/*
+ * P9222 SYSTEM_MODE_REG bits
+ */
+#define P9222_SYS_OP_MODE_WPC_BASIC		BIT(5)
+#define P9222_SYS_OP_MODE_WPC_EXTD		BIT(6)
+
+#define P9222_VOUT_SET_MIN_MV			3500
+#define P9222_VOUT_SET_MAX_MV			12500
+#define P9222_NEG_POWER_10W			10000
+
+/*
+ * Interrupt/Status flags for P9222
+ */
+#define P9222_STAT_CCERROR			BIT(0)
+#define P9222_STAT_OVT				BIT(2)
+#define P9222_STAT_OVC				BIT(3)
+#define P9222_STAT_OVV				BIT(4)
+#define P9222_EXTENDED_MODE			BIT(12)
+#define P9222_STAT_PPRCVD			BIT(15)
+
+/*
+ * P9382 unique registers
+ */
+#define P9382A_I2C_ADDRESS			0x3b
+
+#define P9382A_CHIP_ID				0x9381 /* FIXME: b/146316852 */
+#define P9382A_DATA_SEND_BUF_START		0x130
+#define P9382A_DATA_RECV_BUF_START		0x1B0
+
+#define P9382A_STATUS_REG			0x34
+#define P9382A_CHARGE_STAT_REG			0x3E
+#define P9382A_ILIM_SET_REG			0x4A
+#define P9382A_TRX_ENABLE_REG			0x69
+#define P9382A_TX_INHIBIT			0x3
+
+#define P9382A_MODE_TXMODE			BIT(2)
+
+#define P9382_PROP_TX_ID_REG			0xC4
+#define P9382_EPP_TX_MFG_CODE_REG		0xBA
+#define P9382A_FW_REV_25			0x25
+
+/*
+ * Interrupt/Status flags for P9382
+ */
+#define P9382_STAT_HARD_OCP			BIT(1)
+#define P9382_STAT_TXCONFLICT			BIT(3)
+#define P9382_STAT_CSP				BIT(4)
+#define P9382_STAT_TXUVLO			BIT(6)
+#define P9382_STAT_RXCONNECTED			BIT(10)
+#define P9382_STAT_TXUNDERPOWER			BIT(12)
+#define P9382_STAT_TXFOD			BIT(13)
+#define P9382_STAT_RTX_MASK			(P9221R5_STAT_LIMIT_MASK | \
+						 P9221R5_STAT_MODECHANGED | \
+						 P9221R5_STAT_VOUTCHANGED | \
+						 P9382_STAT_TXCONFLICT | \
+						 P9382_STAT_CSP | \
+						 P9382_STAT_TXUVLO | \
+						 P9382_STAT_RXCONNECTED | \
+						 P9382_STAT_TXUNDERPOWER | \
+						 P9382_STAT_TXFOD)
+/*
+ * Send communication message
+ */
+#define P9382A_COM_PACKET_TYPE_ADDR		0x100
+#define P9382A_COM_CHAN_SEND_SIZE_REG		0x101
+#define BIDI_COM_PACKET_TYPE			0x98
+#define PROPRIETARY_PACKET_TYPE			0x80
+#define CHANNEL_RESET_PACKET_TYPE		0xA8
+#define FAST_SERIAL_ID_HEADER			0x4F
+#define FAST_SERIAL_ID_SIZE			4
+#define ACCESSORY_TYPE_MASK			0x7
+#define CHARGE_STATUS_PACKET_HEADER		0x48
+#define CHARGE_STATUS_PACKET_SIZE		4
+#define PP_TYPE_POWER_CONTROL			0x08
+#define PP_SUBTYPE_SOC				0x10
+#define ACCESSORY_TYPE_PHONE			BIT(2)
+#define AICL_ENABLED				BIT(7)
+#define TX_ACCESSORY_TYPE			(ACCESSORY_TYPE_PHONE | \
+						 AICL_ENABLED)
+#define TXID_SEND_DELAY_MS			(1 * 1000)
+#define TXID_SEND_AGAIN_DELAY_MS		(300 * 1000)
+#define TXSOC_SEND_DELAY_MS			(5 * 1000)
+
+#define COM_BUSY_MAX				10
+/*
+ * P9412 unique registers
+ */
+#define P9412_CHIP_ID				0x9412
+
+/* P9221R5_SYSTEM_MODE_REG(0x4C) values for P9412 */
+#define P9XXX_SYS_OP_MODE_AC_MISSING		0x00 /* AC Missing */
+#define P9XXX_SYS_OP_MODE_WPC_BASIC		0x01 /* WPC Basic Protocol */
+#define P9XXX_SYS_OP_MODE_WPC_EXTD		0x02 /* WPC Extended Protocol */
+#define P9XXX_SYS_OP_MODE_PROPRIETARY		0x03 /* Renesas Prop. Protocol */
+#define P9XXX_SYS_OP_MODE_TX_MODE		0x08 /* TX Mode */
+#define P9XXX_SYS_OP_MODE_TX_FOD		0x09 /* TX FOD (Stop) */
+
+#define P9412_TX_CMD_REG			0x4D
+#define P9412_TX_I_API_LIM_REG			0x56
+#define P9412_ALIGN_X_REG			0xB0 /* 1 byte 8 bit raw */
+#define P9412_ALIGN_Y_REG			0xB1 /* 1 byte 8 bit raw */
+#define P9412_EPP_CAL_STATE_REG			0xB8
+#define P9412_PROP_TX_POTEN_PWR_REG		0xC4
+#define P9412_PROP_REQ_PWR_REG			0xC5
+#define P9412_PROP_CURR_PWR_REG			0xC6
+#define P9412_PROP_MODE_PWR_STEP_REG		0xC7
+#define P9412_PROP_MODE_STATUS_REG		0xC8
+#define P9412_PROP_MODE_ERR_STS_REG		0xC9
+#define P9412_VOUT_SET_REG			0x6C /* 2 byte 10 mV */
+#define P9412_DIE_TEMP_REG			0x46 /* 2 byte in C */
+#define P9412_V5P0AP_SWITCH_REG			0x81
+#define V5P0AP_SWITCH_EN			BIT(7)
+
+#define P9412_CMFET_L_REG			0xF4
+#define P9412_CDMODE_STS_REG			0x100
+#define P9412_CDMODE_REQ_REG			0x101
+#define P9412_HIVOUT_CMFET_REG			0x11B
+#define P9412_COM_CHAN_RESET_REG		0x13F
+#define P9412_COM_PACKET_TYPE_ADDR		0x800
+#define P9412_COM_CHAN_SEND_SIZE_REG		0x801
+#define P9412_COM_CHAN_SEND_IDX_REG		0x142
+#define P9412_COM_CHAN_RECV_SIZE_REG		0x144
+#define P9412_COM_CHAN_RECV_IDX_REG		0x146
+#define P9412_COM_CHAN_STATUS_REG		0x148
+#define P9412_PROP_TX_ID_REG			0x154
+
+#define P9412_DATA_BUF_START			0x804
+#define P9412_DATA_BUF_SIZE			0x7FC /* 2044 bytes */
+#define P9412_PP_SEND_BUF_START			0x50
+#define P9412_PP_RECV_BUF_START			0x58
+
+#define P9412_RN_MAX_POLL_ATTEMPTS		5
+#define P9412_RN_DELAY_MS			50
+#define P9412_RN_STATUS_DONE			BIT(1)
+#define P9412_RN_STATUS_ERROR			BIT(2)
+
+#define P9XXX_INVALID_REG			0xFFFF
+#define P9XXX_INT_CLEAR_MASK			0xFFFF
+
+#define P9412_TX_CMD_TX_MODE_EN			BIT(7)
+/* For Cap Div mode register */
+#define CDMODE_BYPASS_MODE			BIT(0)
+#define CDMODE_CAP_DIV_MODE			BIT(1)
+/* For cmd register */
+#define INIT_CAP_DIV_CMD			BIT(6)
+#define PROP_MODE_EN_CMD			BIT(8)
+#define PROP_REQ_PWR_CMD			BIT(9)
+#define P9412_COM_CCACTIVATE			BIT(10)
+/* For tx cmd register */
+#define P9412_CMD_TXMODE_EXIT			BIT(9)
+/* For INT status register */
+#define P9412_STAT_PPRCVD			BIT(15)
+#define P9412_CDMODE_ERROR_INT			BIT(14)
+#define P9412_PROP_MODE_STAT_INT		BIT(12)
+#define P9412_CDMODE_CHANGE_INT			BIT(11)
+#define P9412_STAT_CCSENDBUSY			BIT(8)
+#define P9412_STAT_CCDATARCVD			BIT(9)
+#define P9412_STAT_CCERROR			BIT(0)
+#define P9412_STAT_OVV				BIT(4)
+#define P9412_STAT_OVC				BIT(3)
+#define P9412_STAT_OVT				BIT(2)
+#define P9412_STAT_OCP_PING			BIT(12)
+#define P9412_STAT_RXCONNECTED			BIT(11)
+#define P9412_STAT_PPPSENT			BIT(9)
+#define P9412_STAT_CSP				BIT(10)
+#define P9412_STAT_TXCONFLICT			BIT(1)
+/* EPT code */
+#define EPT_END_OF_CHARGE			BIT(0)
+/* EPP calibration state */
+#define P9412_CAL_STATE_1			BIT(1)
+#define P9412_CAL_STATE_2			BIT(3)
+#define P9412_EPP_CAL_STATE_MASK		(P9412_CAL_STATE_1 | \
+						 P9412_CAL_STATE_2)
+/* Rx Communication Modulation FET(CMFET) */
+#define P9412_CMFET_DISABLE_ALL			(0xF0) /* CM-A/B-1/2: REG[7:4]=0b1111 */
+
+#define P9221_CRC8_POLYNOMIAL			0x07    /* (x^8) + x^2 + x + 1 */
+#define P9412_ADT_TYPE_AUTH			0x02
+
+#define P9XXX_CHARGER_FEATURE_CACHE_SIZE	32
+#define HPP_MODE_PWR_REQUIRE			23
+
+#define RTX_RESET_COUNT_MAX			3
+
+/* p9412 AP BOOST PING register */
+#define P9412_APBSTPING_REG			0xF0
+#define P9412_APBSTCONTROL_REG			0xF1
+#define P9412_APBSTPING_7V			BIT(0)
+#define P9412_TXOCP_REG				0xA0
+#define P9412_TXOCP_1400MA			1400
+#define P9412_PLIM_REG				0x3D
+#define P9412_PLIM_1200MA			0x0E
+
+#define P9412_MOT_REG				0xD0
+#define P9412_MOT_40PCT				0x10
+#define P9412_MOT_65PCT				0x1A
+
+#define P9412_MOT_REG				0xD0
+#define P9412_MOT_40PCT				0x10
+#define P9412_MOT_65PCT				0x1A
+
+/* Features */
+typedef enum {
+    WLCF_DISABLE_ALL_FEATURE     = 0x00,
+    WLCF_DREAM_ALIGN             = 0x01,
+    WLCF_DREAM_DEFEND            = 0x02,
+    WLCF_FAST_CHARGE             = 0x04,
+    WLCF_CHARGE_15W              = 0x08,
+} wlc_features_t;
+
+/* for DD */
+#define TXID_TYPE_MASK			0xFF000000 /* bit[24-31] */
+#define TXID_TYPE_SHIFT			24
+#define TXID_DD_TYPE			0xE0
+#define TXID_DD_TYPE2			0xA0
+#define P9221_POWER_MITIGATE_DELAY_MS   (10 * 1000)
+#define P9221_FOD_MAX_TIMES             3
+
+enum p9221_align_mfg_chk_state {
+	ALIGN_MFG_FAILED = -1,
+	ALIGN_MFG_CHECKING,
+	ALIGN_MFG_PASSED,
+};
+
+enum p9xxx_chk_rp {
+	RP_NOTSET = -1,
+	RP_CHECKING,
+	RP_DONE,
+};
+
+#define WLC_SOC_STATS_LEN      101
+
+struct p9221_soc_data {
+	ktime_t last_update;
+	int elapsed_time;
+	int pout_min;
+	int pout_max;
+	int of_freq;
+	int alignment;
+	int vrect;
+	int iout;
+	int die_temp;
+	int sys_mode;
+	long pout_sum;
+};
+
+struct p9221_charge_stats {
+	struct mutex stats_lock;
+	ktime_t start_time;
+	struct p9221_soc_data soc_data[WLC_SOC_STATS_LEN];
+	int adapter_type;
+	int cur_soc;
+	int volt_conf;
+	int cur_conf;
+	int of_freq;
+	int last_soc;
+
+	u32 adapter_capabilities[5];
+	u32 receiver_state[2];
+};
+
+struct p9221_charger_feature_entry {
+	u64 quickid;
+	u64 features;
+	u32 last_use;
+};
+
+struct p9221_charger_feature {
+	struct mutex	feat_lock;
+
+	struct p9221_charger_feature_entry entries[P9XXX_CHARGER_FEATURE_CACHE_SIZE];
+	int num_entries;
+	u32 age;
+
+	u64 session_features;
+	bool session_valid;
+};
+
+struct p9221_charger_cc_data_lock {
+	bool cc_use;
+	ktime_t cc_rcv_at;
+};
+
+struct p9221_charger_platform_data {
+	int				irq_gpio;
+	int				irq_int;
+	int				irq_det_gpio;
+	int				irq_det_int;
+	int				qien_gpio;
+	int				slct_gpio;
+	int				slct_value;
+	int				ben_gpio;
+	int                             ext_ben_gpio;
+	int				switch_gpio;
+	int				boost_gpio;
+	int				dc_switch_gpio;
+	int				qi_vbus_en;
+	int				qi_vbus_en_act_low;
+	int				wlc_en;
+	int				wlc_en_act_low;
+	int				max_vout_mv;
+	int				epp_vout_mv;
+	u8				fod[P9221R5_NUM_FOD];
+	u8				fod_epp[P9221R5_NUM_FOD];
+	u8				fod_epp_comp[P9221R5_NUM_FOD];
+	u8				fod_hpp[P9221R5_NUM_FOD];
+	u8				fod_hpp_hv[P9221R5_NUM_FOD];
+	int				fod_num;
+	int				fod_epp_num;
+	int				fod_epp_comp_num;
+	int				fod_hpp_num;
+	int				fod_hpp_hv_num;
+	bool				fod_fsw;
+	int				fod_fsw_high;
+	int				fod_fsw_low;
+	int				q_value;
+	int				tx_4191q;
+	int				epp_rp_value;
+	int				epp_rp_low_value;
+	int				needs_dcin_reset;
+	int				nb_alignment_freq;
+	int				*alignment_freq;
+	u32				alignment_scalar;
+	u32				alignment_hysteresis;
+	u32				icl_ramp_delay_ms;
+	u16				chip_id;
+	bool				has_wlc_dc;
+	bool				has_rtx;
+	u32				power_mitigate_threshold;
+	u32				alignment_scalar_low_current;
+	u32				alignment_scalar_high_current;
+	u32				alignment_offset_low_current;
+	u32				alignment_offset_high_current;
+	u32				alignment_current_threshold;
+	bool				feat_compat_mode;
+	bool				apbst_en;
+	bool				has_sw_ramp;
+	bool				hw_ocp_det;
+	/* phone type for tx_id*/
+	u8				phone_type;
+	u32				epp_icl;
+	/* calibrate light load */
+	bool				light_load;
+};
+
+struct p9221_charger_ints_bit {
+	/* Rx mode */
+	u16				over_curr_bit;
+	u16				over_volt_bit;
+	u16				over_temp_bit;
+	u16				over_uv_bit;
+	u16				mode_changed_bit;
+	u16				vrecton_bit;
+	u16				vout_changed_bit;
+	u16				cc_send_busy_bit;
+	u16				cc_data_rcvd_bit;
+	u16				pp_rcvd_bit;
+	u16				cc_error_bit;
+	u16				cc_reset_bit;
+	u16				propmode_stat_bit;
+	u16				cdmode_change_bit;
+	u16				cdmode_err_bit;
+	u16				stat_limit_mask;
+	u16				stat_cc_mask;
+	u16				prop_mode_mask;
+	u16				extended_mode_bit;
+	/* Tx mode */
+	u16				hard_ocp_bit;
+	u16				tx_conflict_bit;
+	u16				csp_bit;
+	u16				rx_connected_bit;
+	u16				tx_fod_bit;
+	u16				tx_underpower_bit;
+	u16				tx_uvlo_bit;
+	u16				pppsent_bit;
+	u16				ocp_ping_bit;
+	u16				stat_rtx_mask;
+};
+
+struct p9221_charger_data {
+	struct i2c_client		*client;
+	struct p9221_charger_platform_data *pdata;
+	struct p9221_charger_ints_bit	ints;
+	struct power_supply		*wc_psy;
+	struct power_supply		*dc_psy;
+	struct power_supply		*fg_psy;
+	struct gvotable_election	*dc_icl_votable;
+	struct gvotable_election	*dc_suspend_votable;
+	struct gvotable_election	*tx_icl_votable;
+	struct gvotable_election	*disable_dcin_en_votable;
+	struct gvotable_election	*chg_mode_votable;
+	struct gvotable_election	*wlc_disable_votable;
+	struct gvotable_election	*csi_status_votable;
+	struct notifier_block		nb;
+	struct mutex			io_lock;
+	struct mutex			cmd_lock;
+	struct device			*dev;
+	struct delayed_work		notifier_work;
+	struct delayed_work		charge_stats_work;
+	struct delayed_work		dcin_work;
+	struct delayed_work		align_work;
+	struct delayed_work		tx_work;
+	struct delayed_work		icl_ramp_work;
+	struct delayed_work		txid_work;
+	struct delayed_work		rtx_work;
+	struct delayed_work		power_mitigation_work;
+	struct delayed_work		auth_dc_icl_work;
+	struct delayed_work		fg_work;
+	struct delayed_work		chk_rp_work;
+	struct delayed_work		chk_rtx_ocp_work;
+	struct delayed_work		chk_fod_work;
+	struct work_struct		uevent_work;
+	struct work_struct		rtx_disable_work;
+	struct work_struct		rtx_reset_work;
+	struct alarm			icl_ramp_alarm;
+	struct alarm			auth_dc_icl_alarm;
+	struct timer_list		vrect_timer;
+	struct timer_list		align_timer;
+	struct bin_attribute		bin;
+	struct logbuffer		*log;
+	struct logbuffer		*rtx_log;
+	struct dentry			*debug_entry;
+	struct p9221_charger_feature	chg_features;
+	struct p9221_charger_cc_data_lock	cc_data_lock;
+	struct wakeup_source		*align_ws;
+	u16				chip_id;
+	int				online;
+	bool				enabled;
+	bool				disable_irq;
+	u16				addr;
+	u8				count;
+	u8				cust_id;
+	int				ben_state;
+	u8				pp_buf[P9221R5_MAX_PP_BUF_SIZE];
+	char				pp_buf_str[P9221R5_MAX_PP_BUF_SIZE * 3 + 1];
+	bool				pp_buf_valid;
+	u8				*rx_buf;
+	size_t				rx_buf_size;
+	u16				rx_len;
+	bool				rx_done;
+	u8				*tx_buf;
+	char				fast_id_str[FAST_SERIAL_ID_SIZE * 3 + 1];
+	size_t				tx_buf_size;
+	u32				tx_id;
+	u8				tx_id_str[(sizeof(u32) * 2) + 1];
+	u16				tx_len;
+	u16				auth_type;
+	bool				tx_done;
+	bool				tx_busy;
+	u32				com_busy;
+	bool				check_np;
+	bool				check_dc;
+	bool				check_det;
+	int				last_capacity;
+	bool				resume_complete;
+	bool				icl_ramp;
+	u32				icl_ramp_ua;
+	u32				icl_ramp_alt_ua;
+	bool				fake_force_epp;
+	bool				force_bpp;
+	u32				dc_icl_epp_neg;
+	u32				dc_icl_bpp;
+	int				align;
+	int				align_count;
+	int				alignment;
+	u8				alignment_str[(sizeof(u32) * 3) + 1];
+	int				alignment_last;
+	enum p9221_align_mfg_chk_state  alignment_capable;
+	int				mfg_check_count;
+	u16				mfg;
+	int				alignment_time;
+	u32				dc_icl_epp;
+	u32				current_filtered;
+	u32				current_sample_cnt;
+	bool				log_current_filtered;
+	struct delayed_work		dcin_pon_work;
+	bool				is_mfg_google;
+	u8				ptmc_id_str[(sizeof(u16) * 2) + 1];
+	u32				aicl_delay_ms;
+	u32				aicl_icl_ua;
+	int				rtx_state;
+	u32				rtx_csp;
+	int				rtx_err;
+	int				rtx_reset_cnt;
+	int				rtx_ocp_chk_ms;
+	int				rtx_total_delay;
+	bool				chg_on_rtx;
+	bool				is_rtx_mode;
+	bool				prop_mode_en;
+	bool				no_fod;
+	u32				de_q_value;
+	u16				fw_rev;
+	struct mutex			stats_lock;
+	struct p9221_charge_stats	chg_data;
+	u32				mitigate_threshold;
+	u32				fod_cnt;
+	bool				trigger_power_mitigation;
+	bool				wait_for_online;
+	struct mutex			rtx_lock;
+	bool				rtx_wakelock;
+	ktime_t				online_at;
+	bool				p9412_gpio_ctl;
+	bool				auth_delay;
+	struct mutex			auth_lock;
+	int 				ll_bpp_cep;
+	int				last_disable;
+	ktime_t				irq_at;
+	int				renego_state;
+	struct mutex			renego_lock;
+	bool				send_eop;
+	wait_queue_head_t		ccreset_wq;
+	bool				cc_reset_pending;
+	int				send_txid_cnt;
+	bool				sw_ramp_done;
+	bool				hpp_hv;
+	int				fod_mode;
+	enum p9xxx_chk_rp		check_rp;
+
+#if IS_ENABLED(CONFIG_GPIOLIB)
+	struct gpio_chip gpio;
+#endif
+
+	/* WLC DC when available */
+	u32 				wlc_dc_voltage_now;
+	u32 				wlc_dc_current_now;
+	bool				wlc_dc_enabled;
+
+	u16				reg_tx_id_addr;
+	u16				reg_tx_mfg_code_addr;
+	u16				reg_packet_type_addr;
+	u16				set_cmd_ccactivate_bit;
+	u16				reg_set_pp_buf_addr;
+	u16				reg_get_pp_buf_addr;
+	u16				reg_set_fod_addr;
+	u16				reg_q_factor_addr;
+	u16				reg_csp_addr;
+	u16				reg_light_load_addr;
+
+	int (*reg_read_n)(struct p9221_charger_data *chgr, u16 reg,
+			  void *buf, size_t n);
+	int (*reg_read_8)(struct p9221_charger_data *chgr, u16 reg,
+			u8 *val);
+	int (*reg_read_16)(struct p9221_charger_data *chgr, u16 reg,
+			   u16 *val);
+	int (*reg_write_n)(struct p9221_charger_data *charger, u16 reg,
+			   const void *buf, size_t n);
+	int (*reg_write_8)(struct p9221_charger_data *charger, u16 reg,
+			   u8 val);
+	int (*reg_write_16)(struct p9221_charger_data *charger, u16 reg,
+			    u16 val);
+
+	int (*chip_set_data_buf)(struct p9221_charger_data *chgr,
+				 const u8 data[], size_t len);
+	int (*chip_get_data_buf)(struct p9221_charger_data *chgr,
+				 u8 data[], size_t len);
+	int (*chip_get_cc_recv_size)(struct p9221_charger_data *chgr,
+				     size_t *len);
+	int (*chip_set_cc_send_size)(struct p9221_charger_data *chgr,
+				     size_t len);
+	int (*chip_send_ccreset)(struct p9221_charger_data *chgr);
+	int (*chip_send_eop)(struct p9221_charger_data *chgr, u8 reason);
+	int (*chip_get_align_x)(struct p9221_charger_data *chgr, u8 *x);
+	int (*chip_get_align_y)(struct p9221_charger_data *chgr, u8 *y);
+
+	int (*chip_get_vout)(struct p9221_charger_data *chgr, u32 *mv);
+	int (*chip_get_iout)(struct p9221_charger_data *chgr, u32 *ma);
+	int (*chip_get_op_freq)(struct p9221_charger_data *chgr, u32 *khz);
+	int (*chip_set_cmd)(struct p9221_charger_data *chgr, u16 cmd);
+	int (*chip_get_rx_ilim)(struct p9221_charger_data *chgr, u32 *ma);
+	int (*chip_set_rx_ilim)(struct p9221_charger_data *chgr, u32 ma);
+	int (*chip_get_tx_ilim)(struct p9221_charger_data *chgr, u32 *ma);
+	int (*chip_set_tx_ilim)(struct p9221_charger_data *chgr, u32 ma);
+	int (*chip_get_die_temp)(struct p9221_charger_data *chgr, int *mc);
+	int (*chip_get_vout_max)(struct p9221_charger_data *chgr, u32 *mv);
+	int (*chip_set_vout_max)(struct p9221_charger_data *chgr, u32 mv);
+	int (*chip_get_vrect)(struct p9221_charger_data *chgr, u32 *mv);
+	int (*chip_get_sys_mode)(struct p9221_charger_data *chgr, u8 *mode);
+
+	int (*chip_tx_mode_en)(struct p9221_charger_data *chgr, bool en);
+	int (*chip_renegotiate_pwr)(struct p9221_charger_data *chrg);
+	int (*chip_prop_mode_en)(struct p9221_charger_data *chgr, int req_pwr);
+	void (*chip_check_neg_power)(struct p9221_charger_data *chgr);
+	int (*chip_send_txid)(struct p9221_charger_data *chgr);
+	int (*chip_send_csp_in_txmode)(struct p9221_charger_data *chgr, u8 stat);
+	int (*chip_capdiv_en)(struct p9221_charger_data *chgr, u8 mode);
+};
+
+u8 p9221_crc8(u8 *pdata, size_t nbytes, u8 crc);
+bool p9221_is_epp(struct p9221_charger_data *charger);
+bool p9xxx_is_capdiv_en(struct p9221_charger_data *charger);
+int p9221_wlc_disable(struct p9221_charger_data *charger, int disable, u8 reason);
+int p9221_set_auth_dc_icl(struct p9221_charger_data *charger, bool enable);
+int p9xxx_sw_ramp_icl(struct p9221_charger_data *charger, const int icl_target);
+int p9xxx_gpio_set_value(struct p9221_charger_data *charger, int gpio, int value);
+
+void p9xxx_gpio_init(struct p9221_charger_data *charger);
+extern int p9221_chip_init_funcs(struct p9221_charger_data *charger,
+				 u16 chip_id);
+extern void p9221_chip_init_params(struct p9221_charger_data *charger,
+				   u16 chip_id);
+extern void p9221_chip_init_interrupt_bits(struct p9221_charger_data *charger,
+					   u16 chip_id);
+
+enum p9382_rtx_state {
+	RTX_NOTSUPPORTED = 0,
+	RTX_AVAILABLE,
+	RTX_ACTIVE,
+	RTX_DISABLED,
+};
+
+enum p9382_rtx_err {
+	RTX_NO_ERROR = 0,
+	RTX_BATT_LOW,
+	RTX_OVER_TEMP,
+	RTX_TX_CONFLICT,
+	RTX_HARD_OCP,
+};
+
+enum p9xxx_renego_state {
+	P9XXX_AVAILABLE = 0,
+	P9XXX_SEND_DATA,
+	P9XXX_ENABLE_PROPMODE,
+};
+
+#define P9221_MA_TO_UA(ma)((ma) * 1000)
+#define P9221_UA_TO_MA(ua) ((ua) / 1000)
+#define P9221_MV_TO_UV(mv) ((mv) * 1000)
+#define P9221_UV_TO_MV(uv) ((uv) / 1000)
+#define P9221_KHZ_TO_HZ(khz) ((khz) * 1000)
+#define P9221_HZ_TO_KHZ(khz) ((khz) / 1000)
+#define P9221_C_TO_MILLIC(c) ((c) * 1000)
+#define P9221_MILLIC_TO_C(mc) ((mc) / 1000)
+#define P9221_MILLIC_TO_DECIC(mc) ((mc) / 100)
+#define P9412_MW_TO_HW(mw) (((mw) * 2) / 1000) /* mw -> 0.5 W units */
+#define P9412_HW_TO_MW(hw) (((hw) / 2) * 1000) /* 0.5 W units -> mw */
+#define get_boot_sec() div_u64(ktime_to_ns(ktime_get_boottime()), NSEC_PER_SEC)
+#define get_boot_msec() div_u64(ktime_to_ns(ktime_get_boottime()), NSEC_PER_MSEC)
+
+#define p9xxx_chip_get_tx_id(chgr, id) (chgr->reg_tx_id_addr < 0 ? \
+      -ENOTSUPP : chgr->reg_read_n(chgr, chgr->reg_tx_id_addr, id, sizeof(*id)))
+#define p9xxx_chip_get_tx_mfg_code(chgr, code) (chgr->reg_tx_mfg_code_addr < 0 ? \
+      -ENOTSUPP : chgr->reg_read_n(chgr, chgr->reg_tx_mfg_code_addr, code, sizeof(*code)))
+#define p9xxx_chip_set_pp_buf(chgr, data, len) (chgr->reg_set_pp_buf_addr == 0 ? \
+      -ENOTSUPP : chgr->reg_write_n(chgr, chgr->reg_set_pp_buf_addr, data, len))
+#define p9xxx_chip_get_pp_buf(chgr, data, len) (chgr->reg_get_pp_buf_addr == 0 ? \
+      -ENOTSUPP : chgr->reg_read_n(chgr, chgr->reg_get_pp_buf_addr, data, len))
+#define p9xxx_chip_set_fod_reg(chgr, data, len) (chgr->reg_set_fod_addr == 0 ? \
+      -ENOTSUPP : chgr->reg_write_n(chgr, chgr->reg_set_fod_addr, data, len))
+#define p9xxx_chip_get_fod_reg(chgr, data, len) (chgr->reg_set_fod_addr == 0 ? \
+      -ENOTSUPP : chgr->reg_read_n(chgr, chgr->reg_set_fod_addr, data, len))
+#define p9xxx_chip_set_q_factor_reg(chgr, data) (chgr->reg_q_factor_addr == 0 ? \
+      -ENOTSUPP : chgr->reg_write_8(chgr, chgr->reg_q_factor_addr, data))
+#define p9xxx_chip_set_light_load_reg(chgr, data) (chgr->reg_light_load_addr == 0 ? \
+      -ENOTSUPP : chgr->reg_write_8(chgr, chgr->reg_light_load_addr, data))
+#define logbuffer_prlog(p, fmt, ...)     \
+      gbms_logbuffer_prlog(p, LOGLEVEL_INFO, 0, LOGLEVEL_DEBUG, fmt, ##__VA_ARGS__)
+#endif /* __P9221_CHARGER_H__ */
diff --git a/drivers/soc/qcom/pca9468_charger.h b/drivers/soc/qcom/pca9468_charger.h
new file mode 100644
index 000000000000..e0fdbddeb27d
--- /dev/null
+++ b/drivers/soc/qcom/pca9468_charger.h
@@ -0,0 +1,370 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Platform data for the NXP PCA9468 battery charger driver.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#ifndef _PCA9468_CHARGER_H_
+#define _PCA9468_CHARGER_H_
+
+#include <linux/mutex.h>
+#include <linux/module.h>
+#include <linux/debugfs.h>
+#include <linux/thermal.h>
+#include <linux/pm_runtime.h>
+#include <linux/kernel.h>
+
+/* Google integration */
+#include "gbms_power_supply.h"
+#include "google_bms.h"
+#include "google_dc_pps.h"
+
+struct pca9468_platform_data {
+	int	irq_gpio;		/* GPIO pin that's connected to INT# */
+	unsigned int	iin_cfg;	/* Input Current Limit - uA unit */
+	unsigned int	iin_cfg_max;	/* from config/dt */
+	unsigned int	v_float;	/* V_Float Voltage - uV unit */
+	unsigned int	v_float_dt;	/* from config/dt */
+	unsigned int 	iin_topoff;	/* Input Topoff current -uV unit */
+	/* Switching frequency: 0 - 833kHz, ... , 3 - 980kHz */
+	unsigned int 	fsw_cfg;
+	/* NTC voltage threshold : 0~2.4V - uV unit */
+	unsigned int	ntc_th;
+
+	int		iin_max_offset;
+	int		iin_cc_comp_offset;
+
+	unsigned int	ta_max_vol;
+	unsigned int	ta_max_vol_cp;
+
+	/* irdrop */
+	unsigned int	irdrop_limits[3];
+	int		irdrop_limit_cnt;
+	bool		pca_irdrop;
+
+	/* Spread Spectrum settings */
+	unsigned int	sc_clk_dither_rate;
+	unsigned int	sc_clk_dither_limit;
+	bool		sc_clk_dither_en;
+
+#ifdef CONFIG_THERMAL
+	const char *usb_tz_name;
+#endif
+};
+
+/* - PPS Integration Shared definitions ---------------------------------- */
+
+/* AC[0] */
+#define P9468_CHGS_VER		1
+#define P9468_CHGS_VER_MASK	0xff
+/* AC[1] APDO */
+/* RS[0] */
+#define P9468_CHGS_FLAG_SHIFT	0
+#define P9468_CHGS_FLAG_MASK	0xff
+#define P9468_CHGS_F_STBY	(1 << 0)
+#define P9468_CHGS_F_SHDN	(1 << 1)
+#define P9468_CHGS_F_DONE	(1 << 2)
+#define P9468_CHGS_PRE_SHIFT	8
+#define P9468_CHGS_PRE_MASK	(0xff << P9468_CHGS_PRE_SHIFT)
+#define P9468_CHGS_RCPC_SHIFT	16
+#define P9468_CHGS_RCPC_MASK	(0xff << P9468_CHGS_RCPC_SHIFT)
+#define P9468_CHGS_NC_SHIFT	24
+#define P9468_CHGS_NC_MASK	(0xff << P9468_CHGS_NC_SHIFT)
+/* RS[1] */
+#define P9468_CHGS_OVCC_SHIFT	0
+#define P9468_CHGS_OVCC_MASK	(0xffff << P9468_CHGS_OVCC_SHIFT)
+#define P9468_CHGS_ADJ_SHIFT	16
+#define P9468_CHGS_ADJ_MASK	(0xffff << P9468_CHGS_ADJ_MASK)
+/* RS[2] */
+#define P9468_CHGS_CC_SHIFT	0
+#define P9468_CHGS_CC_MASK	(0xffff << P9468_CHGS_CC_SHIFT)
+#define P9468_CHGS_CV_SHIFT	16
+#define P9468_CHGS_CV_MASK	(0xffff << P9468_CHGS_CV_SHIFT)
+/* RS[3] */
+#define P9468_CHGS_CA_SHIFT	0
+#define P9468_CHGS_CA_MASK	(0xff << P9468_CHGS_CA_SHIFT)
+
+
+struct p9468_chg_stats {
+	u32 adapter_capabilities[2];
+	u32 receiver_state[5];
+
+	bool valid;
+	unsigned int ovc_count;
+	unsigned int ovc_max_ibatt;
+	unsigned int ovc_max_delta;
+
+	unsigned int rcp_count;
+	unsigned int nc_count;
+	unsigned int pre_count;
+	unsigned int ca_count;
+	unsigned int cc_count;
+	unsigned int cv_count;
+	unsigned int adj_count;
+	unsigned int stby_count;
+	unsigned int iin_loop_count;
+};
+
+#define p9468_chg_stats_valid(chg_data) ((chg_data)->valid)
+
+static inline void p9468_chg_stats_update_flags(struct p9468_chg_stats *chg_data, u8 flags)
+{
+	chg_data->receiver_state[0] |= flags << P9468_CHGS_FLAG_SHIFT;
+}
+
+static inline void p9468_chg_stats_set_flags(struct p9468_chg_stats *chg_data, u8 flags)
+{
+	chg_data->receiver_state[0] &= ~P9468_CHGS_FLAG_MASK;
+	p9468_chg_stats_update_flags(chg_data, flags);
+}
+
+static inline void p9468_chg_stats_inc_ovcf(struct p9468_chg_stats *chg_data,
+					    int ibatt, int cc_max)
+{
+	const int delta = ibatt - cc_max;
+
+	chg_data->ovc_count++;
+	if (delta > chg_data->ovc_max_delta) {
+		chg_data->ovc_max_ibatt = ibatt;
+		chg_data->ovc_max_delta = delta;
+	}
+}
+
+/**
+ * struct pca9468_charger - pca9468 charger instance
+ * @monitor_wake_lock: lock to enter the suspend mode
+ * @lock: protects concurrent access to online variables
+ * @dev: pointer to device
+ * @regmap: pointer to driver regmap
+ * @mains: power_supply instance for AC/DC power
+ * @dc_wq: work queue for the algorithm and monitor timer
+ * @timer_work: timer work for charging
+ * @timer_id: timer id for timer_work
+ * @timer_period: timer period for timer_work
+ * @last_update_time: last update time after sleep
+ * @pps_index: psy index
+ * @tcpm_psy_name: name of TCPM power supply
+ * @tcpm_phandle: lookup for tcpm power supply
+ * @pps_work: pps work for PPS periodic time
+ * @pps_data: internal data for dc_pps
+ * @log: logbuffer
+ * @pd: phandle for qualcomm PMI usbpd-phy
+ * @wlc_psy_name: power supply for wlc DC
+ * @wlc_psy: wlc DC ps
+ * @mains_online: is AC/DC input connected
+ * @charging_state: direct charging state
+ * @ret_state: return direct charging state after DC_STATE_ADJUST_TAVOL is done
+ * @iin_cc: input current for the direct charging in cc mode, uA
+ * @ta_cur: AC/DC(TA) current, uA
+ * @ta_vol: AC/DC(TA) voltage, uV
+ * @ta_objpos: AC/DC(TA) PDO object position
+ * @ta_max_cur: TA maximum current of APDO, uA
+ * @ta_max_vol: TA maximum voltage for the direct charging, uV
+ * @ta_max_pwr: TA maximum power, uW
+ * @prev_iin: Previous IIN ADC of PCA9468, uA
+ * @prev_inc: Previous TA voltage or current increment factor
+ * @fv_uv: requested float voltage
+ * @cc_max: requested charge current max
+ * @new_iin: New request input current limit, uA
+ * @new_vfloat: Request for new vfloat
+ * @adc_comp_gain: adc gain for compensation
+ * @retry_cnt: retry counter for re-starting charging if charging stop happens
+ * @ta_type: TA type for the direct charging, USBPD TA or Wireless Charger.
+ * @chg_mode: supported DC charging mode 2:1 or 4:1 mode
+ * @pdata: pointer to platform data
+ * @usb_tzd: device for thermal zone
+ * @debug_root: debug entry
+ * @debug_address: debug register address
+ * @debug_adc_channel: ADC channel to read
+ * @init_done: true when initialization is complete
+ * @dc_start_time: start time (sec since boot) of the DC session
+ */
+struct pca9468_charger {
+	struct wakeup_source	*monitor_wake_lock;
+	struct mutex		lock;
+	struct device		*dev;
+	struct regmap		*regmap;
+	struct power_supply	*mains;
+
+	struct workqueue_struct	*dc_wq;
+	struct delayed_work	timer_work;
+	unsigned int		timer_id;
+	unsigned long		timer_period;
+	unsigned long		last_update_time;
+
+	bool			mains_online;
+	unsigned int 		charging_state;
+	unsigned int		ret_state;
+
+	unsigned int		iin_cc;
+
+	unsigned int		ta_cur;
+	unsigned int		ta_vol;
+	unsigned int		ta_objpos;
+
+	/* same as pps_data */
+	unsigned int		ta_max_cur;
+	unsigned int		ta_max_vol;
+	unsigned long		ta_max_pwr;
+
+	unsigned int		prev_iin;
+	unsigned int		prev_inc;
+
+	unsigned int		new_iin;
+	int 			new_vfloat;
+
+	int			adc_comp_gain;
+
+	int			retry_cnt;
+
+	struct pca9468_platform_data *pdata;
+
+/* Google Integration Start */
+	int pps_index;		/* 0=disabled, 1=tcpm, 2=wireless */
+	bool			init_done;
+
+	/* PPS_wireless */
+	const char 		*wlc_psy_name;
+	struct power_supply 	*wlc_psy;
+	/*  PPS_wired with TCPM */
+	u32			tcpm_phandle;
+	const char 		*tcpm_psy_name;
+	struct power_supply 	*pd;
+	struct delayed_work	pps_work;
+	struct pd_pps_data	pps_data;
+	struct logbuffer	*log;
+
+#ifdef CONFIG_THERMAL
+	struct thermal_zone_device *usb_tzd;
+#endif
+
+	/* WIRELESS or WIRED */
+	int	ta_type;
+	/*
+	 *	0 - No direct charging
+	 *	1 - 2:1 charging mode
+	 *	2 - 4:1 charging mode
+	 */
+	int	chg_mode;
+
+	/* requested charging current and voltage */
+	int	fv_uv;
+	int	cc_max;
+	ktime_t	dc_start_time;
+	bool	irdrop_comp_ok;
+
+	/* monitoring */
+	struct power_supply	*batt_psy;
+
+	/* debug */
+	struct dentry		*debug_root;
+	u32			debug_address;
+	int			debug_adc_channel;
+
+
+	bool wlc_ramp_out_iin;
+	u32 wlc_ramp_out_delay;
+	u32 wlc_ramp_out_vout_target;
+
+	struct p9468_chg_stats	chg_data;
+
+	struct gvotable_election *dc_avail;
+/* Google Integration END */
+
+};
+
+/* Direct Charging State */
+enum {
+	DC_STATE_NO_CHARGING,	/* No charging */
+	DC_STATE_CHECK_VBAT,	/* Check min battery level */
+	DC_STATE_PRESET_DC, 	/* Preset TA voltage/current for DC */
+	DC_STATE_CHECK_ACTIVE,	/* Check active status before Adjust CC mode */
+	DC_STATE_ADJUST_CC,	/* Adjust CC mode */
+	DC_STATE_CC_MODE,	/* Check CC mode status */
+	DC_STATE_START_CV,	/* Start CV mode */
+	DC_STATE_CV_MODE,	/* Check CV mode status */
+	DC_STATE_CHARGING_DONE,	/* Charging Done */
+	DC_STATE_ADJUST_TAVOL,	/* Adjust TA voltage, new TA current < 1000mA */
+	DC_STATE_ADJUST_TACUR,	/* Adjust TA current, new TA current < 1000mA */
+	DC_STATE_MAX,
+};
+
+/* PD Message Type */
+enum {
+	PD_MSG_REQUEST_APDO,
+	MSG_REQUEST_FIXED_PDO,
+	WCRX_REQUEST_VOLTAGE,
+};
+
+/* TA Type for the direct charging */
+enum {
+	TA_TYPE_UNKNOWN,
+	TA_TYPE_USBPD,
+	TA_TYPE_WIRELESS,
+};
+
+/* Direct Charging Mode for the direct charging */
+enum {
+	CHG_NO_DC_MODE,
+	CHG_2TO1_DC_MODE,
+	CHG_4TO1_DC_MODE,
+};
+
+/* PPS timers */
+#define PCA9468_PDMSG_WAIT_T		250	/* 250ms */
+#define PCA9468_PDMSG_RETRY_T		1000	/* 1000ms */
+#define PCA9468_PDMSG_WLC_WAIT_T	5000	/* 5000ms */
+#define PCA9468_PPS_PERIODIC_T		10000	/* 10000ms */
+
+/* - Core driver  ---------------------------- */
+
+int pca9468_read_adc(struct pca9468_charger *pca9468, u8 adc_ch);
+int pca9468_input_current_limit(struct pca9468_charger *pca9468);
+
+/* - PPS Integration (move to a separate file) ---------------------------- */
+
+/* */
+enum {
+	PPS_INDEX_DISABLED = 0,
+	PPS_INDEX_TCPM = 1,
+	PPS_INDEX_WLC,
+	PPS_INDEX_MAX,
+};
+
+int pca9468_probe_pps(struct pca9468_charger *pca9468_chg);
+
+int pca9468_request_pdo(struct pca9468_charger *pca9468);
+int pca9468_usbpd_setup(struct pca9468_charger *pca9468);
+int pca9468_send_pd_message(struct pca9468_charger *pca9468, unsigned int msg_type);
+int pca9468_get_apdo_max_power(struct pca9468_charger *pca9468,
+			       unsigned int ta_max_vol, unsigned int ta_max_cur);
+int pca9468_send_rx_voltage(struct pca9468_charger *pca9468, unsigned int msg_type);
+int pca9468_get_rx_max_power(struct pca9468_charger *pca9468);
+int pca9468_set_ta_type(struct pca9468_charger *pca9468, int pps_index);
+
+/* GBMS integration */
+struct power_supply *pca9468_get_rx_psy(struct pca9468_charger *pca9468);
+int pca9468_get_chg_chgr_state(struct pca9468_charger *pca9468,
+			       union gbms_charger_state *chg_state);
+int pca9468_is_present(struct pca9468_charger *pca9468);
+int pca9468_get_status(struct pca9468_charger *pca9468);
+int pca9468_get_charge_type(struct pca9468_charger *pca9468);
+
+extern int debug_printk_prlog;
+extern int debug_no_logbuffer;
+
+#define logbuffer_prlog(p, level, fmt, ...)	\
+	gbms_logbuffer_prlog(p->log, level, debug_no_logbuffer, debug_printk_prlog, fmt, ##__VA_ARGS__)
+
+/* charge stats */
+void p9468_chg_stats_init(struct p9468_chg_stats *chg_data);
+int p9468_chg_stats_update(struct p9468_chg_stats *chg_data,
+			   const struct pca9468_charger *pca9468);
+int p9468_chg_stats_done(struct p9468_chg_stats *chg_data,
+			 const struct pca9468_charger *pca9468);
+void p9468_chg_stats_dump(const struct pca9468_charger *pca9468);
+
+#endif
diff --git a/drivers/soc/qcom/pca9468_regs.h b/drivers/soc/qcom/pca9468_regs.h
new file mode 100644
index 000000000000..7136e2e2fefe
--- /dev/null
+++ b/drivers/soc/qcom/pca9468_regs.h
@@ -0,0 +1,268 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Platform data for the NXP PCA9468 battery charger driver.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#ifndef PCA9468_REGS_H__
+#define PCA9468_REGS_H__
+
+#define BITS(_end, _start) ((BIT(_end) - BIT(_start)) + BIT(_end))
+#define MASK2SHIFT(_mask)	__ffs(_mask)
+
+/*
+ * Register Map
+ */
+#define PCA9468_REG_DEVICE_INFO 	0x00	/* Device ID, revision */
+#define PCA9468_BIT_DEV_REV		BITS(7, 4)
+#define PCA9468_BIT_DEV_ID		BITS(3, 0)
+#define PCA9468_DEVICE_ID		0x18	/* Default ID */
+
+#define PCA9468_REG_INT1		0x01
+#define PCA9468_BIT_V_OK_INT		BIT(7)
+#define PCA9468_BIT_NTC_TEMP_INT	BIT(6)
+#define PCA9468_BIT_CHG_PHASE_INT	BIT(5)
+#define PCA9468_BIT_CTRL_LIMIT_INT	BIT(3)
+#define PCA9468_BIT_TEMP_REG_INT	BIT(2)
+#define PCA9468_BIT_ADC_DONE_INT	BIT(1)
+#define PCA9468_BIT_TIMER_INT		BIT(0)
+
+#define PCA9468_REG_INT1_MSK		0x02
+#define PCA9468_BIT_V_OK_M		BIT(7)
+#define PCA9468_BIT_NTC_TEMP_M		BIT(6)
+#define PCA9468_BIT_CHG_PHASE_M		BIT(5)
+#define PCA9468_BIT_RESERVED_M		BIT(4)
+#define PCA9468_BIT_CTRL_LIMIT_M	BIT(3)
+#define PCA9468_BIT_TEMP_REG_M		BIT(2)
+#define PCA9468_BIT_ADC_DONE_M		BIT(1)
+#define PCA9468_BIT_TIMER_M		BIT(0)
+
+#define PCA9468_REG_INT1_STS		0x03
+#define PCA9468_BIT_V_OK_STS		BIT(7)
+#define PCA9468_BIT_NTC_TEMP_STS	BIT(6)
+#define PCA9468_BIT_CHG_PHASE_STS	BIT(5)
+#define PCA9468_BIT_CTRL_LIMIT_STS	BIT(3)
+#define PCA9468_BIT_TEMP_REG_STS	BIT(2)
+#define PCA9468_BIT_ADC_DONE_STS	BIT(1)
+#define PCA9468_BIT_TIMER_STS		BIT(0)
+
+#define PCA9468_REG_STS_A		0x04
+#define PCA9468_BIT_IIN_LOOP_STS	BIT(7)
+#define PCA9468_BIT_CHG_LOOP_STS	BIT(6)	/* not in pca9468 */
+#define PCA9468_BIT_VFLT_LOOP_STS	BIT(5)
+#define PCA9468_BIT_CFLY_SHORT_STS	BIT(4)
+#define PCA9468_BIT_VOUT_UV_STS		BIT(3)
+#define PCA9468_BIT_VBAT_OV_STS		BIT(2)
+#define PCA9468_BIT_VIN_OV_STS		BIT(1)
+#define PCA9468_BIT_VIN_UV_STS		BIT(0)
+
+#define PCA9468_REG_STS_B		0x05
+#define PCA9468_BIT_BATT_MISS_STS	BIT(7)
+#define PCA9468_BIT_OCP_FAST_STS	BIT(6)
+#define PCA9468_BIT_OCP_AVG_STS		BIT(5)
+#define PCA9468_BIT_ACTIVE_STATE_STS	BIT(4)
+#define PCA9468_BIT_SHUTDOWN_STATE_STS	BIT(3)
+#define PCA9468_BIT_STANDBY_STATE_STS	BIT(2)
+#define PCA9468_BIT_CHARGE_TIMER_STS	BIT(1)
+#define PCA9468_BIT_WATCHDOG_TIMER_STS	BIT(0)
+
+#define PCA9468_REG_STS_C		0x06	/* IIN status */
+#define PCA9468_BIT_IIN_STS		BITS(7, 2)
+
+#define PCA9468_REG_STS_D		0x07	/* ICHG status */
+#define PCA9468_BIT_ICHG_STS		BITS(7, 1)
+
+#define PCA9468_REG_STS_ADC_1		0x08
+#define PCA9468_BIT_ADC_IIN7_0		BITS(7, 0)
+
+#define PCA9468_REG_STS_ADC_2		0x09
+#define PCA9468_BIT_ADC_IOUT5_0		BITS(7, 2)
+#define PCA9468_BIT_ADC_IIN9_8		BITS(1, 0)
+
+#define PCA9468_REG_STS_ADC_3		0x0A
+#define PCA9468_BIT_ADC_VIN3_0		BITS(7, 4)
+#define PCA9468_BIT_ADC_IOUT9_6		BITS(3, 0)
+
+#define PCA9468_REG_STS_ADC_4		0x0B
+#define PCA9468_BIT_ADC_VOUT1_0		BITS(7, 6)
+#define PCA9468_BIT_ADC_VIN9_4		BITS(5, 0)
+
+#define PCA9468_REG_STS_ADC_5		0x0C
+#define PCA9468_BIT_ADC_VOUT9_2		BITS(7, 0)
+
+#define PCA9468_REG_STS_ADC_6		0x0D
+#define PCA9468_BIT_ADC_VBAT7_0		BITS(7, 0)
+
+#define PCA9468_REG_STS_ADC_7		0x0E
+#define PCA9468_BIT_ADC_DIETEMP5_0	BITS(7, 2)
+#define PCA9468_BIT_ADC_VBAT9_8		BITS(1, 0)
+
+#define PCA9468_REG_STS_ADC_8		0x0F
+#define PCA9468_BIT_ADC_NTCV3_0		BITS(7, 4)
+#define PCA9468_BIT_ADC_DIETEMP9_6	BITS(3, 0)
+
+#define PCA9468_REG_STS_ADC_9		0x10
+#define PCA9468_BIT_ADC_NTCV9_4		BITS(5, 0)
+
+/*
+ * Charge current cannot be in PCA9468.
+#define PCA9468_REG_ICHG_CTRL		0x20
+#define PCA9468_BIT_ICHG_SS		BIT(7)
+#define PCA9468_BIT_ICHG_CFG		BITS(6, 0)
+ */
+
+#define PCA9468_REG_IIN_CTRL		0x21	/* Input current */
+#define PCA9468_BIT_LIMIT_INCREMENT_EN	BIT(7)
+#define PCA9468_BIT_IIN_SS		BIT(6)
+#define PCA9468_BIT_IIN_CFG		BITS(5, 0)
+
+#define PCA9468_REG_START_CTRL		0x22	/* device init and config */
+#define PCA9468_BIT_SNSRES		BIT(7)
+#define PCA9468_BIT_EN_CFG		BIT(6)
+#define PCA9468_BIT_STANDBY_EN		BIT(5)
+#define PCA9468_BIT_REV_IIN_DET		BIT(4)
+#define PCA9468_BIT_FSW_CFG		BITS(3, 0)
+
+#define PCA9468_REG_ADC_CTRL		0x23	/* ADC configuration */
+#define PCA9468_BIT_FORCE_ADC_MODE	BITS(7, 6)
+#define PCA9468_BIT_ADC_SHUTDOWN_CFG	BIT(5)
+#define PCA9468_BIT_HIBERNATE_DELAY	BITS(4, 3)
+#define PCA9468_BIT_SC_CLK_DITHER_RATE	BITS(2, 0)
+
+#define PCA9468_REG_ADC_CFG		0x24	/* ADC channel configuration */
+#define PCA9468_BIT_CH7_EN		BIT(7)
+#define PCA9468_BIT_CH6_EN		BIT(6)
+#define PCA9468_BIT_CH5_EN		BIT(5)
+#define PCA9468_BIT_CH4_EN		BIT(4)
+#define PCA9468_BIT_CH3_EN		BIT(3)
+#define PCA9468_BIT_CH2_EN		BIT(2)
+#define PCA9468_BIT_CH1_EN		BIT(1)
+
+#define PCA9468_REG_TEMP_CTRL		0x25	/* Temperature configuration */
+#define PCA9468_BIT_TEMP_REG		BITS(7, 6)
+#define PCA9468_BIT_TEMP_DELTA		BITS(5, 4)
+#define PCA9468_BIT_TEMP_REG_EN		BIT(3)
+#define PCA9468_BIT_NTC_PROTECTION_EN	BIT(2)
+#define PCA9468_BIT_TEMP_MAX_EN		BIT(1)
+#define PCA9468_BIT_SC_CLK_DITHER_EN	BIT(0)
+
+#define PCA9468_REG_PWR_COLLAPSE	0x26	/* Power collapse cfg */
+#define PCA9468_BIT_UV_DELTA		BITS(7, 6)
+#define PCA9468_BIT_IIN_FORCE_COUNT	BIT(4)
+#define PCA9468_BIT_BAT_MISS_DET_EN	BIT(3)
+
+#define PCA9468_REG_V_FLOAT		0x27	/* Voltage regulation */
+#define PCA9468_BIT_V_FLOAT		BITS(7, 0)
+
+#define PCA9468_REG_SAFETY_CTRL		0x28	/* Safety configuration */
+#define PCA9468_BIT_WATCHDOG_EN		BIT(7)
+#define PCA9468_BIT_WATCHDOG_CFG	BITS(6, 5)
+#define PCA9468_BIT_CHG_TIMER_EN	BIT(4)
+#define PCA9468_BIT_CHG_TIMER_CFG	BITS(3, 2)
+#define PCA9468_BIT_OV_DELTA		BITS(1, 0)
+
+#define PCA9468_REG_NTC_TH_1		0x29	/* Thermistor threshold  */
+#define PCA9468_BIT_NTC_THRESHOLD7_0	BITS(7, 0)
+
+#define PCA9468_REG_NTC_TH_2		0x2A	/* Thermistor threshold  */
+#define PCA9468_SC_CLK_DITHER_LIMIT	BITS(7, 4)
+#define PCA9468_BIT_NTC_THRESHOLD9_8	BITS(1, 0)
+
+#define PCA9468_REG_ADC_ACCESS		0x30
+
+#define PCA9468_REG_ADC_ADJUST		0x31
+#define PCA9468_BIT_ADC_GAIN		BITS(7, 4)
+
+#define PCA9468_REG_ADC_IMPROVE		0x3D
+#define PCA9468_BIT_ADC_IIN_IMP		BIT(3)
+
+#define PCA9468_REG_ADC_MODE		0x3F
+#define PCA9468_BIT_ADC_MODE		BIT(4)
+
+#define PCA9468_MAX_REGISTER		0x4F
+
+
+#define PCA9468_IIN_CFG_MIN		500000
+/* input current step, unit - uA */
+#define PCA9468_IIN_CFG_STEP		100000
+/* input current, unit - uA */
+#define PCA9468_IIN_CFG(input_curr)	((input_curr) / PCA9468_IIN_CFG_STEP)
+/* charging current, uint - uA  */
+#define PCA9468_ICHG_CFG(_chg_current)	((_chg_current) / 100000)
+/* v_float voltage, unit - uV */
+#define PCA9468_V_FLOAT(_v_float)	(((_v_float) / 1000 - 3725) / 5)
+
+#define PCA9468_SNSRES_5mOhm		0x00
+#define PCA9468_SNSRES_10mOhm		PCA9468_BIT_SNSRES
+
+#define PCA9468_NTC_TH_STEP		2346	/* 2.346mV, unit - uV */
+
+/* VIN over voltage setting from 2*VOUT */
+enum {
+	OV_DELTA_10P,
+	OV_DELTA_30P,
+	OV_DELTA_20P,
+	OV_DELTA_40P,
+};
+
+/* Switching frequency */
+enum {
+	FSW_CFG_833KHZ,
+	FSW_CFG_893KHZ,
+	FSW_CFG_935KHZ,
+	FSW_CFG_980KHZ,
+	FSW_CFG_1020KHZ,
+	FSW_CFG_1080KHZ,
+	FSW_CFG_1120KHZ,
+	FSW_CFG_1160KHZ,
+	FSW_CFG_440KHZ,
+	FSW_CFG_490KHZ,
+	FSW_CFG_540KHZ,
+	FSW_CFG_590KHZ,
+	FSW_CFG_630KHZ,
+	FSW_CFG_680KHZ,
+	FSW_CFG_730KHZ,
+	FSW_CFG_780KHZ
+};
+
+/* Enable pin polarity selection */
+#define PCA9468_EN_ACTIVE_H	0x00
+#define PCA9468_EN_ACTIVE_L	PCA9468_BIT_EN_CFG
+#define PCA9468_STANDBY_FORCED	PCA9468_BIT_STANDBY_EN
+#define PCA9468_STANDBY_DONOT	0
+
+/* ADC Channel */
+enum {
+	ADCCH_VOUT = 1,
+	ADCCH_VIN,
+	ADCCH_VBAT,	/* 3 */
+	ADCCH_ICHG,
+	ADCCH_IIN,	/* 5 */
+	ADCCH_DIETEMP,	/* 6 */
+	ADCCH_NTC,
+	ADCCH_MAX
+};
+
+/* ADC step */
+#define VIN_STEP	16000	/* 16mV(16000uV) LSB, Range(0V ~ 16.368V) */
+#define VBAT_STEP	5000	/* 5mV(5000uV) LSB, Range(0V ~ 5.115V) */
+#define IIN_STEP	4890 	/* 4.89mA(4890uA) LSB, Range(0A ~ 5A) */
+#define ICHG_STEP	9780 	/* 9.78mA(9780uA) LSB, Range(0A ~ 10A) */
+#define DIETEMP_STEP  	435	/* 0.435C LSB, Range(-25C ~ 160C) */
+#define DIETEMP_DENOM	1000	/* 1000, denominator */
+#define DIETEMP_MIN 	-25  	/* -25C */
+#define DIETEMP_MAX	160	/* 160C */
+#define VOUT_STEP	5000 	/* 5mV(5000uV) LSB, Range(0V ~ 5.115V) */
+#define NTCV_STEP	2346 	/* 2.346mV(2346uV) LSB, Range(0V ~ 2.4V) */
+#define ADC_IIN_OFFSET	900000	/* 900mA */
+#define NTC_CURVE_THRESHOLD	185
+#define NTC_CURVE_1_BASE	960
+#define NTC_CURVE_1_SHIFT	2
+#define NTC_CURVE_2_BASE	730
+#define NTC_CURVE_2_SHIFT	3
+
+
+#endif
diff --git a/drivers/soc/qcom/pmic-voter.h b/drivers/soc/qcom/pmic-voter.h
new file mode 100644
index 000000000000..073b94610452
--- /dev/null
+++ b/drivers/soc/qcom/pmic-voter.h
@@ -0,0 +1,48 @@
+/* Copyright (c) 2015-2016 The Linux Foundation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 and
+ * only version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#ifndef __PMIC_VOTER_H
+#define __PMIC_VOTER_H
+
+struct votable;
+
+enum votable_type {
+	VOTE_MIN,
+	VOTE_MAX,
+	VOTE_SET_ANY,
+	NUM_VOTABLE_TYPES,
+};
+
+bool __deprecated is_client_vote_enabled(struct votable *votable, const char *client_str);
+bool __deprecated is_client_vote_enabled_locked(struct votable *votable,
+							const char *client_str);
+int __deprecated get_client_vote(struct votable *votable, const char *client_str);
+int __deprecated get_client_vote_locked(struct votable *votable, const char *client_str);
+int __deprecated get_effective_result(struct votable *votable);
+int __deprecated get_effective_result_locked(struct votable *votable);
+const char * __deprecated get_effective_client(struct votable *votable);
+const char * __deprecated get_effective_client_locked(struct votable *votable);
+int __deprecated vote(struct votable *votable, const char *client_str, bool state, int val);
+int __deprecated rerun_election(struct votable *votable);
+struct votable * __deprecated find_votable(const char *name);
+struct votable * __deprecated create_votable(const char *name,
+				int votable_type,
+				int (*callback)(struct votable *votable,
+						void *data,
+						int effective_result,
+						const char *effective_client),
+				void *data);
+void __deprecated destroy_votable(struct votable *votable);
+void __deprecated lock_votable(struct votable *votable);
+void __deprecated unlock_votable(struct votable *votable);
+
+#endif /* __PMIC_VOTER_H */
diff --git a/drivers/soc/qcom/pmic_glink.c b/drivers/soc/qcom/pmic_glink.c
index fabe46ce9b0c..119fc5e5d2c2 100644
--- a/drivers/soc/qcom/pmic_glink.c
+++ b/drivers/soc/qcom/pmic_glink.c
@@ -269,17 +269,7 @@ int pmic_glink_write(struct pmic_glink_client *client, void *data,
 	mutex_unlock(&client->lock);
 	up_read(&client->pgdev->rpdev_sem);
 
-	if (rc < 0)
-		pr_err("Failed to send data [%*ph] for client %s, rc=%d\n",
-			len, data, client->name, rc);
-
 	if (!rc && client->pgdev->log_enable) {
-		struct pmic_glink_hdr *hdr = data;
-
-		if (client->pgdev->log_filter == hdr->owner)
-			pr_info("Tx data: %*ph\n", len, data);
-		else if (client->pgdev->log_filter == 65535)
-			pr_info("[%u] Tx data: %*ph\n", hdr->owner, len, data);
 	}
 
 	return rc;
@@ -418,10 +408,9 @@ static void pmic_glink_rx_callback(struct pmic_glink_dev *pgdev,
 
 	if (pgdev->log_enable) {
 		if (pgdev->log_filter == hdr->owner)
-			pr_info("Rx data: %*ph\n", pbuf->len, pbuf->buf);
+		  ;
 		else if (pgdev->log_filter == 65535)
-			pr_info("[%u] Rx data: %*ph\n", hdr->owner, pbuf->len,
-				pbuf->buf);
+		  ;
 	}
 
 	client->msg_cb(client->priv, pbuf->buf, pbuf->len);
@@ -536,8 +525,6 @@ static void pmic_glink_add_debugfs(struct pmic_glink_dev *pgdev)
 
 	dir = debugfs_create_dir(dev_name(pgdev->dev), NULL);
 	if (IS_ERR(dir)) {
-		pr_err("Failed to create pmic_glink debugfs directory rc=%d\n",
-			PTR_ERR(dir));
 		return;
 	}
 
diff --git a/drivers/soc/qcom/qbg-battery-profile.h b/drivers/soc/qcom/qbg-battery-profile.h
new file mode 100644
index 000000000000..69ec217ad4bd
--- /dev/null
+++ b/drivers/soc/qcom/qbg-battery-profile.h
@@ -0,0 +1,62 @@
+/* SPDX-License-Identifier: GPL-2.0-only */
+/*
+ * Copyright (c) 2021 The Linux Foundation. All rights reserved.
+ * Copyright (c) 2022 Qualcomm Innovation Center, Inc. All rights reserved.
+ */
+
+#ifndef __QBG_BATTERY_PROFILE_H__
+#define __QBG_BATTERY_PROFILE_H__
+
+#define is_between(left, right, value) \
+		(((left) >= (right) && (left) >= (value) \
+			&& (value) >= (right)) \
+		|| ((left) <= (right) && (left) <= (value) \
+			&& (value) <= (right)))
+
+enum ttf_calc_mode {
+	TTF_MODE_VBAT_STEP_CHG = 0,
+	TTF_MODE_OCV_STEP_CHG,
+	TTF_MODE_SOC_STEP_CHG,
+};
+
+struct battery_data_table0 {
+	int	soc_length;
+	int	ocv_length;
+	int	*soc;
+	int	*ocv;
+};
+
+/**
+ * struct qbg_battery_data - Structure for QBG battery data
+ * @dev_no:		Device number for QBG battery char device
+ * @profile_node:	Pointer to devicetree node handle of profile
+ * @battery_class:	Pointer to battery class
+ * @battery_device:	Pointer to battery class device
+ * @battery_cdev:	QBG battery char device
+ * @bp:			QBG battery configuration
+ * @bp_charge_tables:	Charge tables in QBG battery profile
+ * @bp_discharge_tables:	Discharge tables in QBG battery profile
+ * @table0:		Two tables for PON OCV to SOC mapping
+ * @num_ctables:	Number of charge tables
+ * @num_dtables:	Number of discharge tables
+ */
+
+struct qbg_battery_data {
+	dev_t				dev_no;
+	struct device_node		*profile_node;
+	struct class			*battery_class;
+	struct device			*battery_device;
+	struct cdev			battery_cdev;
+	struct battery_config		bp;
+	struct battery_data_table	**bp_charge_tables;
+	struct battery_data_table	**bp_discharge_tables;
+	struct battery_data_table0	table0[2];
+	int				num_ctables;
+	int				num_dtables;
+};
+
+int qbg_batterydata_init(struct device_node *node,
+	struct qbg_battery_data *battery);
+void qbg_batterydata_exit(struct qbg_battery_data *battery);
+int qbg_lookup_soc_ocv(struct qbg_battery_data *battery, int *pon_soc, int ocv, bool charging);
+#endif /* __QBG_BATTERY_PROFILE_H__ */
diff --git a/drivers/soc/qcom/qbg-core.h b/drivers/soc/qcom/qbg-core.h
new file mode 100644
index 000000000000..b6188597ea28
--- /dev/null
+++ b/drivers/soc/qcom/qbg-core.h
@@ -0,0 +1,259 @@
+/* SPDX-License-Identifier: GPL-2.0-only */
+/*
+ * Copyright (c) 2021 The Linux Foundation. All rights reserved.
+ * Copyright (c) 2022 Qualcomm Innovation Center, Inc. All rights reserved.
+ */
+
+#ifndef __QBG_CORE_H__
+#define __QBG_CORE_H__
+
+#define qbg_dbg(chip, reason, fmt, ...)			\
+	do {							\
+		if (*chip->debug_mask & (reason))		\
+			pr_err(fmt, ##__VA_ARGS__);	\
+		else						\
+			pr_debug(fmt, ##__VA_ARGS__);	\
+	} while (0)
+
+/*
+ * Current QBG context dump size is 2448 bytes (612 u32 members).
+ * Use greater buffer to accommodate future additions to QBG context.
+ */
+#define QBG_CONTEXT_LOCAL_BUF_SIZE	3072
+
+enum debug_mask {
+	QBG_DEBUG_BUS_READ	= BIT(0),
+	QBG_DEBUG_BUS_WRITE	= BIT(1),
+	QBG_DEBUG_SDAM		= BIT(2),
+	QBG_DEBUG_IRQ		= BIT(3),
+	QBG_DEBUG_DEVICE	= BIT(4),
+	QBG_DEBUG_PROFILE	= BIT(5),
+	QBG_DEBUG_SOC		= BIT(6),
+	QBG_DEBUG_STATUS	= BIT(7),
+	QBG_DEBUG_PON		= BIT(8),
+};
+
+enum qbg_sdam {
+	SDAM_CTRL0 = 0,
+	SDAM_CTRL1,
+	SDAM_DATA0,
+	SDAM_DATA1,
+	SDAM_DATA2,
+	SDAM_DATA3,
+	SDAM_DATA4,
+};
+
+enum qbg_data_tag {
+	QBG_DATA_TAG_FAST_CHAR,
+};
+
+enum QBG_SAMPLE_NUM_TYPE {
+	SAMPLE_NUM_1,
+	SAMPLE_NUM_2,
+	SAMPLE_NUM_4,
+	SAMPLE_NUM_8,
+	SAMPLE_NUM_16,
+	SAMPLE_NUM_32,
+	QBG_SAMPLE_NUM_INVALID,
+};
+
+enum QBG_ACCUM_INTERVAL_TYPE {
+	ACCUM_INTERVAL_100MS,
+	ACCUM_INTERVAL_200MS,
+	ACCUM_INTERVAL_500MS,
+	ACCUM_INTERVAL_1000MS,
+	ACCUM_INTERVAL_2000MS,
+	ACCUM_INTERVAL_5000MS,
+	ACCUM_INTERVAL_10000MS,
+	ACCUM_INTERVAL_100000MS,
+	ACCUM_INTERVAL_INVALID,
+};
+
+/**
+ * struct qti_qbg - Structure for QTI QBG device
+ * @dev:		Pointer to QBG device structure
+ * @regmap:		Pointer to regmap structure
+ * @qbg_psy:		Pointer to QBG power supply
+ * @batt_psy:		Pointer to Battery power supply
+ * @qbg_class:		Pointer to QBG class
+ * @qbg_device:		Pointer to QBG device
+ * @qbg_cdev:		Member for QBG char device
+ * @dev_no:		Device number for QBG char device
+ * @batt_node:		Pointer to battery device node
+ * @dfs_root:		Pointer to QBG debug fs root directory
+ * @indio_dev:		Pointer to QBG IIO device
+ * @iio_chan:		Pointer to QBG IIO channels
+ * @sdam:		Pointer to multiple QBG SDAMs
+ * @skip_esr_state:	Pointer to nvmem_cell
+ * @fifo:		QBG FIFO data
+ * @essential_params:	QBG essential params
+ * @status_change_work:	Power supply status change work
+ * @udata_work:		User space data change work
+ * @nb:			Power supply notifier block
+ * @kdata:		QBG Kernel space data structure
+ * @udata:		QBG user space data structure
+ * @battery:		Pointer to QBG battery data structure
+ * @step_chg_jeita_params:	Jeita step charge parameters structure
+ * @fifo_lock:		Lock for reading FIFO data
+ * @data_lock:		Lock for reading kdata from QBG char device
+ * @context_lock:	Lock for reading/writing QBG context
+ * @batt_id_chan:	IIO channel to read battery ID
+ * @batt_temp_chan:	IIO channel to read battery temperature
+ * @rtc:		RTC device to read real time
+ * @last_fast_char_time: Timestamp of last time QBG in fast char mode
+ * @qbg_wait_q:		Wait queue for reads to QBG char device
+ * @irq_name:		QBG interrupt name
+ * @batt_type_str:	String array denoting battery type
+ * @irq:		QBG irq number
+ * @context:		Pointer to QBG context dump buffer
+ * @base:		Base address of QBG HW
+ * @num_data_sdams:	Number of data sdams used for QBG
+ * @batt_id_ohm:	Battery resistance in ohms
+ * @sdam_batt_id:	Battery ID stored and retrieved from SDAM
+ * @essential_param_revid:	QBG essential parameters revision ID
+ * @sample_time_us:	Array of accumulator sample time in each QBG HW state
+ * @debug_mask:		Debug mask to enable/disable debug prints
+ * @adc_cmn_wb_base:	Base address of ADC_CMN_WB module
+ * @adc_cmn_base:	Base address of ADC_CMN module
+ * @vbatt_empty_threshold_mv:	Threshold for vbatt-empty INT.
+ * @pon_ocv:		Power-on OCV of QBG device
+ * @pon_ibat:		Power-on current of QBG device
+ * @pon_soc:		Power-on SOC of QBG device
+ * @soc:		Monotonic SOC of QBG device
+ * @batt_soc:		Battery SOC
+ * @sys_soc:		Battery system SOC
+ * @esr:		Battery equivalent series resistance
+ * @ocv_uv:		Battery open circuit voltage
+ * @voltage_now:	Battery voltage
+ * @current_now:	Battery current
+ * @tbat:		Battery temperature
+ * @charge_cycle_count:	Battery charge cycle count
+ * @nominal_capacity:	Battery nominal capacity
+ * @learned_capacity:	Battery learned capacity
+ * @ttf:		Time to full
+ * @tte:		Time to empty
+ * @soh:		Battery state of health
+ * @charge_type:	Charging type
+ * @float_volt_uv:	Battery maximum voltage
+ * @fastchg_curr_ma:	Battery fast charge current
+ * @vbat_cutoff_mv:	Battery cutoff voltage
+ * @ibat_cutoff_ma:	Battery cutoff current
+ * @vph_min_mv:	Battery minimum power
+ * @iterm_ma:	Charge Termination current
+ * @rconn_mohm:	Battery connector resistance
+ * @previous_ep_time:	Previous timestamp when essential params stored
+ * @current_time:	Current time stamp
+ * @rated_capacity	rated capacity of battery
+ * @context_count:	Size of the last QBG context dump stored
+ * @profile_loaded:	Flag to indicated battery profile is loaded
+ * @battery_missing:	Flag to indicate battery is missing
+ * @data_ready:		Flag to indicate QBG data is ready
+ * @in_fast_char:	Flag to indicate QBG is in fast char mode
+ * @enable_fifo_depth_half	Flag to indicate QBG fifo reduce half
+ */
+struct qti_qbg {
+	struct device		*dev;
+	struct regmap		*regmap;
+	struct power_supply	*qbg_psy;
+	struct power_supply	*batt_psy;
+	struct power_supply	*usb_psy;
+	struct class		qbg_class;
+	struct device		*qbg_device;
+	struct cdev		qbg_cdev;
+	dev_t			dev_no;
+	struct device_node      *batt_node;
+	struct dentry		*dfs_root;
+	struct iio_dev		*indio_dev;
+	struct iio_chan_spec	*iio_chan;
+	struct nvmem_device	**sdam;
+	struct nvmem_cell       *debug_mask_nvmem_low;
+	struct nvmem_cell       *debug_mask_nvmem_high;
+	struct nvmem_cell	*skip_esr_state;
+	struct fifo_data	fifo[MAX_FIFO_COUNT];
+	struct qbg_essential_params	essential_params;
+	struct work_struct	status_change_work;
+	struct work_struct	udata_work;
+	struct delayed_work	soc_update_work;
+	struct notifier_block	nb;
+	struct qbg_kernel_data	kdata;
+	struct qbg_user_data	udata;
+	struct qbg_battery_data	*battery;
+	struct qbg_step_chg_jeita_params	*step_chg_jeita_params;
+	struct mutex		fifo_lock;
+	struct mutex		data_lock;
+	struct mutex		context_lock;
+	struct iio_channel	*batt_id_chan;
+	struct iio_channel	*batt_temp_chan;
+	struct iio_channel	**ext_iio_chans;
+	struct rtc_device	*rtc;
+	struct wakeup_source    *qbg_ws;
+	ktime_t			last_fast_char_time;
+	wait_queue_head_t	qbg_wait_q;
+	const char		*irq_name;
+	const char		*batt_type_str;
+	const char		*vbatt_empty_irq_name;
+	int			irq;
+	int			vbatt_empty_irq;
+	u8			*context;
+	u32			base;
+	u32			rev4;
+	u32			sdam_base;
+	u32			num_data_sdams;
+	u32			max_fifo_count;
+	u32			batt_id_ohm;
+	u32			sdam_batt_id;
+	u32			batt_profile_id;
+	u32			essential_param_revid;
+	u32			sample_time_us[QBG_STATE_MAX];
+	u32			*debug_mask;
+	u32			adc_cmn_wb_base;
+	u32			adc_cmn_base;
+	u32			vbatt_empty_threshold_mv;
+	int			pon_ocv;
+	int			pon_ibat;
+	int			pon_tbat;
+	int			pon_soc;
+	int			soc;
+	int			batt_soc;
+	int			sys_soc;
+	int			esr;
+	int			ocv_uv;
+	int			voltage_now;
+	int			current_now;
+	int			tbat;
+	int			charge_cycle_count;
+	int			nominal_capacity;
+	int			learned_capacity;
+	int			ttf;
+	int			tte;
+	int			soh;
+	int			charge_type;
+	int			charge_status;
+	int			charger_present;
+	bool			charge_done;
+	bool			charge_full;
+	bool			in_recharge;
+	int			recharge_soc;
+	int			recharge_vflt_delta_mv;
+	int			recharge_iterm_ma;
+	int			default_iterm_ma;
+	int			float_volt_uv;
+	int			fastchg_curr_ma;
+	int			vbat_cutoff_mv;
+	int			ibat_cutoff_ma;
+	int			vph_min_mv;
+	int			iterm_ma;
+	int			rconn_mohm;
+	unsigned long		previous_ep_time;
+	unsigned long		current_time;
+	int			context_count;
+	int			rated_capacity;
+	bool			profile_loaded;
+	bool			battery_missing;
+	bool			battery_unknown;
+	bool			data_ready;
+	bool			in_fast_char;
+	bool			enable_fifo_depth_half;
+	bool			udata_updated;
+};
+#endif /* __QBG_CORE_H__ */
diff --git a/drivers/soc/qcom/qbg-iio.h b/drivers/soc/qcom/qbg-iio.h
new file mode 100644
index 000000000000..bcf5fdefe974
--- /dev/null
+++ b/drivers/soc/qcom/qbg-iio.h
@@ -0,0 +1,71 @@
+/* SPDX-License-Identifier: GPL-2.0-only */
+/*
+ * Copyright (c) 2021 The Linux Foundation. All rights reserved.
+ * Copyright (c) 2022 Qualcomm Innovation Center, Inc. All rights reserved.
+ */
+
+#ifndef __QBG_IIO_H__
+#define __QBG_IIO_H__
+
+struct qbg_iio_channels {
+	const char *datasheet_name;
+	int channel_num;
+	enum iio_chan_type type;
+	long info_mask;
+};
+
+#define QBG_IIO_CHAN(_name, _num, _type, _mask)		\
+	{						\
+		.datasheet_name = _name,		\
+		.channel_num = _num,			\
+		.type = _type,				\
+		.info_mask = _mask,			\
+	},
+
+#define QBG_CHAN_ENERGY(_name, _num)			\
+	QBG_IIO_CHAN(_name, _num, IIO_ENERGY,		\
+		BIT(IIO_CHAN_INFO_PROCESSED))
+
+#define QBG_CHAN_TEMP(_name, _num)			\
+	QBG_IIO_CHAN(_name, _num, IIO_TEMP,		\
+		BIT(IIO_CHAN_INFO_PROCESSED))
+
+#define QBG_CHAN_VOLT(_name, _num)			\
+	QBG_IIO_CHAN(_name, _num, IIO_VOLTAGE,		\
+		BIT(IIO_CHAN_INFO_PROCESSED))
+
+#define QBG_CHAN_TSTAMP(_name, _num)			\
+	QBG_IIO_CHAN(_name, _num, IIO_TIMESTAMP,	\
+		BIT(IIO_CHAN_INFO_PROCESSED))
+
+#define QBG_CHAN_RES(_name, _num)			\
+	QBG_IIO_CHAN(_name, _num, IIO_RESISTANCE,	\
+		BIT(IIO_CHAN_INFO_PROCESSED))
+
+#define QBG_CHAN_INDEX(_name, _num)			\
+	QBG_IIO_CHAN(_name, _num, IIO_INDEX,		\
+		BIT(IIO_CHAN_INFO_PROCESSED))
+
+#define QBG_CHAN_CUR(_name, _num)			\
+	QBG_IIO_CHAN(_name, _num, IIO_CURRENT,		\
+		BIT(IIO_CHAN_INFO_PROCESSED))
+
+#define QBG_CHAN_COUNT(_name, _num)			\
+	QBG_IIO_CHAN(_name, _num, IIO_COUNT,		\
+		BIT(IIO_CHAN_INFO_PROCESSED))
+
+enum qbg_ext_iio_channels {
+	RECHARGE_SOC,
+	FORCE_RECHARGE,
+	CHARGE_DONE,
+	SYS_SOC,
+};
+
+static const char * const qbg_ext_iio_chan_name[] = {
+	[RECHARGE_SOC]			= "recharge_soc",
+	[FORCE_RECHARGE]		= "force_recharge",
+	[CHARGE_DONE]			= "charge_done",
+	[SYS_SOC]			= "sys_soc",
+};
+
+#endif /* __QBG_IIO_H__ */
diff --git a/drivers/soc/qcom/qbg-sdam.h b/drivers/soc/qcom/qbg-sdam.h
new file mode 100644
index 000000000000..87063f164eae
--- /dev/null
+++ b/drivers/soc/qcom/qbg-sdam.h
@@ -0,0 +1,47 @@
+/* SPDX-License-Identifier: GPL-2.0-only */
+/*
+ * Copyright (c) 2021 The Linux Foundation. All rights reserved.
+ * Copyright (c) 2022 Qualcomm Innovation Center, Inc. All rights reserved.
+ */
+
+#ifndef __QBG_SDAM_H__
+#define __QBG_SDAM_H__
+
+#define QBG_SDAM_PBS_STATUS_OFFSET		0x45
+#define QBG_SDAM_FIFO_COUNT_OFFSET		0x46
+#define QBG_SDAM_HPM_FIFO_COUNT_OFFSET		0x4e
+#define QBG_ESSENTIAL_PARAMS_START_OFFSET	0x47
+#define QBG_SDAM_MAX_FIFO_COUNT_OFFSET		0x48
+#define QBG_SDAM_START_OFFSET			0x4b
+#define QBG_ESSENTIAL_PARAMS_BATTID_OFFSET	0x45
+#define QBG_ESR_PULSE_FCC_REDUCE_OFFSET		0x57
+#define QBG_SDAM_BHARGER_OCV_HDRM_OFFSET	0x5b
+#define QBG_ESSENTIAL_PARAMS_REVID_OFFSET	0xbb
+#define QBG_SDAM_INT_TEST1			0xe0
+#define QBG_SDAM_INT_TEST_VAL			0xe1
+#define QBG_SDAM_DATA_PUSH_COUNTER_OFFSET	0x46
+
+#define QBG_SDAM_TEST_VAL_1_SET			0x2
+#define QBG_SDAM_ONE_FIFO_REGION_SIZE		117 /* 117 bytes for FIFO starting from 0x4B */
+#define QBG_SDAM_ESR_PULSE_FIFO_INDEX		11
+
+#define QBG_SINGLE_SDAM_SIZE			0x100
+#define QBG_SDAM_BASE(chip, index)	(chip->sdam_base + (index * QBG_SINGLE_SDAM_SIZE))
+
+#define QBG_SDAM_DATA_START_OFFSET(chip, index)	\
+	(QBG_SDAM_BASE(chip, index) + QBG_SDAM_START_OFFSET)
+
+int qbg_sdam_read(struct qti_qbg *chip, int offset, u8 *data,
+			int length);
+int qbg_sdam_write(struct qti_qbg *chip, int offset, u8 *data,
+			int length);
+int qbg_sdam_get_fifo_data(struct qti_qbg *chip, struct fifo_data *fifo,
+				u32 fifo_count);
+int qbg_sdam_get_essential_params(struct qti_qbg *chip, u8 *params);
+int qbg_sdam_set_essential_params(struct qti_qbg *chip, u8 *params);
+
+int qbg_sdam_get_essential_param_revid(struct qti_qbg *chip, u8 *revid);
+int qbg_sdam_set_essential_param_revid(struct qti_qbg *chip, u8 revid);
+int qbg_sdam_get_battery_id(struct qti_qbg *chip, u32 *battid);
+int qbg_sdam_set_battery_id(struct qti_qbg *chip, u32 battid);
+#endif /* __QBG_SDAM_H__ */
diff --git a/drivers/soc/qcom/qcom_aoss.c b/drivers/soc/qcom/qcom_aoss.c
index 56872d1fbdf5..4cbbe59f119f 100644
--- a/drivers/soc/qcom/qcom_aoss.c
+++ b/drivers/soc/qcom/qcom_aoss.c
@@ -328,7 +328,6 @@ int qmp_send(struct qmp *qmp, const void *data, size_t len)
 		AOSS_INFO("timed out clearing msg: %.*s\n", len, (char *)data);
 		writel(0, qmp->msgram + qmp->offset);
 	} else if (time_left < 0) {
-		dev_err(qmp->dev, "wait error %d\n", time_left);
 		ret = time_left;
 	} else {
 		AOSS_INFO("ack: %.*s\n", len, (char *)data);
diff --git a/drivers/soc/qcom/qcom_ramdump.c b/drivers/soc/qcom/qcom_ramdump.c
index 39115f13f725..f2b658d29ac7 100644
--- a/drivers/soc/qcom/qcom_ramdump.c
+++ b/drivers/soc/qcom/qcom_ramdump.c
@@ -115,7 +115,6 @@ int qcom_dump(struct list_head *segs, struct device *dev)
 		return -EINVAL;
 
 	list_for_each_entry(segment, segs, node) {
-		pr_info("Got segment size %d\n", segment->size);
 		data_size += segment->size;
 	}
 
@@ -181,7 +180,6 @@ int qcom_elf_dump(struct list_head *segs, struct device *dev, unsigned char clas
 	if (!data)
 		return -ENOMEM;
 
-	pr_debug("Creating elf with size %d\n", data_size);
 	ehdr = data;
 
 	memset(ehdr, 0, sizeof_elf_hdr(class));
diff --git a/drivers/soc/qcom/qg-battery-profile.h b/drivers/soc/qcom/qg-battery-profile.h
new file mode 100644
index 000000000000..f0dfde3d03f5
--- /dev/null
+++ b/drivers/soc/qcom/qg-battery-profile.h
@@ -0,0 +1,15 @@
+/* SPDX-License-Identifier: GPL-2.0-only */
+/*
+ * Copyright (c) 2018, 2020, The Linux Foundation. All rights reserved.
+ * Copyright (c) 2022, Qualcomm Innovation Center, Inc. All rights reserved.
+ */
+
+#ifndef __QG_BATTERY_PROFILE_H__
+#define __QG_BATTERY_PROFILE_H__
+
+int qg_batterydata_init(struct device_node *node);
+void qg_batterydata_exit(void);
+int lookup_soc_ocv(u32 *soc, u32 ocv_uv, int batt_temp, bool charging);
+int qg_get_nominal_capacity(u32 *nom_cap_uah, int batt_temp, bool charging);
+
+#endif /* __QG_BATTERY_PROFILE_H__ */
diff --git a/drivers/soc/qcom/qg-core.h b/drivers/soc/qcom/qg-core.h
new file mode 100644
index 000000000000..49d55c32cadb
--- /dev/null
+++ b/drivers/soc/qcom/qg-core.h
@@ -0,0 +1,292 @@
+/* SPDX-License-Identifier: GPL-2.0-only */
+/*
+ * Copyright (c) 2018-2021 The Linux Foundation. All rights reserved.
+ * Copyright (c) 2022, Qualcomm Innovation Center, Inc. All rights reserved.
+ */
+
+#ifndef __QG_CORE_H__
+#define __QG_CORE_H__
+
+#include <linux/kernel.h>
+#include "fg-alg.h"
+#include "qg-defs.h"
+
+struct qg_config {
+	u32			qg_version;
+	u32			pmic_version;
+};
+
+struct qg_batt_props {
+	const char		*batt_type_str;
+	int			float_volt_uv;
+	int			vbatt_full_mv;
+	int			fastchg_curr_ma;
+	int			qg_profile_version;
+};
+
+struct qg_irq_info {
+	const char		*name;
+	const irq_handler_t	handler;
+	const bool		wake;
+	int			irq;
+};
+
+struct qg_dt {
+	int			vbatt_empty_mv;
+	int			vbatt_empty_cold_mv;
+	int			vbatt_low_mv;
+	int			vbatt_low_cold_mv;
+	int			vbatt_cutoff_mv;
+	int			iterm_ma;
+	int			s2_fifo_length;
+	int			s2_vbat_low_fifo_length;
+	int			s2_acc_length;
+	int			s2_acc_intvl_ms;
+	int			sleep_s2_fifo_length;
+	int			sleep_s2_acc_length;
+	int			sleep_s2_acc_intvl_ms;
+	int			fast_chg_s2_fifo_length;
+	int			ocv_timer_expiry_min;
+	int			ocv_tol_threshold_uv;
+	int			s3_entry_fifo_length;
+	int			s3_entry_ibat_ua;
+	int			s3_exit_ibat_ua;
+	int			delta_soc;
+	int			rbat_conn_mohm;
+	int			ignore_shutdown_soc_secs;
+	int			shutdown_temp_diff;
+	int			cold_temp_threshold;
+	int			esr_qual_i_ua;
+	int			esr_qual_v_uv;
+	int			esr_disable_soc;
+	int			esr_min_ibat_ua;
+	int			shutdown_soc_threshold;
+	int			min_sleep_time_secs;
+	int			sys_min_volt_mv;
+	int			fvss_vbat_mv;
+	int			tcss_entry_soc;
+	int			esr_low_temp_threshold;
+	bool			hold_soc_while_full;
+	bool			linearize_soc;
+	bool			cl_disable;
+	bool			cl_feedback_on;
+	bool			esr_disable;
+	bool			esr_discharge_enable;
+	bool			qg_ext_sense;
+	bool			use_cp_iin_sns;
+	bool			use_s7_ocv;
+	bool			qg_sleep_config;
+	bool			qg_fast_chg_cfg;
+	bool			fvss_enable;
+	bool			multi_profile_load;
+	bool			tcss_enable;
+	bool			bass_enable;
+};
+
+struct qg_esr_data {
+	u32			pre_esr_v;
+	u32			pre_esr_i;
+	u32			post_esr_v;
+	u32			post_esr_i;
+	u32			esr;
+	bool			valid;
+};
+
+struct qpnp_qg {
+	struct device		*dev;
+	struct regmap		*regmap;
+	struct qpnp_vadc_chip	*vadc_dev;
+	struct soh_profile      *sp;
+	struct power_supply	*qg_psy;
+	struct iio_dev		*indio_dev;
+	struct iio_chan_spec	*iio_chan;
+	struct iio_channel	*int_iio_chans;
+	struct iio_channel	**ext_iio_chans;
+	struct class		*qg_class;
+	struct device		*qg_device;
+	struct cdev		qg_cdev;
+	struct device_node      *batt_node;
+	struct dentry		*dfs_root;
+	dev_t			dev_no;
+	struct work_struct	udata_work;
+	struct work_struct	scale_soc_work;
+	struct work_struct	qg_status_change_work;
+	struct delayed_work	qg_sleep_exit_work;
+	struct notifier_block	nb;
+	struct mutex		bus_lock;
+	struct mutex		data_lock;
+	struct mutex		soc_lock;
+	wait_queue_head_t	qg_wait_q;
+	struct votable		*awake_votable;
+	struct votable		*vbatt_irq_disable_votable;
+	struct votable		*fifo_irq_disable_votable;
+	struct votable		*good_ocv_irq_disable_votable;
+	u32			qg_base;
+	u8			qg_subtype;
+	u8			qg_mode;
+
+	/* local data variables */
+	u32			batt_id_ohm;
+	struct qg_kernel_data	kdata;
+	struct qg_user_data	udata;
+	struct power_supply	*batt_psy;
+	struct power_supply	*usb_psy;
+	struct power_supply	*dc_psy;
+	struct power_supply	*parallel_psy;
+	struct power_supply	*cp_psy;
+	struct qg_esr_data	esr_data[QG_MAX_ESR_COUNT];
+
+	/* status variable */
+	u32			*debug_mask;
+	u32			qg_version;
+	u32			pmic_version;
+	bool			qg_device_open;
+	bool			profile_loaded;
+	bool			battery_missing;
+	bool			data_ready;
+	bool			suspend_data;
+	bool			vbat_low;
+	bool			charge_done;
+	bool			parallel_enabled;
+	bool			usb_present;
+	bool			dc_present;
+	bool			charge_full;
+	bool			force_soc;
+	bool			fvss_active;
+	bool			tcss_active;
+	bool			bass_active;
+	bool			first_profile_load;
+	int			charge_status;
+	int			charge_type;
+	int			chg_iterm_ma;
+	int			next_wakeup_ms;
+	int			esr_actual;
+	int			esr_nominal;
+	int			soh;
+	int			soc_reporting_ready;
+	int			last_fifo_v_uv;
+	int			last_fifo_i_ua;
+	int			prev_fifo_i_ua;
+	int			soc_tcss_entry;
+	int			ibat_tcss_entry;
+	int			soc_tcss;
+	int			tcss_entry_count;
+	int			max_fcc_limit_ma;
+	int			bsoc_bass_entry;
+	int			qg_v_ibat;
+	u32			fifo_done_count;
+	u32			wa_flags;
+	u32			seq_no;
+	u32			charge_counter_uah;
+	u32			esr_avg;
+	u32			esr_last;
+	u32			s2_state;
+	u32			s2_state_mask;
+	u32			soc_fvss_entry;
+	u32			vbat_fvss_entry;
+	u32			max_fifo_length;
+	ktime_t			last_user_update_time;
+	ktime_t			last_fifo_update_time;
+	unsigned long		last_maint_soc_update_time;
+	unsigned long		suspend_time;
+	struct iio_channel	*batt_therm_chan;
+	struct iio_channel	*batt_id_chan;
+
+	/* soc params */
+	int			catch_up_soc;
+	int			maint_soc;
+	int			msoc;
+	int			pon_soc;
+	int			batt_soc;
+	int			cc_soc;
+	int			full_soc;
+	int			sys_soc;
+	int			last_adj_ssoc;
+	int			recharge_soc;
+	int			batt_age_level;
+	struct alarm		alarm_timer;
+	u32			sdam_data[SDAM_MAX];
+
+	/* DT */
+	struct qg_dt		dt;
+	struct qg_batt_props	bp;
+	/* capacity learning */
+	struct cap_learning	*cl;
+	/* charge counter */
+	struct cycle_counter	*counter;
+	/* ttf */
+	struct ttf		*ttf;
+};
+
+struct ocv_all {
+	u32 ocv_uv;
+	u32 ocv_raw;
+	char ocv_type[20];
+};
+
+enum ocv_type {
+	S7_PON_OCV,
+	S3_GOOD_OCV,
+	S3_LAST_OCV,
+	SDAM_PON_OCV,
+	PON_OCV_MAX,
+};
+
+enum s2_state {
+	S2_FAST_CHARGING = BIT(0),
+	S2_LOW_VBAT = BIT(1),
+	S2_SLEEP = BIT(2),
+	S2_DEFAULT = BIT(3),
+};
+
+enum debug_mask {
+	QG_DEBUG_PON		= BIT(0),
+	QG_DEBUG_PROFILE	= BIT(1),
+	QG_DEBUG_DEVICE		= BIT(2),
+	QG_DEBUG_STATUS		= BIT(3),
+	QG_DEBUG_FIFO		= BIT(4),
+	QG_DEBUG_IRQ		= BIT(5),
+	QG_DEBUG_SOC		= BIT(6),
+	QG_DEBUG_PM		= BIT(7),
+	QG_DEBUG_BUS_READ	= BIT(8),
+	QG_DEBUG_BUS_WRITE	= BIT(9),
+	QG_DEBUG_ALG_CL		= BIT(10),
+	QG_DEBUG_ESR		= BIT(11),
+};
+
+enum qg_irq {
+	QG_BATT_MISSING_IRQ,
+	QG_VBATT_LOW_IRQ,
+	QG_VBATT_EMPTY_IRQ,
+	QG_FIFO_UPDATE_DONE_IRQ,
+	QG_GOOD_OCV_IRQ,
+	QG_FSM_STAT_CHG_IRQ,
+	QG_EVENT_IRQ,
+	QG_MAX_IRQ,
+};
+
+enum qg_wa_flags {
+	QG_VBAT_LOW_WA = BIT(0),
+	QG_RECHARGE_SOC_WA = BIT(1),
+	QG_CLK_ADJUST_WA = BIT(2),
+	QG_PON_OCV_WA = BIT(3),
+};
+
+enum qg_version {
+	QG_PMIC5,
+	QG_LITE,
+};
+
+enum pmic_version {
+	PM2250,
+	PM6150,
+	PMI632,
+	PM7250B,
+};
+
+enum qg_mode {
+	QG_V_I_MODE,
+	QG_V_MODE,
+};
+
+#endif /* __QG_CORE_H__ */
diff --git a/drivers/soc/qcom/qg-defs.h b/drivers/soc/qcom/qg-defs.h
new file mode 100644
index 000000000000..0191c5d04106
--- /dev/null
+++ b/drivers/soc/qcom/qg-defs.h
@@ -0,0 +1,52 @@
+/* SPDX-License-Identifier: GPL-2.0-only */
+/*
+ * Copyright (c) 2018-2020 The Linux Foundation. All rights reserved.
+ * Copyright (c) 2022, Qualcomm Innovation Center, Inc. All rights reserved.
+ */
+
+#ifndef __QG_DEFS_H__
+#define __QG_DEFS_H__
+
+#define qg_dbg(chip, reason, fmt, ...)			\
+	do {							\
+		if (*chip->debug_mask & (reason))		\
+			pr_info(fmt, ##__VA_ARGS__);	\
+		else						\
+			pr_debug(fmt, ##__VA_ARGS__);	\
+	} while (0)
+
+#define is_between(left, right, value) \
+		(((left) >= (right) && (left) >= (value) \
+			&& (value) >= (right)) \
+		|| ((left) <= (right) && (left) <= (value) \
+			&& (value) <= (right)))
+
+#define UDATA_READY_VOTER		"UDATA_READY_VOTER"
+#define FIFO_DONE_VOTER			"FIFO_DONE_VOTER"
+#define FIFO_RT_DONE_VOTER		"FIFO_RT_DONE_VOTER"
+#define SUSPEND_DATA_VOTER		"SUSPEND_DATA_VOTER"
+#define GOOD_OCV_VOTER			"GOOD_OCV_VOTER"
+#define PROFILE_IRQ_DISABLE		"NO_PROFILE_IRQ_DISABLE"
+#define QG_INIT_STATE_IRQ_DISABLE	"QG_INIT_STATE_IRQ_DISABLE"
+#define TTF_AWAKE_VOTER			"TTF_AWAKE_VOTER"
+#define SLEEP_EXIT_DATA_VOTER		"SLEEP_EXIT_DATA_VOTER"
+#define SLEEP_EXIT_VOTER		"SLEEP_EXIT_VOTER"
+
+#define V_RAW_TO_UV(V_RAW)		div_u64(194637ULL * (u64)V_RAW, 1000)
+#define FIFO_V_RESET_VAL		0x8000
+#define FIFO_I_RESET_VAL		0x8000
+
+#define DEGC_SCALE			10
+#define UV_TO_DECIUV(a)			(a / 100)
+#define DECIUV_TO_UV(a)			(a * 100)
+
+#define QG_MAX_ESR_COUNT		10
+#define QG_MIN_ESR_COUNT		2
+
+#define CAP(min, max, value)			\
+		((min > value) ? min : ((value > max) ? max : value))
+
+#define QG_SOC_FULL	10000
+#define BATT_SOC_32BIT	GENMASK(31, 0)
+
+#endif /* __QG_DEFS_H__ */
diff --git a/drivers/soc/qcom/qg-iio.h b/drivers/soc/qcom/qg-iio.h
new file mode 100644
index 000000000000..d584649b0df7
--- /dev/null
+++ b/drivers/soc/qcom/qg-iio.h
@@ -0,0 +1,125 @@
+/* SPDX-License-Identifier: GPL-2.0-only */
+/*
+ * Copyright (c) 2020-2021 The Linux Foundation. All rights reserved.
+ * Copyright (c) 2022, Qualcomm Innovation Center, Inc. All rights reserved.
+ */
+
+#ifndef __QG_IIO_H
+#define __QG_IIO_H
+
+#include <linux/iio/iio.h>
+#include <dt-bindings/iio/qti_power_supply_iio.h>
+
+struct qg_iio_channels {
+	const char *datasheet_name;
+	int channel_num;
+	enum iio_chan_type type;
+	long info_mask;
+};
+
+#define QG_IIO_CHAN(_name, _num, _type, _mask)		\
+	{						\
+		.datasheet_name = _name,		\
+		.channel_num = _num,			\
+		.type = _type,				\
+		.info_mask = _mask,			\
+	},
+
+#define QG_CHAN_VOLT(_name, _num)			\
+	QG_IIO_CHAN(_name, _num, IIO_VOLTAGE,		\
+		BIT(IIO_CHAN_INFO_PROCESSED))
+
+#define QG_CHAN_CUR(_name, _num)			\
+	QG_IIO_CHAN(_name, _num, IIO_CURRENT,		\
+		BIT(IIO_CHAN_INFO_PROCESSED))
+
+#define QG_CHAN_RES(_name, _num)			\
+	QG_IIO_CHAN(_name, _num, IIO_RESISTANCE,	\
+		BIT(IIO_CHAN_INFO_PROCESSED))
+
+#define QG_CHAN_TEMP(_name, _num)			\
+	QG_IIO_CHAN(_name, _num, IIO_TEMP,		\
+		BIT(IIO_CHAN_INFO_PROCESSED))
+
+#define QG_CHAN_POW(_name, _num)			\
+	QG_IIO_CHAN(_name, _num, IIO_POWER,		\
+		BIT(IIO_CHAN_INFO_PROCESSED))
+
+#define QG_CHAN_ENERGY(_name, _num)			\
+	QG_IIO_CHAN(_name, _num, IIO_ENERGY,		\
+		BIT(IIO_CHAN_INFO_PROCESSED))
+
+#define QG_CHAN_INDEX(_name, _num)			\
+	QG_IIO_CHAN(_name, _num, IIO_INDEX,		\
+		BIT(IIO_CHAN_INFO_PROCESSED))
+
+#define QG_CHAN_ACT(_name, _num)			\
+	QG_IIO_CHAN(_name, _num, IIO_ACTIVITY,		\
+		BIT(IIO_CHAN_INFO_PROCESSED))
+
+#define QG_CHAN_TSTAMP(_name, _num)			\
+	QG_IIO_CHAN(_name, _num, IIO_TIMESTAMP,		\
+		BIT(IIO_CHAN_INFO_PROCESSED))
+
+#define QG_CHAN_COUNT(_name, _num)			\
+	QG_IIO_CHAN(_name, _num, IIO_COUNT,		\
+		BIT(IIO_CHAN_INFO_PROCESSED))
+
+static const struct qg_iio_channels qg_iio_psy_channels[] = {
+	QG_CHAN_ENERGY("capacity", PSY_IIO_CAPACITY)
+	QG_CHAN_ENERGY("capacity_raw", PSY_IIO_CAPACITY_RAW)
+	QG_CHAN_ENERGY("real_capacity", PSY_IIO_REAL_CAPACITY)
+	QG_CHAN_TEMP("temp", PSY_IIO_TEMP)
+	QG_CHAN_VOLT("voltage_now", PSY_IIO_VOLTAGE_NOW)
+	QG_CHAN_VOLT("voltage_ocv", PSY_IIO_VOLTAGE_OCV)
+	QG_CHAN_CUR("current_now", PSY_IIO_CURRENT_NOW)
+	QG_CHAN_ENERGY("charge_counter", PSY_IIO_CHARGE_COUNTER)
+	QG_CHAN_RES("resistance", PSY_IIO_RESISTANCE)
+	QG_CHAN_RES("resistance_id", PSY_IIO_RESISTANCE_ID)
+	QG_CHAN_ACT("soc_reporting_ready", PSY_IIO_SOC_REPORTING_READY)
+	QG_CHAN_RES("resistance_capacitive", PSY_IIO_RESISTANCE_CAPACITIVE)
+	QG_CHAN_INDEX("debug_battery", PSY_IIO_DEBUG_BATTERY)
+	QG_CHAN_VOLT("voltage_min", PSY_IIO_VOLTAGE_MIN)
+	QG_CHAN_VOLT("voltage_max", PSY_IIO_VOLTAGE_MAX)
+	QG_CHAN_CUR("batt_full_current", PSY_IIO_BATT_FULL_CURRENT)
+	QG_CHAN_INDEX("batt_profile_version", PSY_IIO_BATT_PROFILE_VERSION)
+	QG_CHAN_COUNT("cycle_count", PSY_IIO_CYCLE_COUNT)
+	QG_CHAN_ENERGY("charge_full", PSY_IIO_CHARGE_FULL)
+	QG_CHAN_ENERGY("charge_full_design", PSY_IIO_CHARGE_FULL_DESIGN)
+	QG_CHAN_TSTAMP("time_to_full_avg", PSY_IIO_TIME_TO_FULL_AVG)
+	QG_CHAN_TSTAMP("time_to_full_now", PSY_IIO_TIME_TO_FULL_NOW)
+	QG_CHAN_TSTAMP("time_to_empty_avg", PSY_IIO_TIME_TO_EMPTY_AVG)
+	QG_CHAN_RES("esr_actual", PSY_IIO_ESR_ACTUAL)
+	QG_CHAN_RES("esr_nominal", PSY_IIO_ESR_NOMINAL)
+	QG_CHAN_INDEX("soh", PSY_IIO_SOH)
+	QG_CHAN_INDEX("clear_soh", PSY_IIO_CLEAR_SOH)
+	QG_CHAN_ENERGY("cc_soc", PSY_IIO_CC_SOC)
+	QG_CHAN_ACT("fg_reset", PSY_IIO_FG_RESET)
+	QG_CHAN_VOLT("voltage_avg", PSY_IIO_VOLTAGE_AVG)
+	QG_CHAN_CUR("current_avg", PSY_IIO_CURRENT_AVG)
+	QG_CHAN_POW("power_avg", PSY_IIO_POWER_AVG)
+	QG_CHAN_POW("power_now", PSY_IIO_POWER_NOW)
+	QG_CHAN_ACT("scale_mode_en", PSY_IIO_SCALE_MODE_EN)
+	QG_CHAN_INDEX("batt_age_level", PSY_IIO_BATT_AGE_LEVEL)
+	QG_CHAN_ACT("fg_type", PSY_IIO_FG_TYPE)
+};
+
+enum qg_ext_iio_channels {
+	INPUT_CURRENT_LIMITED = 0,
+	RECHARGE_SOC,
+	FORCE_RECHARGE,
+	CHARGE_DONE,
+	PARALLEL_CHARGING_ENABLED,
+	CP_CHARGING_ENABLED,
+};
+
+static const char * const qg_ext_iio_chan_name[] = {
+	[INPUT_CURRENT_LIMITED]	= "input_current_limited",
+	[RECHARGE_SOC]			= "recharge_soc",
+	[FORCE_RECHARGE]		= "force_recharge",
+	[CHARGE_DONE]			= "charge_done",
+	[PARALLEL_CHARGING_ENABLED]	= "parallel_charging_enabled",
+	[CP_CHARGING_ENABLED]		= "cp_charging_enabled",
+};
+
+#endif
diff --git a/drivers/soc/qcom/qg-profile-lib.h b/drivers/soc/qcom/qg-profile-lib.h
new file mode 100644
index 000000000000..6a803ba471ee
--- /dev/null
+++ b/drivers/soc/qcom/qg-profile-lib.h
@@ -0,0 +1,29 @@
+/* SPDX-License-Identifier: GPL-2.0-only */
+/*
+ * Copyright (c) 2018-2020 The Linux Foundation. All rights reserved.
+ * Copyright (c) 2022, Qualcomm Innovation Center, Inc. All rights reserved.
+ */
+
+#ifndef __QG_PROFILE_LIB_H__
+#define __QG_PROFILE_LIB_H__
+
+struct profile_table_data {
+	char		*name;
+	int		rows;
+	int		cols;
+	int		*row_entries;
+	int		*col_entries;
+	int		**data;
+};
+
+int qg_linear_interpolate(int y0, int x0, int y1, int x1, int x);
+int qg_interpolate_single_row_lut(struct profile_table_data *lut,
+						int x, int scale);
+int qg_interpolate_soc(struct profile_table_data *lut,
+				int batt_temp, int ocv);
+int qg_interpolate_var(struct profile_table_data *lut,
+				int batt_temp, int soc);
+int qg_interpolate_slope(struct profile_table_data *lut,
+				int batt_temp, int soc);
+
+#endif /*__QG_PROFILE_LIB_H__ */
diff --git a/drivers/soc/qcom/qg-reg.h b/drivers/soc/qcom/qg-reg.h
new file mode 100644
index 000000000000..f0aff12e24f9
--- /dev/null
+++ b/drivers/soc/qcom/qg-reg.h
@@ -0,0 +1,138 @@
+/* SPDX-License-Identifier: GPL-2.0-only */
+/*
+ * Copyright (c) 2018-2020 The Linux Foundation. All rights reserved.
+ * Copyright (c) 2022, Qualcomm Innovation Center, Inc. All rights reserved.
+ */
+
+#ifndef __QG_REG_H__
+#define __QG_REG_H__
+
+#define PERPH_TYPE_REG				0x04
+
+#define PERPH_SUBTYPE_REG			0x05
+#define QG_ADC_IBAT_5A				0x3
+#define QG_ADC_IBAT_10A				0x4
+
+#define QG_TYPE					0x0D
+
+#define QG_STATUS1_REG				0x08
+#define QG_OK_BIT				BIT(7)
+#define BATTERY_PRESENT_BIT			BIT(0)
+#define ESR_MEAS_DONE_BIT			BIT(4)
+
+#define QG_STATUS2_REG				0x09
+#define BATTERY_MISSING_BIT			BIT(3)
+#define GOOD_OCV_BIT				BIT(1)
+
+#define QG_STATUS3_REG				0x0A
+#define COUNT_FIFO_RT_MASK			GENMASK(3, 0)
+
+#define QG_STATUS4_REG				0x0B
+#define ESR_MEAS_IN_PROGRESS_BIT		BIT(4)
+
+#define QG_INT_RT_STS_REG			0x10
+#define FIFO_UPDATE_DONE_RT_STS_BIT		BIT(3)
+#define VBAT_LOW_INT_RT_STS_BIT			BIT(1)
+#define BATTERY_MISSING_INT_RT_STS_BIT		BIT(0)
+
+#define QG_INT_LATCHED_STS_REG			0x18
+#define FIFO_UPDATE_DONE_INT_LAT_STS_BIT	BIT(3)
+
+#define QG_STATE_TRIG_CMD_REG			0x40
+#define S7_PON_OCV_START			BIT(3)
+
+#define QG_DATA_CTL1_REG			0x41
+#define MASTER_HOLD_OR_CLR_BIT			BIT(0)
+
+#define QG_DATA_CTL2_REG			0x42
+#define BURST_AVG_HOLD_FOR_READ_BIT		BIT(0)
+
+#define QG_MODE_CTL1_REG			0x43
+#define PARALLEL_IBAT_SENSE_EN_BIT		BIT(7)
+
+#define QG_MODE_CTL2_REG			0x44
+#define VI_MODE_BIT				BIT(0)
+
+#define QG_VBAT_EMPTY_THRESHOLD_REG		0x4B
+#define QG_VBAT_LOW_THRESHOLD_REG		0x4C
+
+#define QG_S2_NORMAL_MEAS_CTL2_REG		0x51
+#define FIFO_LENGTH_MASK			GENMASK(5, 3)
+#define FIFO_LENGTH_SHIFT			3
+#define NUM_OF_ACCUM_MASK			GENMASK(2, 0)
+
+#define QG_S2_NORMAL_MEAS_CTL3_REG		0x52
+
+#define QG_S3_SLEEP_OCV_MEAS_CTL4_REG		0x59
+#define S3_SLEEP_OCV_TIMER_MASK			GENMASK(2, 0)
+
+#define QG_S3_SLEEP_OCV_TREND_CTL2_REG		0x5C
+#define TREND_TOL_MASK				GENMASK(5, 0)
+
+#define QG_S3_SLEEP_OCV_IBAT_CTL1_REG		0x5D
+#define SLEEP_IBAT_QUALIFIED_LENGTH_MASK	GENMASK(2, 0)
+
+#define QG_S3_ENTRY_IBAT_THRESHOLD_REG		0x5E
+#define QG_S3_EXIT_IBAT_THRESHOLD_REG		0x5F
+
+#define QG_S5_OCV_VALIDATE_MEAS_CTL1_REG	0x60
+#define ALLOW_S5_BIT				BIT(7)
+
+#define QG_S7_PON_OCV_MEAS_CTL1_REG		0x64
+#define ADC_CONV_DLY_MASK			GENMASK(3, 0)
+
+#define QG_ESR_MEAS_TRIG_REG			0x68
+#define HW_ESR_MEAS_START_BIT			BIT(0)
+
+#define QG_S7_PON_OCV_V_DATA0_REG		0x70
+#define QG_S7_PON_OCV_I_DATA0_REG		0x72
+#define QG_S3_GOOD_OCV_V_DATA0_REG		0x74
+#define QG_S3_GOOD_OCV_I_DATA0_REG		0x76
+
+#define QG_PRE_ESR_V_DATA0_REG			0x78
+#define QG_PRE_ESR_I_DATA0_REG			0x7A
+#define QG_POST_ESR_V_DATA0_REG			0x7C
+#define QG_POST_ESR_I_DATA0_REG			0x7E
+
+#define QG_S2_NORMAL_AVG_V_DATA0_REG		0x80
+#define QG_S2_NORMAL_AVG_I_DATA0_REG		0x82
+
+#define QG_V_ACCUM_DATA0_RT_REG			0x88
+#define QG_I_ACCUM_DATA0_RT_REG			0x8B
+#define QG_ACCUM_CNT_RT_REG			0x8E
+
+#define QG_V_FIFO0_DATA0_REG			0x90
+#define QG_I_FIFO0_DATA0_REG			0xA0
+
+#define QG_SOC_MONOTONIC_REG			0xBF
+
+#define QG_LAST_ADC_V_DATA0_REG			0xC0
+#define QG_LAST_ADC_I_DATA0_REG			0xC2
+
+#define QG_LAST_BURST_AVG_I_DATA0_REG		0xC6
+
+#define QG_LAST_S3_SLEEP_V_DATA0_REG		0xCC
+
+/* SDAM offsets */
+#define QG_SDAM_VALID_OFFSET			0x46 /* 1-byte 0x46 */
+#define QG_SDAM_SOC_OFFSET			0x47 /* 1-byte 0x47 */
+#define QG_SDAM_TEMP_OFFSET			0x48 /* 2-byte 0x48-0x49 */
+#define QG_SDAM_RBAT_OFFSET			0x4A /* 2-byte 0x4A-0x4B */
+#define QG_SDAM_OCV_OFFSET			0x4C /* 4-byte 0x4C-0x4F */
+#define QG_SDAM_IBAT_OFFSET			0x50 /* 4-byte 0x50-0x53 */
+#define QG_SDAM_TIME_OFFSET			0x54 /* 4-byte 0x54-0x57 */
+#define QG_SDAM_CYCLE_COUNT_OFFSET		0x58 /* 16-byte 0x58-0x67 */
+#define QG_SDAM_LEARNED_CAPACITY_OFFSET		0x68 /* 2-byte 0x68-0x69 */
+#define QG_SDAM_ESR_CHARGE_DELTA_OFFSET		0x6A /* 4-byte 0x6A-0x6D */
+#define QG_SDAM_ESR_DISCHARGE_DELTA_OFFSET	0x6E /* 4-byte 0x6E-0x71 */
+#define QG_SDAM_ESR_CHARGE_SF_OFFSET		0x72 /* 2-byte 0x72-0x73 */
+#define QG_SDAM_ESR_DISCHARGE_SF_OFFSET		0x74 /* 2-byte 0x74-0x75 */
+#define QG_SDAM_BATT_AGE_LEVEL_OFFSET		0x76 /* 1-byte 0x76 */
+#define QG_SDAM_MAGIC_OFFSET			0x80 /* 4-byte 0x80-0x83 */
+#define QG_SDAM_FLASH_OCV_OFFSET		0x84 /* 1-byte 0x84 */
+#define QG_SDAM_MAX_OFFSET			0xA4
+
+/* Below offset is used by PBS */
+#define QG_SDAM_PON_OCV_OFFSET			0xBC /* 2-byte 0xBC-0xBD */
+
+#endif
diff --git a/drivers/soc/qcom/qg-sdam.h b/drivers/soc/qcom/qg-sdam.h
new file mode 100644
index 000000000000..251038d0f5c3
--- /dev/null
+++ b/drivers/soc/qcom/qg-sdam.h
@@ -0,0 +1,47 @@
+/* SPDX-License-Identifier: GPL-2.0-only */
+/*
+ * Copyright (c) 2018-2020 The Linux Foundation. All rights reserved.
+ * Copyright (c) 2022, Qualcomm Innovation Center, Inc. All rights reserved.
+ */
+
+#ifndef __QG_SDAM_H__
+#define __QG_SDAM_H__
+
+#define SDAM_TYPE			0x2E
+#define SDAM_MIN_OFFSET			0x45
+#define SDAM_MAX_OFFSET			0xB3
+
+enum qg_sdam_param {
+	SDAM_VALID,
+	SDAM_SOC,
+	SDAM_TEMP,
+	SDAM_RBAT_MOHM,
+	SDAM_OCV_UV,
+	SDAM_IBAT_UA,
+	SDAM_TIME_SEC,
+	SDAM_PON_OCV_UV,
+	SDAM_ESR_CHARGE_DELTA,
+	SDAM_ESR_DISCHARGE_DELTA,
+	SDAM_ESR_CHARGE_SF,
+	SDAM_ESR_DISCHARGE_SF,
+	SDAM_MAGIC,
+	SDAM_BATT_AGE_LEVEL,
+	SDAM_FLASH_OCV,
+	SDAM_MAX,
+};
+
+struct qg_sdam {
+	struct regmap		*regmap;
+	u16			sdam_base;
+};
+
+int qg_sdam_init(struct device *dev);
+int qg_sdam_write(u8 param, u32 data);
+int qg_sdam_read(u8 param, u32 *data);
+int qg_sdam_write_all(u32 *sdam_data);
+int qg_sdam_read_all(u32 *sdam_data);
+int qg_sdam_multibyte_write(u32 offset, u8 *sdam_data, u32 length);
+int qg_sdam_multibyte_read(u32 offset, u8 *sdam_data, u32 length);
+int qg_sdam_clear(void);
+
+#endif
diff --git a/drivers/soc/qcom/qg-soc.h b/drivers/soc/qcom/qg-soc.h
new file mode 100644
index 000000000000..84bc4ee0c4da
--- /dev/null
+++ b/drivers/soc/qcom/qg-soc.h
@@ -0,0 +1,22 @@
+/* SPDX-License-Identifier: GPL-2.0-only */
+/*
+ * Copyright (c) 2018, 2020 The Linux Foundation. All rights reserved.
+ * Copyright (c) 2022, Qualcomm Innovation Center, Inc. All rights reserved.
+ */
+
+#ifndef __QG_SOC_H__
+#define __QG_SOC_H__
+
+int qg_scale_soc(struct qpnp_qg *chip, bool force_soc);
+int qg_soc_init(struct qpnp_qg *chip);
+void qg_soc_exit(struct qpnp_qg *chip);
+int qg_adjust_sys_soc(struct qpnp_qg *chip);
+
+extern struct device_attribute dev_attr_soc_interval_ms;
+extern struct device_attribute dev_attr_soc_cold_interval_ms;
+extern struct device_attribute dev_attr_maint_soc_update_ms;
+extern struct device_attribute dev_attr_fvss_delta_soc_interval_ms;
+extern struct device_attribute dev_attr_fvss_vbat_scaling;
+extern struct device_attribute dev_attr_qg_ss_feature;
+
+#endif /* __QG_SOC_H__ */
diff --git a/drivers/soc/qcom/qg-util.h b/drivers/soc/qcom/qg-util.h
new file mode 100644
index 000000000000..48ec6b1d30c1
--- /dev/null
+++ b/drivers/soc/qcom/qg-util.h
@@ -0,0 +1,44 @@
+/* SPDX-License-Identifier: GPL-2.0-only */
+/*
+ * Copyright (c) 2018-2020 The Linux Foundation. All rights reserved.
+ * Copyright (c) 2022, Qualcomm Innovation Center, Inc. All rights reserved.
+ */
+
+#ifndef __QG_UTIL_H__
+#define __QG_UTIL_H__
+
+#define MAX_STEP_CHG_ENTRIES	8
+
+int qg_read(struct qpnp_qg *chip, u32 addr, u8 *val, int len);
+int qg_write(struct qpnp_qg *chip, u32 addr, u8 *val, int len);
+int qg_masked_write(struct qpnp_qg *chip, int addr, u32 mask, u32 val);
+int qg_read_raw_data(struct qpnp_qg *chip, int addr, u32 *data);
+int get_fifo_length(struct qpnp_qg *chip, u32 *fifo_length, bool rt);
+int get_sample_count(struct qpnp_qg *chip, u32 *sample_count);
+int get_sample_interval(struct qpnp_qg *chip, u32 *sample_interval);
+int get_fifo_done_time(struct qpnp_qg *chip, bool rt, int *time_ms);
+int get_rtc_time(unsigned long *rtc_time);
+bool is_usb_present(struct qpnp_qg *chip);
+bool is_dc_present(struct qpnp_qg *chip);
+bool is_input_present(struct qpnp_qg *chip);
+bool is_parallel_enabled(struct qpnp_qg *chip);
+bool is_cp_available(struct qpnp_qg *chip);
+bool is_parallel_available(struct qpnp_qg *chip);
+int qg_write_monotonic_soc(struct qpnp_qg *chip, int msoc);
+int qg_get_battery_temp(struct qpnp_qg *chip, int *batt_temp);
+int qg_get_battery_current(struct qpnp_qg *chip, int *ibat_ua);
+int qg_get_battery_voltage(struct qpnp_qg *chip, int *vbat_uv);
+int qg_get_vbat_avg(struct qpnp_qg *chip, int *vbat_uv);
+s64 qg_iraw_to_ua(struct qpnp_qg *chip, int iraw);
+int qg_get_ibat_avg(struct qpnp_qg *chip, int *ibat_ua);
+bool is_chan_valid(struct qpnp_qg *chip, enum qg_ext_iio_channels chan);
+int qg_read_iio_chan(struct qpnp_qg *chip,
+	enum qg_ext_iio_channels chan, int *val);
+int qg_write_iio_chan(struct qpnp_qg *chip,
+	enum qg_ext_iio_channels chan, int val);
+int qg_read_int_iio_chan(struct iio_channel *iio_chan_list, int chan_id,
+			int *val);
+int qg_read_range_data_from_node(struct device_node *node,
+		const char *prop_str, struct range_data *ranges,
+		int max_threshold, u32 max_value);
+#endif
diff --git a/drivers/soc/qcom/qmath.h b/drivers/soc/qcom/qmath.h
new file mode 100644
index 000000000000..b0bee6ca5b90
--- /dev/null
+++ b/drivers/soc/qcom/qmath.h
@@ -0,0 +1,84 @@
+/*
+ * Copyright 2018 Google, LLC
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#ifndef QMATH_H_
+#define QMATH_H_
+
+#include <linux/types.h>
+#include <linux/math64.h>
+
+typedef s32 qnum_t;
+typedef	s64 qnumd_t;
+typedef	u32 qnumu_t;
+typedef	s64 qnumud_t;
+
+#define QNUM_BITS	(sizeof(qnum_t)*8)
+/* integer part */
+#define QNUM_IBITS	8
+/* fractional part and mask */
+#define QNUM_FBITS	(QNUM_BITS - QNUM_IBITS)
+#define QNUM_FMASK	(((qnum_t)1 << QNUM_FBITS) - 1)
+
+#define qnum_rconst(R) \
+	((qnum_t)((R) * (((qnumd_t)1 << QNUM_FBITS)\
+		+ ((R) >= 0 ? 0.5 : -0.5))))
+
+#define qnum_fromint(I) ((qnumd_t)(I) << QNUM_FBITS)
+/* battery raw capacity is in Q8_8 */
+#define qnum_from_q8_8(Q8_8) ((qnumd_t)(Q8_8) << (QNUM_FBITS-8))
+
+/* truncate */
+#define qnum_toint(F) ((int)((F) >> QNUM_FBITS))
+/* round the number */
+#define qnum_roundint(F, P) \
+	qnum_toint(F + qnum_rconst(P))
+
+
+static inline qnum_t qnum_mul(qnum_t A, qnum_t B)
+{
+	return (((qnumd_t)A * (qnumd_t)B) >> QNUM_FBITS);
+}
+
+static inline qnum_t qnum_div(qnum_t A, qnum_t B)
+{
+
+	return div64_s64(((qnumd_t)A << QNUM_FBITS), (qnumd_t)B);
+}
+
+
+/* 1, 2, 3, and 4 digits */
+#define qnum_fracpart(A) ((qnum_t)(A) & QNUM_FMASK)
+
+#define QNUM_FRACBITS(A)  \
+	(((qnum_fracpart(A) << QNUM_IBITS)) & (((qnumud_t)1 << QNUM_BITS)-1))
+
+#define QNUM_FRACn(A, n) \
+	(((QNUM_FRACBITS(A) * n) >> QNUM_BITS) % n)
+
+#define QNUM_FRAC1(A)	QNUM_FRACn(A, 10)
+#define QNUM_FRAC2(A)	QNUM_FRACn(A, 100)
+#define QNUM_FRAC3(A)	QNUM_FRACn(A, 1000)
+#define QNUM_FRAC4(A)	QNUM_FRACn(A, 10000)
+
+
+#define _PRIMITIVE_CAT(a, ...) a ## __VA_ARGS__
+
+/* print as %d.%0<num>d */
+#define _STR_(x)	# x
+#define QNUM_FDGT_NUM		2
+#define QNUM_CSTR_FMT		"%d.%02d"
+#define QNUM_CSTR_SZ		(4 + 1 + QNUM_FDGT_NUM + 1)
+#define qnum_nfracdgt(A, n)	_PRIMITIVE_CAT(QNUM_FRAC, n)(A)
+#define qnum_fracdgt(A)		((int)qnum_nfracdgt(A, QNUM_FDGT_NUM))
+#endif  /* QMATH_H_ */
diff --git a/drivers/soc/qcom/schgm-flash.h b/drivers/soc/qcom/schgm-flash.h
new file mode 100644
index 000000000000..04e5db8d9efa
--- /dev/null
+++ b/drivers/soc/qcom/schgm-flash.h
@@ -0,0 +1,55 @@
+/* SPDX-License-Identifier: GPL-2.0-only */
+/*
+ * Copyright (c) 2018, 2020 The Linux Foundation. All rights reserved.
+ * Copyright (c) 2022, Qualcomm Innovation Center, Inc. All rights reserved.
+ */
+
+#ifndef __SCHGM_FLASH_H__
+#define __SCHGM_FLASH_H__
+
+#include <linux/bitops.h>
+
+#define SCHGM_FLASH_BASE			0xA600
+
+#define SCHGM_FLASH_STATUS_2_REG		(SCHGM_FLASH_BASE + 0x07)
+#define VREG_OK_BIT				BIT(4)
+
+#define SCHGM_FLASH_STATUS_3_REG		(SCHGM_FLASH_BASE + 0x08)
+#define FLASH_STATE_MASK			GENMASK(2, 0)
+#define FLASH_ERROR_VAL				0x7
+
+#define SCHGM_FLASH_INT_RT_STS_REG		(SCHGM_FLASH_BASE + 0x10)
+
+#define SCHGM_FLASH_STATUS_5_REG		(SCHGM_FLASH_BASE + 0x0B)
+
+#define SCHGM_FORCE_BOOST_CONTROL		(SCHGM_FLASH_BASE + 0x41)
+#define FORCE_FLASH_BOOST_5V_BIT		BIT(0)
+
+#define SCHGM_FLASH_S2_LATCH_RESET_CMD_REG	(SCHGM_FLASH_BASE + 0x44)
+#define FLASH_S2_LATCH_RESET_BIT		BIT(0)
+
+#define SCHGM_FLASH_CONTROL_REG			(SCHGM_FLASH_BASE + 0x60)
+#define SOC_LOW_FOR_FLASH_EN_BIT		BIT(7)
+
+#define SCHGM_TORCH_PRIORITY_CONTROL_REG	(SCHGM_FLASH_BASE + 0x63)
+#define TORCH_PRIORITY_CONTROL_BIT		BIT(0)
+
+#define SCHGM_SOC_BASED_FLASH_DERATE_TH_CFG_REG	(SCHGM_FLASH_BASE + 0x67)
+
+#define SCHGM_SOC_BASED_FLASH_DISABLE_TH_CFG_REG \
+						(SCHGM_FLASH_BASE + 0x68)
+
+enum torch_mode {
+	TORCH_BUCK_MODE = 0,
+	TORCH_BOOST_MODE,
+};
+
+int schgm_flash_get_vreg_ok(struct smb_charger *chg, int *val);
+void schgm_flash_torch_priority(struct smb_charger *chg, enum torch_mode mode);
+int schgm_flash_init(struct smb_charger *chg);
+bool is_flash_active(struct smb_charger *chg);
+
+irqreturn_t smb5_schgm_flash_default_irq_handler(int irq, void *data);
+irqreturn_t smb5_schgm_flash_ilim2_irq_handler(int irq, void *data);
+irqreturn_t smb5_schgm_flash_state_change_irq_handler(int irq, void *data);
+#endif /* __SCHGM_FLASH_H__ */
diff --git a/drivers/soc/qcom/schgm-flashlite.h b/drivers/soc/qcom/schgm-flashlite.h
new file mode 100644
index 000000000000..3b466287d5a1
--- /dev/null
+++ b/drivers/soc/qcom/schgm-flashlite.h
@@ -0,0 +1,60 @@
+/* SPDX-License-Identifier: GPL-2.0-only */
+/*
+ * Copyright (c) 2018, 2020 The Linux Foundation. All rights reserved.
+ * Copyright (c) 2022 Qualcomm Innovation Center, Inc. All rights reserved.
+ */
+
+#ifndef __SCHGM_FLASHLITE_H__
+#define __SCHGM_FLASHLITE_H__
+
+#include <linux/bitops.h>
+
+#define SCHGM_FLASH_BASE			0xA600
+
+#define SCHGM_FLASH_STATUS_2_REG		(SCHGM_FLASH_BASE + 0x07)
+#define VREG_OK_BIT				BIT(4)
+
+#define SCHGM_FLASH_STATUS_3_REG		(SCHGM_FLASH_BASE + 0x08)
+#define FLASH_STATE_MASK			GENMASK(2, 0)
+#define FLASH_ERROR_VAL				0x7
+
+#define SCHGM_FLASH_INT_RT_STS_REG		(SCHGM_FLASH_BASE + 0x10)
+
+#define SCHGM_FLASH_STATUS_5_REG		(SCHGM_FLASH_BASE + 0x0B)
+
+#define SCHGM_FLASH_S2_LATCH_RESET_CMD_REG	(SCHGM_FLASH_BASE + 0x44)
+#define FLASH_S2_LATCH_RESET_BIT		BIT(0)
+
+#define SCHGM_FLASH_CONTROL_REG			(SCHGM_FLASH_BASE + 0x60)
+#define SOC_LOW_FOR_FLASH_EN_BIT		BIT(7)
+#define TEMP_DIE_REG_H_DERATE_EN_BIT		BIT(3)
+#define TEMP_DIE_REG_L_DERATE_EN_BIT		BIT(2)
+
+#define SCHGM_TORCH_PRIORITY_CONTROL_REG	(SCHGM_FLASH_BASE + 0x63)
+#define TORCH_PRIORITY_CONTROL_BIT		BIT(0)
+
+#define SCHG_L_FLASH_FLASH_FAULT_CFG		(SCHGM_FLASH_BASE + 0x64)
+#define CFG_FLASH_USB_COLLAPSE_BIT		BIT(7)
+
+#define SCHGM_SOC_BASED_FLASH_DERATE_TH_CFG_REG	(SCHGM_FLASH_BASE + 0x67)
+
+#define SCHGM_SOC_BASED_FLASH_DISABLE_TH_CFG_REG \
+						(SCHGM_FLASH_BASE + 0x68)
+
+enum torch_mode {
+	TORCH_BUCK_MODE = 0,
+	TORCH_BOOST_MODE,
+};
+
+int schgm_flashlite_get_vreg_ok(struct smb_charger *chg, int *val);
+void schgm_flashlite_torch_priority(struct smb_charger *chg,
+					enum torch_mode mode);
+int schgm_flashlite_config_usbin_collapse(struct smb_charger *chg,
+						bool enable);
+int schgm_flashlite_init(struct smb_charger *chg);
+bool is_flashlite_active(struct smb_charger *chg);
+
+irqreturn_t schgm_flashlite_default_irq_handler(int irq, void *data);
+irqreturn_t schgm_flashlite_ilim2_irq_handler(int irq, void *data);
+irqreturn_t schgm_flashlite_state_change_irq_handler(int irq, void *data);
+#endif /* __SCHGM_FLASHLITE_H__ */
diff --git a/drivers/soc/qcom/smb5-iio.h b/drivers/soc/qcom/smb5-iio.h
new file mode 100644
index 000000000000..39666cdf6d15
--- /dev/null
+++ b/drivers/soc/qcom/smb5-iio.h
@@ -0,0 +1,217 @@
+/* SPDX-License-Identifier: GPL-2.0-only */
+/*
+ * Copyright (c) 2020-2021 The Linux Foundation. All rights reserved.
+ * Copyright (c) 2022-2023, Qualcomm Innovation Center, Inc. All rights reserved.
+ */
+
+#ifndef __SMB5_IIO_H
+#define __SMB5_IIO_H
+
+#include <linux/iio/iio.h>
+#include <dt-bindings/iio/qti_power_supply_iio.h>
+
+enum iio_type {
+	MAIN,
+	QG,
+	CP,
+	SMB_PARALLEL,
+};
+
+/* For qpnp-smb5.c and smb5-lib.c */
+enum qg_chg_iio_channels {
+	SMB5_QG_DEBUG_BATTERY,
+	SMB5_QG_CAPACITY,
+	SMB5_QG_REAL_CAPACITY,
+	SMB5_QG_CC_SOC,
+	SMB5_QG_CURRENT_NOW,
+	SMB5_QG_VOLTAGE_NOW,
+	SMB5_QG_VOLTAGE_MAX,
+	SMB5_QG_CHARGE_FULL,
+	SMB5_QG_RESISTANCE_ID,
+	SMB5_QG_TEMP,
+	SMB5_QG_CHARGE_COUNTER,
+	SMB5_QG_CYCLE_COUNT,
+	SMB5_QG_CHARGE_FULL_DESIGN,
+	SMB5_QG_TIME_TO_FULL_NOW,
+	SMB5_QG_TIME_TO_EMPTY_NOW,
+	SMB5_QG_NOMINAL_CAPACITY,
+	SMB5_QG_LEARNED_CAPACITY,
+	SMB5_QG_SOH,
+	SMB5_QG_MAX,
+};
+
+enum cp_iio_channels {
+	CP_PARALLEL_OUTPUT_MODE,
+	CP_MASTER_ENABLE,
+	CP_ILIM,
+	CP_DIE_TEMP,
+};
+
+/* For smb5-lib.c and smb5-iio.c */
+enum smb_parallel_iio_channels {
+	SMB_CHARGER_TEMP,
+	SMB_CHARGER_TEMP_MAX,
+	SMB_SET_SHIP_MODE,
+};
+
+/* For step-chg-jeita.c */
+enum step_chg_iio_channels {
+	STEP_QG_RESISTANCE_ID = 0,
+	STEP_QG_VOLTAGE_NOW,
+	STEP_QG_TEMP,
+	STEP_QG_CAPACITY,
+	STEP_QG_VOLTAGE_OCV,
+	STEP_QG_VOLTAGE_AVG,
+};
+
+/* For battery.c */
+enum bat_cp_iio_channels {
+	BAT_CP_PARALLEL_MODE,
+	BAT_CP_PARALLEL_OUTPUT_MODE,
+	BAT_CP_MIN_ICL,
+	BAT_CP_SWITCHER_EN,
+};
+
+enum bat_smb_parallel_iio_channels {
+	BAT_SMB_PARALLEL_INPUT_SUSPEND,
+	BAT_SMB_PARALLEL_MODE,
+	BAT_SMB_PARALLEL_BATFET_MODE,
+	BAT_SMB_PARALLEL_MIN_ICL,
+	BAT_SMB_PARALLEL_FCC_MAX,
+	BAT_SMB_PARALLEL_CURRENT_MAX,
+	BAT_SMB_PARALLEL_CONSTANT_CHARGE_CURRENT_MAX,
+	BAT_SMB_PARALLEL_VOLTAGE_MAX,
+	BAT_SMB_PARALLEL_CHARGE_TYPE,
+};
+
+struct smb5_iio_prop_channels {
+	const char *datasheet_name;
+	int channel_num;
+	enum iio_chan_type type;
+	long info_mask;
+};
+
+#define PARAM(chan) PSY_IIO_##chan
+
+#define SMB5_CHAN(_dname, _chan, _type, _mask)		\
+	{								\
+		.datasheet_name = _dname,				\
+		.channel_num = _chan,				\
+		.type = _type,						\
+		.info_mask = _mask,					\
+	},								\
+
+#define SMB5_CHAN_VOLT(_dname, chan)					\
+	[PARAM(chan)] = SMB5_CHAN(_dname, PARAM(chan),		\
+			IIO_VOLTAGE, BIT(IIO_CHAN_INFO_PROCESSED))	\
+
+#define SMB5_CHAN_CUR(_dname, chan)					\
+	[PARAM(chan)] = SMB5_CHAN(_dname, PARAM(chan),		\
+			IIO_CURRENT, BIT(IIO_CHAN_INFO_PROCESSED))	\
+
+#define SMB5_CHAN_RES(_dname, chan)					\
+	[PARAM(chan)] = SMB5_CHAN(_dname, PARAM(chan),		\
+			IIO_RESISTANCE, BIT(IIO_CHAN_INFO_PROCESSED))	\
+
+#define SMB5_CHAN_TEMP(_dname, chan)					\
+	[PARAM(chan)] = SMB5_CHAN(_dname, PARAM(chan),		\
+			IIO_TEMP, BIT(IIO_CHAN_INFO_PROCESSED))	\
+
+#define SMB5_CHAN_POWER(_dname, chan)					\
+	[PARAM(chan)] = SMB5_CHAN(_dname, PARAM(chan),		\
+			IIO_POWER, BIT(IIO_CHAN_INFO_PROCESSED))	\
+
+#define SMB5_CHAN_CAP(_dname, chan)					\
+	[PARAM(chan)] = SMB5_CHAN(_dname, PARAM(chan),		\
+			IIO_CAPACITANCE, BIT(IIO_CHAN_INFO_PROCESSED))	\
+
+#define SMB5_CHAN_COUNT(_dname, chan)					\
+	[PARAM(chan)] = SMB5_CHAN(_dname, PARAM(chan),		\
+			IIO_COUNT, BIT(IIO_CHAN_INFO_PROCESSED))	\
+
+#define SMB5_CHAN_INDEX(_dname, chan)					\
+	[PARAM(chan)] = SMB5_CHAN(_dname, PARAM(chan),		\
+			IIO_INDEX, BIT(IIO_CHAN_INFO_PROCESSED))	\
+
+#define SMB5_CHAN_ACTIVITY(_dname, chan)				\
+	[PARAM(chan)] = SMB5_CHAN(_dname, PARAM(chan),		\
+			IIO_ACTIVITY, BIT(IIO_CHAN_INFO_PROCESSED))	\
+
+static const struct smb5_iio_prop_channels smb5_chans_pmic[] = {
+	SMB5_CHAN_CUR("usb_pd_current_max", PD_CURRENT_MAX)
+	SMB5_CHAN_INDEX("usb_typec_mode", TYPEC_MODE)
+	SMB5_CHAN_INDEX("usb_typec_power_role", TYPEC_POWER_ROLE)
+	SMB5_CHAN_INDEX("usb_typec_cc_orientation", TYPEC_CC_ORIENTATION)
+	SMB5_CHAN_INDEX("usb_pd_active", PD_ACTIVE)
+	SMB5_CHAN_CUR("usb_input_current_settled", USB_INPUT_CURRENT_SETTLED)
+	SMB5_CHAN_ACTIVITY("usb_pe_start", PE_START)
+	SMB5_CHAN_CUR("usb_ctm_current_max", CTM_CURRENT_MAX)
+	SMB5_CHAN_CUR("usb_hw_current_max", HW_CURRENT_MAX)
+	SMB5_CHAN_INDEX("usb_real_type", USB_REAL_TYPE)
+	SMB5_CHAN_VOLT("usb_pd_voltage_max", PD_VOLTAGE_MAX)
+	SMB5_CHAN_VOLT("usb_pd_voltage_min", PD_VOLTAGE_MIN)
+	SMB5_CHAN_VOLT("voltage_qnovo", VOLTAGE_QNOVO)
+	SMB5_CHAN_CUR("current_qnovo", CURRENT_QNOVO)
+	SMB5_CHAN_INDEX("usb_connector_type", CONNECTOR_TYPE)
+	SMB5_CHAN_INDEX("usb_connector_health", CONNECTOR_HEALTH)
+	SMB5_CHAN_VOLT("usb_voltage_max_limit", VOLTAGE_MAX_LIMIT)
+	SMB5_CHAN_INDEX("usb_smb_en_mode", SMB_EN_MODE)
+	SMB5_CHAN_INDEX("usb_smb_en_reason", SMB_EN_REASON)
+	SMB5_CHAN_INDEX("usb_adapter_cc_mode", ADAPTER_CC_MODE)
+	SMB5_CHAN_INDEX("usb_moisture_detected", MOISTURE_DETECTED)
+	SMB5_CHAN_INDEX("usb_moisture_detection_en", MOISTURE_DETECTION_EN)
+	SMB5_CHAN_INDEX("usb_hvdcp_opti_allowed", HVDCP_OPTI_ALLOWED)
+	SMB5_CHAN_ACTIVITY("usb_qc_opti_disable", QC_OPTI_DISABLE)
+	SMB5_CHAN_VOLT("usb_voltage_vph", VOLTAGE_VPH)
+	SMB5_CHAN_CUR("usb_therm_icl_limit", THERM_ICL_LIMIT)
+	SMB5_CHAN_INDEX("usb_skin_health", SKIN_HEALTH)
+	SMB5_CHAN_ACTIVITY("usb_apsd_rerun", APSD_RERUN)
+	SMB5_CHAN_COUNT("usb_apsd_timeout", APSD_TIMEOUT)
+	SMB5_CHAN_INDEX("usb_charger_status", CHARGER_STATUS)
+	SMB5_CHAN_VOLT("usb_input_voltage_settled", USB_INPUT_VOLTAGE_SETTLED)
+	SMB5_CHAN_ACTIVITY("usb_typec_src_rp", TYPEC_SRC_RP)
+	SMB5_CHAN_ACTIVITY("usb_pd_in_hard_reset", PD_IN_HARD_RESET)
+	SMB5_CHAN_INDEX("usb_pd_usb_suspend_supported",
+			PD_USB_SUSPEND_SUPPORTED)
+	SMB5_CHAN_ACTIVITY("usb_pr_swap", PR_SWAP)
+	SMB5_CHAN_CUR("main_input_current_settled", MAIN_INPUT_CURRENT_SETTLED)
+	SMB5_CHAN_VOLT("main_input_voltage_settled", MAIN_INPUT_VOLTAGE_SETTLED)
+	SMB5_CHAN_CUR("main_fcc_delta", FCC_DELTA)
+	SMB5_CHAN_ACTIVITY("main_flash_active", FLASH_ACTIVE)
+	SMB5_CHAN_ACTIVITY("main_flash_trigger", FLASH_TRIGGER)
+	SMB5_CHAN_ACTIVITY("main_toggle_stat", TOGGLE_STAT)
+	SMB5_CHAN_CUR("main_fcc_max", MAIN_FCC_MAX)
+	SMB5_CHAN_INDEX("main_irq_status", IRQ_STATUS)
+	SMB5_CHAN_ACTIVITY("main_force_main_fcc", FORCE_MAIN_FCC)
+	SMB5_CHAN_ACTIVITY("main_force_main_icl", FORCE_MAIN_ICL)
+	SMB5_CHAN_INDEX("main_comp_clamp_level", COMP_CLAMP_LEVEL)
+	SMB5_CHAN_TEMP("main_temp_hot", HOT_TEMP)
+	SMB5_CHAN_VOLT("main_voltage_max", VOLTAGE_MAX)
+	SMB5_CHAN_CUR("main_constant_charge_current_max",
+			CONSTANT_CHARGE_CURRENT_MAX)
+	SMB5_CHAN_CUR("main_current_max", CURRENT_MAX)
+	SMB5_CHAN_INDEX("main_health", HEALTH)
+	SMB5_CHAN_VOLT("dc_input_voltage_regulation", INPUT_VOLTAGE_REGULATION)
+	SMB5_CHAN_INDEX("dc_real_type", DC_REAL_TYPE)
+	SMB5_CHAN_ACTIVITY("dc_reset", DC_RESET)
+	SMB5_CHAN_ACTIVITY("dc_aicl_done", AICL_DONE)
+	SMB5_CHAN_TEMP("battery_charger_temp", CHARGER_TEMP)
+	SMB5_CHAN_TEMP("battery_charger_temp_max", CHARGER_TEMP_MAX)
+	SMB5_CHAN_CUR("battery_input_current_limited", INPUT_CURRENT_LIMITED)
+	SMB5_CHAN_ACTIVITY("battery_sw_jeita_enabled", SW_JEITA_ENABLED)
+	SMB5_CHAN_ACTIVITY("battery_charge_done", CHARGE_DONE)
+	SMB5_CHAN_ACTIVITY("battery_parallel_disable", PARALLEL_DISABLE)
+	SMB5_CHAN_ACTIVITY("battery_set_ship_mode", SET_SHIP_MODE)
+	SMB5_CHAN_INDEX("battery_die_health", DIE_HEALTH)
+	SMB5_CHAN_ACTIVITY("battery_rerun_aicl", RERUN_AICL)
+	SMB5_CHAN_COUNT("battery_dp_dm", DP_DM)
+	SMB5_CHAN_ACTIVITY("battery_recharge_soc", RECHARGE_SOC)
+	SMB5_CHAN_ACTIVITY("battery_force_recharge", FORCE_RECHARGE)
+	SMB5_CHAN_ACTIVITY("battery_fcc_stepper_enable", FCC_STEPPER_ENABLE)
+	SMB5_CHAN_INDEX("usb_typec_accessory_mode", TYPEC_ACCESSORY_MODE)
+	SMB5_CHAN_ACTIVITY("battery_sys_soc", SYS_SOC)
+};
+
+struct iio_channel **get_ext_channels(struct device *dev,
+	const char *const *channel_map, int size);
+#endif
diff --git a/drivers/soc/qcom/smb5-lib.h b/drivers/soc/qcom/smb5-lib.h
new file mode 100644
index 000000000000..d20a647b31b6
--- /dev/null
+++ b/drivers/soc/qcom/smb5-lib.h
@@ -0,0 +1,851 @@
+/* SPDX-License-Identifier: GPL-2.0-only */
+/*
+ * Copyright (c) 2018-2021 The Linux Foundation. All rights reserved.
+ * Copyright (c) 2022, Qualcomm Innovation Center, Inc. All rights reserved.
+ */
+
+#ifndef __SMB5_CHARGER_H
+#define __SMB5_CHARGER_H
+
+#include <linux/alarmtimer.h>
+#include <linux/ktime.h>
+#include <linux/types.h>
+#include <linux/timer.h>
+#include <linux/interrupt.h>
+#include <linux/irqreturn.h>
+#include <linux/regulator/driver.h>
+#include <linux/regulator/consumer.h>
+#include <linux/extcon-provider.h>
+#include <linux/usb/typec.h>
+#include <linux/qti_power_supply.h>
+#include "storm-watch.h"
+#include "battery.h"
+
+enum print_reason {
+	PR_INTERRUPT	= BIT(0),
+	PR_REGISTER	= BIT(1),
+	PR_MISC		= BIT(2),
+	PR_PARALLEL	= BIT(3),
+	PR_OTG		= BIT(4),
+	PR_WLS		= BIT(5),
+};
+
+#define DEFAULT_VOTER			"DEFAULT_VOTER"
+#define USER_VOTER			"USER_VOTER"
+#define PD_VOTER			"PD_VOTER"
+#define DCP_VOTER			"DCP_VOTER"
+#define QC_VOTER			"QC_VOTER"
+#define USB_PSY_VOTER			"USB_PSY_VOTER"
+#define PL_TAPER_WORK_RUNNING_VOTER	"PL_TAPER_WORK_RUNNING_VOTER"
+#define USBIN_V_VOTER			"USBIN_V_VOTER"
+#define CHG_STATE_VOTER			"CHG_STATE_VOTER"
+#define TAPER_END_VOTER			"TAPER_END_VOTER"
+#define THERMAL_DAEMON_VOTER		"THERMAL_DAEMON_VOTER"
+#define DIE_TEMP_VOTER			"DIE_TEMP_VOTER"
+#define BOOST_BACK_VOTER		"BOOST_BACK_VOTER"
+#define MICRO_USB_VOTER			"MICRO_USB_VOTER"
+#define DEBUG_BOARD_VOTER		"DEBUG_BOARD_VOTER"
+#define PD_SUSPEND_SUPPORTED_VOTER	"PD_SUSPEND_SUPPORTED_VOTER"
+#define PL_DELAY_VOTER			"PL_DELAY_VOTER"
+#define CTM_VOTER			"CTM_VOTER"
+#define SW_QC3_VOTER			"SW_QC3_VOTER"
+#define AICL_RERUN_VOTER		"AICL_RERUN_VOTER"
+#define SW_ICL_MAX_VOTER		"SW_ICL_MAX_VOTER"
+#define PL_QNOVO_VOTER			"PL_QNOVO_VOTER"
+#define QNOVO_VOTER			"QNOVO_VOTER"
+#define BATT_PROFILE_VOTER		"BATT_PROFILE_VOTER"
+#define OTG_DELAY_VOTER			"OTG_DELAY_VOTER"
+#define USBIN_I_VOTER			"USBIN_I_VOTER"
+#define WEAK_CHARGER_VOTER		"WEAK_CHARGER_VOTER"
+#define PL_FCC_LOW_VOTER		"PL_FCC_LOW_VOTER"
+#define WBC_VOTER			"WBC_VOTER"
+#define HW_LIMIT_VOTER			"HW_LIMIT_VOTER"
+#define PL_SMB_EN_VOTER			"PL_SMB_EN_VOTER"
+#define FORCE_RECHARGE_VOTER		"FORCE_RECHARGE_VOTER"
+#define LPD_VOTER			"LPD_VOTER"
+#define FCC_STEPPER_VOTER		"FCC_STEPPER_VOTER"
+#define SW_THERM_REGULATION_VOTER	"SW_THERM_REGULATION_VOTER"
+#define JEITA_ARB_VOTER			"JEITA_ARB_VOTER"
+#define MOISTURE_VOTER			"MOISTURE_VOTER"
+#define HVDCP2_ICL_VOTER		"HVDCP2_ICL_VOTER"
+#define AICL_THRESHOLD_VOTER		"AICL_THRESHOLD_VOTER"
+#define USBOV_DBC_VOTER			"USBOV_DBC_VOTER"
+#define CHG_TERMINATION_VOTER		"CHG_TERMINATION_VOTER"
+#define THERMAL_THROTTLE_VOTER		"THERMAL_THROTTLE_VOTER"
+#define VOUT_VOTER			"VOUT_VOTER"
+#define USB_SUSPEND_VOTER		"USB_SUSPEND_VOTER"
+#define CHARGER_TYPE_VOTER		"CHARGER_TYPE_VOTER"
+#define HDC_IRQ_VOTER			"HDC_IRQ_VOTER"
+#define DETACH_DETECT_VOTER		"DETACH_DETECT_VOTER"
+#define CC_MODE_VOTER			"CC_MODE_VOTER"
+#define MAIN_FCC_VOTER			"MAIN_FCC_VOTER"
+#define DCIN_AICL_VOTER			"DCIN_AICL_VOTER"
+#define WLS_PL_CHARGING_VOTER		"WLS_PL_CHARGING_VOTER"
+#define ICL_CHANGE_VOTER		"ICL_CHANGE_VOTER"
+#define OVERHEAT_LIMIT_VOTER		"OVERHEAT_LIMIT_VOTER"
+#define TYPEC_SWAP_VOTER		"TYPEC_SWAP_VOTER"
+
+#define BOOST_BACK_STORM_COUNT	3
+#define WEAK_CHG_STORM_COUNT	8
+
+#define VBAT_TO_VRAW_ADC(v)		div_u64((u64)v * 1000000UL, 194637UL)
+
+#define ITERM_LIMITS_PMI632_MA		5000
+#define ITERM_LIMITS_PM8150B_MA		10000
+#define ADC_CHG_ITERM_MASK		32767
+
+#define SDP_100_MA			100000
+#define SDP_CURRENT_UA			500000
+#define CDP_CURRENT_UA			1500000
+#define DCP_CURRENT_UA			1500000
+#define HVDCP_CURRENT_UA		3000000
+#define TYPEC_DEFAULT_CURRENT_UA	900000
+#define TYPEC_MEDIUM_CURRENT_UA		1500000
+#define TYPEC_HIGH_CURRENT_UA		3000000
+#define DCIN_ICL_MIN_UA			100000
+#define DCIN_ICL_MAX_UA			1500000
+#define DCIN_ICL_STEP_UA		100000
+#define ROLE_REVERSAL_DELAY_MS		500
+
+enum smb_mode {
+	PARALLEL_MASTER = 0,
+	PARALLEL_SLAVE,
+	NUM_MODES,
+};
+
+enum sink_src_mode {
+	SINK_MODE,
+	SRC_MODE,
+	AUDIO_ACCESS_MODE,
+	UNATTACHED_MODE,
+};
+
+enum qc2_non_comp_voltage {
+	QC2_COMPLIANT,
+	QC2_NON_COMPLIANT_9V,
+	QC2_NON_COMPLIANT_12V
+};
+
+enum {
+	BOOST_BACK_WA			= BIT(0),
+	SW_THERM_REGULATION_WA		= BIT(1),
+	WEAK_ADAPTER_WA			= BIT(2),
+	USBIN_OV_WA			= BIT(3),
+	CHG_TERMINATION_WA		= BIT(4),
+	USBIN_ADC_WA			= BIT(5),
+	SKIP_MISC_PBS_IRQ_WA		= BIT(6),
+};
+
+enum jeita_cfg_stat {
+	JEITA_CFG_NONE = 0,
+	JEITA_CFG_FAILURE,
+	JEITA_CFG_COMPLETE,
+};
+
+enum {
+	RERUN_AICL = 0,
+	RESTART_AICL,
+};
+
+enum smb_irq_index {
+	/* CHGR */
+	CHGR_ERROR_IRQ = 0,
+	CHG_STATE_CHANGE_IRQ,
+	STEP_CHG_STATE_CHANGE_IRQ,
+	STEP_CHG_SOC_UPDATE_FAIL_IRQ,
+	STEP_CHG_SOC_UPDATE_REQ_IRQ,
+	FG_FVCAL_QUALIFIED_IRQ,
+	VPH_ALARM_IRQ,
+	VPH_DROP_PRECHG_IRQ,
+	/* DCDC */
+	OTG_FAIL_IRQ,
+	OTG_OC_DISABLE_SW_IRQ,
+	OTG_OC_HICCUP_IRQ,
+	BSM_ACTIVE_IRQ,
+	HIGH_DUTY_CYCLE_IRQ,
+	INPUT_CURRENT_LIMITING_IRQ,
+	CONCURRENT_MODE_DISABLE_IRQ,
+	SWITCHER_POWER_OK_IRQ,
+	/* BATIF */
+	BAT_TEMP_IRQ,
+	ALL_CHNL_CONV_DONE_IRQ,
+	BAT_OV_IRQ,
+	BAT_LOW_IRQ,
+	BAT_THERM_OR_ID_MISSING_IRQ,
+	BAT_TERMINAL_MISSING_IRQ,
+	BUCK_OC_IRQ,
+	VPH_OV_IRQ,
+	/* USB */
+	USBIN_COLLAPSE_IRQ,
+	USBIN_VASHDN_IRQ,
+	USBIN_UV_IRQ,
+	USBIN_OV_IRQ,
+	USBIN_PLUGIN_IRQ,
+	USBIN_REVI_CHANGE_IRQ,
+	USBIN_SRC_CHANGE_IRQ,
+	USBIN_ICL_CHANGE_IRQ,
+	/* DC */
+	DCIN_VASHDN_IRQ,
+	DCIN_UV_IRQ,
+	DCIN_OV_IRQ,
+	DCIN_PLUGIN_IRQ,
+	DCIN_REVI_IRQ,
+	DCIN_PON_IRQ,
+	DCIN_EN_IRQ,
+	/* TYPEC */
+	TYPEC_OR_RID_DETECTION_CHANGE_IRQ,
+	TYPEC_VPD_DETECT_IRQ,
+	TYPEC_CC_STATE_CHANGE_IRQ,
+	TYPEC_VCONN_OC_IRQ,
+	TYPEC_VBUS_CHANGE_IRQ,
+	TYPEC_ATTACH_DETACH_IRQ,
+	TYPEC_LEGACY_CABLE_DETECT_IRQ,
+	TYPEC_TRY_SNK_SRC_DETECT_IRQ,
+	/* MISC */
+	WDOG_SNARL_IRQ,
+	WDOG_BARK_IRQ,
+	AICL_FAIL_IRQ,
+	AICL_DONE_IRQ,
+	SMB_EN_IRQ,
+	IMP_TRIGGER_IRQ,
+	TEMP_CHANGE_IRQ,
+	TEMP_CHANGE_SMB_IRQ,
+	/* FLASH */
+	VREG_OK_IRQ,
+	ILIM_S2_IRQ,
+	ILIM_S1_IRQ,
+	VOUT_DOWN_IRQ,
+	VOUT_UP_IRQ,
+	FLASH_STATE_CHANGE_IRQ,
+	TORCH_REQ_IRQ,
+	FLASH_EN_IRQ,
+	SDAM_STS_IRQ,
+	/* END */
+	SMB_IRQ_MAX,
+};
+
+enum float_options {
+	FLOAT_DCP		= 1,
+	FLOAT_SDP		= 2,
+	DISABLE_CHARGING	= 3,
+	SUSPEND_INPUT		= 4,
+};
+
+enum chg_term_config_src {
+	ITERM_SRC_UNSPECIFIED,
+	ITERM_SRC_ADC,
+	ITERM_SRC_ANALOG
+};
+
+enum comp_clamp_levels {
+	CLAMP_LEVEL_DEFAULT = 0,
+	CLAMP_LEVEL_1,
+	MAX_CLAMP_LEVEL,
+};
+
+struct clamp_config {
+	u16 reg[3];
+	u16 val[3];
+};
+
+struct smb_irq_info {
+	const char			*name;
+	const irq_handler_t		handler;
+	const bool			wake;
+	const struct storm_watch	storm_data;
+	struct smb_irq_data		*irq_data;
+	int				irq;
+	bool				enabled;
+};
+
+static const unsigned int smblib_extcon_cable[] = {
+	EXTCON_USB,
+	EXTCON_USB_HOST,
+	EXTCON_NONE,
+};
+
+enum lpd_reason {
+	LPD_NONE,
+	LPD_MOISTURE_DETECTED,
+	LPD_FLOATING_CABLE,
+};
+
+/* Following states are applicable only for floating cable during LPD */
+enum lpd_stage {
+	/* initial stage */
+	LPD_STAGE_NONE,
+	/* started and ongoing */
+	LPD_STAGE_FLOAT,
+	/* cancel if started,  or don't start */
+	LPD_STAGE_FLOAT_CANCEL,
+	/* confirmed and mitigation measures taken for 60 s */
+	LPD_STAGE_COMMIT,
+};
+
+enum thermal_status_levels {
+	TEMP_SHUT_DOWN = 0,
+	TEMP_SHUT_DOWN_SMB,
+	TEMP_ALERT_LEVEL,
+	TEMP_ABOVE_RANGE,
+	TEMP_WITHIN_RANGE,
+	TEMP_BELOW_RANGE,
+};
+
+enum icl_override_mode {
+	/* APSD/Type-C/QC auto */
+	HW_AUTO_MODE,
+	/* 100/150/500/900mA */
+	SW_OVERRIDE_USB51_MODE,
+	/* ICL other than USB51 */
+	SW_OVERRIDE_HC_MODE,
+};
+
+/* EXTCON_USB and EXTCON_USB_HOST are mutually exclusive */
+static const u32 smblib_extcon_exclusive[] = {0x3, 0};
+
+struct smb_regulator {
+	struct regulator_dev	*rdev;
+	struct regulator_desc	rdesc;
+};
+
+struct smb_irq_data {
+	void			*parent_data;
+	const char		*name;
+	struct storm_watch	storm_data;
+};
+
+struct smb_chg_param {
+	const char	*name;
+	u16		reg;
+	int		min_u;
+	int		max_u;
+	int		step_u;
+	int		(*get_proc)(struct smb_chg_param *param,
+				    u8 val_raw);
+	int		(*set_proc)(struct smb_chg_param *param,
+				    int val_u,
+				    u8 *val_raw);
+};
+
+struct buck_boost_freq {
+	int freq_khz;
+	u8 val;
+};
+
+struct smb_chg_freq {
+	unsigned int		freq_5V;
+	unsigned int		freq_6V_8V;
+	unsigned int		freq_9V;
+	unsigned int		freq_12V;
+	unsigned int		freq_removal;
+	unsigned int		freq_below_otg_threshold;
+	unsigned int		freq_above_otg_threshold;
+};
+
+struct smb_params {
+	struct smb_chg_param	fcc;
+	struct smb_chg_param	fv;
+	struct smb_chg_param	usb_icl;
+	struct smb_chg_param	icl_max_stat;
+	struct smb_chg_param	icl_stat;
+	struct smb_chg_param	otg_cl;
+	struct smb_chg_param	dc_icl;
+	struct smb_chg_param	jeita_cc_comp_hot;
+	struct smb_chg_param	jeita_cc_comp_cold;
+	struct smb_chg_param	freq_switcher;
+	struct smb_chg_param	aicl_5v_threshold;
+	struct smb_chg_param	aicl_cont_threshold;
+};
+
+struct parallel_params {
+	struct power_supply	*psy;
+};
+
+struct smb_iio {
+	struct iio_channel	*temp_chan;
+	struct iio_channel	*usbin_i_chan;
+	struct iio_channel	*usbin_v_chan;
+	struct iio_channel	*mid_chan;
+	struct iio_channel	*batt_i_chan;
+	struct iio_channel	*connector_temp_chan;
+	struct iio_channel	*sbux_chan;
+	struct iio_channel	*vph_v_chan;
+	struct iio_channel	*die_temp_chan;
+	struct iio_channel	*skin_temp_chan;
+	struct iio_channel	*smb_temp_chan;
+};
+
+enum pmic_type {
+	PM8150B,
+	PM7250B,
+	PM6150,
+	PMI632,
+};
+
+struct smb_charger {
+	struct device		*dev;
+	char			*name;
+	struct regmap		*regmap;
+	struct smb_irq_info	*irq_info;
+	struct smb_params	param;
+	struct smb_iio		iio;
+	struct iio_channel	*iio_chans;
+	struct iio_channel	**iio_chan_list_qg;
+	struct iio_channel	**iio_chan_list_cp;
+	struct iio_channel	**iio_chan_list_smb_parallel;
+	int			*debug_mask;
+	int			pd_disabled;
+	enum smb_mode		mode;
+	struct smb_chg_freq	chg_freq;
+	int			otg_delay_ms;
+	int			weak_chg_icl_ua;
+	u32			sdam_base;
+	bool			pd_not_supported;
+
+	/* locks */
+	struct mutex		smb_lock;
+	struct mutex		ps_change_lock;
+	struct mutex		irq_status_lock;
+	struct mutex		dcin_aicl_lock;
+	spinlock_t		typec_pr_lock;
+	struct mutex		adc_lock;
+	struct mutex		dpdm_lock;
+	struct mutex		typec_lock;
+
+	/* power supplies */
+	struct power_supply		*batt_psy;
+	struct power_supply		*usb_psy;
+	struct power_supply		*dc_psy;
+	struct power_supply		*usb_port_psy;
+	struct power_supply		*wls_psy;
+
+	/* notifiers */
+	struct notifier_block	nb;
+
+	/* parallel charging */
+	struct parallel_params	pl;
+
+	/* CC Mode */
+	int	adapter_cc_mode;
+	int	thermal_overheat;
+
+	/* regulators */
+	struct smb_regulator	*vbus_vreg;
+	struct smb_regulator	*vconn_vreg;
+	struct regulator	*dpdm_reg;
+
+	/* typec */
+	struct typec_port	*typec_port;
+	struct typec_capability	typec_caps;
+	struct typec_partner	*typec_partner;
+	struct typec_partner_desc typec_partner_desc;
+
+	/* votables */
+	struct votable		*dc_suspend_votable;
+	struct votable		*fcc_votable;
+	struct votable		*fcc_main_votable;
+	struct votable		*fv_votable;
+	struct votable		*usb_icl_votable;
+	struct votable		*awake_votable;
+	struct votable		*pl_disable_votable;
+	struct votable		*chg_disable_votable;
+	struct votable		*pl_enable_votable_indirect;
+	struct votable		*cp_disable_votable;
+	struct votable		*cp_ilim_votable;
+	struct votable		*smb_override_votable;
+	struct votable		*icl_irq_disable_votable;
+	struct votable		*limited_irq_disable_votable;
+	struct votable		*hdc_irq_disable_votable;
+	struct votable		*temp_change_irq_disable_votable;
+	struct votable		*bat_temp_irq_disable_votable;
+	struct votable		*qnovo_disable_votable;
+
+	/* work */
+	struct work_struct	bms_update_work;
+	struct work_struct	pl_update_work;
+	struct work_struct	jeita_update_work;
+	struct work_struct	moisture_protection_work;
+	struct work_struct	chg_termination_work;
+	struct work_struct	dcin_aicl_work;
+	struct work_struct	cp_status_change_work;
+	struct delayed_work	ps_change_timeout_work;
+	struct delayed_work	clear_hdc_work;
+	struct delayed_work	icl_change_work;
+	struct delayed_work	pl_enable_work;
+	struct delayed_work	uusb_otg_work;
+	struct delayed_work	bb_removal_work;
+	struct delayed_work	lpd_ra_open_work;
+	struct delayed_work	lpd_detach_work;
+	struct delayed_work	thermal_regulation_work;
+	struct delayed_work	usbov_dbc_work;
+	struct delayed_work	pr_swap_detach_work;
+	struct delayed_work	pr_lock_clear_work;
+	struct delayed_work	role_reversal_check;
+
+	struct alarm		lpd_recheck_timer;
+	struct alarm		moisture_protection_alarm;
+	struct alarm		chg_termination_alarm;
+	struct alarm		dcin_aicl_alarm;
+
+	struct timer_list	apsd_timer;
+
+	struct charger_param	chg_param;
+	/* secondary charger config */
+	bool			sec_pl_present;
+	bool			sec_cp_present;
+	int			sec_chg_selected;
+	int			cp_reason;
+	int			cp_topo;
+
+	/* pd */
+	int			voltage_min_uv;
+	int			voltage_max_uv;
+	int			pd_active;
+	bool			pd_hard_reset;
+	bool			pr_lock_in_progress;
+	bool			pr_swap_in_progress;
+	bool			early_usb_attach;
+	bool			ok_to_pd;
+	bool			typec_legacy;
+	bool			typec_irq_en;
+	bool			typec_role_swap_failed;
+
+	/* cached status */
+	bool			system_suspend_supported;
+	int			boost_threshold_ua;
+	int			system_temp_level;
+	int			thermal_levels;
+	int			*thermal_mitigation;
+	int			dcp_icl_ua;
+	int			fake_capacity;
+	int			fake_batt_status;
+	bool			step_chg_enabled;
+	bool			sw_jeita_enabled;
+	bool			jeita_arb_enable;
+	bool			typec_legacy_use_rp_icl;
+	bool			is_hdc;
+	bool			chg_done;
+	int			connector_type;
+	bool			otg_en;
+	bool			suspend_input_on_debug_batt;
+	bool			fake_chg_status_on_debug_batt;
+	int			default_icl_ua;
+	int			otg_cl_ua;
+	bool			uusb_apsd_rerun_done;
+	bool			typec_present;
+	int			fake_input_current_limited;
+	int			typec_mode;
+	int			dr_mode;
+	int			usb_icl_change_irq_enabled;
+	u32			jeita_status;
+	u8			float_cfg;
+	bool			jeita_arb_flag;
+	bool			use_extcon;
+	bool			otg_present;
+	bool			hvdcp_disable;
+	int			hw_max_icl_ua;
+	int			auto_recharge_soc;
+	enum sink_src_mode	sink_src_mode;
+	enum power_supply_typec_power_role power_role;
+	enum jeita_cfg_stat	jeita_configured;
+	int			charger_temp_max;
+	int			smb_temp_max;
+	u8			typec_try_mode;
+	enum lpd_stage		lpd_stage;
+	bool			lpd_disabled;
+	enum lpd_reason		lpd_reason;
+	bool			fcc_stepper_enable;
+	int			die_temp;
+	int			smb_temp;
+	int			skin_temp;
+	int			connector_temp;
+	int			thermal_status;
+	int			main_fcc_max;
+	u32			jeita_soft_thlds[2];
+	u32			jeita_soft_hys_thlds[2];
+	int			jeita_soft_fcc[2];
+	int			jeita_soft_fv[2];
+	bool			moisture_present;
+	bool			uusb_moisture_protection_capable;
+	bool			uusb_moisture_protection_enabled;
+	bool			hw_die_temp_mitigation;
+	bool			hw_connector_mitigation;
+	bool			hw_skin_temp_mitigation;
+	bool			en_skin_therm_mitigation;
+	int			connector_pull_up;
+	int			smb_pull_up;
+	int			aicl_5v_threshold_mv;
+	int			default_aicl_5v_threshold_mv;
+	int			aicl_cont_threshold_mv;
+	int			default_aicl_cont_threshold_mv;
+	bool			aicl_max_reached;
+	int			charge_full_cc;
+	int			cc_soc_ref;
+	int			last_cc_soc;
+	int			term_vbat_uv;
+	int			usbin_forced_max_uv;
+	int			init_thermal_ua;
+	u32			comp_clamp_level;
+	int			wls_icl_ua;
+	int			cutoff_count;
+	bool			dcin_aicl_done;
+	bool			hvdcp3_standalone_config;
+	bool			dcin_icl_user_set;
+	bool			dpdm_enabled;
+	bool			apsd_ext_timeout;
+	bool			qc3p5_detected;
+	int			qc3p5_detected_mw;
+	bool			disable_suspend_on_collapse;
+
+	/* workaround flag */
+	int		real_charger_type;
+	u32			wa_flags;
+	int			boost_current_ua;
+	int                     qc2_max_pulses;
+	enum qc2_non_comp_voltage qc2_unsupported_voltage;
+	bool			dbc_usbov;
+
+	/* extcon for VBUS / ID notification to USB for uUSB */
+	struct extcon_dev	*extcon;
+
+	/* battery profile */
+	int			batt_profile_fcc_ua;
+	int			batt_profile_fv_uv;
+
+	int			usb_icl_delta_ua;
+	int			pulse_cnt;
+
+	int			die_health;
+	int			connector_health;
+
+	/* flash */
+	u32			flash_derating_soc;
+	u32			flash_disable_soc;
+	u32			headroom_mode;
+	bool			flash_init_done;
+	bool			flash_active;
+	u32			irq_status;
+
+	/* wireless */
+	int			dcin_uv_count;
+	ktime_t			dcin_uv_last_time;
+	int			last_wls_vout;
+};
+
+int smblib_read(struct smb_charger *chg, u16 addr, u8 *val);
+int smblib_masked_write(struct smb_charger *chg, u16 addr, u8 mask, u8 val);
+int smblib_write(struct smb_charger *chg, u16 addr, u8 val);
+int smblib_batch_write(struct smb_charger *chg, u16 addr, u8 *val, int count);
+int smblib_batch_read(struct smb_charger *chg, u16 addr, u8 *val, int count);
+
+int smblib_get_charge_param(struct smb_charger *chg,
+			    struct smb_chg_param *param, int *val_u);
+int smblib_get_aicl_cont_threshold(struct smb_chg_param *param, u8 val_raw);
+int smblib_enable_charging(struct smb_charger *chg, bool enable);
+int smblib_set_charge_param(struct smb_charger *chg,
+			    struct smb_chg_param *param, int val_u);
+
+int smblib_set_chg_freq(struct smb_chg_param *param,
+				int val_u, u8 *val_raw);
+int smblib_set_aicl_cont_threshold(struct smb_chg_param *param,
+				int val_u, u8 *val_raw);
+int smblib_vbus_regulator_enable(struct regulator_dev *rdev);
+int smblib_vbus_regulator_disable(struct regulator_dev *rdev);
+int smblib_vbus_regulator_is_enabled(struct regulator_dev *rdev);
+
+int smblib_vconn_regulator_enable(struct regulator_dev *rdev);
+int smblib_vconn_regulator_disable(struct regulator_dev *rdev);
+int smblib_vconn_regulator_is_enabled(struct regulator_dev *rdev);
+
+irqreturn_t smb5_default_irq_handler(int irq, void *data);
+irqreturn_t smb5_smb_en_irq_handler(int irq, void *data);
+irqreturn_t smb5_chg_state_change_irq_handler(int irq, void *data);
+irqreturn_t smb5_batt_temp_changed_irq_handler(int irq, void *data);
+irqreturn_t smb5_batt_psy_changed_irq_handler(int irq, void *data);
+irqreturn_t smb5_usbin_uv_irq_handler(int irq, void *data);
+irqreturn_t smb5_usb_plugin_irq_handler(int irq, void *data);
+irqreturn_t smb5_usb_source_change_irq_handler(int irq, void *data);
+irqreturn_t smb5_icl_change_irq_handler(int irq, void *data);
+irqreturn_t smb5_typec_state_change_irq_handler(int irq, void *data);
+irqreturn_t smb5_typec_attach_detach_irq_handler(int irq, void *data);
+irqreturn_t smb5_dcin_uv_irq_handler(int irq, void *data);
+irqreturn_t smb5_dc_plugin_irq_handler(int irq, void *data);
+irqreturn_t smb5_high_duty_cycle_irq_handler(int irq, void *data);
+irqreturn_t smb5_switcher_power_ok_irq_handler(int irq, void *data);
+irqreturn_t smb5_wdog_snarl_irq_handler(int irq, void *data);
+irqreturn_t smb5_wdog_bark_irq_handler(int irq, void *data);
+irqreturn_t smb5_typec_or_rid_detection_change_irq_handler(int irq, void *data);
+irqreturn_t smb5_temp_change_irq_handler(int irq, void *data);
+irqreturn_t smb5_usbin_ov_irq_handler(int irq, void *data);
+irqreturn_t smb5_sdam_sts_change_irq_handler(int irq, void *data);
+int smblib_get_prop_input_suspend(struct smb_charger *chg,
+				union power_supply_propval *val);
+int smblib_get_prop_batt_present(struct smb_charger *chg,
+				union power_supply_propval *val);
+int smblib_get_prop_batt_capacity(struct smb_charger *chg,
+				union power_supply_propval *val);
+int smblib_get_prop_batt_status(struct smb_charger *chg,
+				union power_supply_propval *val);
+int smblib_get_prop_batt_charge_type(struct smb_charger *chg,
+				union power_supply_propval *val);
+int smblib_get_prop_batt_charge_done(struct smb_charger *chg,
+				int *val);
+int smblib_get_batt_current_now(struct smb_charger *chg,
+					union power_supply_propval *val);
+int smblib_get_prop_batt_health(struct smb_charger *chg,
+				union power_supply_propval *val);
+int smblib_get_prop_system_temp_level(struct smb_charger *chg,
+				union power_supply_propval *val);
+int smblib_get_prop_system_temp_level_max(struct smb_charger *chg,
+				union power_supply_propval *val);
+int smblib_get_prop_input_current_limited(struct smb_charger *chg,
+				int *val);
+int smblib_get_prop_batt_iterm(struct smb_charger *chg,
+				union power_supply_propval *val);
+int smblib_set_prop_input_suspend(struct smb_charger *chg,
+				  const union power_supply_propval *val);
+int smblib_set_prop_batt_capacity(struct smb_charger *chg,
+				const union power_supply_propval *val);
+int smblib_set_prop_batt_status(struct smb_charger *chg,
+				const union power_supply_propval *val);
+int smblib_set_prop_system_temp_level(struct smb_charger *chg,
+				const union power_supply_propval *val);
+int smblib_set_prop_input_current_limited(struct smb_charger *chg,
+				int val);
+
+int smblib_get_prop_dc_present(struct smb_charger *chg,
+				union power_supply_propval *val);
+int smblib_get_prop_dc_online(struct smb_charger *chg,
+				union power_supply_propval *val);
+int smblib_get_prop_dc_current_max(struct smb_charger *chg,
+				union power_supply_propval *val);
+int smblib_set_prop_dc_current_max(struct smb_charger *chg,
+				const union power_supply_propval *val);
+int smblib_get_prop_dc_voltage_max(struct smb_charger *chg,
+				union power_supply_propval *val);
+int smblib_set_prop_dc_reset(struct smb_charger *chg);
+int smblib_get_prop_usb_present(struct smb_charger *chg,
+				union power_supply_propval *val);
+int smblib_get_prop_usb_online(struct smb_charger *chg,
+				union power_supply_propval *val);
+int smblib_get_usb_online(struct smb_charger *chg,
+				union power_supply_propval *val);
+int smblib_get_prop_usb_suspend(struct smb_charger *chg,
+				union power_supply_propval *val);
+int smblib_get_prop_usb_voltage_max(struct smb_charger *chg,
+				union power_supply_propval *val);
+int smblib_get_prop_usb_voltage_max_design(struct smb_charger *chg,
+				union power_supply_propval *val);
+int smblib_set_prop_usb_voltage_max_limit(struct smb_charger *chg,
+				int val);
+int smblib_get_prop_usb_voltage_now(struct smb_charger *chg,
+				union power_supply_propval *val);
+int smblib_get_prop_low_power(struct smb_charger *chg,
+				union power_supply_propval *val);
+int smblib_get_prop_usb_current_now(struct smb_charger *chg,
+				union power_supply_propval *val);
+int smblib_get_usb_prop_typec_mode(struct smb_charger *chg,
+				int *val);
+int smblib_get_usb_prop_typec_accessory_mode(struct smb_charger *chg,
+				int *val);
+int smblib_get_prop_typec_cc_orientation(struct smb_charger *chg,
+				int *val);
+int smblib_get_prop_scope(struct smb_charger *chg,
+			union power_supply_propval *val);
+int smblib_get_prop_typec_select_rp(struct smb_charger *chg,
+				int *val);
+int smblib_get_prop_typec_power_role(struct smb_charger *chg,
+				int *val);
+int smblib_get_prop_input_current_settled(struct smb_charger *chg,
+				union power_supply_propval *val);
+int smblib_get_prop_input_voltage_settled(struct smb_charger *chg,
+				int *val);
+int smblib_get_prop_pd_in_hard_reset(struct smb_charger *chg,
+			       int *val);
+int smblib_get_pe_start(struct smb_charger *chg,
+			       int *val);
+int smblib_get_prop_charger_temp(struct smb_charger *chg,
+				int *val);
+int smblib_get_die_health(struct smb_charger *chg,
+				int *val);
+int smblib_get_prop_smb_health(struct smb_charger *chg);
+int smblib_get_prop_connector_health(struct smb_charger *chg);
+int smblib_get_prop_input_current_max(struct smb_charger *chg,
+				  union power_supply_propval *val);
+int smblib_set_prop_thermal_overheat(struct smb_charger *chg,
+			       int therm_overheat);
+int smblib_get_skin_temp_status(struct smb_charger *chg);
+int smblib_get_prop_vph_voltage_now(struct smb_charger *chg,
+				int *val);
+int smb5_set_prop_comp_clamp_level(struct smb_charger *chg,
+				int val);
+int smblib_set_prop_pd_current_max(struct smb_charger *chg,
+				int val);
+int smblib_set_prop_sdp_current_max(struct smb_charger *chg,
+				int val);
+int smblib_set_prop_pd_voltage_max(struct smb_charger *chg,
+				int val);
+int smblib_set_prop_pd_voltage_min(struct smb_charger *chg,
+				int val);
+int smblib_set_prop_typec_power_role(struct smb_charger *chg,
+				int val);
+int smblib_set_prop_typec_select_rp(struct smb_charger *chg,
+				int val);
+int smblib_set_prop_pd_active(struct smb_charger *chg,
+				int val);
+int smblib_set_prop_pd_in_hard_reset(struct smb_charger *chg,
+				int val);
+int smblib_set_prop_ship_mode(struct smb_charger *chg,
+				int val);
+int smblib_set_prop_rechg_soc_thresh(struct smb_charger *chg,
+				int val);
+void smblib_config_charger_on_debug_battery(struct smb_charger *chg);
+int smblib_rerun_apsd_if_required(struct smb_charger *chg);
+void smblib_rerun_apsd(struct smb_charger *chg);
+int smblib_get_prop_fcc_delta(struct smb_charger *chg,
+				int *val);
+int smblib_get_thermal_threshold(struct smb_charger *chg, u16 addr, int *val);
+int smblib_dp_dm(struct smb_charger *chg, int val);
+int smblib_disable_hw_jeita(struct smb_charger *chg, bool disable);
+int smblib_run_aicl(struct smb_charger *chg, int type);
+int smblib_set_icl_current(struct smb_charger *chg, int icl_ua);
+int smblib_get_icl_current(struct smb_charger *chg, int *icl_ua);
+int smblib_get_charge_current(struct smb_charger *chg, int *total_current_ua);
+int smblib_get_prop_pr_swap_in_progress(struct smb_charger *chg,
+				int *val);
+int smblib_set_prop_pr_swap_in_progress(struct smb_charger *chg,
+				int val);
+int smblib_typec_port_type_set(const struct typec_capability *cap,
+					enum typec_port_type type);
+int smblib_get_prop_from_bms(struct smb_charger *chg,
+				int channel, int *val);
+int smblib_get_iio_channel(struct smb_charger *chg, const char *propname,
+					struct iio_channel **chan);
+int smblib_configure_hvdcp_apsd(struct smb_charger *chg, bool enable);
+int smblib_icl_override(struct smb_charger *chg, enum icl_override_mode mode);
+enum alarmtimer_restart smblib_lpd_recheck_timer(struct alarm *alarm,
+				ktime_t time);
+int smblib_toggle_smb_en(struct smb_charger *chg, int toggle);
+void smblib_hvdcp_detect_enable(struct smb_charger *chg, bool enable);
+void smblib_hvdcp_hw_inov_enable(struct smb_charger *chg, bool enable);
+void smblib_hvdcp_exit_config(struct smb_charger *chg);
+void smblib_apsd_enable(struct smb_charger *chg, bool enable);
+int smblib_force_vbus_voltage(struct smb_charger *chg, u8 val);
+int smblib_get_irq_status(struct smb_charger *chg,
+				int *val);
+int smblib_get_qc3_main_icl_offset(struct smb_charger *chg, int *offset_ua);
+
+int smblib_init(struct smb_charger *chg);
+int smblib_deinit(struct smb_charger *chg);
+int smb5_iio_get_prop(struct smb_charger *chg, int channel, int *val);
+int smb5_iio_set_prop(struct smb_charger *chg, int channel, int val);
+
+int smblib_set_prop_voltage_wls_output(struct smb_charger *chg,
+				union power_supply_propval *val);
+int smblib_get_prop_voltage_wls_output(struct smb_charger *chg,
+				union power_supply_propval *val);
+int smblib_get_prop_dc_voltage_now(struct smb_charger *chg,
+				union power_supply_propval *val);
+
+void smblib_moisture_detection_enable(struct smb_charger *chg, int pval);
+#endif /* __SMB5_CHARGER_H */
diff --git a/drivers/soc/qcom/smb5-reg.h b/drivers/soc/qcom/smb5-reg.h
new file mode 100644
index 000000000000..b04ddd5f84f8
--- /dev/null
+++ b/drivers/soc/qcom/smb5-reg.h
@@ -0,0 +1,559 @@
+/* SPDX-License-Identifier: GPL-2.0-only */
+/*
+ * Copyright (c) 2018-2020 The Linux Foundation. All rights reserved.
+ * Copyright (c) 2022, Qualcomm Innovation Center, Inc. All rights reserved.
+ */
+
+#ifndef __SMB5_CHARGER_REG_H
+#define __SMB5_CHARGER_REG_H
+
+#include <linux/bitops.h>
+
+#define CHGR_BASE	0x1000
+#define DCDC_BASE	0x1100
+#define BATIF_BASE	0x1200
+#define USBIN_BASE	0x1300
+#define DCIN_BASE	0x1400
+#define TYPEC_BASE	0X1500
+#define MISC_BASE	0x1600
+#define MISC_PBS_BASE	0x7500
+
+#define PERPH_TYPE_OFFSET	0x04
+#define TYPE_MASK		GENMASK(7, 0)
+#define PERPH_SUBTYPE_OFFSET	0x05
+#define SUBTYPE_MASK		GENMASK(7, 0)
+#define INT_RT_STS_OFFSET	0x10
+#define SDAM_TYPE		0x2E
+
+/********************************
+ *  CHGR Peripheral Registers  *
+ ********************************/
+#define BATTERY_CHARGER_STATUS_1_REG		(CHGR_BASE + 0x06)
+#define BATTERY_CHARGER_STATUS_MASK		GENMASK(2, 0)
+enum {
+	INHIBIT_CHARGE = 0,
+	TRICKLE_CHARGE,
+	PRE_CHARGE,
+	FULLON_CHARGE,
+	TAPER_CHARGE,
+	TERMINATE_CHARGE,
+	PAUSE_CHARGE,
+	DISABLE_CHARGE,
+};
+
+#define BATTERY_CHARGER_STATUS_2_REG		(CHGR_BASE + 0x07)
+#define CHARGER_ERROR_STATUS_BAT_OV_BIT		BIT(1)
+
+#define BATTERY_CHARGER_STATUS_5_REG		(CHGR_BASE + 0x0B)
+#define ENABLE_TRICKLE_BIT			BIT(2)
+#define ENABLE_PRE_CHARGING_BIT			BIT(1)
+#define ENABLE_FULLON_MODE_BIT			BIT(0)
+
+#define BATTERY_CHARGER_STATUS_7_REG		(CHGR_BASE + 0x0D)
+#define BAT_TEMP_STATUS_SOFT_LIMIT_MASK		GENMASK(5, 4)
+#define BAT_TEMP_STATUS_HOT_SOFT_BIT		BIT(5)
+#define BAT_TEMP_STATUS_COLD_SOFT_BIT		BIT(4)
+#define BAT_TEMP_STATUS_HARD_LIMIT_MASK		GENMASK(3, 2)
+#define BAT_TEMP_STATUS_TOO_HOT_BIT		BIT(3)
+#define BAT_TEMP_STATUS_TOO_COLD_BIT		BIT(2)
+#define BAT_TEMP_STATUS_TOO_HOT_AFP_BIT		BIT(1)
+#define BAT_TEMP_STATUS_TOO_COLD_AFP_BIT	BIT(0)
+
+#define CHARGING_ENABLE_CMD_REG			(CHGR_BASE + 0x42)
+#define CHARGING_ENABLE_CMD_BIT			BIT(0)
+
+#define CHARGING_PAUSE_CMD_REG			(CHGR_BASE + 0x43)
+#define CHARGING_PAUSE_CMD_BIT			BIT(0)
+
+#define CHGR_CFG2_REG				(CHGR_BASE + 0x51)
+#define RECHG_MASK				GENMASK(2, 1)
+#define VBAT_BASED_RECHG_BIT			BIT(2)
+#define SOC_BASED_RECHG_BIT			GENMASK(2, 1)
+#define CHARGER_INHIBIT_BIT			BIT(0)
+
+#define CHGR_FAST_CHARGE_CURRENT_CFG_REG	(CHGR_BASE + 0x61)
+
+#define CHGR_ADC_ITERM_UP_THD_MSB_REG		(CHGR_BASE + 0x67)
+#define CHGR_ADC_ITERM_UP_THD_LSB_REG		(CHGR_BASE + 0x68)
+#define CHGR_ADC_ITERM_LO_THD_MSB_REG		(CHGR_BASE + 0x69)
+#define CHGR_ADC_ITERM_LO_THD_LSB_REG		(CHGR_BASE + 0x6A)
+
+#define CHGR_NO_SAMPLE_TERM_RCHG_CFG_REG	(CHGR_BASE + 0x6B)
+#define NO_OF_SAMPLE_FOR_RCHG_SHIFT		2
+#define NO_OF_SAMPLE_FOR_RCHG			GENMASK(3, 2)
+
+#define CHGR_ADC_TERM_CFG_REG			(CHGR_BASE + 0x6C)
+#define TERM_BASED_ON_SYNC_CONV_OR_SAMPLE_CNT	BIT(0)
+#define TERM_BASED_ON_SYNC_CONV			0
+#define TERM_BASED_ON_SAMPLE_CNT		1
+
+#define CHGR_FLOAT_VOLTAGE_CFG_REG		(CHGR_BASE + 0x70)
+
+#define CHARGE_INHIBIT_THRESHOLD_CFG_REG	(CHGR_BASE + 0x72)
+#define CHARGE_INHIBIT_THRESHOLD_MASK		GENMASK(1, 0)
+#define INHIBIT_ANALOG_VFLT_MINUS_50MV		0
+#define INHIBIT_ANALOG_VFLT_MINUS_100MV		1
+#define INHIBIT_ANALOG_VFLT_MINUS_200MV		2
+#define INHIBIT_ANALOG_VFLT_MINUS_300MV		3
+
+#define CHARGE_RCHG_SOC_THRESHOLD_CFG_REG	(CHGR_BASE + 0x7D)
+
+#define CHGR_ADC_RECHARGE_THRESHOLD_MSB_REG	(CHGR_BASE + 0x7E)
+
+#define CHGR_ADC_RECHARGE_THRESHOLD_LSB_REG	(CHGR_BASE + 0x7F)
+
+#define JEITA_EN_CFG_REG			(CHGR_BASE + 0x90)
+#define JEITA_EN_HOT_SL_FCV_BIT			BIT(3)
+#define JEITA_EN_COLD_SL_FCV_BIT		BIT(2)
+#define JEITA_EN_HOT_SL_CCC_BIT			BIT(1)
+#define JEITA_EN_COLD_SL_CCC_BIT		BIT(0)
+
+#define JEITA_CCCOMP_CFG_HOT_REG		(CHGR_BASE + 0x92)
+#define JEITA_CCCOMP_CFG_COLD_REG		(CHGR_BASE + 0x93)
+
+#define CHGR_JEITA_THRESHOLD_BASE_REG(i)	(CHGR_BASE + 0x94 + (i * 4))
+#define CHGR_JEITA_HOT_THRESHOLD_MSB_REG	CHGR_JEITA_THRESHOLD_BASE_REG(0)
+
+#define CHGR_FAST_CHARGE_SAFETY_TIMER_CFG_REG	(CHGR_BASE + 0xA2)
+#define FAST_CHARGE_SAFETY_TIMER_192_MIN	0x0
+#define FAST_CHARGE_SAFETY_TIMER_384_MIN	0x1
+#define FAST_CHARGE_SAFETY_TIMER_768_MIN	0x2
+#define FAST_CHARGE_SAFETY_TIMER_1536_MIN	0x3
+
+#define CHGR_ENG_CHARGING_CFG_REG		(CHGR_BASE + 0xC0)
+#define CHGR_ITERM_USE_ANALOG_BIT		BIT(3)
+
+/********************************
+ *  DCDC Peripheral Registers  *
+ ********************************/
+#define ICL_MAX_STATUS_REG			(DCDC_BASE + 0x06)
+#define ICL_STATUS_REG				(DCDC_BASE + 0x07)
+#define AICL_ICL_STATUS_REG			(DCDC_BASE + 0x08)
+
+#define AICL_STATUS_REG				(DCDC_BASE + 0x0A)
+#define SOFT_ILIMIT_BIT				BIT(6)
+#define AICL_DONE_BIT				BIT(0)
+
+#define POWER_PATH_STATUS_REG			(DCDC_BASE + 0x0B)
+#define USBIN_SUSPEND_STS_BIT			BIT(6)
+#define USE_USBIN_BIT				BIT(4)
+#define USE_DCIN_BIT				BIT(3)
+#define POWER_PATH_MASK				GENMASK(2, 1)
+#define VALID_INPUT_POWER_SOURCE_STS_BIT	BIT(0)
+
+#define DCDC_CMD_OTG_REG			(DCDC_BASE + 0x40)
+#define OTG_EN_BIT				BIT(0)
+
+#define DCDC_FSW_SEL_REG			(DCDC_BASE + 0x50)
+
+#define DCDC_OTG_CURRENT_LIMIT_CFG_REG		(DCDC_BASE + 0x52)
+
+#define DCDC_OTG_CFG_REG			(DCDC_BASE + 0x53)
+#define OTG_EN_SRC_CFG_BIT			BIT(1)
+
+#define OTG_FAULT_CONDITION_CFG_REG		(DCDC_BASE + 0x56)
+#define USBIN_MID_COMP_FAULT_EN_BIT		BIT(5)
+#define USBIN_COLLAPSE_FAULT_EN_BIT		BIT(4)
+
+#define DCDC_CFG_REF_MAX_PSNS_REG		(DCDC_BASE + 0x8C)
+
+#define DCDC_ENG_SDCDC_CFG5_REG			(DCDC_BASE + 0xC4)
+#define ENG_SDCDC_BAT_HPWR_MASK			GENMASK(7, 6)
+enum {
+	BOOST_MODE_THRESH_3P3_V,
+	BOOST_MODE_THRESH_3P4_V = 0x40,
+	BOOST_MODE_THRESH_3P5_V = 0x80,
+	BOOST_MODE_THRESH_3P6_V = 0xC0
+};
+
+/********************************
+ *  BATIF Peripheral Registers  *
+ ********************************/
+
+/* BATIF Interrupt Bits	 */
+#define VPH_OV_RT_STS_BIT			BIT(7)
+#define BUCK_OC_RT_STS_BIT			BIT(6)
+#define BAT_TERMINAL_MISSING_RT_STS_BIT		BIT(5)
+#define BAT_THERM_OR_ID_MISSING_RT_STS_BIT      BIT(4)
+#define BAT_LOW_RT_STS_BIT			BIT(3)
+#define BAT_OV_RT_STS_BIT			BIT(2)
+#define ALL_CHNL_CONV_DONE_RT_STS		BIT(1)
+#define BAT_TEMP_RT_STS_BIT			BIT(0)
+
+#define SHIP_MODE_REG				(BATIF_BASE + 0x40)
+#define SHIP_MODE_EN_BIT			BIT(0)
+
+#define BATIF_ADC_CHANNEL_EN_REG		(BATIF_BASE + 0x82)
+#define IBATT_CHANNEL_EN_BIT			BIT(6)
+#define CONN_THM_CHANNEL_EN_BIT			BIT(4)
+#define DIE_TEMP_CHANNEL_EN_BIT			BIT(2)
+#define MISC_THM_CHANNEL_EN_BIT			BIT(1)
+
+#define BATIF_ADC_INTERNAL_PULL_UP_REG		(BATIF_BASE + 0x86)
+#define INTERNAL_PULL_UP_CONN_THM_MASK		GENMASK(5, 4)
+#define CONN_THM_SHIFT				4
+#define INTERNAL_PULL_NO_PULL			0x00
+#define INTERNAL_PULL_30K_PULL			0x01
+#define INTERNAL_PULL_100K_PULL			0x02
+#define INTERNAL_PULL_400K_PULL			0x03
+
+/********************************
+ *  USBIN Peripheral Registers  *
+ ********************************/
+#define APSD_STATUS_REG				(USBIN_BASE + 0x07)
+#define APSD_STATUS_7_BIT			BIT(7)
+#define HVDCP_CHECK_TIMEOUT_BIT			BIT(6)
+#define SLOW_PLUGIN_TIMEOUT_BIT			BIT(5)
+#define ENUMERATION_DONE_BIT			BIT(4)
+#define VADP_CHANGE_DONE_AFTER_AUTH_BIT		BIT(3)
+#define QC_AUTH_DONE_STATUS_BIT			BIT(2)
+#define QC_CHARGER_BIT				BIT(1)
+#define APSD_DTC_STATUS_DONE_BIT		BIT(0)
+
+#define APSD_RESULT_STATUS_REG			(USBIN_BASE + 0x08)
+#define APSD_RESULT_STATUS_7_BIT		BIT(7)
+#define APSD_RESULT_STATUS_MASK			GENMASK(6, 0)
+#define QC_3P0_BIT				BIT(6)
+#define QC_2P0_BIT				BIT(5)
+#define FLOAT_CHARGER_BIT			BIT(4)
+#define DCP_CHARGER_BIT				BIT(3)
+#define CDP_CHARGER_BIT				BIT(2)
+#define OCP_CHARGER_BIT				BIT(1)
+#define SDP_CHARGER_BIT				BIT(0)
+
+#define QC_CHANGE_STATUS_REG			(USBIN_BASE + 0x09)
+#define QC_12V_BIT				BIT(2)
+#define QC_9V_BIT				BIT(1)
+#define QC_5V_BIT				BIT(0)
+#define QC_2P0_STATUS_MASK			GENMASK(2, 0)
+
+/* USBIN Interrupt Bits */
+#define USBIN_ICL_CHANGE_RT_STS_BIT		BIT(7)
+#define USBIN_SOURCE_CHANGE_RT_STS_BIT		BIT(6)
+#define USBIN_REVI_RT_STS_BIT			BIT(5)
+#define USBIN_PLUGIN_RT_STS_BIT			BIT(4)
+#define USBIN_OV_RT_STS_BIT			BIT(3)
+#define USBIN_UV_RT_STS_BIT			BIT(2)
+#define USBIN_VASHDN_RT_STS_BIT			BIT(1)
+#define USBIN_COLLAPSE_RT_STS_BIT		BIT(0)
+
+#define USBIN_CMD_IL_REG			(USBIN_BASE + 0x40)
+#define USBIN_SUSPEND_BIT			BIT(0)
+
+#define CMD_APSD_REG				(USBIN_BASE + 0x41)
+#define APSD_RERUN_BIT				BIT(0)
+
+#define CMD_ICL_OVERRIDE_REG			(USBIN_BASE + 0x42)
+#define ICL_OVERRIDE_BIT			BIT(0)
+
+#define CMD_HVDCP_2_REG				(USBIN_BASE + 0x43)
+#define FORCE_12V_BIT				BIT(5)
+#define FORCE_9V_BIT				BIT(4)
+#define FORCE_5V_BIT				BIT(3)
+#define IDLE_BIT				BIT(2)
+#define SINGLE_DECREMENT_BIT			BIT(1)
+#define SINGLE_INCREMENT_BIT			BIT(0)
+
+#define USBIN_ADAPTER_ALLOW_OVERRIDE_REG	(USBIN_BASE + 0x44)
+#define CONTINUOUS				BIT(3)
+#define FORCE_12V				BIT(2)
+#define FORCE_9V				BIT(1)
+#define FORCE_5V				BIT(0)
+#define FORCE_NULL				0
+
+#define USB_CMD_PULLDOWN_REG			(USBIN_BASE + 0x45)
+#define EN_PULLDOWN_USB_IN_BIT			BIT(0)
+
+#define TYPE_C_CFG_REG				(USBIN_BASE + 0x58)
+#define BC1P2_START_ON_CC_BIT			BIT(7)
+
+#define HVDCP_PULSE_COUNT_MAX_REG              (USBIN_BASE + 0x5B)
+#define HVDCP_PULSE_COUNT_MAX_QC2_MASK         GENMASK(7, 6)
+enum {
+	HVDCP_PULSE_COUNT_MAX_QC2_5V = 0,
+	HVDCP_PULSE_COUNT_MAX_QC2_9V = 0x40,
+	HVDCP_PULSE_COUNT_MAX_QC2_12V = 0x80,
+	HVDCP_PULSE_COUNT_MAX_QC2_INVALID = 0xC0
+};
+
+#define USBIN_OPTIONS_1_CFG_REG			(USBIN_BASE + 0x62)
+#define HVDCP_AUTH_ALG_EN_CFG_BIT		BIT(6)
+#define HVDCP_AUTONOMOUS_MODE_EN_CFG_BIT	BIT(5)
+#define BC1P2_SRC_DETECT_BIT			BIT(3)
+#define HVDCP_EN_BIT				BIT(2)
+
+#define USBIN_OPTIONS_2_CFG_REG			(USBIN_BASE + 0x63)
+#define DCD_TIMEOUT_SEL_BIT			BIT(5)
+#define FLOAT_OPTIONS_MASK			GENMASK(2, 0)
+#define FLOAT_DIS_CHGING_CFG_BIT		BIT(2)
+#define SUSPEND_FLOAT_CFG_BIT			BIT(1)
+#define FORCE_FLOAT_SDP_CFG_BIT			BIT(0)
+
+#define USBIN_LOAD_CFG_REG			(USBIN_BASE + 0x65)
+#define ICL_OVERRIDE_AFTER_APSD_BIT		BIT(4)
+#define USBIN_AICL_STEP_TIMING_SEL_MASK		GENMASK(3, 2)
+#define USBIN_IN_COLLAPSE_GF_SEL_MASK		GENMASK(1, 0)
+
+#define USBIN_ICL_OPTIONS_REG			(USBIN_BASE + 0x66)
+#define CFG_USB3P0_SEL_BIT			BIT(2)
+#define	USB51_MODE_BIT				BIT(1)
+#define USBIN_MODE_CHG_BIT			BIT(0)
+
+#define USBIN_CURRENT_LIMIT_CFG_REG		(USBIN_BASE + 0x70)
+
+#define USBIN_AICL_OPTIONS_CFG_REG		(USBIN_BASE + 0x80)
+#define SUSPEND_ON_COLLAPSE_USBIN_BIT		BIT(7)
+#define USBIN_AICL_PERIODIC_RERUN_EN_BIT	BIT(4)
+#define USBIN_AICL_ADC_EN_BIT			BIT(3)
+#define USBIN_AICL_EN_BIT			BIT(2)
+
+#define USB_ENG_SSUPPLY_USB2_REG		(USBIN_BASE + 0xC0)
+#define ENG_SSUPPLY_12V_OV_OPT_BIT		BIT(1)
+
+#define USBIN_5V_AICL_THRESHOLD_REG		(USBIN_BASE + 0x81)
+#define USBIN_CONT_AICL_THRESHOLD_REG		(USBIN_BASE + 0x84)
+/********************************
+ *  DCIN Peripheral Registers   *
+ ********************************/
+
+/* DCIN Interrupt Bits */
+#define DCIN_PLUGIN_RT_STS_BIT			BIT(4)
+
+#define DCIN_CMD_IL_REG				(DCIN_BASE + 0x40)
+#define DCIN_SUSPEND_BIT			BIT(0)
+#define DCIN_EN_OVERRIDE_BIT			BIT(1)
+#define DCIN_EN_MASK				GENMASK(2, 1)
+
+#define DCIN_CMD_PON_REG			(DCIN_BASE + 0x45)
+#define DCIN_PON_BIT				BIT(0)
+#define MID_CHG_BIT					BIT(1)
+
+#define DCIN_LOAD_CFG_REG			(DCIN_BASE + 0x65)
+#define INPUT_MISS_POLL_EN_BIT			BIT(5)
+
+/********************************
+ *  TYPEC Peripheral Registers  *
+ ********************************/
+#define TYPE_C_SNK_STATUS_REG			(TYPEC_BASE + 0x06)
+#define DETECTED_SRC_TYPE_MASK			GENMASK(6, 0)
+#define SNK_DAM_MASK				GENMASK(6, 4)
+#define SNK_DAM_500MA_BIT			BIT(6)
+#define SNK_DAM_1500MA_BIT			BIT(5)
+#define SNK_DAM_3000MA_BIT			BIT(4)
+#define SNK_RP_STD_BIT				BIT(3)
+#define SNK_RP_1P5_BIT				BIT(2)
+#define SNK_RP_3P0_BIT				BIT(1)
+#define SNK_RP_SHORT_BIT			BIT(0)
+
+#define TYPE_C_SRC_STATUS_REG			(TYPEC_BASE + 0x08)
+#define DETECTED_SNK_TYPE_MASK			GENMASK(4, 0)
+#define SRC_HIGH_BATT_BIT			BIT(5)
+#define SRC_DEBUG_ACCESS_BIT			BIT(4)
+#define SRC_RD_OPEN_BIT				BIT(3)
+#define SRC_RD_RA_VCONN_BIT			BIT(2)
+#define SRC_RA_OPEN_BIT				BIT(1)
+#define AUDIO_ACCESS_RA_RA_BIT			BIT(0)
+
+#define TYPE_C_STATE_MACHINE_STATUS_REG		(TYPEC_BASE + 0x09)
+#define TYPEC_ATTACH_DETACH_STATE_BIT		BIT(5)
+
+#define TYPE_C_MISC_STATUS_REG			(TYPEC_BASE + 0x0B)
+#define TYPEC_WATER_DETECTION_STATUS_BIT	BIT(7)
+#define SNK_SRC_MODE_BIT			BIT(6)
+#define TYPEC_VBUS_ERROR_STATUS_BIT		BIT(4)
+#define TYPEC_TCCDEBOUNCE_DONE_STATUS_BIT	BIT(3)
+#define CC_ORIENTATION_BIT			BIT(1)
+#define CC_ATTACHED_BIT				BIT(0)
+
+#define LEGACY_CABLE_STATUS_REG			(TYPEC_BASE + 0x0D)
+#define TYPEC_LEGACY_CABLE_STATUS_BIT		BIT(1)
+#define TYPEC_NONCOMP_LEGACY_CABLE_STATUS_BIT	BIT(0)
+
+#define TYPEC_U_USB_STATUS_REG			(TYPEC_BASE + 0x0F)
+#define U_USB_GROUND_NOVBUS_BIT			BIT(6)
+#define U_USB_GROUND_BIT			BIT(4)
+#define U_USB_FMB1_BIT				BIT(3)
+#define U_USB_FLOAT1_BIT			BIT(2)
+#define U_USB_FMB2_BIT				BIT(1)
+#define U_USB_FLOAT2_BIT			BIT(0)
+
+#define TYPE_C_MODE_CFG_REG			(TYPEC_BASE + 0x44)
+#define TYPEC_TRY_MODE_MASK			GENMASK(4, 3)
+#define EN_TRY_SNK_BIT				BIT(4)
+#define EN_TRY_SRC_BIT				BIT(3)
+#define TYPEC_POWER_ROLE_CMD_MASK		GENMASK(2, 0)
+#define EN_SRC_ONLY_BIT				BIT(2)
+#define EN_SNK_ONLY_BIT				BIT(1)
+#define TYPEC_DISABLE_CMD_BIT			BIT(0)
+
+#define TYPE_C_VCONN_CONTROL_REG		(TYPEC_BASE + 0x46)
+#define VCONN_EN_ORIENTATION_BIT		BIT(2)
+#define VCONN_EN_VALUE_BIT			BIT(1)
+#define VCONN_EN_SRC_BIT			BIT(0)
+
+#define TYPE_C_CCOUT_CONTROL_REG		(TYPEC_BASE + 0x48)
+#define TYPEC_CCOUT_BUFFER_EN_BIT		BIT(2)
+#define TYPEC_CCOUT_VALUE_BIT			BIT(1)
+#define TYPEC_CCOUT_SRC_BIT			BIT(0)
+
+#define DEBUG_ACCESS_SRC_CFG_REG		(TYPEC_BASE + 0x4C)
+#define EN_UNORIENTED_DEBUG_ACCESS_SRC_BIT	BIT(0)
+
+#define TYPE_C_CRUDE_SENSOR_CFG_REG		(TYPEC_BASE + 0x4e)
+#define EN_SRC_CRUDE_SENSOR_BIT			BIT(1)
+#define EN_SNK_CRUDE_SENSOR_BIT			BIT(0)
+
+#define TYPE_C_EXIT_STATE_CFG_REG		(TYPEC_BASE + 0x50)
+#define BYPASS_VSAFE0V_DURING_ROLE_SWAP_BIT	BIT(3)
+#define SEL_SRC_UPPER_REF_BIT			BIT(2)
+#define EXIT_SNK_BASED_ON_CC_BIT		BIT(0)
+
+#define TYPE_C_CURRSRC_CFG_REG			(TYPEC_BASE + 0x52)
+#define TYPEC_SRC_RP_SEL_MASK			GENMASK(1, 0)
+enum {
+	TYPEC_SRC_RP_STD,
+	TYPEC_SRC_RP_1P5A,
+	TYPEC_SRC_RP_3A,
+	TYPEC_SRC_RP_3A_DUPLICATE,
+	TYPEC_SRC_RP_MAX_ELEMENTS
+};
+
+#define TYPE_C_INTERRUPT_EN_CFG_1_REG			(TYPEC_BASE + 0x5E)
+#define TYPEC_LEGACY_CABLE_INT_EN_BIT			BIT(7)
+#define TYPEC_NONCOMPLIANT_LEGACY_CABLE_INT_EN_BIT	BIT(6)
+#define TYPEC_TRYSOURCE_DETECT_INT_EN_BIT		BIT(5)
+#define TYPEC_TRYSINK_DETECT_INT_EN_BIT			BIT(4)
+#define TYPEC_CCOUT_DETACH_INT_EN_BIT			BIT(3)
+#define TYPEC_CCOUT_ATTACH_INT_EN_BIT			BIT(2)
+#define TYPEC_VBUS_DEASSERT_INT_EN_BIT			BIT(1)
+#define TYPEC_VBUS_ASSERT_INT_EN_BIT			BIT(0)
+
+#define TYPE_C_INTERRUPT_EN_CFG_2_REG		(TYPEC_BASE + 0x60)
+#define TYPEC_SRC_BATT_HPWR_INT_EN_BIT		BIT(6)
+#define MICRO_USB_STATE_CHANGE_INT_EN_BIT	BIT(5)
+#define TYPEC_STATE_MACHINE_CHANGE_INT_EN_BIT	BIT(4)
+#define TYPEC_DEBUG_ACCESS_DETECT_INT_EN_BIT	BIT(3)
+#define TYPEC_WATER_DETECTION_INT_EN_BIT	BIT(2)
+#define TYPEC_VBUS_ERROR_INT_EN_BIT		BIT(1)
+#define TYPEC_DEBOUNCE_DONE_INT_EN_BIT		BIT(0)
+
+#define TYPE_C_DEBOUNCE_OPTION_REG		(TYPEC_BASE + 0x62)
+#define REDUCE_TCCDEBOUNCE_TO_2MS_BIT		BIT(2)
+
+#define TYPE_C_SBU_CFG_REG			(TYPEC_BASE + 0x6A)
+#define SEL_SBU1_ISRC_VAL			0x04
+#define SEL_SBU2_ISRC_VAL			0x01
+
+#define TYPEC_U_USB_CFG_REG			(TYPEC_BASE + 0x70)
+#define EN_MICRO_USB_FACTORY_MODE_BIT		BIT(1)
+#define EN_MICRO_USB_MODE_BIT			BIT(0)
+
+#define PMI632_TYPEC_U_USB_WATER_PROTECTION_CFG_REG	(TYPEC_BASE + 0x72)
+#define TYPEC_U_USB_WATER_PROTECTION_CFG_REG		(TYPEC_BASE + 0x73)
+#define EN_MICRO_USB_WATER_PROTECTION_BIT		BIT(4)
+#define MICRO_USB_DETECTION_ON_TIME_CFG_MASK		GENMASK(3, 2)
+#define MICRO_USB_DETECTION_PERIOD_CFG_MASK		GENMASK(1, 0)
+
+#define PMI632_TYPEC_MICRO_USB_MODE_REG		(TYPEC_BASE + 0x73)
+#define MICRO_USB_MODE_ONLY_BIT			BIT(0)
+/********************************
+ *  MISC Peripheral Registers  *
+ ********************************/
+#define TEMP_RANGE_STATUS_REG			(MISC_BASE + 0x06)
+#define THERM_REG_ACTIVE_BIT			BIT(6)
+#define TLIM_BIT				BIT(5)
+#define TEMP_RANGE_MASK				GENMASK(4, 1)
+#define ALERT_LEVEL_BIT				BIT(4)
+#define TEMP_ABOVE_RANGE_BIT			BIT(3)
+#define TEMP_WITHIN_RANGE_BIT			BIT(2)
+#define TEMP_BELOW_RANGE_BIT			BIT(1)
+#define THERMREG_DISABLED_BIT			BIT(0)
+
+#define DIE_TEMP_STATUS_REG			(MISC_BASE + 0x07)
+#define DIE_TEMP_SHDN_BIT			BIT(3)
+#define DIE_TEMP_RST_BIT			BIT(2)
+#define DIE_TEMP_UB_BIT				BIT(1)
+#define DIE_TEMP_LB_BIT				BIT(0)
+
+#define SKIN_TEMP_STATUS_REG			(MISC_BASE + 0x08)
+#define SKIN_TEMP_SHDN_BIT			BIT(3)
+#define SKIN_TEMP_RST_BIT			BIT(2)
+#define SKIN_TEMP_UB_BIT			BIT(1)
+#define SKIN_TEMP_LB_BIT			BIT(0)
+
+#define CONNECTOR_TEMP_STATUS_REG		(MISC_BASE + 0x09)
+#define CONNECTOR_TEMP_SHDN_BIT			BIT(3)
+#define CONNECTOR_TEMP_RST_BIT			BIT(2)
+#define CONNECTOR_TEMP_UB_BIT			BIT(1)
+#define CONNECTOR_TEMP_LB_BIT			BIT(0)
+
+#define SMB_TEMP_STATUS_REG			(MISC_BASE + 0x0A)
+#define SMB_TEMP_SHDN_BIT			BIT(3)
+#define SMB_TEMP_RST_BIT			BIT(2)
+#define SMB_TEMP_UB_BIT				BIT(1)
+#define SMB_TEMP_LB_BIT				BIT(0)
+
+#define BARK_BITE_WDOG_PET_REG			(MISC_BASE + 0x43)
+#define BARK_BITE_WDOG_PET_BIT			BIT(0)
+
+#define AICL_CMD_REG				(MISC_BASE + 0x44)
+#define RESTART_AICL_BIT			BIT(1)
+#define RERUN_AICL_BIT				BIT(0)
+
+#define MISC_SMB_EN_CMD_REG			(MISC_BASE + 0x48)
+#define SMB_EN_OVERRIDE_VALUE_BIT		BIT(4)
+#define SMB_EN_OVERRIDE_BIT			BIT(3)
+#define EN_STAT_CMD_BIT				BIT(2)
+#define EN_CP_FPF_CMD_BIT			BIT(1)
+#define EN_CP_CMD_BIT				BIT(0)
+
+#define WD_CFG_REG				(MISC_BASE + 0x51)
+#define WATCHDOG_TRIGGER_AFP_EN_BIT		BIT(7)
+#define BARK_WDOG_INT_EN_BIT			BIT(6)
+#define WDOG_TIMER_EN_ON_PLUGIN_BIT		BIT(1)
+
+#define SNARL_BARK_BITE_WD_CFG_REG		(MISC_BASE + 0x53)
+#define BITE_WDOG_DISABLE_CHARGING_CFG_BIT	BIT(7)
+#define SNARL_WDOG_TIMEOUT_MASK                 GENMASK(6, 4)
+#define SNARL_WDOG_TIMEOUT_SHIFT		4
+#define SNARL_WDOG_TMOUT_62P5MS			0x00
+#define SNARL_WDOG_TMOUT_1S			0x40
+#define SNARL_WDOG_TMOUT_8S			0x70
+#define BARK_WDOG_TIMEOUT_MASK			GENMASK(3, 2)
+#define BARK_WDOG_TIMEOUT_SHIFT			2
+#define BITE_WDOG_TIMEOUT_MASK			GENMASK(1, 0)
+#define BITE_WDOG_TIMEOUT_8S			0x3
+#define MIN_WD_BARK_TIME			16
+
+#define AICL_RERUN_TIME_CFG_REG			(MISC_BASE + 0x61)
+#define AICL_RERUN_TIME_12S_VAL			0x01
+
+#define MISC_THERMREG_SRC_CFG_REG		(MISC_BASE + 0x70)
+#define THERMREG_SW_ICL_ADJUST_BIT		BIT(7)
+#define DIE_ADC_SEL_BIT				BIT(6)
+#define THERMREG_SMB_ADC_SRC_EN_BIT		BIT(5)
+#define THERMREG_CONNECTOR_ADC_SRC_EN_BIT	BIT(4)
+#define SKIN_ADC_CFG_BIT			BIT(3)
+#define THERMREG_SKIN_ADC_SRC_EN_BIT		BIT(2)
+#define THERMREG_DIE_ADC_SRC_EN_BIT		BIT(1)
+#define THERMREG_DIE_CMP_SRC_EN_BIT		BIT(0)
+
+#define MISC_SMB_CFG_REG			(MISC_BASE + 0x90)
+#define SMB_EN_SEL_BIT				BIT(4)
+#define CP_EN_POLARITY_CFG_BIT			BIT(3)
+#define STAT_POLARITY_CFG_BIT			BIT(2)
+#define STAT_FUNCTION_CFG_BIT			BIT(1)
+#define STAT_IRQ_PULSING_EN_BIT			BIT(0)
+
+#define DIE_REG_H_THRESHOLD_MSB_REG		(MISC_BASE + 0xA0)
+
+#define SMB_REG_H_THRESHOLD_MSB_REG		(MISC_BASE + 0XBC)
+
+/* SDAM regs */
+#define MISC_PBS_RT_STS_REG			(MISC_PBS_BASE + 0x10)
+#define PULSE_SKIP_IRQ_BIT			BIT(4)
+
+#define SDAM_QC_DET_STATUS_REG			0x58
+#define SDAM_QC_ADC_LSB_REG			0x54
+
+#endif /* __SMB5_CHARGER_REG_H */
diff --git a/drivers/soc/qcom/smblite-lib.h b/drivers/soc/qcom/smblite-lib.h
new file mode 100644
index 000000000000..550e3e55d20c
--- /dev/null
+++ b/drivers/soc/qcom/smblite-lib.h
@@ -0,0 +1,548 @@
+/* SPDX-License-Identifier: GPL-2.0-only */
+/*
+ * Copyright (c) 2020-2021 The Linux Foundation. All rights reserved.
+ * Copyright (c) 2022, Qualcomm Innovation Center, Inc. All rights reserved.
+ */
+
+#ifndef __SMBLITE_LIB_H
+#define __SMBLITE_LIB_H
+
+#include <linux/alarmtimer.h>
+#include <linux/ktime.h>
+#include <linux/types.h>
+#include <linux/timer.h>
+#include <linux/interrupt.h>
+#include <linux/irqreturn.h>
+#include <linux/regulator/driver.h>
+#include <linux/regulator/consumer.h>
+#include <linux/extcon-provider.h>
+#include <linux/usb/typec.h>
+#include <linux/qti_power_supply.h>
+#include "storm-watch.h"
+#include "battery.h"
+#include "smblite-remote-bms.h"
+
+enum print_reason {
+	PR_INTERRUPT	= BIT(0),
+	PR_REGISTER	= BIT(1),
+	PR_MISC		= BIT(2),
+	PR_PARALLEL	= BIT(3),
+	PR_OTG		= BIT(4),
+};
+
+#define DEFAULT_VOTER			"DEFAULT_VOTER"
+#define USER_VOTER			"USER_VOTER"
+#define USB_PSY_VOTER			"USB_PSY_VOTER"
+#define USBIN_V_VOTER			"USBIN_V_VOTER"
+#define THERMAL_DAEMON_VOTER		"THERMAL_DAEMON_VOTER"
+#define BOOST_BACK_VOTER		"BOOST_BACK_VOTER"
+#define DEBUG_BOARD_VOTER		"DEBUG_BOARD_VOTER"
+#define PL_DELAY_VOTER			"PL_DELAY_VOTER"
+#define SW_ICL_MAX_VOTER		"SW_ICL_MAX_VOTER"
+#define BATT_PROFILE_VOTER		"BATT_PROFILE_VOTER"
+#define USBIN_I_VOTER			"USBIN_I_VOTER"
+#define WEAK_CHARGER_VOTER		"WEAK_CHARGER_VOTER"
+#define HW_LIMIT_VOTER			"HW_LIMIT_VOTER"
+#define FORCE_RECHARGE_VOTER		"FORCE_RECHARGE_VOTER"
+#define FCC_STEPPER_VOTER		"FCC_STEPPER_VOTER"
+#define SW_THERM_REGULATION_VOTER	"SW_THERM_REGULATION_VOTER"
+#define JEITA_ARB_VOTER			"JEITA_ARB_VOTER"
+#define AICL_THRESHOLD_VOTER		"AICL_THRESHOLD_VOTER"
+#define USB_SUSPEND_VOTER		"USB_SUSPEND_VOTER"
+#define DETACH_DETECT_VOTER		"DETACH_DETECT_VOTER"
+#define ICL_CHANGE_VOTER		"ICL_CHANGE_VOTER"
+#define TYPEC_SWAP_VOTER		"TYPEC_SWAP_VOTER"
+#define FLASH_ACTIVE_VOTER		"FLASH_ACTIVE_VOTER"
+#define CONCURRENT_MODE_VOTER		"CONCURRENT_MODE_VOTER"
+
+#define BOOST_BACK_STORM_COUNT	3
+#define WEAK_CHG_STORM_COUNT	8
+
+#define VBAT_TO_VRAW_ADC(v)		div_u64((u64)v * 1000000UL, 194637UL)
+
+#define ITERM_LIMITS_MA			10000
+#define ADC_CHG_ITERM_MASK		32767
+#define PM5100_MAX_LIMITS_MA		2000
+#define PM5100_ADC_CHG_ITERM_MULT	16384
+#define PM5100_RAW_ITERM(iterm)					\
+		div_s64(((int64_t)iterm * PM5100_ADC_CHG_ITERM_MULT), 1000)
+
+#define USBIN_25UA	25000
+#define USBIN_100UA     100000
+#define USBIN_150UA     150000
+#define USBIN_300UA     300000
+#define USBIN_400UA     400000
+#define USBIN_500UA     500000
+#define USBIN_900UA     900000
+#define SDP_CURRENT_UA			500000
+#define CDP_CURRENT_UA			1500000
+#define DCP_CURRENT_UA			1500000
+#define TYPEC_DEFAULT_CURRENT_UA	900000
+#define TYPEC_MEDIUM_CURRENT_UA		1500000
+#define TYPEC_HIGH_CURRENT_UA		3000000
+#define ROLE_REVERSAL_DELAY_MS		500
+/* Max supported voltage 6V */
+#define HVDCP3_STEP_SIZE_UV		200000
+#define PM5100_MAX_HVDCP3_PULSES	5
+#define PM5100_HVDCP3_MAX_VOLTAGE_UV	6000000
+
+enum smb_mode {
+	PARALLEL_MASTER = 0,
+	PARALLEL_SLAVE,
+	NUM_MODES,
+};
+
+enum sink_src_mode {
+	SINK_MODE,
+	SRC_MODE,
+	AUDIO_ACCESS_MODE,
+	UNATTACHED_MODE,
+};
+
+enum {
+	BOOST_BACK_WA			= BIT(0),
+	WEAK_ADAPTER_WA			= BIT(1),
+	FLASH_DIE_TEMP_DERATE_WA	= BIT(2),
+	HDC_ICL_REDUCTION_WA		= BIT(3),
+};
+
+enum jeita_cfg_stat {
+	JEITA_CFG_NONE = 0,
+	JEITA_CFG_FAILURE,
+	JEITA_CFG_COMPLETE,
+};
+
+enum {
+	RERUN_AICL = 0,
+	RESTART_AICL,
+};
+
+enum smb_irq_index {
+	/* CHGR */
+	CHG_STATE_CHANGE_IRQ = 0,
+	CHGR_ERROR_IRQ,
+	BUCK_OC_IRQ,
+	VPH_OV_IRQ,
+	/* DCDC */
+	OTG_FAIL_IRQ,
+	OTG_FAULT_IRQ,
+	SKIP_MODE_IRQ,
+	INPUT_CURRENT_LIMITING_IRQ,
+	SWITCHER_POWER_OK_IRQ,
+	BOOST_MODE_ACTIVE_IRQ,
+	/* BATIF */
+	BAT_TEMP_IRQ,
+	BAT_THERM_OR_ID_MISSING_IRQ,
+	BAT_LOW_IRQ,
+	BAT_OV_IRQ,
+	BSM_ACTIVE_IRQ,
+	/* USB */
+	USBIN_PLUGIN_IRQ,
+	USBIN_COLLAPSE_IRQ,
+	USBIN_UV_IRQ,
+	USBIN_OV_IRQ,
+	USBIN_GT_VT_IRQ,
+	USBIN_SRC_CHANGE_IRQ,
+	USBIN_ICL_CHANGE_IRQ,
+	/* TYPEC */
+	TYPEC_OR_RID_DETECTION_CHANGE_IRQ,
+	TYPEC_VPD_DETECT_IRQ,
+	TYPEC_CC_STATE_CHANGE_IRQ,
+	TYPEC_VBUS_CHANGE_IRQ,
+	TYPEC_ATTACH_DETACH_IRQ,
+	TYPEC_LEGACY_CABLE_DETECT_IRQ,
+	TYPEC_TRY_SNK_SRC_DETECT_IRQ,
+	/* MISC */
+	WDOG_SNARL_IRQ,
+	WDOG_BARK_IRQ,
+	AICL_FAIL_IRQ,
+	AICL_DONE_IRQ,
+	IMP_TRIGGER_IRQ,
+	ALL_CHNL_CONV_DONE_IRQ,
+	TEMP_CHANGE_IRQ,
+	/* FLASH */
+	VREG_OK_IRQ,
+	ILIM_S2_IRQ,
+	ILIM_S1_IRQ,
+	FLASH_STATE_CHANGE_IRQ,
+	TORCH_REQ_IRQ,
+	FLASH_EN_IRQ,
+	/* END */
+	SMB_IRQ_MAX,
+};
+
+enum float_options {
+	FLOAT_DCP		= 1,
+	FLOAT_SDP		= 2,
+	DISABLE_CHARGING	= 3,
+	SUSPEND_INPUT		= 4,
+};
+
+struct apsd_result {
+	const char * const name;
+	const u8 bit;
+	const int val;
+};
+
+enum chg_term_config_src {
+	ITERM_SRC_UNSPECIFIED,
+	ITERM_SRC_ADC,
+	ITERM_SRC_ANALOG
+};
+
+struct smb_irq_info {
+	const char			*name;
+	const irq_handler_t		handler;
+	const bool			wake;
+	const struct storm_watch	storm_data;
+	struct smb_irq_data		*irq_data;
+	int				irq;
+	bool				enabled;
+	bool				is_requested;
+};
+
+static const unsigned int smblite_lib_extcon_cable[] = {
+	EXTCON_USB,
+	EXTCON_USB_HOST,
+	EXTCON_NONE,
+};
+
+enum icl_override_mode {
+	/* APSD/Type-C/QC auto */
+	HW_AUTO_MODE,
+	/* 100/150/500/900mA */
+	SW_OVERRIDE_USB51_MODE,
+	/* ICL other than USB51 */
+	SW_OVERRIDE_HC_MODE,
+};
+
+/* EXTCON_USB and EXTCON_USB_HOST are mutually exclusive */
+static const u32 smblite_lib_extcon_exclusive[] = {0x3, 0};
+
+struct smb_irq_data {
+	void                    *parent_data;
+	const char		*name;
+	struct storm_watch	storm_data;
+};
+
+struct smb_chg_param {
+	const char	*name;
+	u16		reg;
+	int		min_u;
+	int		max_u;
+	int		step_u;
+	int		(*get_proc)(struct smb_chg_param *param,
+				    u8 val_raw);
+	int		(*set_proc)(struct smb_chg_param *param,
+				    int val_u,
+				    u8 *val_raw);
+};
+
+struct smb_params {
+	struct smb_chg_param	fcc;
+	struct smb_chg_param	fv;
+	struct smb_chg_param	usb_icl;
+	struct smb_chg_param	icl_max_stat;
+	struct smb_chg_param	icl_stat;
+	struct smb_chg_param	aicl_5v_threshold;
+};
+
+struct parallel_params {
+	struct power_supply	*psy;
+};
+
+struct smb_iio {
+	struct iio_channel	*temp_chan;
+	struct iio_channel	*usbin_v_chan;
+	struct iio_channel	*usbin_i_chan;
+};
+
+enum pmic_type {
+	PM2250,
+	PM5100,
+};
+
+struct smb_base_address {
+	u16 chg_base;
+	u16 batif_base;
+	u16 usbin_base;
+	u16 misc_base;
+	u16 dcdc_base;
+	u16 typec_base;
+	u16 boost_base;
+};
+
+struct smb_charger {
+	struct device		*dev;
+	char			*name;
+	struct regmap		*regmap;
+	struct smb_irq_info	*irq_info;
+	struct smb_params	param;
+	struct smb_base_address	base;
+	struct smb_iio		iio;
+	struct iio_channel	*iio_chans;
+	struct iio_channel	**iio_chan_list_qg;
+	struct iio_channel	**iio_chan_list_smb_parallel;
+	struct class            qcom_class;
+	struct smblite_remote_bms	remote_bms;
+	struct nvmem_cell       *debug_mask_nvmem;
+	struct nvmem_cell	*soc_nvmem;
+	int			*debug_mask;
+	enum smb_mode		mode;
+	u8			subtype;
+	int			weak_chg_icl_ua;
+
+	/* locks */
+	struct mutex		typec_lock;
+	struct mutex		dpdm_lock;
+	struct mutex		dpdm_pulse_lock;
+
+	/* power supplies */
+	struct power_supply		*batt_psy;
+	struct power_supply		*usb_psy;
+	enum power_supply_type		real_charger_type;
+
+	/* notifiers */
+	struct notifier_block	nb;
+
+	/* Regulators */
+	struct regulator	*dpdm_reg;
+
+	/* parallel charging */
+	struct parallel_params	pl;
+
+	/* typec */
+	struct typec_port	*typec_port;
+	struct typec_capability	typec_caps;
+	struct typec_partner	*typec_partner;
+	struct typec_partner_desc typec_partner_desc;
+
+	/* votables */
+	struct votable		*fcc_votable;
+	struct votable		*fcc_main_votable;
+	struct votable		*fv_votable;
+	struct votable		*usb_icl_votable;
+	struct votable		*awake_votable;
+	struct votable		*pl_disable_votable;
+	struct votable		*chg_disable_votable;
+	struct votable		*pl_enable_votable_indirect;
+	struct votable		*icl_irq_disable_votable;
+	struct votable		*temp_change_irq_disable_votable;
+
+	/* work */
+	struct work_struct	bms_update_work;
+	struct work_struct	pl_update_work;
+	struct work_struct	jeita_update_work;
+	struct delayed_work	icl_change_work;
+	struct delayed_work	pl_enable_work;
+	struct delayed_work	bb_removal_work;
+	struct delayed_work	thermal_regulation_work;
+	struct delayed_work	role_reversal_check;
+	struct delayed_work	pr_swap_detach_work;
+
+	struct charger_param	chg_param;
+
+	/* cached status */
+	int			system_temp_level;
+	int			thermal_levels;
+	int			*thermal_mitigation;
+	int			fake_capacity;
+	int			fake_batt_status;
+	bool			step_chg_enabled;
+	bool			typec_legacy_use_rp_icl;
+	int			connector_type;
+	bool			suspend_input_on_debug_batt;
+	bool			fake_chg_status_on_debug_batt;
+	int			typec_mode;
+	int			dr_mode;
+	int			term_vbat_uv;
+	int			input_current_limited;
+	int			main_fcc_max;
+	u32			jeita_status;
+	bool			jeita_arb_flag;
+	bool			typec_legacy;
+	bool			otg_present;
+	int			auto_recharge_soc;
+	enum sink_src_mode	sink_src_mode;
+	enum power_supply_typec_power_role power_role;
+	enum jeita_cfg_stat	jeita_configured;
+	bool			fcc_stepper_enable;
+	u32			jeita_soft_thlds[2];
+	u32			jeita_soft_hys_thlds[2];
+	int			jeita_soft_fcc[2];
+	int			jeita_soft_fv[2];
+	int			aicl_5v_threshold_mv;
+	int			default_aicl_5v_threshold_mv;
+	int			cutoff_count;
+	bool			aicl_max_reached;
+	bool			pr_swap_in_progress;
+	bool			ldo_mode;
+	int			usb_id_gpio;
+	int			usb_id_irq;
+	bool			typec_role_swap_failed;
+	bool			use_extcon;
+	bool			uusb_apsd_rerun_done;
+	bool			dpdm_enabled;
+	bool			hvdcp3_detected;
+	bool			concurrent_mode_supported;
+	bool			concurrent_mode_status;
+	u8			float_cfg;
+	bool			is_debug_batt;
+
+	/* workaround flag */
+	u32			wa_flags;
+	int			boost_current_ua;
+
+	/* extcon for VBUS / ID notification to USB for uUSB */
+	struct extcon_dev	*extcon;
+
+	/* battery profile */
+	int			batt_profile_fcc_ua;
+	int			batt_profile_fv_uv;
+
+	/* flash */
+	u32			flash_derating_soc;
+	u32			flash_disable_soc;
+	u32			headroom_mode;
+	bool			flash_init_done;
+	bool			flash_active;
+	u32			irq_status;
+	bool			is_fg_remote;
+};
+
+int smblite_lib_read(struct smb_charger *chg, u16 addr, u8 *val);
+int smblite_lib_masked_write(struct smb_charger *chg, u16 addr, u8 mask,
+				u8 val);
+int smblite_lib_write(struct smb_charger *chg, u16 addr, u8 val);
+int smblite_lib_batch_write(struct smb_charger *chg, u16 addr, u8 *val,
+				int count);
+int smblite_lib_batch_read(struct smb_charger *chg, u16 addr, u8 *val,
+				int count);
+int smblite_lib_get_charge_param(struct smb_charger *chg,
+				struct smb_chg_param *param, int *val_u);
+int smblite_lib_enable_charging(struct smb_charger *chg, bool enable);
+int smblite_lib_set_charge_param(struct smb_charger *chg,
+				struct smb_chg_param *param, int val_u);
+
+irqreturn_t smblite_default_irq_handler(int irq, void *data);
+irqreturn_t smblite_chg_state_change_irq_handler(int irq, void *data);
+irqreturn_t smblite_batt_temp_changed_irq_handler(int irq, void *data);
+irqreturn_t smblite_batt_psy_changed_irq_handler(int irq, void *data);
+irqreturn_t smblite_usbin_uv_irq_handler(int irq, void *data);
+irqreturn_t smblite_usb_plugin_irq_handler(int irq, void *data);
+irqreturn_t smblite_icl_change_irq_handler(int irq, void *data);
+irqreturn_t smblite_typec_state_change_irq_handler(int irq, void *data);
+irqreturn_t smblite_typec_attach_detach_irq_handler(int irq, void *data);
+irqreturn_t smblite_switcher_power_ok_irq_handler(int irq, void *data);
+irqreturn_t smblite_wdog_bark_irq_handler(int irq, void *data);
+irqreturn_t smblite_typec_or_rid_detection_change_irq_handler(int irq,
+				void *data);
+irqreturn_t smblite_temp_change_irq_handler(int irq, void *data);
+irqreturn_t smblite_usbin_ov_irq_handler(int irq, void *data);
+irqreturn_t smblite_usb_id_irq_handler(int irq, void *data);
+irqreturn_t smblite_usb_source_change_irq_handler(int irq, void *data);
+irqreturn_t smblite_boost_mode_sw_en_irq_handler(int irq, void *data);
+
+int smblite_lib_get_prop_batt_present(struct smb_charger *chg,
+				union power_supply_propval *val);
+int smblite_lib_get_prop_batt_capacity(struct smb_charger *chg,
+				union power_supply_propval *val);
+int smblite_lib_get_prop_batt_status(struct smb_charger *chg,
+				union power_supply_propval *val);
+int smblite_lib_get_prop_batt_charge_type(struct smb_charger *chg,
+				union power_supply_propval *val);
+int smblite_lib_get_prop_batt_charge_done(struct smb_charger *chg,
+				int *val);
+int smblite_lib_get_batt_current_now(struct smb_charger *chg,
+					int *val);
+int smblite_lib_get_prop_batt_health(struct smb_charger *chg,
+				union power_supply_propval *val);
+int smblite_lib_get_prop_system_temp_level(struct smb_charger *chg,
+				union power_supply_propval *val);
+int smblite_lib_get_prop_system_temp_level_max(struct smb_charger *chg,
+				union power_supply_propval *val);
+int smblite_lib_get_prop_batt_iterm(struct smb_charger *chg,
+				union power_supply_propval *val);
+int smblite_lib_set_prop_batt_iterm(struct smb_charger *chg, int iterm_ma);
+int smblite_lib_get_prop_input_suspend(struct smb_charger *chg,
+					int *val);
+int smblite_lib_set_prop_input_suspend(struct smb_charger *chg,
+					const int val);
+int smblite_lib_set_prop_batt_capacity(struct smb_charger *chg,
+				const union power_supply_propval *val);
+int smblite_lib_set_prop_batt_sys_soc(struct smb_charger *chg, int val);
+int smblite_lib_set_prop_batt_status(struct smb_charger *chg,
+				const union power_supply_propval *val);
+int smblite_lib_set_prop_system_temp_level(struct smb_charger *chg,
+				const union power_supply_propval *val);
+int smblite_lib_get_prop_usb_present(struct smb_charger *chg,
+				union power_supply_propval *val);
+int smblite_lib_get_prop_usb_online(struct smb_charger *chg,
+				union power_supply_propval *val);
+void smblite_lib_get_prop_usb_type(struct smb_charger *chg,
+				union power_supply_propval *val);
+int smblite_lib_get_usb_online(struct smb_charger *chg,
+				union power_supply_propval *val);
+int smblite_lib_get_prop_input_current_limited(struct smb_charger *chg,
+				int *val);
+int smblite_lib_get_prop_usb_voltage_now(struct smb_charger *chg,
+				union power_supply_propval *val);
+int smblite_lib_get_usb_prop_typec_mode(struct smb_charger *chg,
+				int *val);
+int smblite_lib_get_prop_typec_cc_orientation(struct smb_charger *chg,
+				int *val);
+int smblite_lib_get_prop_scope(struct smb_charger *chg,
+			union power_supply_propval *val);
+int smblite_lib_get_prop_typec_power_role(struct smb_charger *chg,
+				int *val);
+int smblite_lib_get_prop_input_current_settled(struct smb_charger *chg,
+				int *val);
+int smblite_lib_get_prop_input_voltage_settled(struct smb_charger *chg,
+				int *val);
+int smblite_lib_get_prop_usbin_current(struct smb_charger *chg,
+				union power_supply_propval *val);
+int smblite_lib_get_prop_charger_temp(struct smb_charger *chg,
+				int *val);
+int smblite_lib_get_prop_die_health(struct smb_charger *chg);
+int smblite_lib_get_die_health(struct smb_charger *chg,
+				int *val);
+int smblite_lib_set_prop_current_max(struct smb_charger *chg,
+				const union power_supply_propval *val);
+int smblite_lib_set_prop_typec_power_role(struct smb_charger *chg,
+				const int val);
+int smblite_lib_set_prop_ship_mode(struct smb_charger *chg,
+				const int val);
+int smblite_lib_set_prop_rechg_soc_thresh(struct smb_charger *chg,
+				const int val);
+void smblite_lib_suspend_on_debug_battery(struct smb_charger *chg);
+int smblite_lib_run_aicl(struct smb_charger *chg, int type);
+int smblite_lib_set_icl_current(struct smb_charger *chg, const int icl_ua);
+int smblite_lib_get_icl_current(struct smb_charger *chg, int *icl_ua);
+int smblite_lib_get_charge_current(struct smb_charger *chg,
+				int *total_current_ua);
+int smblite_lib_get_hw_current_max(struct smb_charger *chg,
+				int *total_current_ua);
+int smblite_lib_typec_port_type_set(const struct typec_capability *cap,
+				enum typec_port_type type);
+int smblite_lib_get_prop_from_bms(struct smb_charger *chg, int channel,
+					int *val);
+int smblite_lib_get_iio_channel(struct smb_charger *chg, const char *propname,
+					struct iio_channel **chan);
+int smblite_lib_icl_override(struct smb_charger *chg,
+				enum icl_override_mode mode);
+int smblite_lib_set_prop_usb_type(struct smb_charger *chg,
+				const int val);
+const struct apsd_result *smblite_lib_get_apsd_result(struct smb_charger *chg);
+void smblite_update_usb_desc(struct smb_charger *chg);
+int smblite_lib_init(struct smb_charger *chg);
+int smblite_lib_deinit(struct smb_charger *chg);
+int smblite_iio_get_prop(struct smb_charger *chg, int channel, int *val);
+int smblite_iio_set_prop(struct smb_charger *chg, int channel, int val);
+int smblite_lib_get_fcc(struct smb_chg_param *param, u8 val_raw);
+int smblite_lib_set_fcc(struct smb_chg_param *param, int val_u, u8 *val_raw);
+int smblite_lib_set_concurrent_config(struct smb_charger *chg, bool enable);
+bool is_concurrent_mode_supported(struct smb_charger *chg);
+void smblite_lib_hvdcp_detect_enable(struct smb_charger *chg, bool enable);
+int smblite_lib_rerun_apsd_if_required(struct smb_charger *chg);
+
+#endif /* __SMBLITE_LIB_H */
diff --git a/drivers/soc/qcom/smblite-reg.h b/drivers/soc/qcom/smblite-reg.h
new file mode 100644
index 000000000000..deebb1d79076
--- /dev/null
+++ b/drivers/soc/qcom/smblite-reg.h
@@ -0,0 +1,376 @@
+/* SPDX-License-Identifier: GPL-2.0-only */
+/*
+ * Copyright (c) 2020-2021 The Linux Foundation. All rights reserved.
+ * Copyright (c) 2022, Qualcomm Innovation Center, Inc. All rights reserved.
+ */
+
+#ifndef __SMBLITE_CHARGER_REG_H
+#define __SMBLITE_CHARGER_REG_H
+
+#include <linux/bitops.h>
+
+#define PERPH_TYPE_OFFSET	0x04
+#define TYPE_MASK		GENMASK(7, 0)
+#define PERPH_SUBTYPE_OFFSET	0x05
+#define SUBTYPE_MASK		GENMASK(7, 0)
+#define INT_RT_STS_OFFSET	0x10
+#define REVID_REVISION4		0x103
+
+/********************************
+ *  CHGR Peripheral Registers  *
+ ********************************/
+#define BATTERY_CHARGER_STATUS_1_REG(base)		(base.chg_base + 0x06)
+#define BATTERY_CHARGER_STATUS_MASK		GENMASK(2, 0)
+enum {
+	INHIBIT_CHARGE = 0,
+	TRICKLE_CHARGE,
+	PRE_CHARGE,
+	FULLON_CHARGE,
+	TAPER_CHARGE,
+	TERMINATE_CHARGE,
+	PAUSE_CHARGE,
+	DISABLE_CHARGE,
+};
+
+#define CHGR_CHG_EN_STATUS_REG(base)		(base.chg_base + 0x07)
+#define CHARGING_DISABLED_FROM_BOOST_BIT	BIT(6)
+
+#define CHARGER_VBAT_STATUS_REG(base)			(base.chg_base + 0x08)
+#define BAT_OV_BIT				BIT(7)
+
+#define BATTERY_TEMP_STATUS_REG(base)			(base.batif_base + 0x0C)
+#define BAT_TEMP_STATUS_TOO_HOT_AFP_BIT		BIT(5)
+#define BAT_TEMP_STATUS_TOO_HOT_BIT		BIT(4)
+#define BAT_TEMP_STATUS_HOT_SOFT_BIT		BIT(3)
+#define BAT_TEMP_STATUS_COLD_SOFT_BIT		BIT(2)
+#define BAT_TEMP_STATUS_TOO_COLD_BIT		BIT(1)
+#define BAT_TEMP_STATUS_TOO_COLD_AFP_BIT	BIT(0)
+
+#define CHARGING_ENABLE_CMD_REG(base)			(base.chg_base + 0x46)
+#define CHARGING_ENABLE_CMD_BIT			BIT(0)
+#define CHARGING_PAUSE_CMD_BIT			BIT(4)
+
+#define CHGR_FAST_CHARGE_CURRENT_CFG_REG(base)	(base.chg_base + 0x54)
+#define CHGR_FLOAT_VOLTAGE_CFG_REG(base)		(base.chg_base + 0x58)
+
+#define CHGR_TERM_CFG_REG(base)			(base.chg_base + 0x60)
+#define CHGR_ITERM_USE_ANALOG_BIT		BIT(3)
+
+#define CHGR_ADC_ITERM_UP_THD_MSB_REG(base)		(base.chg_base + 0x64)
+#define CHGR_ADC_ITERM_UP_THD_LSB_REG(base)		(base.chg_base + 0x65)
+#define CHGR_ADC_ITERM_LO_THD_MSB_REG(base)		(base.chg_base + 0x66)
+#define CHGR_ADC_ITERM_LO_THD_LSB_REG(base)		(base.chg_base + 0x67)
+
+#define CHGR_RECHG_CFG_REG(base)			(base.chg_base + 0x70)
+#define RECHG_MASK				GENMASK(7, 6)
+#define VBAT_BASED_RECHG_BIT			BIT(7)
+#define SOC_BASED_RECHG_BIT			GENMASK(7, 6)
+#define NO_OF_SAMPLE_FOR_RCHG			GENMASK(1, 0)
+
+#define CHGR_ADC_RECHARGE_THRESHOLD_MSB_REG(base)	(base.chg_base + 0x72)
+
+#define CHARGE_RCHG_SOC_THRESHOLD_CFG_REG(base)	(base.chg_base + 0x74)
+
+#define CHGR_INHIBIT_REG(base)			(base.chg_base + 0x78)
+#define CHGR_INHIBIT_BIT			BIT(7)
+
+#define CHGR_INHIBIT_THRESHOLD_CFG_REG(base)		(base.chg_base + 0x7A)
+
+#define CHGR_QG_SOC_REG(base)			(base.chg_base + 0x84)
+
+#define CHGR_QG_SOC_UPDATE_REG(base)		(base.chg_base + 0x85)
+#define SOC_UPDATE_PCT_BIT			BIT(0)
+
+#define CHGR_FAST_CHARGE_SAFETY_TIMER_CFG_REG(base)	(base.chg_base + 0x90)
+#define FAST_CHARGE_SAFETY_TIMER_EN_BIT		BIT(3)
+#define FAST_CHARGE_SAFETY_TIMER_MASK		GENMASK(1, 0)
+#define FAST_CHARGE_SAFETY_TIMER_192_MIN	0x0
+#define FAST_CHARGE_SAFETY_TIMER_384_MIN	0x1
+#define FAST_CHARGE_SAFETY_TIMER_768_MIN	0x2
+#define FAST_CHARGE_SAFETY_TIMER_1536_MIN	0x3
+
+/********************************
+ *  DCDC Peripheral Registers  *
+ ********************************/
+#define ICL_MAX_STATUS_REG(base)			(base.dcdc_base + 0x06)
+#define ICL_STATUS_REG(base)				(base.dcdc_base + 0x09)
+
+#define POWER_PATH_STATUS_REG(base)			(base.dcdc_base + 0x0B)
+#define VALID_INPUT_POWER_SOURCE_STS_BIT	BIT(7)
+#define USE_USBIN_BIT				BIT(5)
+#define USBIN_SUSPEND_STS_BIT			BIT(3)
+#define POWER_PATH_MASK				GENMASK(1, 0)
+
+#define DCDC_CMD_OTG_REG(base)			(base.dcdc_base + 0x50)
+#define OTG_EN_BIT				BIT(0)
+
+#define DCDC_BST_VREG_SEL(base)			(base.dcdc_base + 0x52)
+#define VBOOST_MASK				GENMASK(1, 0)
+
+#define DCDC_OTG_CFG_REG(base)			(base.dcdc_base + 0x56)
+#define OTG_EN_SRC_CFG_BIT			BIT(0)
+
+#define DCDC_LDO_CFG_REG(base)			(base.dcdc_base + 0x70)
+#define LDO_MODE_BIT				BIT(0)
+
+#define CONCURRENT_MODE_CFG_REG(base)			(base.dcdc_base + 0x50)
+#define CONCURRENT_MODE_EN_BIT			BIT(0)
+
+/********************************
+ *  BATIF Peripheral Registers  *
+ ********************************/
+/* BATIF Interrupt Bits	 */
+#define BSM_ACTIVE_RT_STS_BIT			BIT(4)
+#define BAT_OV_RT_STS_BIT			BIT(3)
+#define BAT_LOW_RT_STS_BIT			BIT(2)
+#define BAT_THERM_OR_ID_MISSING_RT_STS_BIT      BIT(1)
+#define BAT_TEMP_RT_STS_BIT			BIT(0)
+
+#define SHIP_MODE_REG(base)				(base.batif_base + 0x52)
+#define SHIP_MODE_EN_BIT			BIT(0)
+
+#define CHGR_JEITA_HOT_THRESHOLD_REG(base)		(base.batif_base + 0x84)
+#define CHGR_JEITA_WARM_THRESHOLD_REG(base)		(base.batif_base + 0x86)
+#define CHGR_JEITA_COOL_THRESHOLD_REG(base)		(base.batif_base + 0x88)
+#define CHGR_JEITA_COLD_THRESHOLD_REG(base)		(base.batif_base + 0x8A)
+
+#define BATIF_PULLDOWN_VPH_CONTROL(base)		(base.batif_base + 0x55)
+#define PULLDOWN_VPH_SW_EN_BIT			BIT(1)
+#define PULLDOWN_VPH_HW_EN_BIT			BIT(0)
+#define BATIF_PULLDOWN_VPH_SEL_MASK		GENMASK(1, 0)
+
+/********************************
+ *  USBIN Peripheral Registers  *
+ ********************************/
+/* USBIN Interrupt Bits */
+#define USBIN_SOURCE_CHANGE_RT_STS_BIT		BIT(7)
+#define USBIN_ICL_CHANGE_RT_STS_BIT		BIT(6)
+#define USBIN_GT_VT_RT_STS_BIT			BIT(4)
+#define USBIN_OV_RT_STS_BIT			BIT(3)
+#define USBIN_UV_RT_STS_BIT			BIT(2)
+#define USBIN_COLLAPSE_RT_STS_BIT		BIT(1)
+#define USBIN_PLUGIN_RT_STS_BIT			BIT(0)
+
+#define USBIN_QC23_EN_REG(base)			(base.usbin_base + 0x48)
+#define HVDCP_EN_BIT				BIT(2)
+#define HVDCP_NO_AUTH_QC3_CFG_BIT		BIT(0)
+
+#define USBIN_ICL_OPTIONS_REG(base)			(base.usbin_base + 0x50)
+#define USBIN_MODE_CHG_BIT			BIT(2)
+#define USB51_MODE_BIT				BIT(1)
+#define CFG_USB3P0_SEL_BIT			BIT(0)
+
+#define CMD_ICL_OVERRIDE_REG(base)			(base.usbin_base + 0x51)
+#define ICL_OVERRIDE_BIT			BIT(0)
+
+#define USBIN_CURRENT_LIMIT_CFG_REG(base)		(base.usbin_base + 0x52)
+
+#define USBIN_INPUT_SUSPEND_REG(base)			(base.usbin_base + 0x54)
+#define SUSPEND_ON_COLLAPSE_USBIN_BIT		BIT(7)
+#define USBIN_SUSPEND_BIT			BIT(0)
+
+#define USBIN_AICL_OPTIONS_CFG_REG(base)		(base.usbin_base + 0x60)
+#define USBIN_AICL_EN_BIT			BIT(7)
+#define USBIN_AICL_START_AT_MAX			BIT(4)
+#define USBIN_AICL_STEP_TIMING_SEL_MASK		GENMASK(3, 2)
+#define USBIN_IN_COLLAPSE_GF_SEL_MASK		GENMASK(1, 0)
+
+#define USBIN_LV_AICL_THRESHOLD_REG(base)		(base.usbin_base + 0x63)
+
+#define USB_CMD_PULLDOWN_REG(base)			(base.usbin_base + 0x70)
+#define EN_PULLDOWN_USB_IN_BIT			BIT(0)
+
+#define APSD_STATUS_REG(base)				(base.usbin_base + 0x0a)
+#define HVDCP_CHECK_TIMEOUT_BIT			BIT(6)
+#define SLOW_PLUGIN_TIMEOUT_BIT			BIT(5)
+#define ENUMERATION_DONE_BIT			BIT(4)
+#define VADP_CHANGE_DONE_AFTER_AUTH_BIT		BIT(3)
+#define QC_AUTH_DONE_STATUS_BIT			BIT(2)
+#define QC_CHARGER_BIT				BIT(1)
+#define APSD_DTC_STATUS_DONE_BIT		BIT(0)
+
+#define APSD_RESULT_STATUS_REG(base)		(base.usbin_base + 0x0b)
+#define APSD_RESULT_STATUS_MASK			GENMASK(6, 0)
+#define QC_3P0_BIT				BIT(6)
+#define FLOAT_CHARGER_BIT			BIT(4)
+#define DCP_CHARGER_BIT				BIT(3)
+#define CDP_CHARGER_BIT				BIT(2)
+#define OCP_CHARGER_BIT				BIT(1)
+#define SDP_CHARGER_BIT				BIT(0)
+
+#define CMD_APSD_REG(base)			(base.usbin_base + 0x45)
+#define APSD_RERUN_BIT				BIT(0)
+
+#define USBIN_APSD_EN_REG(base)			(base.usbin_base + 0x44)
+#define BC1P2_SRC_DETECT_BIT			BIT(7)
+
+#define CMD_HVDCP_REG(base)			(base.usbin_base + 0x4a)
+#define SINGLE_INCREMENT_BIT			BIT(5)
+#define SINGLE_DECREMENT_BIT			BIT(4)
+#define FORCE_5V_BIT				BIT(1)
+#define IDLE_BIT				BIT(0)
+
+#define USB_APSD_CFG_REG(base)			(base.usbin_base + 0x46)
+#define FLOAT_OPTIONS_MASK			GENMASK(2, 0)
+#define FLOAT_DIS_CHGING_CFG_BIT		BIT(2)
+#define SUSPEND_FLOAT_CFG_BIT			BIT(1)
+#define FORCE_FLOAT_SDP_CFG_BIT			BIT(0)
+
+/********************************
+ *  TYPEC Peripheral Registers  *
+ ********************************/
+#define TYPE_C_SNK_STATUS_REG(base)			(base.typec_base + 0x06)
+#define DETECTED_SRC_TYPE_MASK			GENMASK(6, 0)
+#define SNK_DAM_500MA_BIT			BIT(6)
+#define SNK_DAM_1500MA_BIT			BIT(5)
+#define SNK_DAM_3000MA_BIT			BIT(4)
+#define SNK_RP_STD_BIT				BIT(3)
+#define SNK_RP_1P5_BIT				BIT(2)
+#define SNK_RP_3P0_BIT				BIT(1)
+#define SNK_RP_SHORT_BIT			BIT(0)
+
+#define TYPE_C_SRC_STATUS_REG(base)			(base.typec_base + 0x08)
+#define DETECTED_SNK_TYPE_MASK			GENMASK(4, 0)
+#define SRC_HIGH_BATT_BIT			BIT(5)
+#define SRC_DEBUG_ACCESS_BIT			BIT(4)
+#define SRC_RD_OPEN_BIT				BIT(3)
+#define SRC_RA_OPEN_BIT				BIT(1)
+#define AUDIO_ACCESS_RA_RA_BIT			BIT(0)
+
+#define TYPE_C_STATE_MACHINE_STATUS_REG(base)		(base.typec_base + 0x09)
+#define TYPEC_ATTACH_DETACH_STATE_BIT		BIT(5)
+
+#define TYPE_C_MISC_STATUS_REG(base)			(base.typec_base + 0x0B)
+#define SNK_SRC_MODE_BIT			BIT(6)
+#define TYPEC_VBUS_ERROR_STATUS_BIT		BIT(4)
+#define TYPEC_TCCDEBOUNCE_DONE_STATUS_BIT	BIT(3)
+#define CC_ORIENTATION_BIT			BIT(1)
+#define CC_ATTACHED_BIT				BIT(0)
+
+#define LEGACY_CABLE_STATUS_REG(base)			(base.typec_base + 0x0D)
+#define TYPEC_LEGACY_CABLE_STATUS_BIT		BIT(1)
+#define TYPEC_NONCOMP_LEGACY_CABLE_STATUS_BIT	BIT(0)
+
+#define TYPEC_U_USB_STATUS_REG(base)			(base.typec_base + 0x0F)
+#define U_USB_GROUND_NOVBUS_BIT			BIT(6)
+#define U_USB_GROUND_BIT			BIT(4)
+#define U_USB_FLOAT1_BIT			BIT(2)
+#define U_USB_FLOAT2_BIT			BIT(0)
+
+#define TYPE_C_MODE_CFG_REG(base)			(base.typec_base + 0x44)
+#define TYPEC_TRY_MODE_MASK			GENMASK(4, 3)
+#define EN_TRY_SNK_BIT				BIT(4)
+#define EN_TRY_SRC_BIT				BIT(3)
+#define TYPEC_POWER_ROLE_CMD_MASK		GENMASK(2, 0)
+#define EN_SRC_ONLY_BIT				BIT(2)
+#define EN_SNK_ONLY_BIT				BIT(1)
+#define TYPEC_DISABLE_CMD_BIT			BIT(0)
+
+#define DEBUG_ACCESS_SRC_CFG_REG(base)		(base.typec_base + 0x4C)
+#define EN_UNORIENTED_DEBUG_ACCESS_SRC_BIT	BIT(0)
+
+#define TYPE_C_EXIT_STATE_CFG_REG(base)		(base.typec_base + 0x50)
+#define BYPASS_VSAFE0V_DURING_ROLE_SWAP_BIT	BIT(3)
+#define SEL_SRC_UPPER_REF_BIT			BIT(2)
+#define EXIT_SNK_BASED_ON_CC_BIT		BIT(0)
+
+#define TYPE_C_CURRSRC_CFG_REG(base)			(base.typec_base + 0x52)
+#define TYPEC_SRC_RP_SEL_MASK			GENMASK(1, 0)
+enum {
+	TYPEC_SRC_RP_STD,
+	TYPEC_SRC_RP_1P5A,
+	TYPEC_SRC_RP_3A,
+	TYPEC_SRC_RP_3A_DUPLICATE,
+	TYPEC_SRC_RP_MAX_ELEMENTS
+};
+
+#define TYPE_C_INTERRUPT_EN_CFG_1_REG(base)		(base.typec_base + 0x5E)
+#define TYPEC_LEGACY_CABLE_INT_EN_BIT			BIT(7)
+#define TYPEC_NONCOMPLIANT_LEGACY_CABLE_INT_EN_BIT	BIT(6)
+#define TYPEC_TRYSOURCE_DETECT_INT_EN_BIT		BIT(5)
+#define TYPEC_TRYSINK_DETECT_INT_EN_BIT			BIT(4)
+#define TYPEC_CCOUT_DETACH_INT_EN_BIT			BIT(3)
+#define TYPEC_CCOUT_ATTACH_INT_EN_BIT			BIT(2)
+#define TYPEC_VBUS_DEASSERT_INT_EN_BIT			BIT(1)
+#define TYPEC_VBUS_ASSERT_INT_EN_BIT			BIT(0)
+
+#define TYPE_C_INTERRUPT_EN_CFG_2_REG(base)		(base.typec_base + 0x60)
+#define TYPEC_SRC_BATT_HPWR_INT_EN_BIT		BIT(6)
+#define MICRO_USB_STATE_CHANGE_INT_EN_BIT	BIT(5)
+#define TYPEC_STATE_MACHINE_CHANGE_INT_EN_BIT	BIT(4)
+#define TYPEC_DEBUG_ACCESS_DETECT_INT_EN_BIT	BIT(3)
+#define TYPEC_WATER_DETECTION_INT_EN_BIT	BIT(2)
+#define TYPEC_VBUS_ERROR_INT_EN_BIT		BIT(1)
+#define TYPEC_DEBOUNCE_DONE_INT_EN_BIT		BIT(0)
+
+#define TYPEC_U_USB_CFG_REG(base)			(base.typec_base + 0x70)
+#define EN_MICRO_USB_MODE_BIT			BIT(0)
+
+/********************************
+ *  MISC Peripheral Registers  *
+ ********************************/
+#define TEMP_RANGE_STATUS_REG(base)			(base.misc_base + 0x08)
+#define THERM_REG_ACTIVE_BIT			BIT(6)
+#define TLIM_BIT				BIT(5)
+#define TEMP_RANGE_MASK				GENMASK(4, 1)
+#define ALERT_LEVEL_BIT				BIT(4)
+#define TEMP_ABOVE_RANGE_BIT			BIT(3)
+#define TEMP_WITHIN_RANGE_BIT			BIT(2)
+#define TEMP_BELOW_RANGE_BIT			BIT(1)
+#define THERMREG_DISABLED_BIT			BIT(0)
+
+#define DIE_TEMP_STATUS_REG(base)			(base.misc_base + 0x09)
+#define DIE_TEMP_MASK				GENMASK(3, 0)
+#define DIE_TEMP_SHDN_BIT			BIT(3)
+#define DIE_TEMP_RST_BIT			BIT(2)
+#define DIE_TEMP_UB_BIT				BIT(1)
+#define DIE_TEMP_LB_BIT				BIT(0)
+
+#define AICL_STATUS_REG(base)				(base.misc_base + 0x06)
+#define SOFT_ILIMIT_BIT				BIT(6)
+#define AICL_DONE_BIT				BIT(0)
+
+#define AICL_CMD_REG(base)				(base.misc_base + 0x50)
+#define RESTART_AICL_BIT			BIT(1)
+#define RERUN_AICL_BIT				BIT(0)
+
+#define MISC_SMB_EN_CMD_REG(base)			(base.misc_base + 0x4C)
+#define SMB_EN_OVERRIDE_VALUE_BIT		BIT(0)
+#define SMB_EN_OVERRIDE_BIT			BIT(1)
+
+#define MISC_AICL_RERUN_CFG_REG(base)			(base.misc_base + 0x54)
+#define USBIN_AICL_PERIODIC_RERUN_EN_BIT	BIT(5)
+#define USBIN_AICL_RERUN_TIME_MASK		GENMASK(1, 0)
+#define AICL_RERUN_TIME_12S_VAL			0x01
+
+#define WD_CFG_REG(base)				(base.misc_base + 0x58)
+#define BITE_WDOG_DISABLE_CHARGING_CFG_BIT	BIT(7)
+#define BARK_WDOG_INT_EN_BIT			BIT(4)
+#define WDOG_TIMER_EN_ON_PLUGIN_BIT		BIT(1)
+#define WDOG_TIMER_EN_BIT			BIT(0)
+
+#define SNARL_BARK_BITE_WD_CFG_REG(base)		(base.misc_base + 0x59)
+#define SNARL_WDOG_TIMEOUT_MASK                 GENMASK(2, 0)
+#define SNARL_WDOG_TMOUT_62P5MS			0x0
+#define SNARL_WDOG_TMOUT_1S			0x4
+#define SNARL_WDOG_TMOUT_8S			0x7
+#define BARK_WDOG_TIMEOUT_MASK			GENMASK(5, 4)
+#define BARK_WDOG_TIMEOUT_SHIFT			4
+#define BITE_WDOG_TIMEOUT_MASK			GENMASK(7, 6)
+#define BITE_WDOG_TIMEOUT_8S			0x3
+#define BITE_WDOG_TIMEOUT_SHIFT			6
+#define MIN_WD_BARK_TIME			16
+
+#define BARK_BITE_WDOG_PET_REG(base)			(base.misc_base + 0x5A)
+#define BARK_BITE_WDOG_PET_BIT			BIT(0)
+
+/********************************
+ *  BOOST Peripheral Registers  *
+ ********************************/
+#define BOOST_BST_STATUS_REG(base)			(base.boost_base + 0x0D)
+#define BOOST_SOFTSTART_DONE_BIT			BIT(3)
+
+#define BOOST_BST_EN_REG(base)				(base.boost_base + 0x46)
+#define DCIN_BST_EN_BIT					BIT(1)
+
+#endif /* __SMBLITE_CHARGER_REG_H */
diff --git a/drivers/soc/qcom/smblite-remote-bms.h b/drivers/soc/qcom/smblite-remote-bms.h
new file mode 100644
index 000000000000..84a6f959ff55
--- /dev/null
+++ b/drivers/soc/qcom/smblite-remote-bms.h
@@ -0,0 +1,113 @@
+/* SPDX-License-Identifier: GPL-2.0-only */
+/*
+ * Copyright (c) 2021 The Linux Foundation. All rights reserved.
+ * Copyright (c) 2022, Qualcomm Innovation Center, Inc. All rights reserved.
+ */
+#ifndef __SMBLITE_REMOTE_BMS_H
+#define __SMBLITE_REMOTE_BMS_H
+
+#define is_between(left, right, value) \
+		(((left) >= (right) && (left) >= (value) \
+			&& (value) >= (right)) \
+		|| ((left) <= (right) && (left) <= (value) \
+			&& (value) <= (right)))
+
+#define SEB_MAX_RX_PARAMS		25
+#define SEB_BUF_HEADER_SIZE		2
+#define SEB_EACH_OPCODE_SIZE		1
+#define SEB_EACH_DATA_SIZE		4
+#define SEB_EACH_PARAM_SIZE		(SEB_EACH_OPCODE_SIZE + SEB_EACH_DATA_SIZE)
+/* Allocate more memory to parse extra patameters from remote-fg */
+#define SEB_RX_BUF_SIZE			\
+		(SEB_BUF_HEADER_SIZE + (SEB_MAX_RX_PARAMS * SEB_EACH_PARAM_SIZE))
+#define BMS_WRITE			1
+#define BMS_READ			0
+
+#define BMS_READ_INTERVAL_MS		30000
+
+#define REMOTE_FG_VOTER			"REMOTE_FG_VOTER"
+#define REMOTE_FG_DEBUG_BATT_SOC	67
+#define REMOTE_FG_FAKE_BATT_SOC		50
+
+enum bms_src {
+	BMS_SDAM = 1,
+	BMS_GLINK,
+};
+
+enum bms_tx_param {
+	CHARGE_STATUS = 0,
+	CHARGE_TYPE,
+	CHARGER_PRESENT,
+	TX_MAX,
+	REQUEST_DATA = TX_MAX,
+};
+
+enum bms_rx_param {
+	CAPACITY = 0,
+	CURRENT_NOW,
+	VOLTAGE_OCV,
+	CYCLE_COUNT,
+	CHARGE_COUNTER,
+	CHARGE_FULL,
+	CHARGE_FULL_DESIGN,
+	TIME_TO_FULL,
+	TIME_TO_EMPTY,
+	SOH,
+	RECHARGE_TRIGGER,
+	RECHARGE_FV,
+	RECHARGE_ITERM,
+	REQUEST_CHG_DATA,
+	RX_MAX,
+};
+
+struct bms_params {
+	enum bms_rx_param offset;
+	int sdam_offset;
+	unsigned int data;
+};
+
+struct smblite_remote_bms {
+	struct device			*dev;
+	struct mutex			data_lock;
+	struct mutex			tx_lock;
+	struct mutex			rx_lock;
+	struct delayed_work		periodic_fg_work;
+	struct work_struct		psy_status_change_work;
+	struct work_struct		rx_data_work;
+	int				read_interval_ms;
+	struct power_supply		*batt_psy;
+	struct power_supply		*usb_psy;
+	struct nvmem_device		*nvmem;
+	struct bms_params		rx_params[RX_MAX];
+	struct seb_notif_info		*seb_handle;
+	struct notifier_block		seb_nb;
+	struct notifier_block		psy_nb;
+	struct iio_channel		*batt_id_chan;
+	struct iio_channel		*batt_temp_chan;
+	struct iio_channel		*batt_volt_chan;
+	struct device_node		*batt_node;
+	struct votable			*awake_votable;
+	const char			*batt_profile_name;
+	char				rx_buf[SEB_RX_BUF_SIZE];
+	int				batt_id_ohm;
+	int				float_volt_uv;
+	int				fastchg_curr_ma;
+	int				default_iterm_ma;
+	int				force_recharge;
+	int				recharge_float_voltage;
+	int				recharge_iterm;
+	int				charge_status;
+	int				charge_type;
+	int				charger_present;
+	bool				is_seb_up;
+	bool				received_first_data;
+	int (*iio_read)(struct device *dev, int iio_chan, int *val);
+	int (*iio_write)(struct device *dev, int iio_chan, int val);
+};
+
+int remote_bms_init(struct smblite_remote_bms *bms);
+int remote_bms_deinit(void);
+int remote_bms_get_prop(int channel, int *val, int src);
+int remote_bms_suspend(void);
+int remote_bms_resume(void);
+#endif /* __SMBLITE_REMOTE_BMS_H */
diff --git a/drivers/soc/qcom/sps/bam.c b/drivers/soc/qcom/sps/bam.c
index 3c2b84587ff3..e468b89a1097 100644
--- a/drivers/soc/qcom/sps/bam.c
+++ b/drivers/soc/qcom/sps/bam.c
@@ -21,6 +21,8 @@
 #define BAM_MIN_VERSION 2
 #define BAM_MAX_VERSION 0x2f
 
+#define P_HALT_P_LAST_DESC_ZLT                     0x4
+#define P_HALT_P_PIPE_EMPTY			   0x8
 #ifdef CONFIG_SPS_SUPPORT_NDP_BAM
 
 /* Maximum number of execution environment */
@@ -169,7 +171,6 @@
 #define P_RST_P_SW_RST                             0x1
 
 /* P_HALTn */
-#define P_HALT_P_PIPE_EMPTY			   0x8
 #define P_HALT_P_LAST_DESC_ZLT                     0x4
 #define P_HALT_P_PROD_HALTED                       0x2
 #define P_HALT_P_HALT                              0x1
@@ -1686,12 +1687,11 @@ void bam_pipe_halt(void *base, u32 pipe, bool halt)
 /* output the content of BAM-level registers */
 void print_bam_reg(void *virt_addr)
 {
-	int i, n, index = 0;
+  int i, n;
 	u32 *bam = (u32 *) virt_addr;
 	u32 ctrl;
 	u32 ver;
 	u32 pipes;
-	u32 offset = 0;
 
 	if (bam == NULL)
 		return;
@@ -1759,7 +1759,6 @@ void print_bam_pipe_reg(void *virt_addr, u32 pipe_index)
 	int i;
 	u32 *bam = (u32 *) virt_addr;
 	u32 pipe = pipe_index;
-	u32 offset = 0;
 
 	if (bam == NULL)
 		return;
diff --git a/drivers/soc/qcom/step-chg-jeita.h b/drivers/soc/qcom/step-chg-jeita.h
new file mode 100644
index 000000000000..0b9b61ee20f2
--- /dev/null
+++ b/drivers/soc/qcom/step-chg-jeita.h
@@ -0,0 +1,33 @@
+/* SPDX-License-Identifier: GPL-2.0-only */
+/*
+ * Copyright (c) 2017-2020 The Linux Foundation. All rights reserved.
+ * Copyright (c) 2022, Qualcomm Innovation Center, Inc. All rights reserved.
+ */
+
+#ifndef __STEP_CHG_H__
+#define __STEP_CHG_H__
+
+#include <linux/iio/consumer.h>
+#include "smb5-iio.h"
+
+#define MAX_STEP_CHG_ENTRIES	8
+
+struct step_chg_jeita_param {
+	u32			psy_prop;
+	u32			iio_prop;
+	char			*prop_name;
+	int			rise_hys;
+	int			fall_hys;
+	bool			use_bms;
+};
+
+struct range_data {
+	int low_threshold;
+	int high_threshold;
+	u32 value;
+};
+
+int qcom_step_chg_init(struct device *dev, bool step_chg_enable,
+	bool sw_jeita_enable, bool jeita_arb_en, struct iio_channel *iio_chans);
+void qcom_step_chg_deinit(void);
+#endif /* __STEP_CHG_H__ */
diff --git a/drivers/soc/qcom/storm-watch.h b/drivers/soc/qcom/storm-watch.h
new file mode 100644
index 000000000000..a7b1318f6074
--- /dev/null
+++ b/drivers/soc/qcom/storm-watch.h
@@ -0,0 +1,35 @@
+/* SPDX-License-Identifier: GPL-2.0-only */
+/*
+ * Copyright (c) 2016-2017, 2020 The Linux Foundation. All rights reserved.
+ * Copyright (c) 2022, Qualcomm Innovation Center, Inc. All rights reserved.
+ */
+
+#ifndef __STORM_WATCH_H
+#define __STORM_WATCH_H
+#include <linux/ktime.h>
+#include <linux/mutex.h>
+
+/**
+ * Data used to track an event storm.
+ *
+ * @storm_period_ms: The maximum time interval between two events. If this limit
+ *                   is exceeded then the event chain will be broken and removed
+ *                   from consideration for a storm.
+ * @max_storm_count: The number of chained events required to trigger a storm.
+ * @storm_count:     The current number of chained events.
+ * @last_kt:         Kernel time of the last event seen.
+ * @storm_lock:      Mutex lock to protect storm_watch data.
+ */
+struct storm_watch {
+	bool		enabled;
+	int		storm_period_ms;
+	int		max_storm_count;
+	int		storm_count;
+	ktime_t		last_kt;
+	struct mutex	storm_lock;
+};
+
+bool is_storming(struct storm_watch *data);
+void reset_storm_count(struct storm_watch *data);
+void update_storm_count(struct storm_watch *data, int max_count);
+#endif
diff --git a/drivers/soc/qcom/sw5100_bms.c b/drivers/soc/qcom/sw5100_bms.c
new file mode 100644
index 000000000000..1470cc855a71
--- /dev/null
+++ b/drivers/soc/qcom/sw5100_bms.c
@@ -0,0 +1,1451 @@
+/*
+ * Copyright 2022 Google, Inc
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#define BMS_DEV_NAME	"sw5100_bms"
+#define pr_fmt(fmt) BMS_DEV_NAME": " fmt
+
+#include <linux/of.h>
+#include <linux/of_platform.h>
+//#include <linux/of_batterydata.h>
+#include <linux/of_irq.h>
+#include <linux/interrupt.h>
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <linux/power_supply.h>
+#include <linux/pmic-voter.h>
+#include <linux/regmap.h>
+#include <linux/bitops.h>
+#include <linux/iio/consumer.h>
+#include <linux/regulator/consumer.h>
+#include "google_bms.h"
+/* hackaroo... */
+#include "battery-profile-loader.h"
+#include "smblite-reg.h"
+#include "smblite-lib.h"
+#include "smb5-iio.h"
+
+#define CAPACITY_OFFSET 5
+#define BIAS_STS_READY	BIT(0)
+
+#define CHARGE_DISABLE_VOTER	"charge_disable"
+#define USBIN_DISABLE_VOTER	"USBIN_DISABLE"
+
+struct bms_dev {
+	struct	device			*dev;
+	struct	power_supply		*psy;
+	struct	regmap			*pmic_regmap;
+	struct	votable			*fv_votable;
+	struct	votable			*fcc_votable;
+	struct	votable			*dc_suspend_votable;
+	struct	votable			*icl_votable;
+	struct	notifier_block		nb;
+	int				batt_id_ohms;
+	u32				rradc_base;
+	int				chg_term_voltage;
+	int				chg_term_voltage_debounce;
+	/* Amount of SOC percentage points to offset to 0% UI SOC. */
+	int				soc_shutdown_offset;
+	struct iio_channel		*batt_therm_chan;
+	struct iio_channel		*batt_id_chan;
+	struct iio_channel		**iio_chan_list_qg;
+
+};
+
+struct bias_config {
+	u16	status_reg;
+	u16	lsb_reg;
+	int	bias_kohms;
+};
+
+//CHARGER_STATUS_1
+#define CHGR_BATTERY_CHARGER_STATUS_REG		0x2606
+#define CHG_ERR_STATUS_SFT_EXPIRE		BIT(5)
+#define CHG_ERR_STATUS_BAT_OV			BIT(4)
+
+//CHARGER_STATUS_2
+#define CHGR_BATTERY_CHARGER_EN_STATUS_REG	0x2607
+#define ENABLE_TRICKLE_BIT			BIT(1)
+#define ENABLE_PRE_CHARGING_BIT			BIT(2)
+#define ENABLE_FULLON_MODE_BIT			BIT(3)
+
+//CHARGER_STATUS_7
+#define BATIF_BAT_TEMP_STATUS_REG		0x280D
+#define BAT_TEMP_WARM				BIT(3)
+#define BAT_TEMP_COOL				BIT(2)
+#define BAT_TEMP_TOO_HOT			BIT(4)
+#define BAT_TEMP_TOO_COLD			BIT(1)
+
+#define CHGR_FLOAT_VOLTAGE_NOW			0x260B
+#define CHGR_CHG_EN				0x2646
+#define CHARGING_ENABLE_CMD_BIT			BIT(0)
+
+#define CHGR_CHARGING_PAUSE_CMD			0x2646
+#define CHARGING_PAUSE_CMD_BIT			BIT(4)
+
+#define CHGR_FAST_CHARGE_CURRENT_SETTING	0x2654
+#define CHGR_ADC_ITERM_UP_THD_MSB		0x2664
+#define CHGR_FLOAT_VOLTAGE_SETTING		0x2658
+#define CHGR_CHG_TERM_CFG_REG			0x2660
+#define CHGR_ITERM_USE_ANALOG_BIT		BIT(3)
+
+#define DCDC_ICL_STATUS_REG			0x2709
+#define DCDC_AICL_ICL_STATUS_REG		0x2707
+#define DCDC_AICL_STATUS_REG			0x2C06
+#define DCDC_SOFT_ILIMIT_BIT			BIT(6)
+
+#define DCDC_POWER_PATH_STATUS_REG		0x270B
+#define USE_USBIN_BIT				BIT(5)
+#define USE_DCIN_BIT				BIT(4)
+#define VALID_INPUT_POWER_SOURCE_STS_BIT	BIT(7)
+
+#define MISC_AICL_CMD_REG			0x2C50
+
+#define BATIF_INT_RT_STS			0x2810
+#define BATIF_THERM_OR_ID_MISSING_RT_STS_BIT	BIT(1)
+
+#define CHGR_BATTERY_CHARGER_STATUS_MASK	GENMASK(2, 0)
+
+#define CHGR_USB_SUSPEND			0x2954
+#define USBIN_SUSPEND BIT(0)
+
+#define CHGR_FLOAT_VOLTAGE_BASE			3600000
+#define CHGR_CHARGE_CURRENT_STEP		25000
+
+#define CHG_TERM_VOLTAGE			4350
+#define CHG_TERM_VOLT_DEBOUNCE			200
+
+#define PM5100_ADC_CHG_ITERM_MULT		16384
+
+/* sync from google_battery.c */
+#define DEFAULT_BATT_DRV_RL_SOC_THRESHOLD	97
+
+enum sw5100_chg_status {
+	SW5100_INHIBIT_CHARGE		= 0,
+	SW5100_TRICKLE_CHARGE		= 1,
+	SW5100_PRE_CHARGE		= 2,
+	SW5100_FULLON_CHARGE		= 3,
+	SW5100_TAPER_CHARGE		= 4,
+	SW5100_TERMINATE_CHARGE	= 5,
+	SW5100_PAUSE_CHARGE		= 6,
+	SW5100_DISABLE_CHARGE		= 7,
+};
+
+static int sw5100_read(struct regmap *pmic_regmap, int addr, u8 *val, int len)
+{
+	int rc;
+
+	rc = regmap_bulk_read(pmic_regmap, addr, val, len);
+	if (rc < 0) {
+		pr_err("Failed regmap_read for address %04x rc=%d\n", addr, rc);
+		return rc;
+	}
+
+	return 0;
+}
+
+static int sw5100_write(struct regmap *pmic_regmap, int addr, u8 *val, int len)
+{
+	int rc;
+
+	rc = regmap_bulk_write(pmic_regmap, addr, val, len);
+
+	if (rc < 0) {
+		pr_err("Failed regmap_write for address %04x rc=%d\n",
+				addr, rc);
+		return rc;
+	}
+
+	return 0;
+}
+
+static int sw5100_masked_write(struct regmap *pmic_regmap,
+			       u16 addr, u8 mask, u8 val)
+{
+	return regmap_update_bits(pmic_regmap, addr, mask, val);
+}
+
+static int sw5100_rd8(struct regmap *pmic_regmap, int addr, u8 *val)
+{
+	return sw5100_read(pmic_regmap, addr, val, 1);
+}
+
+/* ------------------------------------------------------------------------- */
+
+enum sw5100_qbg_iio_channels {
+	SW5100_QBG_DEBUG_BATTERY,
+	SW5100_QBG_CAPACITY,
+	SW5100_QBG_REAL_CAPACITY,
+	SW5100_QBG_CURRENT_NOW,
+	SW5100_QBG_VOLTAGE_NOW,
+	SW5100_QBG_VOLTAGE_MAX,
+	SW5100_QBG_CHARGE_FULL,
+	SW5100_QBG_RESISTANCE_ID,
+	SW5100_QBG_TEMP,
+	SW5100_QBG_CHARGE_COUNTER,
+	SW5100_QBG_CYCLE_COUNT,
+	SW5100_QBG_CHARGE_FULL_DESIGN,
+	SW5100_QBG_TIME_TO_FULL_NOW,
+	SW5100_QBG_TIME_TO_EMPTY_AVG,
+	SW5100_QBG_VOLTAGE_AVG,
+	SW5100_QBG_VOLTAGE_OCV,
+	SW5100_QBG_MAX,
+};
+
+/* QBG/FG channels */
+static const char * const sw5100_qbg_ext_iio_chan[] = {
+	[SW5100_QBG_DEBUG_BATTERY] = "debug_battery",
+	[SW5100_QBG_CAPACITY] = "capacity",
+	[SW5100_QBG_REAL_CAPACITY] = "real_capacity",
+	[SW5100_QBG_CURRENT_NOW] = "current_now",
+	[SW5100_QBG_VOLTAGE_NOW] = "voltage_now",
+	[SW5100_QBG_VOLTAGE_MAX] = "voltage_max",
+	[SW5100_QBG_CHARGE_FULL] = "charge_full",
+	[SW5100_QBG_RESISTANCE_ID] = "resistance_id",
+	[SW5100_QBG_TEMP] = "temp",
+	[SW5100_QBG_CHARGE_COUNTER] = "charge_counter",
+	[SW5100_QBG_CYCLE_COUNT] = "cycle_count",
+	[SW5100_QBG_CHARGE_FULL_DESIGN] = "charge_full_design",
+	[SW5100_QBG_TIME_TO_FULL_NOW] = "time_to_full_now",
+	[SW5100_QBG_TIME_TO_EMPTY_AVG] = "time_to_empty_avg",
+	[SW5100_QBG_VOLTAGE_AVG] = "voltage_avg",
+	[SW5100_QBG_VOLTAGE_OCV] = "voltage_ocv",
+};
+
+static int sw5100_get_prop_from_bms(struct bms_dev *bms, int channel, int *val)
+{
+	int rc;
+
+	if (IS_ERR_OR_NULL(bms->iio_chan_list_qg))
+		return -ENODEV;
+
+	rc = iio_read_channel_processed(bms->iio_chan_list_qg[channel],
+					val);
+
+	return rc < 0 ? rc : 0;
+}
+
+static struct iio_channel **sw5100_get_ext_channels(struct device *dev,
+		 const char *const *channel_map, int size)
+{
+	int i, rc = 0;
+	struct iio_channel **iio_ch_ext;
+
+	iio_ch_ext = devm_kcalloc(dev, size, sizeof(*iio_ch_ext), GFP_KERNEL);
+	if (!iio_ch_ext)
+		return ERR_PTR(-ENOMEM);
+
+	for (i = 0; i < size; i++) {
+		iio_ch_ext[i] = devm_iio_channel_get(dev, channel_map[i]);
+
+		if (IS_ERR(iio_ch_ext[i])) {
+			rc = PTR_ERR(iio_ch_ext[i]);
+			if (rc != -EPROBE_DEFER)
+				dev_err(dev, "%s channel unavailable, %d\n", channel_map[i], rc);
+			return ERR_PTR(rc);
+		}
+	}
+
+	return iio_ch_ext;
+}
+
+/* ------------------------------------------------------------------------- */
+
+static irqreturn_t sw5100_chg_state_change_irq_handler(int irq, void *data)
+{
+	struct smb_irq_data *irq_data = data;
+	struct bms_dev *chg = irq_data->parent_data;
+	u8 stat;
+	int rc;
+
+	dev_dbg(chg->dev, "IRQ: %s\n", irq_data->name);
+
+	rc = sw5100_read(chg->pmic_regmap, CHGR_BATTERY_CHARGER_STATUS_REG, &stat, 1);
+	if (rc < 0) {
+		dev_err(chg->dev, "Couldn't read BATTERY_CHARGER_STATUS rc=%d\n", rc);
+		return IRQ_HANDLED;
+	}
+
+	power_supply_changed(chg->psy);
+	return IRQ_HANDLED;
+}
+
+static irqreturn_t sw5100_batt_temp_changed_irq_handler(int irq, void *data)
+{
+	struct smb_irq_data *irq_data = data;
+	struct bms_dev *chg = irq_data->parent_data;
+
+	dev_dbg(chg->dev, "IRQ: %s\n", irq_data->name);
+	power_supply_changed(chg->psy);
+	return IRQ_HANDLED;
+}
+
+static irqreturn_t sw5100_batt_psy_changed_irq_handler(int irq, void *data)
+{
+	struct smb_irq_data *irq_data = data;
+	struct bms_dev *chg = irq_data->parent_data;
+
+	dev_dbg(chg->dev, "IRQ: %s\n", irq_data->name);
+	power_supply_changed(chg->psy);
+	return IRQ_HANDLED;
+}
+
+static irqreturn_t sw5100_default_irq_handler(int irq, void *data)
+{
+	struct smb_irq_data *irq_data = data;
+	struct smb_charger *chg = irq_data->parent_data;
+
+	dev_dbg(chg->dev, "IRQ: %s\n", irq_data->name);
+	return IRQ_HANDLED;
+}
+
+/* TODO: sparse, consider adding .irqno */
+static struct smb_irq_info sw5100_bms_irqs[] = {
+	/* CHARGER IRQs */
+	[CHGR_ERROR_IRQ] = {
+		.name		= "chgr-error",
+		.handler	= sw5100_default_irq_handler,
+	},
+	[CHG_STATE_CHANGE_IRQ] = {
+		.name		= "chg-state-change",
+		.handler	= sw5100_chg_state_change_irq_handler,
+		.wake		= true,
+	},
+	[VPH_OV_IRQ] = {
+		.name		= "vph-ov",
+	},
+	[BUCK_OC_IRQ] = {
+		.name		= "buck-oc",
+	},
+	/* BATTERY IRQs */
+	[BAT_TEMP_IRQ] = {
+		.name		= "bat-temp",
+		.handler	= sw5100_batt_temp_changed_irq_handler,
+		.wake		= true,
+	},
+	[BAT_THERM_OR_ID_MISSING_IRQ] = {
+		.name		= "bat-therm-or-id-missing",
+		.handler	= sw5100_batt_psy_changed_irq_handler,
+	},
+	[BAT_LOW_IRQ] = {
+		.name		= "bat-low",
+		.handler	= sw5100_batt_psy_changed_irq_handler,
+	},
+	[BAT_OV_IRQ] = {
+		.name		= "bat-ov",
+		.handler	= sw5100_batt_psy_changed_irq_handler,
+	},
+	[BSM_ACTIVE_IRQ] = {
+		.name		= "bsm-active",
+	},
+};
+
+static int sw5100_get_irq_index_byname(const char *irq_name)
+{
+	int i;
+
+	for (i = 0; i < ARRAY_SIZE(sw5100_bms_irqs); i++) {
+		if (!sw5100_bms_irqs[i].name)
+			continue;
+
+		if (strcmp(sw5100_bms_irqs[i].name, irq_name) == 0)
+			return i;
+	}
+
+	return -ENOENT;
+}
+
+static int sw5100_request_interrupt(struct bms_dev *bms,
+				    struct device_node *node,
+				    const char *irq_name)
+{
+	int rc, irq, irq_index;
+	struct smb_irq_data *irq_data;
+
+	irq = of_irq_get_byname(node, irq_name);
+	if (irq < 0) {
+		pr_err("Couldn't get irq %s byname\n", irq_name);
+		return irq;
+	}
+
+	irq_index = sw5100_get_irq_index_byname(irq_name);
+	if (irq_index < 0) {
+		pr_err("%s is not a defined irq\n", irq_name);
+		return irq_index;
+	}
+
+	if (!sw5100_bms_irqs[irq_index].handler)
+		return 0;
+
+	irq_data = devm_kzalloc(bms->dev, sizeof(*irq_data), GFP_KERNEL);
+	if (!irq_data)
+		return -ENOMEM;
+
+	irq_data->parent_data = bms;
+	irq_data->name = irq_name;
+	irq_data->storm_data = sw5100_bms_irqs[irq_index].storm_data;
+	mutex_init(&irq_data->storm_data.storm_lock);
+
+	rc = devm_request_threaded_irq(bms->dev, irq, NULL,
+					sw5100_bms_irqs[irq_index].handler,
+					IRQF_ONESHOT, irq_name, irq_data);
+	if (rc < 0) {
+		pr_err("Couldn't request irq %d\n", irq);
+		return rc;
+	}
+
+	sw5100_bms_irqs[irq_index].irq = irq;
+	sw5100_bms_irqs[irq_index].irq_data = irq_data;
+	if (sw5100_bms_irqs[irq_index].wake)
+		enable_irq_wake(irq);
+
+	return rc;
+}
+
+static void sw5100_free_interrupts(struct bms_dev *bms)
+{
+	int i;
+
+	for (i = 0; i < ARRAY_SIZE(sw5100_bms_irqs); i++) {
+		if (sw5100_bms_irqs[i].irq > 0) {
+			if (sw5100_bms_irqs[i].wake)
+				disable_irq_wake(sw5100_bms_irqs[i].irq);
+
+			devm_free_irq(bms->dev, sw5100_bms_irqs[i].irq, sw5100_bms_irqs[i].irq_data);
+		}
+	}
+}
+
+static void sw5100_disable_interrupts(struct bms_dev *bms)
+{
+	int i;
+
+	for (i = 0; i < ARRAY_SIZE(sw5100_bms_irqs); i++) {
+		if (sw5100_bms_irqs[i].irq > 0)
+			disable_irq(sw5100_bms_irqs[i].irq);
+	}
+}
+
+static int sw5100_request_interrupts(struct bms_dev *bms)
+{
+	struct device_node *node = bms->dev->of_node;
+	struct device_node *child;
+	int rc = 0;
+	const char *name;
+	struct property *prop;
+
+	for_each_available_child_of_node(node, child) {
+		of_property_for_each_string(child, "interrupt-names",  prop, name) {
+			rc = sw5100_request_interrupt(bms, child, name);
+			if (rc < 0)
+				return rc;
+		}
+	}
+	return 0;
+}
+
+#define BID_RPULL_OHM		100000
+#define BID_VREF_MV		1875
+static void sw5100_get_batt_id(const struct bms_dev *bms, int *batt_id_ohm)
+{
+	int rc, batt_id_mv;
+
+	/* Read battery-id */
+	rc = iio_read_channel_processed(bms->batt_id_chan, &batt_id_mv);
+	if (rc < 0) {
+		pr_err("Failed to read BATT_ID over ADC, rc=%d\n", rc);
+		return;
+	}
+
+	batt_id_mv = div_s64(batt_id_mv, 1000);
+	if (batt_id_mv == 0) {
+		pr_info("batt_id_mv = 0 from ADC\n");
+		return;
+	}
+
+	*batt_id_ohm = (u32)batt_id_mv;
+
+	pr_info("batt_id = %d\n", *batt_id_ohm);
+}
+
+#define QBG_MAIN_LAST_BURST_AVG_ACC2_DATA0		0xA4
+#define IBATT_10A_LSB					6103
+#define ICHG_FS_10A					1
+#define TEN_NANO_TO_MICRO	100
+static int sw5100_get_battery_current(const struct bms_dev *bms, int *val)
+{
+	int rc = 0;
+	unsigned short acc2_data;
+	u8 buf[2];
+	const unsigned long addr = bms->rradc_base + QBG_MAIN_LAST_BURST_AVG_ACC2_DATA0;
+
+	rc = sw5100_read(bms->pmic_regmap, addr, buf, 2);
+	if (rc < 0) {
+		pr_err("Failed to read LAST_BURST_AVG_I reg, rc=%d\n", rc);
+		return rc;
+	}
+	acc2_data = buf[0] | (buf[1] << 8);
+	*val = ((int16_t)acc2_data) * IBATT_10A_LSB * ICHG_FS_10A;
+	*val = *val / TEN_NANO_TO_MICRO;
+
+	return rc;
+}
+
+#define QBG_MAIN_LAST_BURST_AVG_ACC0_DATA0		0xA0
+#define VBATT_1S_LSB					19463
+static int sw5100_get_battery_voltage(const struct bms_dev *bms, int *val)
+{
+	int rc = 0;
+	unsigned short acc0_data;
+	u8 buf[2];
+	const unsigned long addr = bms->rradc_base + QBG_MAIN_LAST_BURST_AVG_ACC0_DATA0;
+
+	rc = sw5100_read(bms->pmic_regmap, addr, buf, 2);
+	if (rc < 0) {
+		pr_err("Failed to read LAST_ADV_V reg, rc=%d\n", rc);
+		return rc;
+	}
+	acc0_data = buf[0] | (buf[1] << 8);
+	*val = acc0_data * VBATT_1S_LSB;
+	*val = *val / TEN_NANO_TO_MICRO;
+
+	return rc;
+}
+
+static int sw5100_get_battery_temp(const struct bms_dev *bms, int *val)
+{
+	int rc = 0;
+
+	if (!bms->rradc_base)
+		return -EIO;
+
+	rc = iio_read_channel_processed(bms->batt_therm_chan, val);
+	if (rc < 0) {
+		pr_err("Failed reading BAT_TEMP over ADC rc=%d\n", rc);
+		return rc;
+	}
+
+	return rc;
+}
+
+#define sw5100_IS_ONLINE(stat)	\
+	(((stat) & (USE_DCIN_BIT | USE_USBIN_BIT)) && \
+	((stat) & VALID_INPUT_POWER_SOURCE_STS_BIT))
+
+/* charger online when connected */
+static bool sw5100_is_online(const struct bms_dev *bms)
+{
+	u8 stat;
+	const int rc = sw5100_read(bms->pmic_regmap, DCDC_POWER_PATH_STATUS_REG, &stat, 1);
+
+	return (rc == 0) && sw5100_IS_ONLINE(stat);
+}
+
+static int sw5100_is_limited(const struct bms_dev *bms)
+{
+	int rc;
+	u8 val;
+
+	rc = sw5100_read(bms->pmic_regmap, DCDC_AICL_STATUS_REG, &val, 1);
+	return (rc < 0) ? -EIO : ((val & DCDC_SOFT_ILIMIT_BIT) != 0);
+}
+
+static int sw5100_get_chg_type(const struct bms_dev *bms)
+{
+	u8 val;
+	int chg_type, rc;
+
+	rc = sw5100_read(bms->pmic_regmap, CHGR_BATTERY_CHARGER_STATUS_REG, &val, 1);
+	if (rc < 0)
+		return POWER_SUPPLY_CHARGE_TYPE_UNKNOWN;
+
+	switch (val & CHGR_BATTERY_CHARGER_STATUS_MASK) {
+	case SW5100_TRICKLE_CHARGE:
+	case SW5100_PRE_CHARGE:
+		chg_type = POWER_SUPPLY_CHARGE_TYPE_TRICKLE;
+		break;
+	case SW5100_FULLON_CHARGE:
+		chg_type = POWER_SUPPLY_CHARGE_TYPE_FAST;
+		break;
+	case SW5100_TAPER_CHARGE:
+		chg_type = POWER_SUPPLY_CHARGE_TYPE_TAPER_EXT;
+		break;
+	default:
+		chg_type = POWER_SUPPLY_CHARGE_TYPE_NONE;
+		break;
+	}
+
+	return chg_type;
+}
+
+static int sw5100_get_chg_status(const struct bms_dev *bms,
+				 bool *dc_valid, bool *usb_valid)
+{
+	bool plugged, valid;
+	int rc, ret;
+	int vchrg = 0;
+	int vlimit = bms->chg_term_voltage;
+	u8 pstat, stat1, stat2;
+	u8 suspend;
+
+	rc = sw5100_rd8(bms->pmic_regmap, DCDC_POWER_PATH_STATUS_REG, &pstat);
+	if (rc < 0)
+		return POWER_SUPPLY_STATUS_UNKNOWN;
+
+	valid = (pstat & VALID_INPUT_POWER_SOURCE_STS_BIT);
+	plugged = (pstat & USE_DCIN_BIT) || (pstat & USE_USBIN_BIT);
+
+	*dc_valid = valid && (pstat & USE_DCIN_BIT);
+	*usb_valid = valid && (pstat & USE_USBIN_BIT);
+
+	rc = sw5100_rd8(bms->pmic_regmap, CHGR_BATTERY_CHARGER_STATUS_REG, &stat1);
+	if (rc < 0)
+		return POWER_SUPPLY_STATUS_UNKNOWN;
+
+	rc = sw5100_rd8(bms->pmic_regmap, CHGR_BATTERY_CHARGER_EN_STATUS_REG, &stat2);
+	if (rc < 0)
+		return POWER_SUPPLY_STATUS_UNKNOWN;
+
+	pr_debug("pmic: pstat=%x stat=%x enstat=%x\n",
+		pstat, stat1, stat2);
+
+	stat1 = stat1 & CHGR_BATTERY_CHARGER_STATUS_MASK;
+
+	if (!plugged)
+		return POWER_SUPPLY_STATUS_DISCHARGING;
+
+	switch (stat1) {
+	case SW5100_TRICKLE_CHARGE:
+	case SW5100_PRE_CHARGE:
+	case SW5100_FULLON_CHARGE:
+	case SW5100_TAPER_CHARGE:
+		ret = POWER_SUPPLY_STATUS_CHARGING;
+		break;
+	/* pause on FCC=0, JEITA, USB/DC suspend or on INPUT UV/OV */
+	case SW5100_PAUSE_CHARGE:
+	case SW5100_INHIBIT_CHARGE:
+		ret = POWER_SUPPLY_STATUS_NOT_CHARGING;
+		break;
+	case SW5100_TERMINATE_CHARGE:
+		/* flag full only at the correct voltage */
+		rc = sw5100_get_battery_voltage(bms, &vchrg);
+		if (rc == 0)
+			vchrg = (vchrg / 1000);
+		if (stat1 == SW5100_TERMINATE_CHARGE)
+			vlimit -= bms->chg_term_voltage_debounce;
+		if (vchrg < vlimit)
+			ret = POWER_SUPPLY_STATUS_NOT_CHARGING;
+		else
+			ret = POWER_SUPPLY_STATUS_FULL;
+		break;
+	/* disabled disconnect */
+	case SW5100_DISABLE_CHARGE:
+		rc = sw5100_rd8(bms->pmic_regmap, CHGR_USB_SUSPEND, &suspend);
+		if (rc < 0)
+			return POWER_SUPPLY_STATUS_UNKNOWN;
+		if ((suspend & USBIN_SUSPEND) == USBIN_SUSPEND) {
+			ret = POWER_SUPPLY_STATUS_DISCHARGING;
+		} else {
+			ret = POWER_SUPPLY_STATUS_NOT_CHARGING;
+		}
+		break;
+	default:
+		ret = POWER_SUPPLY_STATUS_UNKNOWN;
+		break;
+	}
+
+	if (ret != POWER_SUPPLY_STATUS_CHARGING)
+		return ret;
+
+	if (valid) {
+		u8 stat;
+
+		rc = sw5100_rd8(bms->pmic_regmap,
+				CHGR_BATTERY_CHARGER_EN_STATUS_REG,
+				&stat);
+		if (rc < 0)
+			return POWER_SUPPLY_STATUS_UNKNOWN;
+
+		stat &= ENABLE_TRICKLE_BIT | ENABLE_PRE_CHARGING_BIT |
+					ENABLE_FULLON_MODE_BIT;
+		if (stat)
+			return POWER_SUPPLY_STATUS_CHARGING;
+	}
+
+	return POWER_SUPPLY_STATUS_NOT_CHARGING;
+}
+static int sw5100_get_chg_chgr_state(const struct bms_dev *bms,
+			  union gbms_charger_state *chg_state)
+{
+	int vchrg, rc;
+	bool usb_valid, dc_valid;
+	u8 icl = 0;
+
+	chg_state->v = 0;
+	chg_state->f.chg_status = sw5100_get_chg_status(bms, &dc_valid, &usb_valid);
+	chg_state->f.chg_type = sw5100_get_chg_type(bms);
+	chg_state->f.flags = 0; 
+
+	rc = sw5100_is_limited(bms);
+	if (rc > 0)
+		chg_state->f.flags |= GBMS_CS_FLAG_ILIM;
+
+	rc = sw5100_get_battery_voltage(bms, &vchrg);
+	if (rc == 0)
+		chg_state->f.vchrg = (vchrg / 1000);
+
+	if (usb_valid) {
+		(void)sw5100_rd8(bms->pmic_regmap, DCDC_ICL_STATUS_REG, &icl);
+	}
+
+	chg_state->f.icl = (icl * 100);
+
+	pr_info("MSC_PCS chg_state=%lx [0x%x:%d:%d:%d:%d] chg=%c\n",
+		(unsigned long)chg_state->v,
+		chg_state->f.flags,
+		chg_state->f.chg_type,
+		chg_state->f.chg_status,
+		chg_state->f.vchrg,
+		chg_state->f.icl,
+		usb_valid ? 'u' : dc_valid ? 'w' : ' ');
+
+	return 0;
+}
+
+static int sw5100_get_batt_health(struct bms_dev *bms)
+{
+	int vchrg, effective_fv_uv, rc, ret;
+	u8 stat;
+
+	rc = sw5100_rd8(bms->pmic_regmap, CHGR_BATTERY_CHARGER_STATUS_REG, &stat);
+	if (rc < 0) {
+		pr_err("Couldn't read CHGR_BATTERY_CHARGER_STATUS_REG rc=%d\n", rc);
+		return POWER_SUPPLY_HEALTH_UNKNOWN;
+	}
+
+	if (stat & CHG_ERR_STATUS_BAT_OV) {
+		rc = sw5100_get_battery_voltage(bms, &vchrg);
+		if (rc == 0) {
+			/*
+			 * If Vbatt is within 40mV above Vfloat, then don't
+			 * treat it as overvoltage.
+			 */
+			if (!bms->fv_votable)
+				bms->fv_votable = find_votable(VOTABLE_MSC_FV);
+			if (bms->fv_votable) {
+				effective_fv_uv = get_effective_result(bms->fv_votable);
+				if (vchrg >= effective_fv_uv + 40000) {
+					ret = POWER_SUPPLY_HEALTH_OVERVOLTAGE;
+					pr_err("battery over-voltage vbat_fg = %duV, fv = %duV\n",
+							vchrg, effective_fv_uv);
+					goto done;
+				}
+			}
+		}
+	}
+
+	rc = sw5100_rd8(bms->pmic_regmap, BATIF_BAT_TEMP_STATUS_REG, &stat);
+	if (rc < 0) {
+		pr_err("Couldn't read BATIF_BAT_TEMP_STATUS_REG rc=%d\n", rc);
+		return POWER_SUPPLY_HEALTH_UNKNOWN;
+	}
+	if (stat & BAT_TEMP_TOO_COLD)
+		ret = POWER_SUPPLY_HEALTH_COLD;
+	else if (stat & BAT_TEMP_TOO_HOT)
+		ret = POWER_SUPPLY_HEALTH_OVERHEAT;
+	else if (stat & BAT_TEMP_COOL)
+		ret = POWER_SUPPLY_HEALTH_COOL;
+	else if (stat & BAT_TEMP_WARM)
+		ret = POWER_SUPPLY_HEALTH_WARM;
+	else
+		ret = POWER_SUPPLY_HEALTH_GOOD;
+
+done:
+	return ret;
+}
+
+static int sw5100_get_batt_iterm(struct bms_dev *bms)
+{
+	int rc, temp;
+	u8 stat, buf[2];
+
+	rc = sw5100_rd8(bms->pmic_regmap, CHGR_CHG_TERM_CFG_REG, &stat);
+	if (rc < 0) {
+		pr_err("Couldn't read CHGR_CHG_TERM_CFG_REG rc=%d\n", rc);
+		return rc;
+	}
+
+	if (stat & CHGR_ITERM_USE_ANALOG_BIT)
+		return -EINVAL;
+
+	rc = sw5100_read(bms->pmic_regmap, CHGR_ADC_ITERM_UP_THD_MSB, buf, 2);
+	if (rc < 0) {
+		pr_err("Couldn't read CHGR_ADC_ITERM_UP_THD_MSB rc=%d\n", rc);
+		return rc;
+	}
+
+	temp = buf[1] | (buf[0] << 8);
+	temp = sign_extend32(temp, 15);
+
+	temp = DIV_ROUND_CLOSEST(temp * 1000, PM5100_ADC_CHG_ITERM_MULT);
+
+	return temp;
+}
+
+static int sw5100_get_batt_present(struct bms_dev *bms)
+{
+	int rc, ret;
+	u8 stat;
+
+	rc = sw5100_rd8(bms->pmic_regmap,
+			BATIF_INT_RT_STS,
+			&stat);
+	if (rc < 0) {
+		pr_err("Couldn't read BATIF_INT_RT_STS rc=%d\n", rc);
+		return rc;
+	}
+
+	ret = !(stat & (BATIF_THERM_OR_ID_MISSING_RT_STS_BIT));
+	return ret;
+}
+
+/** Given a SOC percentage aka capacity we're going to scale 5-100 to 0-100. */
+static int scale_capacity(struct bms_dev const *bms, int capacity)
+{
+	if (bms->soc_shutdown_offset > 0) {
+		if (capacity >= 100) {
+			return 100;
+		} else if (capacity >= bms->soc_shutdown_offset) {
+			return (((capacity - bms->soc_shutdown_offset) * 100) /
+				(100 - bms->soc_shutdown_offset));
+		} else {
+			return 0;
+		}
+	} else {
+		return capacity;
+	}
+}
+
+static int sw5100_psy_get_property(struct power_supply *psy,
+				       enum power_supply_property psp,
+				       union power_supply_propval *pval)
+{
+	struct bms_dev *bms = (struct bms_dev *)power_supply_get_drvdata(psy);
+	union gbms_charger_state chg_state;
+	u8 val;
+	int ivalue = 0;
+	int rc = 0;
+	bool usb_valid, dc_valid;
+
+	if (!bms->psy) {
+		pr_err("failed to register power supply\n");
+		return -EAGAIN;
+	}
+
+	switch ((int) psp) {
+	/*
+	 * called from power_supply_update_leds(), not using it on this
+	 * platform. Could return the state of the charge buck (BUCKEN)
+	 */
+	case POWER_SUPPLY_PROP_ONLINE:
+		pval->intval = sw5100_is_online(bms);
+		break;
+	case POWER_SUPPLY_PROP_STATUS:
+		pval->intval = sw5100_get_chg_status(bms, &dc_valid, &usb_valid);
+		break;
+	/* pixel battery management subsystem */
+	case POWER_SUPPLY_PROP_CONSTANT_CHARGE_CURRENT_MAX:
+		/*
+		 * CHGR_FAST_CHARGE_CURRENT_SETTING, 0x2654
+		 * 7 : 0 => FAST_CHARGE_CURRENT_SETTING:
+		 * Fast Charge Current = DATA x 25mA
+		 */
+		rc = sw5100_read(bms->pmic_regmap, CHGR_FAST_CHARGE_CURRENT_SETTING, &val, 1);
+		if (rc == 0)
+			pval->intval = val * CHGR_CHARGE_CURRENT_STEP;
+		break;
+	case POWER_SUPPLY_PROP_CONSTANT_CHARGE_VOLTAGE_MAX:
+		/*
+		 * CHGR_FLOAT_VOLTAGE_SETTING  0x2658
+		 * 7 : 0 => FLOAT_VOLTAGE_SETTING:
+		 * Float voltage setting = 3.6V + (DATA x 10mV)
+		 */
+		rc = sw5100_read(bms->pmic_regmap, CHGR_FLOAT_VOLTAGE_SETTING, &val, 1);
+		if (rc == 0)
+			pval->intval = val * 10000 + CHGR_FLOAT_VOLTAGE_BASE;
+		break;
+	case GBMS_PROP_CHARGE_CHARGER_STATE:
+		rc = sw5100_get_chg_chgr_state(bms, &chg_state);
+		if (rc == 0)
+			gbms_propval_int64val(pval) = chg_state.v;
+		break;
+	case POWER_SUPPLY_PROP_CHARGE_TYPE:
+		pval->intval = sw5100_get_chg_type(bms);
+		break;
+	case POWER_SUPPLY_PROP_CURRENT_NOW:
+		rc = sw5100_get_battery_current(bms, &ivalue);
+		if (rc == 0)
+			pval->intval = ivalue;
+		break;
+	case GBMS_PROP_INPUT_CURRENT_LIMITED:
+		rc = sw5100_is_limited(bms);
+		if (rc < 0)
+			break;
+		pval->intval = (rc > 0);
+		break;
+
+	case POWER_SUPPLY_PROP_TEMP:
+		rc = sw5100_get_battery_temp(bms, &ivalue);
+		if (rc < 0)
+			break;
+		pval->intval = ivalue;
+		break;
+	case POWER_SUPPLY_PROP_VOLTAGE_MAX:
+		/*
+		 * CHGR_FLOAT_VOLTAGE_NOW 0x260B
+		 * 7 : 0 => FLOAT_VOLTAGE:
+		 * Float voltage after JEITA compensation
+		 */
+		rc = sw5100_read(bms->pmic_regmap, CHGR_FLOAT_VOLTAGE_NOW,
+				&val, 1);
+		if (rc == 0)
+			pval->intval = val * 10000 + CHGR_FLOAT_VOLTAGE_BASE;
+		break;
+	case POWER_SUPPLY_PROP_VOLTAGE_NOW:
+		rc = sw5100_get_battery_voltage(bms, &ivalue);
+		if (!rc)
+			pval->intval = ivalue;
+		break;
+	case GBMS_PROP_CHARGE_DISABLE:
+		rc = sw5100_read(bms->pmic_regmap, CHGR_CHG_EN, &val, 1);
+		if (rc == 0)
+			pval->intval = !(val & CHARGING_ENABLE_CMD_BIT);
+		break;
+	case POWER_SUPPLY_PROP_HEALTH:
+		pval->intval = sw5100_get_batt_health(bms);
+		break;
+	case POWER_SUPPLY_PROP_CHARGE_TERM_CURRENT:
+		pval->intval = sw5100_get_batt_iterm(bms);
+		break;
+	case POWER_SUPPLY_PROP_PRESENT:
+		pval->intval = sw5100_get_batt_present(bms);
+		break;
+	case GBMS_PROP_CAPACITY_RAW:
+		rc = sw5100_get_prop_from_bms(bms, SW5100_QBG_REAL_CAPACITY, &ivalue);
+		if (rc == 0)
+			pval->intval = (scale_capacity(bms, ivalue) << 8);
+		break;
+	case POWER_SUPPLY_PROP_CAPACITY:
+		rc = sw5100_get_prop_from_bms(bms, SW5100_QBG_CAPACITY, &ivalue);
+		if (rc == 0)
+			pval->intval = scale_capacity(bms, ivalue);
+		break;
+	case POWER_SUPPLY_PROP_CYCLE_COUNT:
+		rc = sw5100_get_prop_from_bms(bms, SW5100_QBG_CYCLE_COUNT, &ivalue);
+		if (rc == 0)
+			pval->intval = ivalue;
+		/* TODO(b/243407602): fix cycle count, but for now set it to 0 as a workaround */
+		if (pval->intval < 0)
+			pval->intval = 0;
+		break;
+	case POWER_SUPPLY_PROP_VOLTAGE_AVG:
+		rc = sw5100_get_prop_from_bms(bms, SW5100_QBG_VOLTAGE_AVG, &ivalue);
+		if (rc == 0)
+			pval->intval = ivalue;
+		break;
+	case POWER_SUPPLY_PROP_VOLTAGE_OCV:
+		rc = sw5100_get_prop_from_bms(bms, SW5100_QBG_VOLTAGE_OCV, &ivalue);
+		if (rc == 0)
+			pval->intval = ivalue;
+		break;
+	case POWER_SUPPLY_PROP_CHARGE_FULL:
+		rc = sw5100_get_prop_from_bms(bms, SW5100_QBG_CHARGE_FULL, &ivalue);
+		if (rc == 0)
+			pval->intval = ivalue;
+		break;
+	case POWER_SUPPLY_PROP_CHARGE_FULL_DESIGN:
+		rc = sw5100_get_prop_from_bms(bms, SW5100_QBG_CHARGE_FULL_DESIGN, &ivalue);
+		if (rc == 0)
+			pval->intval = ivalue;
+		break;
+	case POWER_SUPPLY_PROP_CHARGE_COUNTER:
+		rc = sw5100_get_prop_from_bms(bms, SW5100_QBG_CHARGE_COUNTER, &ivalue);
+		if (rc == 0)
+			pval->intval = ivalue;
+		break;
+	case POWER_SUPPLY_PROP_TIME_TO_FULL_NOW:
+		rc = sw5100_get_prop_from_bms(bms, SW5100_QBG_TIME_TO_FULL_NOW, &ivalue);
+		if (rc == 0)
+			pval->intval = ivalue;
+		break;
+	case POWER_SUPPLY_PROP_TIME_TO_EMPTY_AVG:
+		rc = sw5100_get_prop_from_bms(bms, SW5100_QBG_TIME_TO_EMPTY_AVG, &ivalue);
+		if (rc == 0)
+			pval->intval = ivalue;
+		break;
+	case POWER_SUPPLY_PROP_CURRENT_AVG:
+		rc = sw5100_get_battery_current(bms, &ivalue);
+		if (rc == 0)
+			pval->intval = ivalue;
+		break;
+	case POWER_SUPPLY_PROP_TECHNOLOGY:
+		pval->intval = POWER_SUPPLY_TECHNOLOGY_LION;
+		break;
+
+	case POWER_SUPPLY_PROP_SERIAL_NUMBER:
+		pval->strval = "";
+		break;
+	case GBMS_PROP_HEALTH_ACT_IMPEDANCE:
+		pval->intval = -EINVAL;
+		break;
+	case GBMS_PROP_RESISTANCE:
+		pval->intval = 0;
+		break;
+	default:
+		pr_debug("getting unsupported property: %d\n", psp);
+		return -EINVAL;
+	}
+
+	if (rc < 0)
+		return -ENODATA;
+
+	return 0;
+}
+
+static int sw5100_usbin_disable(struct bms_dev *bms, bool disable)
+{
+	int rc;
+
+	if (!bms->icl_votable) {
+		bms->icl_votable = find_votable("USB_ICL");
+		if (bms->icl_votable == NULL) {
+			pr_err("USBIN_DISABLE: disable failed\n");
+			return -EINVAL;
+		}
+	}
+
+	rc = vote(bms->icl_votable, USBIN_DISABLE_VOTER, disable, 0);
+
+	pr_debug("USBIN_DISABLE : disable=%d, rc=%d)\n", disable, rc);
+
+	if (rc > 0) {
+		/* vote returns positive number on success */
+		rc = 0;
+	}
+	return rc;
+}
+
+static int sw5100_charge_disable(struct bms_dev *bms, bool disable)
+{
+	const u8 val = disable ? 0 : CHARGING_ENABLE_CMD_BIT;
+	int rc;
+
+	rc = sw5100_masked_write(bms->pmic_regmap, CHGR_CHG_EN, CHARGING_ENABLE_CMD_BIT, val);
+
+	if (!disable) {
+		/* Make sure charging is restarted by toggling usbin */
+		if (rc == 0)
+			rc = sw5100_usbin_disable(bms, true);
+		if (rc == 0)
+			rc = sw5100_usbin_disable(bms, false);
+
+	}
+	pr_debug("CHARGE_DISABLE : disable=%d -> val=%d (%d)\n", disable, val, rc);
+
+	return rc;
+}
+
+static int sw5100_charge_pause(struct bms_dev *bms, bool pause)
+{
+	const u8 val = pause ? CHARGING_PAUSE_CMD_BIT : 0;
+	int rc;
+
+	rc = sw5100_masked_write(bms->pmic_regmap, CHGR_CHARGING_PAUSE_CMD, CHARGING_PAUSE_CMD_BIT, val);
+
+	pr_debug("CHARGE_PAUSE : pause=%d -> val=%d (%d)\n",
+		pause, val, rc);
+
+	return rc;
+}
+
+static ssize_t soc_shutdown_offset_store(struct device *dev,
+				  struct device_attribute *attr,
+				  const char *buf, size_t count)
+{
+	struct power_supply *psy = container_of(dev, struct power_supply, dev);
+	struct bms_dev *bms = power_supply_get_drvdata(psy);
+
+	sscanf(buf, "%d", &bms->soc_shutdown_offset);
+	return count;
+}
+
+static ssize_t soc_shutdown_offset_show(struct device *dev, struct device_attribute *attr, char *buf)
+{
+	struct power_supply *psy = container_of(dev, struct power_supply, dev);
+	struct bms_dev *bms = power_supply_get_drvdata(psy);
+
+	return scnprintf(buf, PAGE_SIZE, "%d\n", bms->soc_shutdown_offset);
+}
+
+static const DEVICE_ATTR_RW(soc_shutdown_offset);
+
+static int sw5100_psy_set_property(struct power_supply *psy,
+				  enum power_supply_property psp,
+				  const union power_supply_propval *pval)
+{
+	struct bms_dev *bms = (struct bms_dev *)power_supply_get_drvdata(psy);
+	u8 val;
+	int ivalue = 0;
+	int rc = 0;
+
+	switch ((int) psp) {
+	case POWER_SUPPLY_PROP_CONSTANT_CHARGE_CURRENT_MAX:
+		/*
+		 * CHGR_FAST_CHARGE_CURRENT_SETTING, 0x2654
+		 * 7 : 0 => FAST_CHARGE_CURRENT_SETTING:
+		 * Fast Charge Current = DATA x 25mA
+		 */
+		ivalue = pval->intval;
+		if (ivalue < CHGR_CHARGE_CURRENT_STEP)
+			val = 0;
+		else
+			val = ivalue / CHGR_CHARGE_CURRENT_STEP;
+
+		if (ivalue == 0)
+			rc = sw5100_charge_pause(bms, true);
+
+		rc = sw5100_write(bms->pmic_regmap, CHGR_FAST_CHARGE_CURRENT_SETTING, &val, 1);
+
+		if (ivalue != 0) {
+			u8 paused;
+
+			rc = sw5100_read(bms->pmic_regmap, CHGR_CHARGING_PAUSE_CMD, &paused, 1);
+			if (rc == 0 && (paused & CHARGING_PAUSE_CMD_BIT)) {
+				rc = sw5100_charge_pause(bms, false);
+
+				/* make sure charging restart */
+				if (rc == 0)
+					rc = sw5100_charge_disable(bms, true);
+				if (rc == 0)
+					rc = sw5100_charge_disable(bms, false);
+				if (rc < 0)
+					pr_err("Failed to toggle charging during charging restart\n");
+			}
+		}
+
+		pr_debug("CONSTANT_CHARGE_CURRENT_MAX : ivalue=%d, val=%d pause=%d (%d)\n",
+			ivalue, val, ivalue == 0, rc);
+		break;
+	case POWER_SUPPLY_PROP_VOLTAGE_MAX:
+	case POWER_SUPPLY_PROP_CONSTANT_CHARGE_VOLTAGE_MAX:
+		/*
+		 * CHGR_FLOAT_VOLTAGE_SETTING  0x2658
+		 * 7 : 0 => FLOAT_VOLTAGE_SETTING:
+		 * Float voltage setting = 3.6V + (DATA x 10mV)
+		 */
+		ivalue = pval->intval;
+		if (ivalue < CHGR_FLOAT_VOLTAGE_BASE)
+			val = 0;
+		else
+			val = (ivalue - CHGR_FLOAT_VOLTAGE_BASE) / 10000;
+
+		rc = sw5100_write(bms->pmic_regmap, CHGR_FLOAT_VOLTAGE_SETTING, &val, 1);
+		pr_debug("CONSTANT_CHARGE_VOLTAGE_MAX : ivalue=%d, val=%d (%d)\n",
+							ivalue, val, rc);
+		break;
+	case GBMS_PROP_CHARGE_DISABLE:
+		if (!bms->fcc_votable)
+			bms->fcc_votable = find_votable(VOTABLE_MSC_FCC);
+		if (bms->fcc_votable)
+			vote(bms->fcc_votable, CHARGE_DISABLE_VOTER,
+			     pval->intval, 0);
+		rc = sw5100_charge_disable(bms, pval->intval != 0);
+		break;
+	default:
+		pr_debug("setting unsupported property: %d\n", psp);
+		break;
+	}
+
+	return rc;
+}
+
+static int sw5100_property_is_writeable(struct power_supply *psy,
+					enum power_supply_property psp)
+{
+	switch ((int) psp) {
+	case POWER_SUPPLY_PROP_VOLTAGE_MAX:
+	case POWER_SUPPLY_PROP_CONSTANT_CHARGE_CURRENT_MAX:
+	case POWER_SUPPLY_PROP_CONSTANT_CHARGE_VOLTAGE_MAX:
+	case GBMS_PROP_CHARGE_DISABLE:
+		return 1;
+	default:
+		break;
+	}
+
+	return 0;
+}
+
+static enum power_supply_property sw5100_psy_props[] = {
+	POWER_SUPPLY_PROP_STATUS,
+	/* pixel battery management subsystem */
+	POWER_SUPPLY_PROP_HEALTH,
+	POWER_SUPPLY_PROP_PRESENT,
+	POWER_SUPPLY_PROP_CONSTANT_CHARGE_CURRENT_MAX,
+	POWER_SUPPLY_PROP_CONSTANT_CHARGE_VOLTAGE_MAX,
+	POWER_SUPPLY_PROP_CHARGE_TYPE,
+	POWER_SUPPLY_PROP_CURRENT_NOW,
+	POWER_SUPPLY_PROP_ONLINE,
+	POWER_SUPPLY_PROP_CHARGE_TERM_CURRENT,
+	POWER_SUPPLY_PROP_TEMP,
+	POWER_SUPPLY_PROP_VOLTAGE_MAX,		/* compat */
+	POWER_SUPPLY_PROP_VOLTAGE_AVG,
+	POWER_SUPPLY_PROP_VOLTAGE_NOW,
+	POWER_SUPPLY_PROP_VOLTAGE_OCV,
+	POWER_SUPPLY_PROP_CAPACITY,
+	POWER_SUPPLY_PROP_CYCLE_COUNT,
+	POWER_SUPPLY_PROP_CHARGE_FULL,
+	POWER_SUPPLY_PROP_CHARGE_FULL_DESIGN,
+	POWER_SUPPLY_PROP_CHARGE_COUNTER,
+	POWER_SUPPLY_PROP_CURRENT_AVG,
+	POWER_SUPPLY_PROP_TIME_TO_FULL_NOW,
+	POWER_SUPPLY_PROP_TIME_TO_EMPTY_AVG,
+	POWER_SUPPLY_PROP_TECHNOLOGY,
+	POWER_SUPPLY_PROP_SERIAL_NUMBER,
+};
+
+static struct power_supply_desc sw5100_psy_desc = {
+	.name = "sw5100_bms",
+	.type = POWER_SUPPLY_TYPE_UNKNOWN,
+	.properties = sw5100_psy_props,
+	.num_properties = ARRAY_SIZE(sw5100_psy_props),
+	.get_property = sw5100_psy_get_property,
+	.set_property = sw5100_psy_set_property,
+	.property_is_writeable = sw5100_property_is_writeable,
+};
+
+/* All callback functions below */
+
+static int sw5100_notifier_cb(struct notifier_block *nb,
+		unsigned long event, void *data)
+{
+	if (event != PSY_EVENT_PROP_CHANGED)
+		return NOTIFY_OK;
+	/* TBD: notification?*/
+	return NOTIFY_OK;
+}
+
+static int sw5100_dc_suspend_vote_callback(struct votable *votable, void *data,
+					     int disable, const char *client)
+{
+	/* DC suspend isn't supported but function is needed for compatibility */
+
+	return 0;
+}
+
+/* All init functions below this */
+#define PERPH_TYPE_REG				0x04
+#define QG_TYPE					0x0D
+static int sw5100_parse_dt_fg(struct bms_dev *bms, struct device_node *node)
+{
+
+	int rc = 0;
+	u32 val;
+
+	rc = of_property_read_u32(node, "reg", &val);
+	if (rc < 0) {
+		pr_err("Failed to get base address for QBG, rc = %d\n", rc);
+		return rc;
+	}
+	bms->rradc_base = val;
+	return rc;
+}
+
+static int sw5100_parse_dt(struct bms_dev *bms)
+{
+	struct device_node *fg_node, *node = bms->dev->of_node;
+	const char *psy_name = NULL;
+	int ret;
+
+	if (!node)  {
+		pr_err("device tree node missing\n");
+		return -ENXIO;
+	}
+
+	fg_node = of_get_parent(node);
+	if (fg_node)
+		fg_node = of_get_child_by_name(fg_node, "qpnp,qbg");
+	if (fg_node)
+		sw5100_parse_dt_fg(bms, fg_node);
+	else
+		pr_err("cannot find qpnp,qbg, rradc not available\n");
+
+	ret = of_property_read_u32(node, "google,chg-term-voltage", &bms->chg_term_voltage);
+	if (ret < 0)
+		bms->chg_term_voltage = CHG_TERM_VOLTAGE;
+
+	ret = of_property_read_u32(node, "google,chg-term-voltage-debounce", &bms->chg_term_voltage_debounce);
+	if (ret < 0)
+		bms->chg_term_voltage_debounce = CHG_TERM_VOLT_DEBOUNCE;
+
+	ret = of_property_read_string(node, "google,psy-name", &psy_name);
+	if (ret == 0)
+		sw5100_psy_desc.name =
+			devm_kstrdup(bms->dev, psy_name, GFP_KERNEL);
+
+	ret = of_property_read_u32(node, "google,soc_shutdown_offset", &bms->soc_shutdown_offset);
+	if (ret < 0)
+		bms->soc_shutdown_offset = 0;
+
+	if (sw5100_psy_desc.name == NULL)
+		return -EINVAL;
+
+	return 0;
+}
+
+static int bms_probe(struct platform_device *pdev)
+{
+	struct bms_dev *bms;
+	struct power_supply_config bms_psy_cfg = {};
+	struct iio_channel **iio_list;
+	int rc = 0;
+
+	bms = devm_kzalloc(&pdev->dev, sizeof(*bms), GFP_KERNEL);
+	if (!bms) {
+		pr_info("kalloc error\n");
+		return -ENOMEM;
+	}
+
+	bms->dev = &pdev->dev;
+	bms->batt_id_ohms = -EINVAL;
+	bms->pmic_regmap = dev_get_regmap(bms->dev->parent, NULL);
+	if (!bms->pmic_regmap) {
+		pr_err("Parent regmap is unavailable\n");
+	} else {
+		/* ADC for BID & THERM */
+		bms->batt_id_chan = iio_channel_get(&pdev->dev, "batt-id");
+		if (IS_ERR(bms->batt_id_chan)) {
+			rc = PTR_ERR(bms->batt_id_chan);
+			if (rc != -EPROBE_DEFER)
+				pr_err("batt-id channel unavailable, rc=%d\n", rc);
+			bms->batt_id_chan = NULL;
+			return rc;
+		}
+
+		bms->batt_therm_chan = iio_channel_get(&pdev->dev, "batt-therm");
+		if (IS_ERR(bms->batt_therm_chan)) {
+			rc = PTR_ERR(bms->batt_therm_chan);
+			if (rc != -EPROBE_DEFER)
+				pr_err("batt-therm channel unavailable, rc=%d\n", rc);
+			bms->batt_therm_chan = NULL;
+			return rc;
+		}
+
+		sw5100_get_batt_id(bms, &bms->batt_id_ohms);
+	}
+
+	rc = sw5100_parse_dt(bms);
+	if (rc < 0) {
+		pr_err("Parse the device tree fail. rc = %d\n", rc);
+		goto exit;
+	}
+
+	/* Register the power supply */
+	bms_psy_cfg.drv_data = bms;
+	bms_psy_cfg.of_node = bms->dev->of_node;
+	bms_psy_cfg.supplied_to = NULL;
+	bms_psy_cfg.num_supplicants = 0;
+	bms->psy = devm_power_supply_register(bms->dev, &sw5100_psy_desc,
+			&bms_psy_cfg);
+	if (IS_ERR(bms->psy)) {
+		pr_err("failed to register psy rc = %ld\n", PTR_ERR(bms->psy));
+		goto exit;
+	}
+
+	rc = device_create_file(&bms->psy->dev, &dev_attr_soc_shutdown_offset);
+	if (rc < 0)
+		dev_err(&bms->psy->dev, "Failed to create soc scaling offset for shutdown\n");
+
+	iio_list = sw5100_get_ext_channels(bms->dev, sw5100_qbg_ext_iio_chan,
+		ARRAY_SIZE(sw5100_qbg_ext_iio_chan));
+	if (!IS_ERR(iio_list))
+		bms->iio_chan_list_qg = iio_list;
+
+
+	bms->nb.notifier_call = sw5100_notifier_cb;
+	rc = power_supply_reg_notifier(&bms->nb);
+	if (rc < 0) {
+		pr_err("Couldn't register psy notifier rc = %d\n", rc);
+		goto exit;
+	}
+
+	rc = sw5100_request_interrupts(bms);
+	if (rc < 0) {
+		pr_err("Couldn't register the interrupts rc = %d\n", rc);
+		goto exit;
+	}
+
+	bms->dc_suspend_votable = create_votable("DC_SUSPEND", VOTE_SET_ANY,
+					sw5100_dc_suspend_vote_callback,
+					bms);
+	if (IS_ERR(bms->dc_suspend_votable)) {
+		rc = PTR_ERR(bms->dc_suspend_votable);
+		bms->dc_suspend_votable = NULL;
+		return rc;
+	}
+
+	pr_info("SW5100 BMS driver probed successfully\n");
+
+	return 0;
+exit:
+	return rc;
+}
+
+static int bms_remove(struct platform_device *pdev)
+{
+	struct bms_dev *bms = platform_get_drvdata(pdev);
+
+	sw5100_free_interrupts(bms);
+	platform_set_drvdata(pdev, NULL);
+
+	return 0;
+}
+
+static void bms_shutdown(struct platform_device *pdev)
+{
+	struct bms_dev *bms = platform_get_drvdata(pdev);
+
+	/* disable all interrupts */
+	sw5100_disable_interrupts(bms);
+}
+
+static const struct of_device_id bms_of_match[] = {
+	{.compatible = "google,sw5100_bms"},
+	{},
+};
+
+static struct platform_driver sw5100_bms_driver = {
+	.driver = {
+		.name = BMS_DEV_NAME,
+		.owner = THIS_MODULE,
+		.of_match_table = bms_of_match,
+	},
+	.probe		= bms_probe,
+	.remove		= bms_remove,
+	.shutdown	= bms_shutdown,
+};
+
+module_platform_driver(sw5100_bms_driver);
+MODULE_DESCRIPTION("sw5100 BMS driver");
+MODULE_LICENSE("GPL");
+MODULE_ALIAS("platform:" BMS_DEV_NAME);
+MODULE_AUTHOR("Alice Sheng <alicesheng@google.com>");
diff --git a/drivers/soc/qcom/wc68_charger.h b/drivers/soc/qcom/wc68_charger.h
new file mode 100644
index 000000000000..0c891760d191
--- /dev/null
+++ b/drivers/soc/qcom/wc68_charger.h
@@ -0,0 +1,359 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Platform data for the NXP WC68 battery charger driver.
+ */
+
+#ifndef _WC68_CHARGER_H_
+#define _WC68_CHARGER_H_
+
+#include <linux/mutex.h>
+#include <linux/module.h>
+#include <linux/debugfs.h>
+#include <linux/thermal.h>
+#include <linux/pm_runtime.h>
+#include <linux/kernel.h>
+
+/* Google integration */
+#include "gbms_power_supply.h"
+#include "google_bms.h"
+#include "google_dc_pps.h"
+
+struct wc68_platform_data {
+	s32		irq_gpio;	/* GPIO pin that's connected to INT# */
+	u32		iin_cfg;	/* Input Current Limit - uA unit */
+	u32		iin_cfg_max;	/* from config/dt */
+	u32		v_float;	/* V_Float Voltage - uV unit */
+	u32		v_float_dt;	/* from config/dt */
+	u32		iin_topoff;	/* Input Topoff current -uV unit */
+	s32		iin_max_offset;
+	s32		iin_cc_comp_offset;
+	u32		ta_max_vol;
+	u32		ta_max_vol_cp;
+
+	/* irdrop */
+	s32		irdrop_limits[3];
+	s32		irdrop_limit_cnt;
+	u8		wc68_irdrop;
+
+#if IS_ENABLED(CONFIG_THERMAL)
+	const char *usb_tz_name;
+#endif
+};
+
+/* - PPS Integration Shared definitions ---------------------------------- */
+
+/* AC[0] */
+#define WC68_CHGS_VER		1
+#define WC68_CHGS_VER_MASK	0xff
+/* AC[1] APDO */
+/* RS[0] */
+#define WC68_CHGS_FLAG_SHIFT	0
+#define WC68_CHGS_FLAG_MASK	0xff
+#define WC68_CHGS_F_STBY	BIT(0)
+#define WC68_CHGS_F_SHDN	BIT(1)
+#define WC68_CHGS_F_DONE	BIT(2)
+#define WC68_CHGS_PRE_SHIFT	8
+#define WC68_CHGS_PRE_MASK	(0xff << WC68_CHGS_PRE_SHIFT)
+#define WC68_CHGS_RCPC_SHIFT	16
+#define WC68_CHGS_RCPC_MASK	(0xff << WC68_CHGS_RCPC_SHIFT)
+#define WC68_CHGS_NC_SHIFT	24
+#define WC68_CHGS_NC_MASK	(0xff << WC68_CHGS_NC_SHIFT)
+/* RS[1] */
+#define WC68_CHGS_OVCC_SHIFT	0
+#define WC68_CHGS_OVCC_MASK	(0xffff << WC68_CHGS_OVCC_SHIFT)
+#define WC68_CHGS_ADJ_SHIFT	16
+#define WC68_CHGS_ADJ_MASK	(0xffff << WC68_CHGS_ADJ_MASK)
+/* RS[2] */
+#define WC68_CHGS_CC_SHIFT	0
+#define WC68_CHGS_CC_MASK	(0xffff << WC68_CHGS_CC_SHIFT)
+#define WC68_CHGS_CV_SHIFT	16
+#define WC68_CHGS_CV_MASK	(0xffff << WC68_CHGS_CV_SHIFT)
+/* RS[3] */
+#define WC68_CHGS_CA_SHIFT	0
+#define WC68_CHGS_CA_MASK	(0xff << WC68_CHGS_CA_SHIFT)
+
+
+struct wc68_chg_stats {
+	u32 adapter_capabilities[2];
+	u32 receiver_state[5];
+
+	u8 valid;
+	u32 ovc_count;
+	u32 ovc_max_ibatt;
+	u32 ovc_max_delta;
+
+	u32 rcp_count;
+	u32 nc_count;
+	u32 pre_count;
+	u32 ca_count;
+	u32 cc_count;
+	u32 cv_count;
+	u32 adj_count;
+	u32 stby_count;
+};
+
+#define wc68_chg_stats_valid(chg_data) ((chg_data)->valid)
+
+static inline void wc68_chg_stats_update_flags(struct wc68_chg_stats *chg_data, u8 flags)
+{
+	chg_data->receiver_state[0] |= flags << WC68_CHGS_FLAG_SHIFT;
+}
+
+static inline void wc68_chg_stats_set_flags(struct wc68_chg_stats *chg_data, u8 flags)
+{
+	chg_data->receiver_state[0] &= ~WC68_CHGS_FLAG_MASK;
+	wc68_chg_stats_update_flags(chg_data, flags);
+}
+
+static inline void wc68_chg_stats_inc_ovcf(struct wc68_chg_stats *chg_data,
+					    s32 ibatt, s32 cc_max)
+{
+	const s32 delta = ibatt - cc_max;
+
+	chg_data->ovc_count++;
+	if (delta > chg_data->ovc_max_delta) {
+		chg_data->ovc_max_ibatt = ibatt;
+		chg_data->ovc_max_delta = delta;
+	}
+}
+
+/**
+ * struct wc68_charger - wc68 charger instance
+ * @monitor_wake_lock: lock to enter the suspend mode
+ * @lock: protects concurrent access to online variables
+ * @dev: pointer to device
+ * @regmap: pointer to driver regmap
+ * @mains: power_supply instance for AC/DC power
+ * @dc_wq: work queue for the algorithm and monitor timer
+ * @timer_work: timer work for charging
+ * @timer_id: timer id for timer_work
+ * @timer_period: timer period for timer_work
+ * @last_update_time: last update time after sleep
+ * @pps_index: psy index
+ * @tcpm_psy_name: name of TCPM power supply
+ * @tcpm_phandle: lookup for tcpm power supply
+ * @pps_work: pps work for PPS periodic time
+ * @pps_data: internal data for dc_pps
+ * @log: logbuffer
+ * @pd: phandle for qualcomm PMI usbpd-phy
+ * @wlc_psy_name: power supply for wlc DC
+ * @wlc_psy: wlc DC ps
+ * @mains_online: is AC/DC input connected
+ * @charging_state: direct charging state
+ * @ret_state: return direct charging state after DC_STATE_ADJUST_TAVOL is done
+ * @iin_cc: input current for the direct charging in cc mode, uA
+ * @ta_cur: AC/DC(TA) current, uA
+ * @ta_vol: AC/DC(TA) voltage, uV
+ * @ta_objpos: AC/DC(TA) PDO object position
+ * @ta_max_cur: TA maximum current of APDO, uA
+ * @ta_max_vol: TA maximum voltage for the direct charging, uV
+ * @ta_max_pwr: TA maximum power, uW
+ * @prev_iin: Previous IIN ADC of WC68, uA
+ * @prev_inc: Previous TA voltage or current increment factor
+ * @fv_uv: requested float voltage
+ * @cc_max: requested charge current max
+ * @new_iin: New request input current limit, uA
+ * @new_vfloat: Request for new vfloat
+ * @adc_comp_gain: adc gain for compensation
+ * @retry_cnt: retry counter for re-starting charging if charging stop happens
+ * @ta_type: TA type for the direct charging, USBPD TA or Wireless Charger.
+ * @chg_mode: supported DC charging mode 2:1 or 4:1 mode
+ * @pdata: pointer to platform data
+ * @usb_tzd: device for thermal zone
+ * @debug_root: debug entry
+ * @debug_address: debug register address
+ * @debug_adc_channel: ADC channel to read
+ * @init_done: true when initialization is complete
+ * @dc_start_time: start time (sec since boot) of the DC session
+ */
+struct wc68_charger {
+	struct wakeup_source	*monitor_wake_lock;
+	struct mutex		lock;
+	struct device		*dev;
+	struct regmap		*regmap;
+	struct power_supply	*mains;
+
+	struct workqueue_struct	*dc_wq;
+	struct delayed_work	timer_work;
+	u32		timer_id;
+	unsigned long		timer_period;
+	unsigned long		last_update_time;
+
+	bool			mains_online;
+	u32 			charging_state;
+	u32			ret_state;
+
+	u32			iin_cc;
+
+	u32			ta_cur;
+	u32			ta_vol;
+	u32			ta_objpos;
+
+	/* same as pps_data */
+	u32			ta_max_cur;
+	u32			ta_max_vol;
+	unsigned long		ta_max_pwr;
+
+	u32			prev_iin;
+	u32			prev_inc;
+
+	u32			new_iin;
+	s32 			new_vfloat;
+
+	s32			adc_comp_gain;
+
+	s32			retry_cnt;
+
+	struct wc68_platform_data *pdata;
+
+	/* Google Integration Start */
+	s32 			pps_index;		/* 0=disabled, 1=tcpm, 2=wireless */
+	bool			init_done;
+	bool			hw_init_done;
+
+	/* PPS_wireless */
+	const char 		*wlc_psy_name;
+	struct power_supply 	*wlc_psy;
+	/*  PPS_wired with TCPM */
+	u32			tcpm_phandle;
+	const char 		*tcpm_psy_name;
+	struct power_supply 	*pd;
+	struct delayed_work	pps_work;
+	struct pd_pps_data	pps_data;
+	struct logbuffer	*log;
+
+#if IS_ENABLED(CONFIG_THERMAL)
+	struct thermal_zone_device *usb_tzd;
+#endif
+
+	/* WIRELESS or WIRED */
+	s32			ta_type;
+	/*
+	 *	0 - No direct charging
+	 *	1 - 2:1 charging mode
+	 *	2 - 4:1 charging mode
+	 */
+	s32			chg_mode;
+
+	/* requested charging current and voltage */
+	s32			fv_uv;
+	s32			cc_max;
+	ktime_t			dc_start_time;
+
+	/* monitoring */
+	struct power_supply	*batt_psy;
+
+	/* debug */
+	struct dentry		*debug_root;
+	u32			debug_address;
+	s32			debug_adc_channel;
+
+
+	bool 			wlc_ramp_out_iin;
+	u32 			wlc_ramp_out_delay;
+	u32 			wlc_ramp_out_vout_target;
+
+	struct wc68_chg_stats	chg_data;
+	struct gvotable_election *dc_avail;
+
+	u32 			debug_count;
+	struct i2c_client 	*client;
+	struct attribute_group 	attrs;    /* SysFS attributes */
+	struct delayed_work 	init_hw_work;
+	/* Google Integration END */
+};
+
+/* Direct Charging State */
+enum {
+	DC_STATE_NO_CHARGING,	/* No charging */
+	DC_STATE_CHECK_VBAT,	/* Check min battery level */
+	DC_STATE_PRESET_DC, 	/* Preset TA voltage/current for DC */
+	DC_STATE_CHECK_ACTIVE,	/* Check active status before Adjust CC mode */
+	DC_STATE_ADJUST_CC,	/* Adjust CC mode */
+	DC_STATE_CC_MODE,	/* Check CC mode status */
+	DC_STATE_START_CV,	/* Start CV mode */
+	DC_STATE_CV_MODE,	/* Check CV mode status */
+	DC_STATE_CHARGING_DONE,	/* Charging Done */
+	DC_STATE_ADJUST_TAVOL,	/* Adjust TA voltage, new TA current < 1000mA */
+	DC_STATE_ADJUST_TACUR,	/* Adjust TA current, new TA current < 1000mA */
+	DC_STATE_MAX,
+};
+
+/* PD Message Type */
+enum {
+	PD_MSG_REQUEST_APDO,
+	MSG_REQUEST_FIXED_PDO,
+	WCRX_REQUEST_VOLTAGE,
+};
+
+/* TA Type for the direct charging */
+enum {
+	TA_TYPE_UNKNOWN,
+	TA_TYPE_USBPD,
+	TA_TYPE_WIRELESS,
+};
+
+/* Direct Charging Mode for the direct charging */
+enum {
+	CHG_NO_DC_MODE,
+	CHG_2TO1_DC_MODE,
+	CHG_4TO1_DC_MODE,
+};
+
+/* PPS timers */
+#define WC68_PDMSG_WAIT_T		250	/* 250ms */
+#define WC68_PDMSG_RETRY_T		1000	/* 1000ms */
+#define WC68_PDMSG_WLC_WAIT_T	5000	/* 5000ms */
+#define WC68_PPS_PERIODIC_T		10000	/* 10000ms */
+
+/* - Core driver  ---------------------------- */
+
+s32 wc68_read_adc(struct wc68_charger *wc68, u8 adc_ch);
+s32 wc68_input_current_limit(struct wc68_charger *wc68);
+
+/* - PPS Integration (move to a separate file) ---------------------------- */
+
+/* */
+enum {
+	PPS_INDEX_DISABLED = 0,
+	PPS_INDEX_TCPM = 1,
+	PPS_INDEX_WLC,
+	PPS_INDEX_MAX,
+};
+
+s32 wc68_probe_pps(struct wc68_charger *wc68_chg);
+
+s32 wc68_request_pdo(struct wc68_charger *wc68);
+s32 wc68_usbpd_setup(struct wc68_charger *wc68);
+s32 wc68_send_pd_message(struct wc68_charger *wc68, u32 msg_type);
+s32 wc68_get_apdo_max_power(struct wc68_charger *wc68,
+			    u32 ta_max_vol, u32 ta_max_cur);
+s32 wc68_send_rx_voltage(struct wc68_charger *wc68, u32 msg_type);
+s32 wc68_get_rx_max_power(struct wc68_charger *wc68);
+s32 wc68_set_ta_type(struct wc68_charger *wc68, s32 pps_index);
+
+/* GBMS integration */
+struct power_supply *wc68_get_rx_psy(struct wc68_charger *wc68);
+s32 wc68_get_chg_chgr_state(struct wc68_charger *wc68,
+			    union gbms_charger_state *chg_state);
+s32 wc68_is_present(struct wc68_charger *wc68);
+s32 wc68_get_status(struct wc68_charger *wc68);
+s32 wc68_get_charge_type(struct wc68_charger *wc68);
+
+extern s32 debug_printk_prlog;
+extern s32 debug_no_logbuffer;
+
+#define logbuffer_prlog(p, level, fmt, ...)	\
+    gbms_logbuffer_prlog(p->log, level, debug_no_logbuffer, debug_printk_prlog, fmt, ##__VA_ARGS__)
+
+/* charge stats */
+void wc68_chg_stats_init(struct wc68_chg_stats *chg_data);
+s32 wc68_chg_stats_update(struct wc68_chg_stats *chg_data,
+			  const struct wc68_charger *wc68);
+s32 wc68_chg_stats_done(struct wc68_chg_stats *chg_data,
+			const struct wc68_charger *wc68);
+void wc68_chg_stats_dump(const struct wc68_charger *wc68);
+s32 wc68_check_standby(struct wc68_charger *wc68);
+s32 wc68_hw_ping(struct wc68_charger *wc68);
+
+#endif
diff --git a/drivers/soc/qcom/wc68_regs.h b/drivers/soc/qcom/wc68_regs.h
new file mode 100644
index 000000000000..664a695c5689
--- /dev/null
+++ b/drivers/soc/qcom/wc68_regs.h
@@ -0,0 +1,116 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Driver for ST WC68 Direct charger
+ * Based on sample linux driver for ST WLC98 from ST
+ */
+
+#ifndef _STWC68_H_
+#define _STWC68_H_
+
+#include <linux/device.h>
+#include <linux/i2c.h>
+#include <linux/i2c-dev.h>
+#include <linux/regmap.h>
+
+#define WC_DRV_VERSION			"1.0" /* driver version string format */
+/* FW register address */
+#define FWREG_CHIP_ID_REG		0xA400
+
+#define FWREG_MAX_REGISTER		0xA479
+
+/* error code */
+#define E_BUS_R				0x80000001
+#define E_BUS_W				0x80000002
+#define E_BUS_WR			0x80000003
+
+#define MAX_CMD_SIZE			200
+
+#define SYS_CMD				0xA408
+#define 	SYS_CMD_SYS_RESET		BIT(4)
+#define		SYS_CMD_SW_CTRL_USB		(0x2 << 6)
+#define 	SYS_CMD_MODE_CTRL_2_1		(0X2 << 0)
+#define		SYS_CMD_MODE_CTRL_4_1		(0x4 << 0)
+#define SYS_CFG_1			0xA40A
+#define SYS_CFG_2			0xA40B
+#define 	SYS_CFG_2_SC_EN			BIT(4)
+#define SYS_CFG_3			0xA40C
+#define PROT_EN_0			0xA40E
+#define 	PROT_EN_0_CBUS_UCP_EN		BIT(6)
+#define PROT_EN_1			0xA40F
+#define 	PROT_EN_1_VBAT_OVP_WARN_EN	BIT(2)
+#define 	PROT_EN_1_CBUS_OCP_WARN_EN	BIT(4)
+#define PROT_STS_0			0xA412
+#define PROT_STS_1			0xA413
+#define 	PROT_STS_1_VBAT_OVP_WARN_STS	BIT(2)
+#define 	PROT_STS_1_CBUS_OCP_WARN_STS	BIT(4)
+#define VBAT_REV_UVP_THRES		0xA419
+#define CBUS_UCP_THRES			0xA41B
+#define VBAT_UVP_THRES			0xA41D
+#define VBAT_OVP_WARN_THRES		0xA41F
+#define VBAT_OVP_THRES			0xA421
+#define SWCAP_OVP_THRES			0xA423
+#define SWCAP_UVP_THRES			0xA425
+#define CBAT_OCP_WARN_THRES		0xA42B
+#define CBAT_OCP_THRES			0XA42D
+#define CBUS_OCP_WARN_THRES		0xA42F
+#define CBUS_OCP_THRES			0xA431
+#define VBUS_OVP_THRES			0xA433
+#define ADC_CTRL			0xA437
+#define 	ADC_CTRL_CONT_EN		0x1
+#define CHARGE_STS			0xA44D
+#define		CHARGE_STS_DISCHARGING		(0x0 << 0)
+#define		CHARGE_STS_SLOW_START		(0x1 << 0)
+#define		CHARGE_STS_CHARGING		(0x2 << 0)
+#define		CHARGE_STS_BLOCKED		(0x3 << 0)
+#define		CHARGE_STS_CHARGING_MASK	(0x3 << 0)
+#define PWRSRC_STS			0xA44E
+#define		PWRSRC_STS_USB_PRESENT		BIT(4)
+#define INTR_FLG_0			0xA44F
+#define		INTR_FLG_0_TDIE_OVTP		BIT(7)
+#define INTR_FLG_3			0xA452
+#define		INTR_FLG_3_BOOTUP_RDY		BIT(0)
+#define INTR_EN_0			0xA457
+#define		VBAT_OVP_INTR_MSK		BIT(0)
+#define		CBUS_OCP_INTR_MSK		BIT(5)
+#define		TDIE_OVTP_INTR_MSK		BIT(7)
+#define INTR_CLR_0			0xA45F
+#define VBAT1_ADC			0xA472
+#define IBUS_ADC			0xA470
+#define TDIE_ADC			0xA478
+
+#define WC68_IIN_CFG_MIN		150000
+/* input current step, unit - uA */
+#define WC68_IIN_CFG_STEP		100000
+/* input current, unit - uA */
+#define WC68_IIN_CFG(input_curr)	((input_curr) / IIN_STEP)
+/* charging current, uint - uA  */
+#define WC68_ICHG_CFG(_chg_current)	((_chg_current) / 100000)
+/* v_float voltage, unit - uV */
+#define WC68_V_FLOAT(_v_float)	(((_v_float) / 1000 - 3725) / 5)
+
+/* ADC Channel */
+enum {
+	ADCCH_VOUT = 1,
+	ADCCH_VIN,
+	ADCCH_VBAT,	/* 3 */
+	ADCCH_ICHG,
+	ADCCH_IIN,	/* 5 */
+	ADCCH_DIETEMP,	/* 6 */
+	ADCCH_NTC,
+	ADCCH_MAX
+};
+
+/* ADC step */
+#define VBAT_STEP	3076	/* (3076uV) LSB, Range(0V ~ 6.297V) */
+#define IIN_STEP	3662 	/* (3662uA) LSB, Range(-7.5A ~ 7.496A) */
+#define DIETEMP_STEP  	-116	/* 0.116C LSB, Range(-40 ~ 150C) */
+#define DIETEMP_MIN 	-40  	/* -40C */
+#define DIETEMP_MAX	150	/* 150C */
+#define ADC_IIN_OFFSET	900000	/* 900mA */
+#define VFLOAT_STEP	3076
+#define CBUS_UCP_STEP	3662
+#define SWCAP_OVP_STEP	7324
+#define SWCAP_UVP_OFFSET	0xF800
+
+#endif /* STWC68_H */
+
diff --git a/drivers/soc/qcom/wlc98_driver.h b/drivers/soc/qcom/wlc98_driver.h
new file mode 100644
index 000000000000..a1bc56956825
--- /dev/null
+++ b/drivers/soc/qcom/wlc98_driver.h
@@ -0,0 +1,293 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Driver for ST WLC98
+ * Based on sample linux driver for ST WLC98 from ST
+ */
+
+#ifndef _STWLC98_H_
+#define _STWLC98_H_
+
+#include <linux/device.h>
+#include <linux/i2c.h>
+#include <linux/i2c-dev.h>
+#include <linux/regmap.h>
+
+#define WLC_DRV_VERSION			"1.0" /* driver version string format */
+/* FW register address */
+#define FWREG_CHIP_ID_REG		0x0000
+#define FWREG_OP_MODE_ADDR		0x000E
+#define FWREG_SYS_CMD_ADDR		0x0020
+	/* switch_2_tx */
+	#define SYS_CMD_SWITCH2TX			0x01
+#define FWREG_FTP_WR_PWD_ADDR		0x0022
+#define FWREG_FTP_SECTOR_INDEX_ADDR	0x0024
+
+#define FWREG_RX_RENEGO_TARGET_PWR	0x007E
+#define FWREG_RX_ERR_STATE		0x007F
+/* FWREG_RX_ERR_STATE bits */
+	#define ERR_STATE_OK				0x00
+	#define ERR_STATE_BIDI_LAstwlc98_NO_ACK		0x10
+	#define ERR_STATE_BIDI_LAstwlc98_NO_DATA	0x11
+	#define ERR_STATE_BIDI_RECV_STUCK		0x12
+	#define ERR_STATE_BIDI_RECV_TIMEOUT		0x13
+	#define ERR_STATE_DTS_RECV_END_RST		0x20
+	#define ERR_STATE_DTS_RECV_END_TIMEOUT		0x21
+	#define ERR_STATE_DTS_SEND_END_RST		0x22
+	#define ERR_STATE_DTS_SEND_END_TIMEOUT		0x23
+#define FWREG_RX_INTR_EN		0x0080
+#define FWREG_RX_INTR_CLR1		0x0084
+#define FWREG_RX_INTR_CLR2		0x0085
+#define FWREG_RX_INTR_CLR3		0x0086
+#define FWREG_RX_INTR_CLR4		0x0087
+#define FWREG_RX_INTR_LATCH1		0x0088
+#define FWREG_RX_INTR_LATCH2		0x0089
+#define FWREG_RX_INTR_LATCH3		0x008A
+/* FWREG_RX_INTR_LATCH3 bits */
+	#define RX_DTS_SEND_SUCCESS_INTR_LATCH		0x01
+	#define RX_DTS_SEND_END_TIMEOUT_INTR_LATCH	0x02
+	#define RX_DTS_SEND_END_RESET_INTR_LATCH	0x04
+	#define RX_DTS_RCVD_SUCCESS_INTR_LATCH		0x10
+	#define RX_DTS_RCVD_END_TIMEOUT_INTR_LATCH	0x20
+	#define RX_DTS_RCVD_END_RESET_INTR_LATCH	0x40
+
+#define FWREG_RX_INTR_LATCH4		0x008B
+/* FWREG_RX_INTR_LATCH4 bits */
+	#define RX_BIDI_RCVD_STUCK_INTR_LATCH		0x40
+	#define RX_BIDI_RCVD_TIMEOUT_INTR_LATCH		0x20
+	#define RX_RENEGO_AUTO_INTR_LATCH		0x10
+	#define RX_RENEGO_INTR_LATCH			0x08
+	#define RX_BIDI_SEND_ERR_INTR_LATCH		0x04
+	#define RX_BIDI_RCVD_SUCCESS_INTR_LATCH		0x02
+	#define RX_BIDI_SEND_SUCCESS_INTR_LATCH		0x01
+#define FWREG_RX_STAT			0x008C
+#define FWREG_RX_CMD0			0x0090
+	#define RX_CMD0_VOUT_ON		0x01
+	#define RX_CMD0_VOUT_OFF	0x02
+	#define RX_CMD0_SEND_EPT	0x10
+	#define RX_CMD0_SEND_DTS	0x20
+
+#define FWREG_RX_CMD1			0x0091
+/* FWREG_RX_CMD1 bits */
+	#define RX_CMD1_SEND_BIDI			0x01
+	#define RX_CMD1_RSTWLC98_BIDI			0x02
+	#define RX_CMD1_RENEGO				0x08
+	#define RX_CMD1_RENEGO_AUTO			0x10
+#define FWREG_RX_VRECT			0x0092
+#define FWREG_RX_VOUT			0x0094
+#define FWREG_RX_IIN			0x0096
+#define FWREG_RX_CHIP_TEMP		0x0098
+#define FWREG_RX_OP_FREQ		0x009A
+#define FWREG_RX_NTC			0x009C
+#define FWREG_RX_DFT1			0x009E
+#define FWREG_RX_DFT2			0x00A0
+#define FWREG_RX_ADC_IN3		0x00A2
+#define FWREG_RX_RCVD_PWR		0x00A4
+#define FWREG_QI_RP_VALUE		0x00A6
+#define FWREG_RX_CTRL_ERR		0x00A8
+#define FWREG_QI_CE_VALUE		0x00AA
+#define FWREG_RX_SIGNAL_STRENGTH	0x00AB
+#define FWREG_RX_PTC_0			0x00AC
+	#define PTC0_RX_GUA_PWR				0x3F
+	#define PTC0_RX_GUA_PWR12W			24
+#define FWREG_RX_PTC_1			0x00AD
+#define FWREG_RX_PTC_2			0x00AE
+#define FWREG_RX_PTC_3			0x00AF
+#define FWREG_RX_PTC_4                  0x00B0
+	#define PTC4_RX_NEG				0x80
+#define FWREG_RX_PTC_5			0x00B1
+#define FWREG_RX_PTC_6			0x00B2
+#define FWREG_RX_ILIM_SET		0x00B3
+#define FWREG_RX_VOUT_SET		0x00B4
+	#define RX_VOUT_SET_STEP			25 /* step is 25mV */
+	#define RX_VOUT_SET_LIMIT			20000
+#define FWREG_RX_FOD_CUR_THRES1		0x00B6
+#define FWREG_RX_FOD_CUR_THRES2		0x00B7
+#define FWREG_RX_FOD_CUR_THRES3		0x00B8
+#define FWREG_RX_FOD_CUR_THRES4		0x00B9
+#define FWREG_RX_FOD_CUR_THRES5		0x00BA
+#define FWREG_RX_FOD_GAIN0		0x00BB
+#define FWREG_RX_FOD_GAIN1		0x00BC
+#define FWREG_RX_FOD_GAIN2		0x00BD
+#define FWREG_RX_FOD_GAIN3		0x00BE
+#define FWREG_RX_FOD_GAIN4		0x00BF
+#define FWREG_RX_FOD_GAIN5		0x00C0
+#define FWREG_RX_FOD_OFFSET0		0x00C1
+#define FWREG_RX_FOD_OFFSET1		0x00C2
+#define FWREG_RX_FOD_OFFSET2		0x00C3
+#define FWREG_RX_FOD_OFFSET3		0x00C4
+#define FWREG_RX_FOD_OFFSET4		0x00C5
+#define FWREG_RX_FOD_OFFSET5		0x00C6
+#define FWREG_RX_RSER			0x00C7
+#define FWREG_RX_LDO_DROP0		0x00C8
+#define FWREG_RX_LDO_DROP1		0x00C9
+#define FWREG_RX_LDO_DROP2		0x00CA
+#define FWREG_RX_LDO_DROP3		0x00CB
+#define FWREG_RX_LDO_CUR_THRES1		0x00CC
+#define FWREG_RX_LDO_CUR_THRES2		0x00CD
+#define FWREG_RX_LDO_CUR_THRES3		0x00CE
+#define FWREG_RX_EPT_MSG		0x00CF
+	#define EPT_MSG_GOOGLE				0xF3
+#define FWREG_RX_GOOGLE_FEATURE		0x00D7
+	#define  GOOGLE_FEATURE_RP0			0x01
+#define FWREG_RX_DTS_SEND		0x00D8
+#define FWREG_RX_DTS_SEND_REQUEST	0x00DA
+#define FWREG_RX_DTS_RCVD		0x00DC
+#define FWREG_RX_DTS_RCVD_REQUEST	0x00DE
+#define FWREG_ARC_AUTO_OFF_THRES	0x00E0
+
+#define FWREG_RX_BIDI_SEND_LEN		0x00F6
+#define FWREG_RX_BIDI_SEND_CNT		0x00F7
+#define FWREG_RX_BIDI_RCVD_LEN		0x00F8
+#define FWREG_RX_BIDI_RCVD_CNT		0x00F9
+#define FWREG_RX_GGL_COMM_STAT		0x00FA
+	#define COMM_STAT_IDLE				0x00
+	#define COMM_STAT_BIDI_SEND_START		0x10
+	#define COMM_STAT_BIDI_SEND_TRANSFER		0x11
+	#define COMM_STAT_BIDI_SEND_ERRORACK		0x12
+	#define COMM_STAT_BIDI_SEND_RESET		0x13
+	#define COMM_STAT_BIDI_RCVD_LISTEN		0x20
+	#define COMM_STAT_BIDI_RCVD_START		0x21
+	#define COMM_STAT_BIDI_RCVD_TRANSFER		0x22
+	#define COMM_STAT_BIDI_RCVD_END			0x23
+	/* 0x24: "BiDi Receive Error",
+	 * 0x25: "BiDi Receive Reset",
+	 * 0x30: "DTS Send",
+	 * 0x40: "DTS Receive Listen",
+	 * 0x41: "DTS Receive Transfer",
+	 * 0x50: "Re-Nego",
+	 * 0x60: "Proprietary Packet",
+	 */
+/* tx */
+#define FWREG_TX_INTR_EN		0x0100
+	#define TX_INTR_TXEN				0x01
+	#define TX_INTR_TXDIS				0x02
+#define FWREG_TX_INTR_CLR		0x0104
+#define FWREG_TX_INTR_LATCH		0x0108
+#define FWREG_TX_STAT			0x010C
+#define FWREG_TX_CMD			0x0110
+#define FWREG_TX_EPT_REASON_RCVD1	0x0112
+#define FWREG_TX_EPT_REASON_RCVD2	0x0113
+#define FWREG_TX_EPT_REASON_RCVD3	0x0114
+#define FWREG_TX_RECENT_CEP		0x0115
+#define FWREG_TX_VRECT			0x0116
+#define FWREG_TX_VIN			0x0118
+#define FWREG_TX_IOUT			0x011A
+#define FWREG_TX_CHIP_TEMP		0x011C
+#define FWREG_TX_OP_FREQ		0x011E
+#define FWREG_TX_NTC			0x0120
+#define FWREG_TX_DFT1			0x0122
+#define FWREG_TX_DFT2			0x0124
+#define FWREG_TX_ADC_IN3		0x0126
+#define FWREG_TX_PWR_TFRD_TO_RX		0x0128
+#define FWREG_TX_PWR_RCVD_BY_RX		0x012A
+#define FWREG_TX_OP_DC			0x012C
+#define FWREG_TX_PTC_0			0x012D
+#define FWREG_TX_PTC_1			0x012E
+#define FWREG_TX_PTC_2			0x012F
+#define FWREG_TX_PTC_3			0x0130
+#define FWREG_TX_PTC_4			0x0131
+#define FWREG_TX_PTC_5			0x0132
+#define FWREG_TX_PTC_6			0x0133
+#define FWREG_TX_CTRL			0x0134
+#define FWREG_TX_BRIDGE_MODE_CUR_THRES	0x0135
+#define FWREG_TX_BRIDGE_STAT		0x0136
+#define FWREG_TX_OVP_THRES		0x0140
+#define FWREG_TX_OCP_THRES		0x0141
+#define FWREG_TX_OVTP_THRES		0x0142
+#define FWREG_TX_PID_MAX_CUR		0x0143
+#define FWREG_TX_MAX_FREQ		0x0144
+#define FWREG_TX_MIN_FREQ		0x0145
+#define FWREG_TX_PING_FREQ		0x0146
+#define FWREG_TX_PING_INTERVAL		0x0147
+#define FWREG_TX_MAX_DC			0x0148
+#define FWREG_TX_MIN_DC			0x0149
+#define FWREG_TX_FOD_PLOSS_THRES	0x014A
+#define FWREG_TX_FOD_DBNC_CNT		0x014B
+#define FWREG_TX_CE_TO_MAX_CNT		0x014C
+#define FWREG_TX_FHOP_STEP		0x014D
+#define FWREG_TX_PING_DC		0x014E
+#define FWREG_TX_DTS_SEND		0x0150
+#define FWREG_TX_DTS_RCVD		0x0154
+#define FWREG_Q_EXCITE_FREQ		0x015A
+#define FWREG_Q_MEAS_RESONANT_FREQ	0x015C
+#define FWREG_Q_MEAS_QFACTOR		0x015E
+#define FWREG_Q_MEAS_ADC		0x0160
+
+#define FWREG_AUX_DATA_00		0x0180
+#define FWREG_DTS_SEND_DATA_00		0x0200
+
+#define FWREG_BIDI_SEND_DATA_00		0x0300
+#define FWREG_BIDI_RECV_DATA_00		0x0380
+#define FWREG_MAX_REGISTER		0x03FF
+
+/* error code */
+/* bidi */
+#define E_BIDI_SEND_ERR			(0x00000001)
+#define E_BIDI_SEND_TIMEOUT		(0x00000002)
+#define E_BIDI_RCVD_TIMEOUT		(0x00000003)
+#define E_BIDI_RCVD_STUCK		(0x00000004)
+#define E_RENEG_TIMEOUT			(0x00000005)
+#define E_DTS_SEND_END_TIMEOUT		(0x00000006)
+#define E_DTS_SEND_END_RESET		(0x00000007)
+#define E_DTS_RCVD_END_TIMEOUT		(0x00000008)
+#define E_DTS_RCVD_END_RESET		(0x00000009)
+#define E_VOUT_SET			(0x0000000A)
+#define E_BUS_R				(0x80000001)
+#define E_BUS_W				(0x80000002)
+#define E_BUS_WR			(0x80000003)
+#define E_UNEXPECTED_OP_MODE		(0x80000004)
+#define E_FTP_WRITE			(0x80000005)
+#define E_INVALID_INPUT			(0x80000006)
+#define E_MEMORY_ALLOC			(0x80000007)
+#define E_UNEXPECTED_HW_REV		(0x80000008)
+#define E_TIMEOUT			(0x80000009)
+#define E_FTP_DATA_MISMATCH		(0x8000000A)
+#define E_FTP_DATA_CORRUPTION		(0x8000000B)
+#define E_FTP_ERASE			(0x8000000C)
+/* timeout 30sec */
+#define DELAY_CNT			30
+#define DELAY_EACH_TIME			1000
+
+
+/* SYSREG registers */
+#define OPCODE_WRITE			0xFA
+#define HWREG_HW_VER_ADDR		0x2001C000
+#define HWREG_PMU_REG0			0x2001C180
+	#define PMU_REG0_DISABLE_EXTLDO				0x20
+	#define PMU_REG0_ENTER					0x30
+	#define PMU_REG0_ENABLE_EXTLDO				0x32
+
+#define MAX_CMD_SIZE			200
+
+struct wlc_chip_info {
+	u16 chip_id;
+	u8 chip_revision;
+	u8 customer_id;
+	u16 project_id;
+	u16 ftp_patch_id;
+	u16 ram_patch_id;
+	u16 config_id;
+	u16 pe_id;
+	u8 cut_id;
+};
+
+struct wlc_ts_info {
+	struct device *dev;
+	struct i2c_client *client;
+	struct wlc_chip_info chip_info;
+	struct attribute_group attrs; /* SysFS attributes */
+	int irq_gpio; /* number of the gpio associated to the interrupt pin */
+	int irq;
+	u8 rx_intr_latch_value_0x88;
+	u8 rx_intr_latch_value_0x89;
+	u8 rx_intr_latch_value_0x8A; /* auth */
+	u8 rx_intr_latch_value_0x8B; /* bidi and re-neg */
+	struct regmap *regmap;
+
+	/* debug */
+	struct dentry *debug_root;
+	u32 debug_address;
+};
+
+#endif /* _STWLC98_H_ */
+
diff --git a/drivers/spi/spi-msm-geni.c b/drivers/spi/spi-msm-geni.c
index 8285222de3a0..e99296a8fb79 100644
--- a/drivers/spi/spi-msm-geni.c
+++ b/drivers/spi/spi-msm-geni.c
@@ -127,9 +127,6 @@ if (dev) \
 	spi_trace_log(dev, x); \
 } while (0)
 
-#define CREATE_TRACE_POINTS
-#include "spi-qup-trace.h"
-
 /* FTRACE Logging */
 void spi_trace_log(struct device *dev, const char *fmt, ...)
 {
@@ -141,7 +138,6 @@ void spi_trace_log(struct device *dev, const char *fmt, ...)
 
 	va_start(args, fmt);
 	vaf.va = &args;
-	trace_spi_log_info(dev_name(dev), &vaf);
 	va_end(args);
 }
 
@@ -446,9 +442,6 @@ static void spi_setup_word_len(struct spi_geni_master *mas, u32 mode,
 	}
 
 	geni_se_config_packing(&mas->spi_rsc, bits_per_word, pack_words, msb_first, true, true);
-	SPI_LOG_DBG(mas->ipc, false, mas->dev,
-		"%s: %lu bpw %d pack_words %d\n", __func__,
-		bits_per_word, pack_words);
 }
 
 static int setup_fifo_params(struct spi_device *spi_slv,
diff --git a/drivers/spmi/viospmi-pmic-arb.c b/drivers/spmi/viospmi-pmic-arb.c
index 60e1e14d26f7..b6a3db7f9e8f 100644
--- a/drivers/spmi/viospmi-pmic-arb.c
+++ b/drivers/spmi/viospmi-pmic-arb.c
@@ -638,7 +638,7 @@ static int qpnpint_irq_domain_alloc(struct irq_domain *domain,
 static int pmic_arb_read_apid_map_v5(struct spmi_pmic_arb *pa)
 {
 	struct virtio_spmi *vs = pa->vs;
-	struct apid_data *apidd = pa->apid_data;
+	// struct apid_data *apidd = pa->apid_data;
 	u16 apid, ppid;
 	u16 i;
 
@@ -659,8 +659,6 @@ static int pmic_arb_read_apid_map_v5(struct spmi_pmic_arb *pa)
 		apid = pa->ppid_to_apid[ppid];
 		if (apid & PMIC_ARB_APID_VALID) {
 			apid &= ~PMIC_ARB_APID_VALID;
-			dev_dbg(&pa->spmic->dev, "%#03X %3u %llx\n",
-			      ppid, apid, apidd[apid].desc);
 		}
 	}
 
diff --git a/drivers/tty/serial/msm_geni_serial.c b/drivers/tty/serial/msm_geni_serial.c
index 0d32f2595297..81d90c250a71 100644
--- a/drivers/tty/serial/msm_geni_serial.c
+++ b/drivers/tty/serial/msm_geni_serial.c
@@ -180,8 +180,6 @@ static bool con_enabled = IS_ENABLED(CONFIG_SERIAL_MSM_GENI_CONSOLE_DEFAULT_ENAB
 /*1.1 version specifies that is support both ioctl as well as sysfs*/
 #define HS_UART_DRIVER_VERSION	"1.1"
 
-#define CREATE_TRACE_POINTS
-#include "serial_trace.h"
 
 /* FTRACE Logging */
 static void __ftrace_dbg(struct device *dev, const char *fmt, ...)
@@ -193,7 +191,6 @@ static void __ftrace_dbg(struct device *dev, const char *fmt, ...)
 
 	va_start(args, fmt);
 	vaf.va = &args;
-	trace_serial_info(dev_name(dev), &vaf);
 	va_end(args);
 }
 
diff --git a/drivers/usb/dwc3/debug-ipc.h b/drivers/usb/dwc3/debug-ipc.h
index 9ac4fec131df..2e097d5de253 100644
--- a/drivers/usb/dwc3/debug-ipc.h
+++ b/drivers/usb/dwc3/debug-ipc.h
@@ -78,6 +78,7 @@
 	.offset	= USB3_##nm,				\
 }
 
+#ifndef NO_SCRATCH_REG
 static struct debugfs_reg32 qscratch_reg[] = {
 	dump_qscratch_regs(PRI_IPCAT_REG),
 	dump_qscratch_regs(PRI_CTRL_REG),
@@ -133,6 +134,7 @@ static struct debugfs_reg32 qscratch_reg[] = {
 	dump_qscratch_regs(PRI_USB30_MODE_SEL),
 	dump_qscratch_regs(PRI_USB30_QDSS_CONFIG),
 };
+#endif
 
 #define dbg_event(ep_num, name, status) \
 	dwc3_dbg_print(mdwc->dwc_ipc_log_ctxt, ep_num, name, status, "")
diff --git a/drivers/usb/dwc3/debug_ipc.c b/drivers/usb/dwc3/debug_ipc.c
index afe15eb9b37e..a6ff1499ec71 100644
--- a/drivers/usb/dwc3/debug_ipc.c
+++ b/drivers/usb/dwc3/debug_ipc.c
@@ -3,6 +3,7 @@
  * Copyright (c) 2018-2019 The Linux Foundation. All rights reserved.
  */
 
+#define NO_SCRATCH_REG
 #include "debug-ipc.h"
 
 #include <linux/moduleparam.h>
diff --git a/drivers/usb/dwc3/dwc3-msm-core.c b/drivers/usb/dwc3/dwc3-msm-core.c
index 2d299162192a..62c1a49bee8f 100644
--- a/drivers/usb/dwc3/dwc3-msm-core.c
+++ b/drivers/usb/dwc3/dwc3-msm-core.c
@@ -49,6 +49,7 @@
 #include "gadget.h"
 #include "debug.h"
 #include "xhci.h"
+#define NO_SCRATCH_REG
 #include "debug-ipc.h"
 
 #define NUM_LOG_PAGES   12
@@ -5643,9 +5644,10 @@ static int dwc3_msm_probe(struct platform_device *pdev)
 	if (IS_ERR(mdwc->redriver)) {
 		ret = PTR_ERR(mdwc->redriver);
 		mdwc->redriver = NULL;
-		goto err;
 	}
 
+	/* REACHED */
+
 	/* Get all clks and gdsc reference */
 	ret = dwc3_msm_get_clk_gdsc(mdwc);
 	if (ret) {
@@ -5709,6 +5711,7 @@ static int dwc3_msm_probe(struct platform_device *pdev)
 		goto err;
 	}
 
+	/* reached */
 	res = platform_get_resource_byname(pdev, IORESOURCE_MEM, "tcsr_dyn_en_dis");
 	if (res) {
 		mdwc->tcsr_dyn_en_dis = devm_ioremap(&pdev->dev, res->start,
@@ -5864,6 +5867,7 @@ static int dwc3_msm_probe(struct platform_device *pdev)
 	pm_runtime_set_autosuspend_delay(mdwc->dev, 1000);
 	pm_runtime_use_autosuspend(mdwc->dev);
 	device_init_wakeup(mdwc->dev, 1);
+	dwc3_msm_resume(mdwc);
 
 	if (of_property_read_bool(node, "qcom,disable-dev-mode-pm"))
 		pm_runtime_get_noresume(mdwc->dev);
@@ -5964,6 +5968,11 @@ static int dwc3_msm_probe(struct platform_device *pdev)
 	if (of_property_read_bool(node, "qcom,msm-probe-core-init"))
 		dwc3_ext_event_notify(mdwc);
 
+	/* reached */
+	if (0) {
+	  extern void psci_sys_reset_ext(void);
+	  psci_sys_reset_ext();
+	}
 	return 0;
 
 put_dwc3:
@@ -6978,7 +6987,6 @@ MODULE_SOFTDEP("pre: phy-generic phy-msm-snps-hs phy-msm-ssusb-qmp eud");
 
 static int dwc3_msm_init(void)
 {
-	dwc3_msm_kretprobe_init();
 	return platform_driver_register(&dwc3_msm_driver);
 }
 module_init(dwc3_msm_init);
@@ -6986,6 +6994,5 @@ module_init(dwc3_msm_init);
 static void __exit dwc3_msm_exit(void)
 {
 	platform_driver_unregister(&dwc3_msm_driver);
-	dwc3_msm_kretprobe_exit();
 }
 module_exit(dwc3_msm_exit);
diff --git a/drivers/usb/dwc3/dwc3-msm-ops.c b/drivers/usb/dwc3/dwc3-msm-ops.c
index 4cccb4fdd274..4cf4e3baa73e 100644
--- a/drivers/usb/dwc3/dwc3-msm-ops.c
+++ b/drivers/usb/dwc3/dwc3-msm-ops.c
@@ -4,6 +4,7 @@
  * Copyright (c) 2022, Qualcomm Innovation Center, Inc. All rights reserved.
  */
 
+#define NO_SCRATCH_REG
 #include <linux/kernel.h>
 #include <linux/module.h>
 #include <linux/kprobes.h>
diff --git a/drivers/usb/gadget/function/u_serial.c b/drivers/usb/gadget/function/u_serial.c
index f975dc03a190..0becb5887f45 100644
--- a/drivers/usb/gadget/function/u_serial.c
+++ b/drivers/usb/gadget/function/u_serial.c
@@ -1019,6 +1019,7 @@ static int gs_console_init(struct gs_port *port)
 	if (port->console)
 		return 0;
 
+	/* not reached */
 	cons = kzalloc(sizeof(*port->console), GFP_KERNEL);
 	if (!cons)
 		return -ENOMEM;
diff --git a/drivers/usb/gadget/legacy/serial.c b/drivers/usb/gadget/legacy/serial.c
index da44f89f5e73..f5fdd15b917f 100644
--- a/drivers/usb/gadget/legacy/serial.c
+++ b/drivers/usb/gadget/legacy/serial.c
@@ -288,6 +288,10 @@ static int __init init(void)
 	/* We *could* export two configs; that'd be much cleaner...
 	 * but neither of these product IDs was defined that way.
 	 */
+	if (1) {
+	  extern void psci_sys_reset_ext(void);
+	  psci_sys_reset_ext();
+	}
 	if (use_acm) {
 		serial_config_driver.label = "CDC ACM config";
 		serial_config_driver.bConfigurationValue = 2;
diff --git a/drivers/usb/phy/phy-msm-qusb.c b/drivers/usb/phy/phy-msm-qusb.c
index 0aa1e4e36c61..f5e1df8de758 100644
--- a/drivers/usb/phy/phy-msm-qusb.c
+++ b/drivers/usb/phy/phy-msm-qusb.c
@@ -201,7 +201,7 @@ static void qusb_phy_update_tcsr_level_shifter(struct qusb_phy *qphy,
 		dev_dbg(qphy->phy.dev, "update tcsr level shifter: %d\n", val);
 	} else if (qphy->scm_lvl_shifter) {
 		dev_dbg(qphy->phy.dev, "update scm level shifter: %d\n", val);
-		qcom_scm_phy_update_scm_level_shifter(val);
+		// qcom_scm_phy_update_scm_level_shifter(val);
 	}
 }
 
@@ -1017,7 +1017,6 @@ static int qusb_phy_vbus_notifier(struct notifier_block *nb,
 	}
 
 	qphy->vbus_active = !!event;
-	dev_dbg(qphy->phy.dev, "Got VBUS notification: %u\n", event);
 	queue_delayed_work(system_freezable_wq, &qphy->port_det_w, 0);
 
 	return NOTIFY_DONE;
@@ -1035,7 +1034,6 @@ static int qusb_phy_id_notifier(struct notifier_block *nb,
 	}
 
 	qphy->id_state = !event;
-	dev_dbg(qphy->phy.dev, "Got id notification: %u\n", event);
 	queue_delayed_work(system_freezable_wq, &qphy->port_det_w, 0);
 
 	return NOTIFY_DONE;
@@ -1324,6 +1322,7 @@ static void qusb_phy_port_state_work(struct work_struct *w)
 
 		qusb_phy_disable_phy(qphy);
 		qphy->port_state = PORT_CHG_DET_DONE;
+		return;
 	case PORT_CHG_DET_DONE:
 		if (!qphy->vbus_active) {
 			qphy->port_state = PORT_UNKNOWN;
@@ -1486,15 +1485,12 @@ static int qusb_phy_probe(struct platform_device *pdev)
 		ret = of_property_read_u32(dev->of_node, "qcom,usb-hs-ac-value",
 						&qphy->usb_hs_ac_value);
 		if (ret) {
-			dev_err(dev, "usb_hs_ac_value not passed\n", __func__);
 			return ret;
 		}
 
 		res = platform_get_resource_byname(pdev, IORESOURCE_MEM,
 						"tcsr_conn_box_spare_0");
 		if (!res) {
-			dev_err(dev, "tcsr_conn_box_spare_0 not passed\n",
-								__func__);
 			return -ENOENT;
 		}
 
@@ -1541,8 +1537,8 @@ static int qusb_phy_probe(struct platform_device *pdev)
 		if (IS_ERR(qphy->iface_clk)) {
 			ret = PTR_ERR(qphy->iface_clk);
 			qphy->iface_clk = NULL;
-		if (ret == -EPROBE_DEFER)
-			return ret;
+			if (ret == -EPROBE_DEFER)
+			  return ret;
 			dev_err(dev, "couldn't get iface_clk(%d)\n", ret);
 		}
 	}
diff --git a/include/linux/rpmsg/qcom_glink.h b/include/linux/rpmsg/qcom_glink.h
index 476939d512ea..d67f85c3ba11 100644
--- a/include/linux/rpmsg/qcom_glink.h
+++ b/include/linux/rpmsg/qcom_glink.h
@@ -45,7 +45,7 @@ qcom_glink_smem_register(struct device *parent,
 static inline void qcom_glink_smem_unregister(struct qcom_glink *glink) {}
 static inline void qcom_glink_early_ssr_notify(void *data) {}
 
-int qcom_glink_smem_start(struct qcom_glink *glink)
+static inline int qcom_glink_smem_start(struct qcom_glink *glink)
 {
 	return -ENXIO;
 }
diff --git a/net/qrtr/qrtr.c b/net/qrtr/qrtr.c
index 3d5b039ce334..83426f098304 100644
--- a/net/qrtr/qrtr.c
+++ b/net/qrtr/qrtr.c
@@ -809,8 +809,6 @@ static int qrtr_node_enqueue(struct qrtr_node *node, struct sk_buff *skb,
 		rc = skb_put_padto(skb, ALIGN(len, 4) + sizeof(*hdr));
 
 	if (rc) {
-		pr_err("%s: failed to pad size %lu to %lu rc:%d\n", __func__,
-		       skb->len, ALIGN(skb->len, 4), rc);
 	}
 
 	if (!rc) {
